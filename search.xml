<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AFNetworking3.1—内部逻辑处理过程]]></title>
    <url>%2FSourceAnnotations%2FAFNLibraryProcessingLogic.html</url>
    <content type="text"><![CDATA[引导 AFNetWorking 基本是iOS开发中使用网络通信框架的标配，这个框架本身比较庞大，也很复杂，但是使用起来非常非常简单。 本篇文章主要从【AFN 内部逻辑处理过程】以Get请求为例，学习总结，在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： AFN GET内部逻辑处理 AFN POST内部逻辑处理 总结 后续【AFN 框架 | 源码 学习总结】 Business logic【AFN GET 内部逻辑处理】 这是 AFNetworking 发起一个 Get 请求的流程图，大概可以分为这几个步骤，下面会逐个解读这个流程。 1. AFHTTPSessionManager 发起GET请求 这个方法是 AFN 的 Get请求 的起点，其他 Get 请求的方法也都是直接或者间接调用这个方法来发起 Get 请求。这个方法的代码量很少也很直观，就是调用其他方法生成 NSURLSessionDataTask对象的实例，然后调用 NSURLSessionDataTask 的 resume 方法发起请求。 2. 创建 NSURLSessionDataTask 这个方法是创建 NSURLSessionDataTask 对象实例并返回这个实例。首先创建一个 NSMutableURLRequest 对象的实例，然后配置。之后是使用 NSMutableURLRequest 对象的实例创建NSURLSessionDataTask 对象实例，然后配置，可以选择性地传入各类Block回调，用于监听网络请求的进度比如上传进度，下载进度，请求成功，请求失败。 3. 配置 NSMutableURLRequest对象 在这个方法中先使用了 url 创建了一个 NSMutableURLRequest 对象的实例,并且设置了 HTTPMethod 为 Get 方法（如果是Post方法，那么这里就是设置Post方法）然后使用KVC的方法设置了 NSMutableURLRequest 的一些属性。 12345678910111213141516// 设置 NSMutableURLRequest 的属性static NSArray * AFHTTPRequestSerializerObservedKeyPaths() &#123; static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //allowsCellularAccess 允许使用数据流量 //cachePolicy 缓存策略 //HTTPShouldHandleCookies 处理Cookie //HTTPShouldUsePipelining 批量请求 //networkServiceType 网络状态 //timeoutInterval 超时 _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))]; &#125;); return _AFHTTPRequestSerializerObservedKeyPaths;&#125; 先设置 HTTP header，之后格式化请求参数，设置参数的编码类型。这个是这个方法的基本操作流程。对于Get操作来说，参数是直接拼接在请求地址后面。 4. 配置 NSURLSessionDataTask对象 之后配置 NSMutableURLRequest 对象就需要配置 NSURLSessionDataTask 对象了。主要分为2个步骤，第一个步骤是创建 NSURLSessionDataTask 对象实例，第二个步骤是给NSURLSessionDataTask 对象实例设置 Delegate。用于实时了解网络请求的过程。 AFN 的代理统一使用 AFURLSessionManagerTaskDelegate 对象来管理，使用 AFURLSessionManagerTaskDelegate 对象来接管NSURLSessionTask 网络请求过程中的回调，然后再传入 AFN 内部进行管理。 12@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt; 如代码所示 AFURLSessionManagerTaskDelegate 接管了NSURLSessionTaskDelegate，NSURLSessionDataDelegate，NSURLSessionDownloadDelegate 的各种回调，然后做内部处理。这也是第三方网络请求框架的重点，让网络请求更加易用，好用。 1234567891011121314// 通过 task 的标识符管理代理- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task&#123; NSParameterAssert(task); NSParameterAssert(delegate); [self.lock lock]; // 将task和代理类绑定，task的taskIdentifier作为字典的key,delegate作为字典的value self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; // 给该task添加两个KVO事件（Resume 和 Suspend） [self addNotificationObserverForTask:task]; [self.lock unlock];&#125; 通过NSURLSessionTask的taskIdentifier标识符对delegate进行管理，只要是用于识别该NSURLSessionTask的代理。 设置各类回调 Block,给 NSURLSessionTask 使用 KVO 进行各种过程进度监听。 123456#pragma mark -// 给task添加暂停和恢复的通知- (void)addNotificationObserverForTask:(NSURLSessionTask *)task &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];&#125; 监听 NSURLSessionTask 被挂起 和 恢复的通知。 5. 网络请求开始12345678910111213141516171819202122232425262728// 发送GET请求/** GET: 请求路径(不包含参数),url parameters: 字典(发送给服务器的数据~参数) progress: 进度回调 success: 成功回调（task:请求任务、responseObject:响应体信息JSON-&gt;OC对象） failure: 失败回调（error:错误信息） task.response: 响应头 */- (NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(id)parameters progress:(void (^)(NSProgress * _Nonnull))downloadProgress success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure&#123; NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"GET" URLString:URLString parameters:parameters uploadProgress:nil downloadProgress:downloadProgress success:success failure:failure]; [dataTask resume]; return dataTask;&#125; 当 NSURLSessionTask 创建和配置完毕之后，它并不会主动执行，而是需要我们主动调用 resume 方法，NSURLSessionTask 才会开始执行。 6. 网络请求回调 AFN 里面有关 NSURLSessionDelegate 的回调方法非常的多，这里我们只说和 NSURLSessionTask 相关的部分方法和 KVO 处理来进行说明，其他的大家可以参考源码细看。 对于我们的 Get请求 来说，我们最关注的莫过于关注请求过程进度，收到响应数据和请求完成这2个回调。 KVO监听的属性值发生变化：123456789101112131415161718192021222324252627282930313233343536// KVO监听的属性值发生变化- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123; if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) &#123; if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) &#123; NSLog(@"countOfBytesReceived"); // 这个是在Get请求下，网络响应过程中已经收到的数据量 // 已经收到 self.downloadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) &#123; NSLog(@"countOfBytesExpectedToReceive"); // 这个是在Get请求下，网络响应过程中期待收到的数据量 // 期待收到 self.downloadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) &#123; NSLog(@"countOfBytesSent"); // 已经发送 self.uploadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) &#123; NSLog(@"countOfBytesExpectedToSend"); // 期待发送 self.uploadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; &#125; &#125; else if ([object isEqual:self.downloadProgress]) &#123; // 下载进度变化 if (self.downloadProgressBlock) &#123; self.downloadProgressBlock(object); &#125; &#125; else if ([object isEqual:self.uploadProgress]) &#123; // 上传进度变化 if (self.uploadProgressBlock) &#123; self.uploadProgressBlock(object); &#125; &#125;&#125; 收到请求响应：1234567891011121314151617181920// 收到请求响应- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123; NSLog(@"收到请求响应"); // 允许处理服务器的响应，才会继续接收服务器返回的数据 NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow; // 是否有收到请求响应的回调Block if (self.dataTaskDidReceiveResponse) &#123; // 若有调用该Block disposition = self.dataTaskDidReceiveResponse(session, dataTask, response); &#125; // 是否有请求响应完成的回调Block if (completionHandler) &#123; // 若有调用该Block completionHandler(disposition); &#125;&#125; 请求完成：123456789101112131415161718192021// 请求完成- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; NSLog(@"请求完成"); // 取出该NSURLSessionTask的代理对象 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) &#123; // 若是该代理对象存在，那么将对应数据转给该代理对象处理 [delegate URLSession:session task:task didCompleteWithError:error]; // NSURLSessionTask任务完成之后，移除该NSURLSessionTask的代理对象 [self removeDelegateForTask:task]; &#125; // 是否有请求完成的回调Block if (self.taskDidComplete) &#123; // 若有调用改Block self.taskDidComplete(session, task, error); &#125;&#125; 因为在配置 NSURLSessionDataTask 对象的时候我们有给 NSURLSessionTask 做了一系列配置，那么当 NSURLSessionDataTask 任务完成之后，我们需要将该 NSURLSessionDataTask 的一系列配置全部清理掉。 这个是我们的配置过程：12345678910111213// 通过task的标识符管理代理- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task&#123; NSParameterAssert(task); NSParameterAssert(delegate); [self.lock lock]; self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; [delegate setupProgressForTask:task]; [self addNotificationObserverForTask:task]; [self.lock unlock];&#125; 那么对应的清理过程是这样的，就是设置过程中做了什么，在清理过程中就需要去掉什么。1234567891011// 给task移除delegate- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123; NSParameterAssert(task); AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; [self.lock lock]; [delegate cleanUpProgressForTask:task]; [self removeNotificationObserverForTask:task]; [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)]; [self.lock unlock];&#125; Business logic【AFN POST内部逻辑处理】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#pragma mark - AFURLRequestSerialization// 设置Header和请求参数- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(request); NSMutableURLRequest *mutableRequest = [request mutableCopy]; [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123; // 判断header的field是否存在,如果不存在则设置，存在则跳过 if (![request valueForHTTPHeaderField:field]) &#123; // 设置 header [mutableRequest setValue:value forHTTPHeaderField:field]; &#125; &#125;]; NSString *query = nil; if (parameters) &#123; // 用传进来的自定义block格式化请求参数 if (self.queryStringSerialization) &#123; NSError *serializationError; query = self.queryStringSerialization(request, parameters, &amp;serializationError); if (serializationError) &#123; if (error) &#123; *error = serializationError; &#125; return nil; &#125; &#125; else &#123; switch (self.queryStringSerializationStyle) &#123; case AFHTTPRequestQueryStringDefaultStyle: // 默认的格式化方式 query = AFQueryStringFromParameters(parameters); break; &#125; &#125; &#125; // 判断是否是GET/HEAD/DELETE方法， 对于GET/HEAD/DELETE方法，把参数加到URL后面 if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123; // 判断是否有参数 if (query &amp;&amp; query.length &gt; 0) &#123; // 拼接请求参数 NSLog(@"query--&gt;%@",query); mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @"&amp;%@" : @"?%@", query]]; &#125; &#125; else &#123; // #2864: an empty string is a valid x-www-form-urlencoded payload if (!query) &#123; query = @""; &#125; // 参数带在body上，大多是POST PUT if (![mutableRequest valueForHTTPHeaderField:@"Content-Type"]) &#123; // 设置Content-Type HTTP头，告诉服务端body的参数编码类型 [mutableRequest setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"]; &#125; [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]]; &#125; return mutableRequest;&#125; 如果是 Post 请求，那么请求参数是没有拼接在 URL 上面，而是放在 body 上，这是 Post 和 Get 请求的最大区别了，其他过程和Get 请求并没有太多区别。 总结AFN发起Get请求主要分为以下步骤： 1.创建NSURLSessionDataTask 2.配置NSURLSessionDataTask 3.设置NSURLSessionDataTask的Delegate 4.调用NSURLSessionDataTask的resume方法开始请求 5.在Delegate的方法里面处理网络请求的各个过程 6.清理NSURLSessionDataTask的配置 其实也就是使用 NSURLSessionDataTask 的步骤，AFN在这几个步骤加了一些封装，让我们的使用更简单。 转载原著 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间和知识管理经验]]></title>
    <url>%2FPerceptionWork%2FTimeManagement.html</url>
    <content type="text"><![CDATA[转自 weekly 维护作者:About Time and Knowledge Management 关于时间管理和知识管理这两个话题，我见过最好的一个总结是： 此生理想、近期计划、今日功课 这是马英九的父亲马鹤凌为马英九制定的人生规划解决之道，是从我的师傅 nwind 的一场培训 工程师的个人发展规划 中学到的。总结的很完美，但实践起来坑很多。分享一些我的实践经验，以及 Weekly 是怎么整理的。 此生理想很多关于时间管理和知识管理的书最后都会指向这点：你的理想是什么，你想成为什么样的人，你想要的生活是什么样的。因为只有搞清楚这点，时间和知识管理才是最高效的。拥有理想看起来很美好，然而现实是：大多数人当下并没有真正想清楚自己的理想是什么，有可能是在年龄很大时才找到属于自己理想。有时候，我们貌似有了一个理想或梦想，但行动往往会出卖我们，暴露出真相并非如此。 所以，我的实践变成了：不刻意去追寻理想，活在当下。做好这几件事： 专注于：解决问题+知识积累，这两件事可以保证知识和技能始总是提升的。不管最终理想是什么，知识和技能最后都会发挥作用。在解决问题的过程中，也会展现个人价值。 不要给自己设限，认定自己不能做什么，勇于尝试各种可能，逐步排除掉什么不是自己想要的。 近期计划请注意：是“近期”而非“远期”，是“计划”而非“规划”。这一点，在理想的驱使下，很容易错误地被实践成长远规划。按我的经验：1 年内的计划比较容易可控，超过 1 年的变数太多，只能当做远景来确定方向。 我的实践是：踏歌而行，踩着节拍往前走。保持节奏可以让我们的工作和学习有序前行，避免迷失方向。我通常这样做： 按 年 -&gt; 月 -&gt; 周 这样的自然节奏进行，在上一个时间周期结束时确定下一个周期的事，比如：春节期间想好下一年的，每月初想好下月的事情，每周写周报或周末空闲时时想好下周要做的事，周末闲暇时间 &amp; 每天在路上想好每件事大致怎么做。所以在工作时，我往往只需执行。 不迷恋于各种日程及时间管理工具，用心记，当一周事情特别多时，用纸+笔 今日功课关于这点，我想分享一个我总结出的词汇“可持续性编程”。为什么编程还需要可持续性，因为：一个人的工作生涯会在20 年以上，这是一场长跑。而且，从职业生涯的角度去看问题，会发现一些有意思的东西： 很多当下的问题根本只是浪花一朵，比如：晋升、绩效、涨薪… 很多看似不可能的东西变得可能，比如：掌握 N 种编程语言、研究清楚浏览器内核、学会一种乐器… 从编程生涯的角度来看，今日功课其实是每日功课，要跑好这场长跑，我觉得这几点很重要： 给自己一个安静的环境，同时省出学习时间 关掉聊天工具、消息提醒，QQ 我已经变成每 1 周甚至 1月去开一次了，在攻坚时我会不开邮件客户端、旺旺、钉钉 少刷微博、微信、新闻，甚至不看，需要时定期去扫即可，不用担心会漏掉什么，重要的东西总会通过各种渠道传递到你这里的 减少不必要的会议，每个技术交流都是一份非常好的学习机会，可以选择不去，但去了后就全心参与，不看手机、不开电脑，专心获取或输出有效信息 健康的体魄，没有好身体，怎么写 20 年代码 工作必须有底线，也不能让自己长期处于高压工作下。我的习惯是：周末尽量不做实体性工作（除非计划有变）；平时不能牺牲吃饭+睡觉时间去赶进度。 适度运动，找到属于自己的一种方式。我会坚持每周去爬山一次，呼吸新鲜空气+思考问题 持续学习的精神，这点 阮一峰老师 是我们的榜样。要保持持续学习，我觉得这两点非常重要： 兼容并蓄：不要给技术贴标签，以学习的心态去看待每个技术，了解它们思考和解决问题的方式、实现原理、应用场景，不断丰富自己对编程的认知和解决问题的思路。 格物致知：计算机科学是非常庞大的一门科学，足以支撑我们研究一辈子。前端所接触的，只是技术的冰山一角，还有很多东西需要我们去探索。格物致知能让我们掌握日常使用的技术背后的原理，从而提升掌控复杂的能力。 Weekly 是如何整理的很多人会问我这个问题，其实，做这件事的初心很简单：记录自己平时看到的优质资料以备用，完善个人知识库。但由于常常有会把一些特别好的东西分享到群里，就有人建议我可以定期整理这类东西，发给大家。于是 Weekly 就开始了，坚持了好多年。 做这件事，我使用的工具是： RSS ：Feedly + gReader，离线、在线都能看，上网约等于看 rss 资源汇集地：hn-daily、JavaScript Weekly 等各种 weekly、技术组织官网、Medium、JavaScriptKicks OneNote：记录感兴趣的文章和资源，比 evernote 快，稳定性、复制 html 的效率和效果、搜索等都更好用 微博：订阅一些喜欢分享资源的人或者组织，其实微博仍然是非常好的一个传播渠道 微信：订阅公众号 方式： 定期看，而非实时关注，一般我会在周三晚上、周六集中扫一遍，筛选出有价值的和感兴趣的，周日汇总并完成整理 零散时间会看 rss 筛选信息，在周末或者晚上空闲时看自己感兴趣的文章 信源： 雪球效应：以资源汇集点为起点，逐步收集优质资源来自的 bolg 、技术站点 整理自己感兴趣的知识，逐步形成个人知识库总结 时间管理和知识管理可以围绕这 12 字去探索自己的模式：此生理想、近期计划、今日功课。我的习惯和建议是： 活在当下：专注于解决问题+知识积累；不给自己设限，去尝试未来的各种可能； 踏歌而行，踩着节拍往前走：以 年 -&gt; 月 -&gt; 周 的维度制定计划；用心而非工具管理计划； 可持续编程：安静的环境；健康的体魄；持续学习的精神； 知识管理：从信息汇聚源除非逐步形成自己的知识库；利用零散时间+定期扫的模式收集资源，在业余时间集中阅读]]></content>
      <categories>
        <category>职场</category>
      </categories>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习技术简历]]></title>
    <url>%2FPerceptionWork%2FTechnicalResume.html</url>
    <content type="text"><![CDATA[先玩个小游戏，如果你在写简历时也遇到了相同的情况，请打勾： [ ] 1. 不知道招聘企业最看重什么，学历、技术、还是项目？ [ ] 2. 习惯把工作年限写长，比如2016年毕业要写2年工作经验。 [ ] 3. Java、Python、C/C++等技能，不管熟不熟，都要写“精通”。 [ ] 4. 项目经历、工作经历几笔带过或啰啰嗦嗦。 [ ] 5. 觉得技术简历和普通简历没什么区别，照着模板写就好了。 [ ] 6. 每次面试官最后说“你有什么要问的吗”，都觉得特别尴尬。 勾0-1条，请点左上方的叉号，关掉这个页面。 勾2-3条，你之前的简历可能是在自嗨，需要一点解药。 勾4-6条，重度患者，请仔细消化下面的内容。 其实，上面的几种情况，大部分人写简历和求职时都会遇到。 有的人不了解面试官的需求，想把简历写得面面俱到，写完却是毫无重点，且不自知，最终简历石沉大海； 有的人想在简历中呈现更好的自己，不管这个“自己”是不是真实的：把工作年限加长、把技能全写成精通。这种自嗨只能换来面试时的尴尬； 有的人技术强，肯努力，却怀才不遇，找不到一条更有效的渠道，让更多大公司了解到自己，就错过了很多上升机会。其实这也是可以改善的。 这篇文章，就教你如何躲过这些简历中常见的“坑”。写一份让面试官喜欢、又真实的技术简历。 如果你是在校生，你更该好好看看这篇文章。它将让你毕业时已经拥有一份最好的技术简历。 （本文内容整理自「 百楼俱乐部技术分享第一期——如何准备技术简历 」，分享人是实验楼CEO石头山。 「 百楼俱乐部 」顾名思义，是实验楼100楼以上的用户组成的群体，除了定期的技术分享外，还有其他福利，欢迎大家爬楼加入。） 简介分享人：石头山 （实验楼CEO，曾任职于VMware、Intel等知名外企，有9年研发和管理经验，筛选过数千份简历，面试过数百名技术人员，深知简历和面试的“套路”，将带你从面试官的角度，了解什么样的简历才是受人欢迎的。） 01 “ 本文不适合老司机… ”今天的话题时如何准备技术简历。我个人因为在技术公司，包括一些外企有过很多经验，所以在这里和大家分享一些想法和经验。 对于这个话题，我们面向的读者是面向互联网行业或软件行业求职的人，而且主要是应届生和毕业三年以内的求职者。因为对于经验丰富的求职者，他们的招聘方式可能会差异非常大。比方说，他对简历的重视程度会越来越低，更多依靠的是行业内的知名度，和公司内部高级工程师的引荐。 因为我个人缺少大型国企、传统行业的经验，所以说这个话题难免不全面，请大家见谅。 02 “ 基本信息那么简单吗？”首先是基本信息，大家肯定都会写到。包括： 姓名 年龄 工作年限 学历 城市 联系方式：手机 + 邮箱 这里还有几项需要注意的： 首先在基本信息里面，我们会看到，有很多同学会故意地把自己的工作年限写得很长。比如16年毕业，自己会选择性地写成两年甚至三年的工作经验。我要讲的是，这是完全没有必要。 因为首先，这会让招聘者很疑惑，你前面的这些工作经验是哪里来的？当然大部分可能是把实习经验算成工作经验了，但实际上到面试阶段还是会把这部分抛除掉的。 所以我们希望的原则是尽可能地实事求是，不要虚报。不要把自己的毕业年限故意提前，来增加自己的工作年限。哪怕这会帮你过简历自动筛选的过程，到人工筛选或面试时，仍有很大的可能会被筛掉。 另外，对于一些转行的朋友，如果你原来不是做计算机这一行的，并且和计算机行业相差非常多，比方说汽车维修，那就简单的一句话概过就可以了。只是为了让你的招聘方知道，你毕业以后前几年并不是在从事计算机行业，然后把自己在计算机行行业内的工作经验、工作年限写清楚就可以了。 联系方式的话，手机号自然不必多说，邮箱尽可能地用一些常用的邮箱。如果你有自己的个人网站，也可以选择用自己个人网站的邮箱。但是呢，邮箱的名称尽可能要简短好认，比如1和L混合在一起的那种邮箱地址，看起来是非常痛苦的。 03 “ 工作、实习经历，相当重要 ”简历的第二部分，就是工作和实习经历。 公司名称 职位 时间 详细工作 这部分相当重要。无论是应届毕业生，还是工作过几年的、有经验的，其实招聘方最看重的就是这一部分的内容。 在这一部分中，至少你要证明你在先前的实习或者工作中，有非常多收获，有对你个人的成长非常有帮助的经历。这样的经历是最有价值的。 另外工作经验要尽可能地避免断档。如果有断档的话，在你面试的时候肯定会问到，你需要有一个比较合理的解释。比方说你中间是出国读书了，或者哪种情况，然后有一两年的断档，这个是没什么问题的。 第二点需要注意的就是，一个公司只需要写一栏。在这一栏下，你可以列出一、二、三、四的这种条目，详细介绍在这个公司中，你所从事的事情以及学到的技术。但是要避免一个公司写很多栏，哪怕你在这公司里的职务有些变化，你可以只写一个最重要职务，或者一个最高级的职务。 对于工作的描述，需要详细地介绍自己曾经开发的产品，以及开发这个产品中间用到的一些技术，负责的任务，并且要标明是否带过团队、带团队的规模是多少个人、这个项目的是否自己独立完成、或者两个人协作完成中你所处的角色，这个是非常细节的地方，但是一定要写得清楚一些。不需要太啰嗦，但是每一点一定要点到位。 最后一点就是刚才也提到的，把每一项以一个简短的条目一二三四标出来。这样能让对方非常清晰地看到，你所收获到的一些关键点，能够抓住他们的眼球。 在描述项目中的时候，尽可能多的使用一些关键字，一些技术的关键字。比方说，这个项目中我用到了Mongo DB、Laravel，或是前后端常用的一些框架，然后把它写到这个项目描述中。 而对于应届生来说的话，如果没有工作经验，实习经验就非常非常宝贵了。因为目前绝大部分的公司，其实都相对功利，希望自己招聘来的应届生能够直接上手，尽可能地快速融入自己的团队，形成战斗力。真正说希望拿过来培养一到两年的公司，应该是规模非常大的企业，属于比较少见的一种情况。 04 “ 什么样的项目经历让人信服？ ”第三部分通常是项目经历，分为： 项目名称 项目描述 承担的职责 用到的技术 实现的效果 项目经历，一般会把自己先前的工作或者实习，以及在学校实验室跟老师做的项目，做一些提取。选取其中最好的项目，最能够代表自己真实水平的。像一些课程的大作业，其实是完全没有必要贴上去的。当然，如果这个大作业的代码量非常大，并且有一定的知名度的话也可以。 一些情况下，项目经验和工作经验是可以合并到一起的。比如你工作经历非常丰富，每一份工作的项目也非常明确，那完全可以将这两项内容合在一起。然后对于应届生，如果工作经历和实习经历都没有，项目经历一定要写得非常精选。 在项目的描述中，我们最看重的就有三点。 这个项目跟应聘的职位之间的关联性。 这个项目在整个技术圈内的知名度。 最后就是这个项目是否有一些数据，可以证明你做到了，并且让你有所收获。 回到刚才的项目经验，其实我们是需要证据的，而最好的证据就是你GitHub的代码链接，或者是你这个项目的一个线上版本——有可能是一个网站，有可能是你展示的一个demo。只要有这样的效果，对于审核简历的人来说，他一眼就能看出来这个项目的技术水平，是能增加很多分的加分项。 选择熟悉的项目，一定要选择熟悉的项目。应该自己写的项目如果进入了面试，很有可能面试官的问题都来自于你写的项目内容中，所以不要写那些自己模棱两可，或者说仅仅是一个旁观者身份的那种项目。只是看过的，或者没办法深入进去的，被问到也很尴尬。 项目经历还需要数据支撑。举个例子，比如你为实验楼开发了一个实验操作的模块，这个模块可以支持1000人同时做实验，并且已经稳定在线上运行了几年，这个实验操作模块能达到几百万次实验的检测。这其实是非常好的，有价值的项目经验。 其实不只是应届生，我们鼓励所有的人在简历里面，尽可能的在项目经验部分列出自己曾经参与过的开源项目。比方说你参与过一些非常知名的、像VIEW一类的开源项目，提交过代码、提交过PR，这其实是非常好的增分项。 如果，应届生没有这方面的项目的话，也可以写一些实验楼的大项目。但是呢，如果是单纯的实验楼的教学项目，其实我们更希望你能够做一些扩展，就是在实验楼项目基础之上，额外做了一些扩展功能。这也可以帮你在向面试官介绍项目的时候，更好地展示自己的能力。 最后一点需要注意的是，你的项目描述一定要以非常标准的技术语言来写。甚至说一些技术的关键字，该大写的地方一定要大写，该小写地方一定要小写。这其实非常体现一个人专业化的水平。 05 “ 精通Java、Python、C、PHP = 呵呵 ”第四部分通常是技能列表。 注意事项： 实事求是 根据目标职位适当调整 数字证明：30000行代码、3个项目-Python 项目证据：爬取知乎10万用户-Python 我们在介绍完自己的项目经历之后，通常会写一个技能的列表。而这个技能列表，通常会根据你所应聘的职位做一些修正。你如果应聘Python后端工程师，那你尽可能地把自己Python相关的技能放在最前面。这些关键点，就能够抓住潜在面试官的眼球。 首先需要注意的仍然是实事求是，尽可能地不要写精通这两个字，可以写熟悉或了解。 技能列表也可以增加一些数字辅助的证据。比方说在Python后写上：我曾经有3万行代码的经验；曾经做过三个项目，三个项目在前面的项目经验里也可以做一些验证。此外还有其他的一些证据，比方说我曾经用Python爬取知乎10万个用户，这其实都是非常好的、能体现你技能水平的一些工作。 06 “ 教育经历中需要规避的 ”教育经历这部分，好像就没有什么太多可说的。基本上专科、本科、硕士这些自己写清楚，学校、专业、时间也写清楚就可以了。 务必实事求是，没有必要在这方面弄虚造假。尽管很多的公司可能会看学校，看学历，但在我的理解，他们只是在选择一种更快的筛选方式。而这一点，在实验楼我们并不会特别看重。我们对学历，或者说学校，其实并不是特别在乎。我们更看重的是你先前的一些工作经验或者自己的项目经验，和其他的一些证明自己实力和能力的东西。 在教育经历这里，大家尽量不要特别强调自学成才。因为哪怕你没有上大学，没有上大专，高中毕业，但是自己对计算机非常感兴趣，又非常努力，是可以拿项目来证明的。但是不要在这里强调自学成才，因为自学成才的概率是非常非常低的，完全靠自己拼搏，出来一个能力非常强的个人，是非常难的，很多公司对这种小概率是非常惧怕的，基本上就会选择筛过。 最后一点就是，尽可能不要写培训班的经验。因为目前大部分的线下培训，都是比较粗糙的，能够获得的技能的提升也是非常有限的。 07 “ 不要轻视额外信息 ”第六点基本上简历的最后一部分，会介绍很多其他的额外信息，比方说个人的网站或者是GitHub的链接。这里就有很多需要注意的地方。 首先你自己的个人网站或技术博客，如果内容不够丰富的话，只有一两篇日志这种的，其实是完全没有必要放出来的。 第二点需要强调的就是，GitHub是非常非常重要的。至少我们实验楼在招聘的时候，会首先看GitHub上面的一些记录，比方说原创的代码项目，甚至说代码的一些规范，包括提交的一些记录。如果你的GitHub仓库里是空的，并且，大部分都是fork别人的代码，那就不要放了，可以避免很多时间上的浪费。 如果你有其他原创的项目代码的下载链接，其实也是可以放在这里的。但是，如果需要招聘方花很多时间去查看的话，通常都不会有人看。 在列出任何一个额外信息的时候，把它的亮点附在后面。比方说你自己的技术博客，你可以写上有150篇的技术博文，当月的访问量达到了100万。这样子是通过数字来吸引别人对你技术博客的关注。 在技术简历里，非技术相关的信息，比方说参加过的志愿活动、社团活动啊、一律不要放，除非是技术社团。但是技术社团除非很知名，一般情况下也价值不大。 最后就是，不要写自己的个人描述。技术简历比较单纯一些，我们只看重你的技术水平，你的项目经验。其他的你个人的一些爱好，比如喜欢什么运动，这真的不是特别重要。 最后一点就是，如果职位没有要求你写期望的薪资，就不要写，可以到现场去谈。有可能你写了就会错过一些面试的机会。 08 “ 私人干货——技术社交！”最后介绍一些简历之外的东西，我个人称之为就是「 技术社交 」。其实是为你打造一个不需要简历，就获得一些应聘机会的方式。需要通过下面这些渠道，增加你自己在技术社区里的知名度。 当知名度有了的话，很多公司会主动地去联系你。我知道的就有很多大公司的HR，会泡在GitHub上，然后去爬当地star排名非常靠前的用户，再主动地发邮件联系他们，邀请他们来公司进行面试。 而这部分的内容，就需要时间和个人精力的投入。比方说大学里，你可以选择从大二开始维护自己的GitHub仓库，在上面可以多创建一下项目，然后把自己原创的一些代码，包括参与的开源项目中提交的PR都可以发布上去。 你还可以用GitHub去搭建一个自己的技术博客，把大二大三大四几年以来的技术的积累和收获都放在上面，到你真正毕业去找工作的时候，其实你基本上不需要一个简历了。GitHub上面几百次的提交就是对你最好的一个证明。 还有就是像Stack Overflow这一类的技术社区。我个人建议是，在你有一些非常深入的技术了解之后，可以尝试着去回答一些小白的提问，这样子对个人的名声和技术也是有一个提高。 其他的内容无外乎就是你翻译过的一些技术文档，国外的非常著名的技术文档。其实在GitHub上，就可以加入很多的翻译组。还有你为一些在线教育网站贡献的内容，比方说想实验楼，你在实验楼投稿了一些课程，或是在一些在线教育的视频网站上，发布了一些自己录制的视频，这其实都是非常好的证明。 09 “ 常见问题！”第三部分的内容，就是我能想到的一些常见的问题。 首先需要注意的是，简历一定要短。把你最重要的内容精简到一页纸里面；把你最重要的关键字，精简到最突出的位置上。 千万不要增加大段的内容，大段的文字是简历的一个大忌。也不要夹杂太多个人感受、个人经历的文字，真的没人看。Hr或者工程师在收到很多简历的时候，他们的时间是非常有限的。如果你不能在很短的时间内抓住他们的眼球，那其实是浪费了一个很好的机会。 第二点是关于信息的顺序。首先应届生的话要突出学校，就把自己的教育信息和个人信息合在一起就可以了。非应届的话，最重要的是你的工作经验——你先前的工作、工作的时间长短、工作的核心内容是否与你应聘的职位相关、以及工作中的一些数据证据。个人信息下面就可以直接放一些工作经历。 在投递简历的时候要根据应聘的职位进行一些调整。比如调整一些想要顺序、技术技能的顺序、以及先前工作经验中重点关键词的描述，尽可能往应聘需求上靠。 简历的格式尽可能的用pdf，这样通用性会更好一些。然后是不要放照片，除非是长得非常漂亮，或者职位有要求的，基本上，我见过的职位是没有要求放照片的。 最后就是如果投递外企的话，尽可能一页英文简历，一页中文简历，因为面试你的很可能是外国工程师。 另外，如果选择一个公司，可以适当地对这个公司的产品，包括用到的技术进行一些调研，也可以准备一份简短的对该公司产品的技术分析，放在简历里面。当然基本上用不到，更多的可能在面试环节里会用到。 这就是我今天给大家分享的一些内容，因为比较精简，可能很多地方并不是特别全面，大家想问的问题，或者想讨论的话题都可以提出来。 10 “ 用户提问” 01 提问：学完基础后，怎么找一个好项目来做？ 回答：学完基础之后，可以先来实验楼做一些小的项目。如果你想有拿得出去、可以证明的项目，最好是去GitHub上找一些开源的项目，看一下人家提的ISSUE，然后找一些自己可以修的，再尝试着去提一些PR，哪怕被拒掉了。我觉得经过这几次交流之后，基本会有被接受的。这是一个非常好的锻炼自己的机会。 02 提问：一般公司最看重应届生的哪方面？实习经验还是其他东西？ 回答：就拿我们公司来说，对应届生更多地看重的是实习的项目经验，以及学习能力，包括他真正解决问题的能力。并不是特别重要的是你现在技术方面的东西。因为过来以后，都是需要在团队里面进行很长时间的磨合，磨合的过程中也会有高级工程师会带一些，做一些经验的分享。 03 提问：您强调 GitHub 中原创性的重要性，但个人又想兼容较大的提交量，这样的话需要怎么平衡？比如在实验楼做完实验，自动会把实验代码git下，其实更多的是一种个人的记录和托管，但这不是与原创性有所矛盾啦？ 回答：GitHub的提交和原创性其实并不矛盾啊。比方说你有什么思路，就在GitHub上创建这个项目，尝试着从最小的版本开始，慢慢地做一些迭代，持续上半年的时间，你的项目从代码量到知名度都会起来的啊。当然这就是一个坚持的过程。另外，如果要一个知名度比较高的，其实可以找一个大型项目里面的ISSUE，相当于你帮别人解决一些已知的问题。或者用他的框架去提出一些问题，然后提出自己的修复方案，提交一个PR，在讨论或者说在代码提交中，都会收到很多国内外工程师的反馈，这也是非常重要的。 04 提问：感觉面试完了，面试官说：我的问题问完了，你有什么要问的吗？这是最尴尬的时候。 回答：其实这个时候面试官也很尴尬……他可能自己也没有什么话要说了，只不过想找一个方式来结束本次面试。其实这个时候你就可以礼貌性质地问一些公司产品或者研发技术的一些问题。如果正好面试官属于这个产品线，或者对这个技术非常感兴趣的话，可以再深入地跟他探讨一下，但是呢，不要冒昧的提出一些自己并不是特别懂的建议。 原文链接 http://www.jianshu.com/p/0b676530e506]]></content>
      <categories>
        <category>职场</category>
      </categories>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 模式详解—「NSNotification通知」]]></title>
    <url>%2FiOSUI%2FNSNotification.html</url>
    <content type="text"><![CDATA[Write in the first【写在最前】 Notification(通知) 是 iOS 系统下重要的消息传递机制之一，通知封装了诸如窗口获得焦点、网络连接关闭等事件信息，通知的内容可按照我们实际的需求来定制。在实际开发中或多或少都会接触到，NSNotificationCenter 与 其它对象之间通信方式类似，但也存在不同，我们需要根据具体应用场景选择（或优先选择）恰当的通信方式。 本篇文章主要从【NSNotification和NSNotificationCenter 使用和注意点】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： NSNotification1.NSNotification 概念2.NSNotification.h 系统文件 NSNotificationCenter1.NSNotificationCenter 概念2.NSNotificationCenter 系统文件 NSNotificationCenter 的使用流程1.注册观察者（添加监听）2.发送通知3.移除观察者（移除监听） NSNotificationQueue1.NSNotificationQueue 概念2.NSNotificationQueue.h 系统文件3.NSNotificatinonCenter 实现原理 NSNotificatinonCenter 实战使用1.基本使用2.通知在多线程中使用3.通知在多线程中注意点 NSNotification Demo效果图 期待 &amp; 后续 &amp; About me NSNotification 本着好好学习，了解权威的目的，我们还是主动看官网的说明。 NSNotification 概念上图简单点释义就是NSNotification是方便NSNotificationCenter 广播到其他对象时的封装对象，简单讲即通知中心对通知调度表中的对象广播时发送NSNotification对象。NSNotification对象(称为通知)包含名称、object 和一个可选字典三个属性，名称是用来标识通知的标记（一般为常量字符串），object是任意想要携带的对象（通常为发送者自己 或为nil），字典用来存储发送通知时附带的信息（可为nil）。NSNotification 对象是不可变的对象。 NSNotification.h 系统文件看完官网，接下来当然是看系统文件了。你说是吧！ 12345678910/**************** Notifications ****************/@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;@property (readonly, copy) NSNotificationName name;// 通知的标识名称(一般为常量字符串)@property (nullable, readonly, retain) id object;// 任意想要携带的对象(通常为发送者自己,可为nil)，@property (nullable, readonly, copy) NSDictionary *userInfo;// 关于通知的附加信息(可为nil)- (instancetype)initWithName:(NSNotificationName)name object:(nullable id)object userInfo:(nullable NSDictionary *)userInfo NS_AVAILABLE(10_6, 4_0) NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER; 接下来看下三个初始化方法 12345+ (instancetype)notificationWithName:(NSNotificationName)aName object:(nullable id)anObject;// 有附加信息+ (instancetype)notificationWithName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;- (instancetype)init /*NS_UNAVAILABLE*/; /* do not invoke; not a valid initializer for this class */ NSNotificationCenter 我们还是主动看官网的说明。 NSNotificationCenter 概念上图简单点释义就是NSNotificationCenter对象(通知中心) 是 Foundation 框架的一个子系统，提供了在程序中广播消息的机制。通过［NSNotificationCenter defaultCenter］获取引用总的通知中心，可以在不同类之间通信的时候使用。 在通知中心注册观察者，发送者使用通知中心广播时，以NSNotification的name和object来确定需要发送给哪个观察者。为保证观察者能接收到通知，所以应先向通知中心注册观察者，接着再发送通知这样才能在通知中心调度表中查找到相应观察者进行通知。 NSNotificationCenter 系统文件看完官网，接下来当然是看系统文件了。你说是吧！ 123456789101112/**************** Notification Center ****************/@interface NSNotificationCenter : NSObject &#123; @package void *_impl; void *_callback; void *_pad[11];&#125;#if FOUNDATION_SWIFT_SDK_EPOCH_AT_LEAST(8)// 获取通知中心@property (class, readonly, strong) NSNotificationCenter *defaultCenter; 总结：获取NSNotificationCenter的方法只有一种，即[NSNotificationCenter defaultCenter]，并且NSNotificationCenter是一个单例模式，一旦创建，这个通知中心的对象会一直存在于一个应用的生命周期。 通知中心的使用流程获取通知中心对象后，我们就可以使用它来处理通知相关的操作了，包括注册观察者、发送通知 和 移除观察者。 1、注册观察者（添加监听）你可以使用以下两种方式注册观察者 123456789101112131415161718192021222324252627//--------------------------- 注册观察者方式一 ------------------------------///** Observer: 观察者 selector: 只要一监听到通知,就会调用观察者这个方法 Name: 通知名称也是通知的唯一标示，编译器就是通过这个找到通知的。 object: 谁发出的通知,表示会对哪个发送者对象发出的事件作出响应，nil 时表示接受所有发送者的事件。 */- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject;//--------------------------- 注册观察者方式二 ------------------------------///** Name: 通知名称 object: 谁发出的通知 queue: 决定block在哪个线程执行,nil:在发布通知的线程中执行 [NSOperationQueue mainQueue]: 一般都是使用主队列 usingBlock: 只要监听到通知,就会执行这个block 注意: 一定要记得移除 */- (id &lt;NSObject&gt;)addObserverForName:(nullable NSNotificationName)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block NS_AVAILABLE(10_6, 4_0);// The return value is retained by the system, and should be held onto by the caller in// order to remove the observer with removeObserver: later, to stop observation. 总结： 第一种方式是比较常用的添加Oberver的方式，接到通知时执行Selector方法，观察者接收到通知后执行任务的代码在发送通知的线程中执行（下面示例代码验证）。 第二种方式是提供了一个以block方式实现的添加观察者的方法。大家第一次看到这个方法时是否会有这样的疑问：观察者呢？参数中并没有指定具体的观察者，那谁是观察者呢？需要移除吗？ 实际上，与前一个方法不同的是，前者使用一个现存的对象作为观察者，而这个方法会创建一个匿名的对象作为观察者(即方法返回的id&lt;NSObject&gt;对象)，这个匿名对象会在指定的队列(queue)上去执行我们的block。 第二种注册方式注意点： 1、参数queue 决定block在哪个线程执行，即我们指定了操作队列。如果queue为nil，则消息是默认在post线程中同步处理，即 观察者接收到通知后执行任务的代码在发送通知的线程中执行（下面示例代码验证）。 2、block块会被通知中心拷贝一份(执行copy操作)，以在堆中维护一个block对象，直到观察者被从通知中心中移除。所以，应该特别注意在block中使用外部对象，避免出现对象的循环引用。 3、如果一个给定的通知触发了多个观察者的block操作，则这些操作会在各自的Operation Queue中被并发执行。所以我们 不能去假设操作的执行会按照添加观察者的顺序来执行。 4、该方法会返回一个表示观察者的对象，记得在不用时移除这个对象。 第2点示例，由于使用的是block，所以需要注意的就是避免引起循环引用的问题： 123456789101112131415161718192021222324252627282930313233343536373839404142@interface Observer : NSObject@property (nonatomic, assign) NSInteger i;@property (nonatomic, weak) id&lt;NSObject&gt; observer;@end @implementation Observer- (instancetype)init &#123; self = [super init]; if (self) &#123; NSLog(@"Init Observer"); // 添加观察者 _observer = [[NSNotificationCenter defaultCenter] addObserverForName:TEST_NOTIFICATION object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *note) &#123; NSLog(@"handle notification"); // 使用self self.i = 10; &#125;]; &#125; return self;&#125;@end #pragma mark - ViewController@implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; [self createObserver]; // 发送消息 [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];&#125;- (void)createObserver &#123; Observer *observer = [[Observer alloc] init];&#125;@end//--------------------------- &lt;#我是分割线#&gt; ------------------------------//// 打印输出Init Observerhandle notification 我们可以看到createObserver中创建的observer并没有被释放。所以，使用addObserverForName:object:queue:usingBlock:一定要注意这个问题。 2、发送通知发送通知可使用以下方法123- (void)postNotification:(NSNotification *)notification;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo; 总结： 三种方式都是发送NSNotification对象给通知中心注册的所有观察者。 发送通知通过name和object来确定来标识观察者，name和object两个参数的规则相同即当通知设置name为kChangeNotifition时，那么只会发送给符合name为kChangeNotifition的观察者，同理object指发送给某个特定对象通知，如果只设置了name，那么只有对应名称的通知会触发。如果同时设置name和object参数时就必须同时符合这两个条件的观察者才能接收到通知。 3、移除观察者（移除监听）在对象被释放前需要移除掉观察者，避免已经被释放的对象还接收到通知导致崩溃。移除观察者有两种方式： 12- (void)removeObserver:(id)observer;- (void)removeObserver:(id)observer name:(nullable NSNotificationName)aName object:(nullable id)anObject; 总结： 传入相应的需要移除的observer 或者使用第二种方式三个参数来移除指定某个观察者。 如果使用基于-[NSNotificationCenter addObserverForName:object:queue:usingBlock:]方法在获取方法返回的观察者进行释放。基于这个方法我们还可以让观察者接到通知后只执行一次： 1234__block __weak id&lt;NSObject&gt; observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"note" object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) &#123; NSLog(@"%@",[NSThread currentThread]);&#125;]; 通知的发送与处理是同步的，在某个地方post一个消息时，会等到所有观察者对象执行完处理操作后，才回到post的地方，继续执行后面的代码。 123456789101112131415161718192021222324- (void)viewDidLoad &#123; [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(reciveNote1) name:@"note" object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(reciveNote2) name:@"note" object:nil]; [[NSNotificationCenter defaultCenter] postNotificationName:@"note" object:nil]; NSLog(@"continue");&#125;- (void)reciveNote1 &#123; NSLog(@"接收到通知--reciveNote1"); &#125;- (void)reciveNote2 &#123; NSLog(@"接收到通知--reciveNote2"); &#125;//--------------------------- &lt;#我是分割线#&gt; ------------------------------////打印输出2016-03-28 15:33:48.423 03-通知补充[8711:298506] 接收到通知--reciveNote12016-03-28 15:33:48.423 03-通知补充[8711:298506] 接收到通知--reciveNote22016-03-28 15:33:48.423 03-通知补充[8711:298506] continue NSNotificationQueue 我们还是主动看官网的说明。 NSNotificationQueue 概念上图简单点释义就是NSNotificationQueue 通知队列，更像是通知中心的缓冲区，用来管理多个通知的调用。通知队列通常以先进先出（FIFO）顺序管理通知。当一个通知上升到队列的前面时，队列就将它发送给通知中心(NSNotificationCenter)，通知中心随后将它派发给所有注册为观察者的对象。。 NSNotificationQueue.h 系统文件看完官网，接下来当然是看系统文件了。你说是吧！ 创建通知队列方法 12// 创建通知队列方法- (instancetype)initWithNotificationCenter:(NSNotificationCenter *)notificationCenter NS_DESIGNATED_INITIALIZER; 往队列加入通知方法(异步) 123// 往队列加入通知方法- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle;- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle coalesceMask:(NSNotificationCoalescing)coalesceMask forModes:(nullable NSArray&lt;NSRunLoopMode&gt; *)modes; 移除队列中的通知方法 12// 移除队列中的通知方法- (void)dequeueNotificationsMatching:(NSNotification *)notification coalesceMask:(NSUInteger)coalesceMask; 发送方式 12345678910// NSPostingStyle包括三种类型typedef NS_ENUM(NSUInteger, NSPostingStyle) &#123; NSPostWhenIdle = 1, NSPostASAP = 2, NSPostNow = 3&#125;;注解：NSPostWhenIdle：空闲发送通知 当运行循环处于等待或空闲状态时，发送通知，对于不重要的通知可以使用。NSPostASAP：尽快发送通知 当前运行循环迭代完成时，通知将会被发送，有点类似没有延迟的定时器。NSPostNow ：同步发送通知 如果不使用合并通知 和postNotification:一样是同步通知。 合并通知 通过合并我们可以用来保证相同的通知只被发送一次。 forModes:(nullable NSArray&lt;NSRunLoopMode&gt; *)modes可以使用不同的NSRunLoopMode配合来发送通知，可以看出实际上NSNotificationQueue与RunLoop的机制以及运行循环有关系，通过NSNotificationQueue队列来发送的通知和关联的RunLoop运行机制来进行的。 12345678910// NSNotificationCoalescing也包括三种类型typedef NS_OPTIONS(NSUInteger, NSNotificationCoalescing) &#123; NSNotificationNoCoalescing = 0, NSNotificationCoalescingOnName = 1, NSNotificationCoalescingOnSender = 2&#125;;注解：NSNotificationNoCoalescing：不合并通知。NSNotificationCoalescingOnName：合并相同名称的通知。NSNotificationCoalescingOnSender：合并相同通知和同一对象的通知。 NSNotificatinonCenter 实现原理 NSNotificatinonCenter是使用观察者模式来实现的用于跨层传递消息，用来降低耦合度。 NSNotificatinonCenter用来管理通知，将观察者注册到NSNotificatinonCenter的通知调度表中，然后发送通知时利用标识符name和object识别出调度表中的观察者，然后调用相应的观察者的方法，即传递消息（在Objective-C中对象调用方法，就是传递消息，消息有name或者selector，可以接受参数，而且可能有返回值），如果是基于block创建的通知就调用NSNotification的block。 NSNotificatinonCenter 实战使用 基本使用第一种注册观察者的方式： 1234567891011121314151617181920212223- (void)viewDidLoad &#123; [super viewDidLoad]; // 1.注册观察者（添加监听） [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(reciveNote1) name:@"note" object:nil]; // 2.发送通知 [[NSNotificationCenter defaultCenter] postNotificationName:@"note" object:nil];&#125;// 一个对象即将销毁就会调用- (void)dealloc &#123; // 3.移除通知 [[NSNotificationCenter defaultCenter] removeObserver:self];&#125;// 观察者接收到通知后执行任务的代码- (void)reciveNote1 &#123; NSLog(@"接收到通知--reciveNote1"); &#125;打印输出：2016-03-28 16:57:45.320 03-通知补充[10343:376649] 接收到通知--reciveNote1 第二种注册观察者的方式： 123456789@property (nonatomic, weak) id observe;// 1.注册观察者（添加监听）_observe = [[NSNotificationCenter defaultCenter] addObserverForName:@"note" object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) &#123; NSLog(@"我是block方式注册观察者");&#125;]; // 2.发送通知[[NSNotificationCenter defaultCenter] postNotificationName:@"note" object:nil]; 总结：这个方法的优点在于添加观察者的操作与回调处理操作的代码更加紧凑，不需要拼命滚动鼠标就能直接找到处理代码，简单直观。个人比较喜欢。 通知在多线程中使用注册观察者两种方式，在多线程中的使用和注意点，以下 会分别说明。 第一种注册观察者方式，以下代码我们将验证这个结论：接收通知代码 由 发出通知线程决定，即观察者接收到通知后执行任务的代码在发送通知的线程中执行 123456789101112131415161718// 1.注册观察者（添加监听）[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(reciveNote1) name:@"note" object:nil];// 2.发送通知（主线程）[[NSNotificationCenter defaultCenter] postNotificationName:@"note" object:nil];// 发送通知（异步线程）dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:@"note" object:nil];&#125;);//--------------------------- &lt;#我是分割线#&gt; ------------------------------////// 接收到通知执行代码- (void)reciveNote1 &#123; NSLog(@"%@",[NSThread currentThread]); NSLog(@"接收到通知--reciveNote1"); &#125; 1234567发送通知（异步线程）打印输出：2016-03-28 17:21:36.122 03-通知补充[10818:402396] &lt;NSThread: 0x600000267cc0&gt;&#123;number = 3, name = (null)&#125;2016-03-28 17:21:36.122 03-通知补充[10818:402396] 接收到通知--reciveNote1发送通知（主线程）打印输出：2016-03-28 17:23:42.705 03-通知补充[10868:404679] &lt;NSThread: 0x60800007a6c0&gt;&#123;number = 1, name = main&#125;2016-03-28 17:23:42.705 03-通知补充[10868:404679] 接收到通知--reciveNote1 第二种注册观察者方式，以下代码我们将验证这个结论：接收通知代码 由 发出通知线程决定，即观察者接收到通知后执行任务的代码在发送通知的线程中执行（指定操作队列除外） 1234567891011121314151617// 指定操作队列 [NSOperationQueue mainQueue] // _observe = [[NSNotificationCenter defaultCenter] addObserverForName:@"note" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123;// 1.注册观察者（添加监听）_observe = [[NSNotificationCenter defaultCenter] addObserverForName:@"note" object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) &#123; // 只要监听到通知 就会调用 NSLog(@"%@",[NSThread currentThread]); NSLog(@"我是block方式注册观察者");&#125;];// 2.发送通知（主线程）[[NSNotificationCenter defaultCenter] postNotificationName:@"note" object:nil];// 发送通知（异步线程）dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:@"note" object:nil];&#125;); 1234567891011发送通知（主线程）打印输出：2016-03-28 18:17:08.587 03-通知补充[11305:421194] &lt;NSThread: 0x608000072940&gt;&#123;number = 1, name = main&#125;2016-03-28 18:17:08.587 03-通知补充[11305:421194] 我是block方式注册观察者发送通知（异步线程）打印输出：2016-03-28 18:24:56.248 03-通知补充[11503:431482] &lt;NSThread: 0x60000007ec40&gt;&#123;number = 3, name = (null)&#125;2016-03-28 18:24:56.248 03-通知补充[11503:431482] 我是block方式注册观察者注册观察者,指定操作队列（不管发送通知在那个线程都按指定操作队列执行）2016-03-28 18:27:04.567 03-通知补充[11555:433722] &lt;NSThread: 0x600000073e40&gt;&#123;number = 1, name = main&#125;2016-03-28 18:27:04.567 03-通知补充[11555:433722] 我是block方式注册观察者 通知在多线程中注意点开发中使用场景，第一种方式，一般在接收通知执行代码中，做一下处理： 123456789- (void)reciveNote1&#123; // 更新UI dispatch_sync(dispatch_get_main_queue(), ^&#123; // 更新UI NSLog(@"%@",[NSThread currentThread]); &#125;);&#125; 第二种方式，一般在接收通知执行代码中，做一下处理： 1234567// 一般不要写nil ,更新UI指定主队列_observe = [[NSNotificationCenter defaultCenter] addObserverForName:@"note" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123; // 更新UI NSLog(@"%@",[NSThread currentThread]);&#125;]; 总结 在我们的应用程序中，两个对象之间如何通信。根据具体应用场景优先选择哪一种通信方式。对象之间的通信方式主要有以下几种： 直接方法调用 Target-Action事件 Delegate代理 block回调 KVO监听 NSNotification通知 优先选择哪一种通信方式： 通信对象是一对一的还是一对多的对象之间的耦合度. 建议： 1.在需要的地方使用通知，要求: 必须得保证通知的名称在监听和发出时是一致的。 2.注册的观察者在不使用时一定要记得移除，即添加和移除要配对出现。 3.尽可能迟地去注册一个观察者，并尽可能早将其移除，这样可以改善程序的性能。因为，每post一个通知，都会是遍历通知中心的分发表，确保通知发给每一个观察者。 4.记住通知的发送和处理是在同一个线程中。 5.使用-addObserverForName:object:queue:usingBlock:务必处理好内存问题，避免出现循环引用。 6.NSNotificationCenter是线程安全的，但并不意味着在多线程环境中不需要关注线程安全问题。不恰当的使用仍然会引发线程问题。 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 模式详解—「KVC编码 & KVO监听」]]></title>
    <url>%2FiOSUI%2FKVCKVO.html</url>
    <content type="text"><![CDATA[Write in the first【写在最前】 开发过程中，最常见的就是程序的流程取决于你所使用的各种变量和属性的值，根据变量和属性的值确定后面运行的代码。学好「获取类中属性的变化」这一模块是开发重要部分之一，目地：为了解决在开发过程中，由需求改变引发的各种蛋疼、繁琐的问题。 本篇文章主要从【KVC &amp; KVO 使用场景相关】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： 引导 KVC 概论 KVC 常用方法 KVC 对多种数据类型的支持 KVC 实现原理 KVC 基本使用1.KVC 简单赋值 &amp; 取值2.KVC 访问私有成员变量3.KVC 字典转模型 KVO 概论 KVO 使用步骤 KVO 实现原理 KVO 手动发送通知机制 引导 我们有多种方式获取对象的改变。例如，使用委托、通知获取值的改变。如果需要观察多个属性的变化，使用委托或通知会产生大量代码，一个更好用来观察属性变化的方法是使用 键值监听（Key Value Observing，简称KVO），Apple 在自己的软件中大量使用 KVO。使用 KVO 跟踪单个属性或集合（如数组）的变化非常高效，键值观察建立在 键值编码（Key Value Coding，简称KVC） 基础上，也就是任何你想使用 KVO 监听的属性必须符合键值编码。KVO 只需要在观察者方法中添加代码，不需要修改被观察文件内代码，这一点和委托、通知不同。 KVC 和 KVO 提供了一个强大高效的方式来编写代码，学习 KVO 前必须先掌握 KVC，所以 我们按实用开发技巧一点点剖析它。 KVC 概论 KVC（全称 key-value-coding）即键值编码。KVC 的操作方法由NSKeyValueCoding 非正式协议提供，而NSObject(NSKeyValueCoding)就实现了这个协议，也就是说ObjC中几乎所有的对象都支持 KVC 操作，它是一种不通过存取方法（Setter、Getter），而通过属性名称字符串（key）间接访问类属性(实例变量)的机制。 KVC 常用方法 KVC 常用的方法如下： 赋值 123456- (void)setValue:(nullable id)value forKey:(NSString *)key;- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;// 注解:setValue:(属性值) forKey:(属性名),（用于简单属性）。setValue:(属性值) forKeyPath:(属性名),（用于复合属性，进行内部的点语法，层层访问内部的属性; 例如student.name，Student学生模型类中的name属性。 获取值 123456- (id)valueForKey:(NSString *)key;- (nullable id)valueForKeyPath:(NSString *)keyPath;// 注解:valueForKey:属性名valueForKeyPath:属性名(用于复合属性） KVC 对多种数据类型的支持 首先要说的是对于基本数据类型的属性，KVC 的这几个方法会自动装箱和拆箱。其次，KVC 也支持数组和字典等集合数据。这里了解不多，不做过多总结，有兴趣可参考：KVC/KVO原理详解及编程指南 简单示例：KVC 自动类型转换如：模型类定义的属性是 float money123456@property (nonatomic, assign) float money;// KVC 赋值[person setValue:@"18" forKeyPath:@"money"];[person setValue:[NSNumber numberWithInteger:18] forKeyPath:@"money"];打印输出会自动转换成 float 类型 18.00; KVC 实现原理 1、[item setValue:@&quot;白开水ln简书&quot; forKey:@&quot;name&quot;]; 1.首先去模型中查找有没有 setName，若有，直接调用赋值 [self setName:@&quot;白开水ln简书&quot;]。 2.若无，去模型中查找有没有 name 属性，若有，直接访问属性赋值 name = value。 3.若无，再去模型中查找有没有 _name 成员变量，若有，直接访问属性赋值 _name = value。 4.找不到，就会直接报找不到的错误（valueForUndefinedKey:）。 2、[item setValuesForKeysWithDictionary:dict]; 1.遍历字典中所有 key。 2.去模型中查找有没有对应的属性。 1234[dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull value, BOOL * _Nonnull stop) &#123; // 2.去模型中查找有没有对应属性 KVC [item setValue:value forKey:key];&#125;]; KVC 基本使用 KVC 简单赋值 &amp; 取值123456LNPerson *person = [[LNPerson alloc] init]; person.dog = [[LNDog alloc] init]; [person.dog setValue:@"阿黄" forKey:@"name"];[person setValue:@"旺财" forKeyPath:@"dog.name"];NSLog(@"%@", person.dog.name); 区别：forKey: 和 forKeyPath:1、forKeyPath 包含了所有 forKey 的功能2、forKeyPath 进行内部的点语法,层层访问内部的属性3、注意：key 值一定要在属性中找到，开发中最好使用forKeyPath。 KVC 取值12345[person valueForKeyPath:@"name"]// 取出数组中所有模型的某个属性值NSArray *allPersons = @[person1, person2, person3];NSArray *allPersonName = [allPersons valueForKeyPath:@"name"]; KVC 访问私有成员变量1234567@implementation LNPerson&#123; int _age; &#125;LNPerson *person = [[LNPerson alloc] init];[person setValue:@"88" forKeyPath:@"age"]; 注意：上面的 keyPath 写age 或 _age都可以，KVC 会自动去查找。 KVC 字典转模型简单示例：12345678910111213141516171819202122NSDictionary *dict = @&#123; @"name" :@"lurry", @"money" : @189.88, //@"development" : @"iOS"--&gt;问题1模型的属性和字典不能一一对应 /* @"dog" : @&#123; @"name" : @"wangcai", @"price" : @8 &#125;, */ //--&gt;问题2模型中嵌套模型 &#125;;LNPerson *person = [[LNPerson alloc] init];[person setValuesForKeysWithDictionary:dict];// 等同于下面的代码// setValuesForKeysWithDictionary: 原理:// 1.遍历字典中所有key,去模型中查找有没有对应的属性[dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull value, BOOL * _Nonnull stop) &#123; // 2.去模型中查找有没有对应属性 KVC [item setValue:value forKey:key]; &#125;];NSLog(@"%@", person); 开发中不建议使用 setValuesForKeysWithDictionary:（把字典中所有值给模型的属性赋值） 问题1：如果服务器多返回几个数据 Key，在模型中系统找不到就会报错。 1reason: '[&lt;LNPerson 0x100304730&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key nam. 解决：重写系统方法 setValue:forUndefinedKey:，就不会有报错信息了。补充：什么时候重写系统方法?1、想给系统方法添加额外功能 2、不想要系统方法实现 问题2：如果模型中带有模型型，setValuesForKeysWithDictionary 不能用。解决：思路，拿到每一个模型属性，去字典中取出对应的值，给模型赋值（提醒：从字典中取值,不一定要全部取出来）。建议使用：MJExtension 字典转模型 和 Runtime（根据模型中属性，去字典中取出对应的 value 给模型属性赋值） 模型转成字典 1NSDictionary *dict = [person dictionaryWithValuesForKeys:@[@"name", @"money"]]; KVO 概论 KVO（Key-Value-Obersver）即键值监听，利用一个key来找到某个属性并监听其属性值得改变，当该属性发生变化时，会自动的通知观察者，这比通知中心需要post通知来说，简单了许多。其实这也是一种典型的观察者模式。 KVO 使用步骤 给目标对象的属性添加观察者 在回调方法中监听属性的变化 移除观察者 具体代码如下：1234567891011121314151617181920212223242526272829303132- (void)viewDidLoad &#123; [super viewDidLoad]; self.person = [[LNPerson alloc] init]; person.name = @"zs"; /* - Observer 观察者 - KeyPath 要监听的属性 - options 选项(可选属性值，示例：旧值和新值) */ // 1.添加观察者 [self.person addObserver:self forKeyPath:@"name" options: NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:nil]; person.name = @"ls";// 这里重新赋值 person.name = @"ww";&#125;- (void)dealloc&#123; // 2.移除观察者 [self.person removeObserver:self forKeyPath:@"name"];&#125;/** * 当监听的属性值发生改变 * @param keyPath 要监听的属性 * @param object 要监听的属性所属的对象 * @param change 改变的内容 * @param context 上下文 */#pragma mark - KVO// 3.监听属性的变化- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(LNPerson *)person change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123; NSLog(@"%@------%@------%@", keyPath, change);&#125; KVO 实现原理 当一个类的属性被观察的时候，系统会通过runtime动态的创建一个该类的派生类，并且会在这个类中重写基类被观察的属性的setter方法，而且系统将这个类的isa指针指向了派生类，从而实现了给监听的属性赋值时调用的是派生类的setter方法。重写的setter方法会在调用原setter方法前后，通知观察对象值得改变。此外，派生类还重写了 dealloc 方法来释放资源。 可以看到重写的 setter 方法，给属性赋值的前后分别调用了两个方法。12- (void)willChangeValueForKey:(NSString *)key;- (void)didChangeValueForKey:(NSString *)key; 而- (void)didChangeValueForKey:(NSString *)key;会调用1- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSString*, id&gt; *)change context:(nullable void *)context; KVO 手动发送通知机制 默认情况下，KVO 观察到属性变化系统会自动发送通知，但在某些情况下，你可能需要控制何时发送通知。例如：在某些情况下不需要发送通知，或将多个改变合并为一个通知发送。其实我们也可以手动，显式的调用上面两个方法，以使其具有通知机制。举个示例：1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; self.person = [[LNPerson alloc] init]; person.name = @"zs"; // 1.添加观察者 [self.person addObserver:self forKeyPath:@"name" options: NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:nil]; [self willChangeValueForKey:@"name"]; person.name = @"this is a test"; // 直接修改成员变量的值，手动的调用上下两个方法，使其就有通知机制 [self didChangeValueForKey:@"name"];&#125;- (void)dealloc&#123; // 2.移除观察者 [self.person removeObserver:self forKeyPath:@"name"];&#125;#pragma mark - KVO// 3.监听属性的变化- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(LNPerson *)person change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123; if(object == self &amp;&amp; [keyPath isEqualToString:@"name"]) &#123; NSLog(@"%@------%@------%@", keyPath, change); &#125; else &#123; [super observeValueForKeyPath:keyPath ofObject: person change:change context:context]; &#125;&#125; 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown—写作便捷高效]]></title>
    <url>%2FToolsAndPlugins%2FMarkdown.html</url>
    <content type="text"><![CDATA[Markdown 认知Markdown Markdown 是什么? Markdown 是一种用来写作的「轻量级标记语言」，创始人为约翰·格鲁伯（John Gruber）。它允许人们「使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档 」—— 维基百科 如果你看不懂以上维基百科对 Markdown 的定义，就当这段掐了没播。约翰·格鲁伯自己对Markdown的描述的重点也在于 「easy-to-read，easy-to-write」。 那么到底 easy 在哪里呢 虽然称作 「标记语言」，但简单理解 Markdown 就是在文本前增加符号来表示文本格式。它用简洁的「标记」语法代替排版，而不像一般我们用的处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专注于内容的编写， 不仅支持文字排版，还支持 插入图片(包括gif)、 链接 等。而这些操作只用键盘就可以通通搞定了。目前也被越来越多的写作爱好者广泛使用，支持 Markdown 语法的编辑器有很多，包括很多网站（如简书）都支持 Markdown 语法的录入。Markdown 从写作到完成，内容「易读易写」，导出格式「随心所欲」，你可以导出 HTML 格式的文件用来网站发布，也可以导出 PDF 格式打印浏览。对求职者来说，Markdown 写出的简历更能得到 HR 的好感。 无图无真相： 使用 Markdown 的优点 1. 编辑，不用操心排版 你只需要把注意力放在内容上。笔者在用 Markdown 之前，打开word 先想想，标题用啥字体呢，几号字呢？不知不觉我的意志力就被消耗了。实际上所谓排版，不就是作者的思路以及内容的层级和结构么，在学会使用 Markdown 之后，几个简单的符号就把这些事儿搞定，样式还特别工整精美。2. 修改，不用担心排版 想想那些你汗洒的 word 文档吧，如果童鞋你从外部粘贴了一段带格式的文字，粘贴后发现整个人都不好了：格式被改的乱七八糟，还要重新调整。如果用 Markdown 编写 ，想改哪里改哪里，根本不用担心格式，改完发布收工，多轻松！3. 导出，不用费心格式 可以导出为 PDF、 HTML 以及.md 本身的格式文件，不管在什么设备上，看起来都是一个工整的样子。 一句话来说，Markdown 是用最简单的方式，零排版成本，写出布局工整、阅读舒适的笔记。减少干扰，降低成本，提高效率，不仅自己阅读爽，分享给朋友也有面儿不是~ P.S : Markdown 中文版语法说明 如何创建 Markdown 笔记 不管我再怎么说 Markdown 的语法记忆负担小、简单，在最初你都会有点儿晕。在这里给大家分享个小技巧： 最初只需要记住 # 标题一、## 标题二、1. 第一点、* 这一点，用这几个写写日志、需求文档、小文章，排版上足够了； 逐渐的你发现有些文字需要重点指出，那么还可以使用 **加粗**、*斜体* 来对文字做重点说明； 如果你是名程序员，那么可以用 ` 把代码块包起来，渲染后可以关键字高亮；123456789101112131415161718194. 学生的话，你可以用 &gt; 做引用&gt; 书是人类进步的阶梯，终生的伴侣，最诚挚的朋友。——高尔基#### Markdown 标记符号简要规范**下文仅是我以自己的方式阐述这些语法的具体用法，供参考****1. 标题**在行首插入 1 到 6个 `#`，分别表示标题 1 到标题 6![标题](http://oiizs6l0g.bkt.clouddn.com/Markdown活学活用3.png)**2. 有序列表 / 无序列表**在行首增加 `1.`、`2.`、`3.`，即数字和英文句点, 不要求数字一定要连续，可以都是`1.`在行首增加 `*` 或 `-`![有、无序列表](http://oiizs6l0g.bkt.clouddn.com/Markdown活学活用2.png)**3. 文本样式**![粗体、斜体、删除线](http://oiizs6l0g.bkt.clouddn.com/Markdown活学活用4.png)**4. 分割线** 123456789-------------************______________**5. 引用**如果你需要引用一小段别处的句子，你可以用 `&gt; 这里是引用的话`&gt; 书是人类进步的阶梯，终生的伴侣，最诚挚的朋友。——高尔基并支持 **多级引用** 使用多个 右尖括号 `&gt;`，表示多级引用。 这里是一级引用内容 这里是二级引用内容 这里是三级引用内容12345678&gt; 这里是一级引用内容&gt; &gt; 这里是二级引用内容&gt; &gt; &gt; 这里是三级引用内容**6. 行内代码块 和 代码框**如果你是个程序猿，需要在文章里优雅的引用代码框，只需在代码前后增加 三个反单引号：` ``` `， 如果需要在行内添加代码块，使用 `代码` 表示行内代码块；让我们聊聊 `iOS攻城狮` int main(int argc, char * argv[]) {@autoreleasepool {return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));}}12345678910111213141516171819202122**7. 插入图片 和 链接** 插入图片格式： `![本地图片](http://cdn.wiz.cn/wp-content/uploads/custompbwaters.github.io)` 插入链接格式：` [链接显示说明](网址)` &gt; P.S : 这里的图片可以是本地图片，也可以是 网络图片。 ![](http://upload-images.jianshu.io/upload_images/2230763-05939fa7a5df62c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ![本地图片](http://upload-images.jianshu.io/upload_images/2230763-cdd0fc1a085fcbdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![](http://upload-images.jianshu.io/upload_images/2230763-a00835b06e5ec64c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![网络图片](http://upload-images.jianshu.io/upload_images/2230763-2fd3aceb036ac541.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)插入链接：`[简书](http://jianshu.io)` ---&gt; [简书](http://jianshu.io) **8. 插入表格**插入表格使用以下语法: ` | 列名 | ` ` |:-:| ` 水平排列模式**意思为**：`| :- |` 居左， `| :-: |` 居中, `| -: | ` 居右样式一： 表格1 表格2 表格3 居左 居中 居右 12345| 表格1 |表格2 | 表格3 ||:--- |:-:|---:|| 居左 | 居中 | 居右|样式二： | 表格1 |表格2 | 表格3||-|-|-| P.S: 中间几个减号都可以| 居左 | 居中 | 居右 || 居左 | 居中 | 居右 |12345678| 表格1 |表格2 | 表格3 ||-|-|-|| 居左 | 居中 | 居右|| 居左 | 居中 | 居右|**P.S : 注脚**使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。这是第二个注脚[^footnote2]的样例。 [^footnote]: 这是一个 注脚 的 文本。[^footnote2]: 这是另一个 注脚 的 文本。P.S:[^这里面可以任一写]```这是一个注脚1的样例。这是第二个注脚2的样例 这是一个 注脚1 的 文本。 ↩这是另一个 注脚2 的 文本。 ↩ 9. 目录在任何你想要展示Markdown 笔记目录的地方，添加 [TOC] ， 在阅读模式下，标题1~6样式的内容会被提取出来作为目录，相当于大纲功能。例如： 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>工具&amp;插件</category>
      </categories>
      <tags>
        <tag>工具&amp;插件</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 管理库工具CocoaPods「安装+问题解决+活用」续更]]></title>
    <url>%2FToolsAndPlugins%2FCocoaPods.html</url>
    <content type="text"><![CDATA[Write in the first 在开发 OS X 和 iOS 应用程序中，CocoaPods 作为库依赖管理工具就是一把利器。 相信很多开发者跟我当初一样，在 CocoaPods 的安装上踩了无数的坑，接着就是报错问题一个一个的来，以至于不能正常使用，更不用说活用的技巧了。作为【iOS 程序员】的我们，掌握CocoaPods 的使用是必不可少的基本技能了。 在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： CocoaPods 相关介绍 CocoaPods 安装 开始使用 安装过程中报错问题解决 指令补充 CocoaPods 均可参考的资料 Contents【相关介绍】 1. CocoaPods 是什么? CocoaPods 是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具。利用 CocoaPods，可以定义自己的依赖关系 (称作 pods)，并且随着时间的变化，以 及在整个开发环境中对第三方库的版本管理非常方便。 2. CocoaPods 背后的理念主要体现在两个方面 在工程中引入第三方代码 会涉及到许多内容。针对 Objective-C 初级开发者来说，工程文件的配置会让 人很沮丧。 在配置 build phases 和 linker flags 过程中，会引起许多人为因素的 错误，CocoaPods 简化了这一切，它能够自动配置编译选项，而且涉及到第三方库的更新升级也可以通过 CocoaPods 进行手动管理更新。 3. CocoaPods 的原理 它是将所有的依赖库都放到另一个名为 Pods 项目中，然后 让主项目依赖 Pods 项目，这样，源码管理工作都从主项目移到了Pods项目中。 Pods项目最终会编译成一个名为 libPods.a 的文件，主项目只需要依赖这个.a 文件即可。 对于资源文件，CocoaPods 提供了一个名为 Pods-resources.sh 的 bash 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目 标目录中。 CocoaPods 通过一个名为 Pods.xcconfig 的文件来在编译时设置所有的依赖 和 参数。 CocoaPods 是用 ruby 实现的，要想使用它首先需要有 ruby 的环境。幸运的是 OS X系统 默认已经可以运行 ruby 了。但是有时候 ruby 版本过低是无法正常支持 CocoaPods 的使用，所以需要先安装更新升级 rvm 和 ruby。 3. Homebrew、Rvm、Ruby 简介 官网及相关链接【Rvm 官网】:https://www.rvm.io/【Ruby 官网】:https://rubygems.org/【Rvm 安装指南】:https://rvm.io/rvm/install【Homebrew 官网】:http://brew.sh/index_zh-cn.html【ruby 镜像 - taobao】:https://ruby.taobao.org/【ruby 镜像 - china】:https://gems.ruby-china.org/ Homebrew 介绍Homebrew 是一个软件包管理器，用于在mac上安装一些os x上没有的UNiX工具；类似于360软件管理器。 Rvm 介绍Rvm 全称 Ruby Version Manager ，是安装和管理 ruby 的一种工具。 摘录：RVM is a command-line tool which allows you to easily install,manage, and work with multiple ruby environments from interpreters to sets of gems. Ruby 介绍Ruby 是一种面向对象的脚本语言，简单易用，功能强大。能跨平台和可移植性好等等。其实就是种脚本语言。Ruby 的软件源使用的是亚马逊的云服务，国内网络环境下载时可能会出现各种不稳定和超时，所以自带的需要翻墙，可以将 官方 ruby 源 替换成国内 淘宝 ruby 源（https://ruby.taobao.org/ ）或者是由 China ruby 源 （https://gems.ruby-china.org/ ）。据消息了解，2016.06【taboo Gems】停止维护了，建议使用 【ruby-china】源。 Installation【CocoaPods 安装】 第一步：检查安装 rvm 环境提示：不管需不需要升级 ruby，rvm 可以让你拥有多个版本的Ruby，并且可以在多个版本之间自由切换。如果已经安装过跳到第2步。12345678910查看是否安装$ rvm -v 输出结果:（ 存在 rvm 环境）LNdeMacBook-Pro:~ sunhui$ rvm -vrvm 1.29.1 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io/]输出结果:（不存在 rvm 环境）LNdeMacBook-Pro:~ sunhui$ rvm -v-bash: rvm: command not found 1234567891011情况二：如果不存在 rvm 环境，先安装配置 rvm 环境① 指令安装 rvm$ curl -L get.rvm.io | bash -s stable② 然后，载入 RVM 环境$ source ~/.bashrc$ source ~/.bash_profile③ 等待终端加载完毕，后输入$ rvm -v如果能显示版本号则安装成功了。 第二步：检查 ruby 版本环境提示：CocoaPods 目前安装需要Ruby的版本大于2.2.2，不然会报错：Error installing pods: activesupport requires Rubyversion &gt;= 2.2.2。目前Mac系统默认自带是2.0，所以需要升级。1234567891011121314151617181920212223① 查看已安装的ruby:$ ruby -v② 列出ruby可安装的版本信息rvm list known③ 指定 ruby 版本进行更新$ rvm install 2.3.0④ 这里一定要设置为默认版本rvm use 2.3.0 --default等待时间，完成后 Ruby Gems 就安装好了补充：1.卸载一个已安装版本$ rvm remove 1.9.22.检查 gem ruby 版本号$ sudo gem -v3.更新 gem ruby 版本号:（建议 升级到 2.6.x 以上）$ gem update --system 第三步：更换源我们需要来修改更换源（由于国内被墙）所以要把源切换至 ruby-china 在终端执行以下命令12345678910111213141516171.更新gem$ sudo gem update --system2.先移除现有的源$ gem sources --remove https://rubygems.org/如果安装了淘宝的镜像$ gem sources --remove https://ruby.taobao.org/ 3.使用新的源$ gem sources -a https://gems.ruby-china.org/4.验证新源是否替换成功$ gem sources -l只有在终端中出现下面文字才表明你上面的命令是成功的：*** CURRENT SOURCES ***说明 CocoaPods 前期配置完毕 第四步：安装Cocoapods提示：安装 CocoaPods（ sudo 表示管理员执行指令 ）（ 此处需要输入一次密码 ）这里有几种选择，你看心情来吧 ~ 选择一：123451.在终端输入以下命令：$ sudo gem install -n /usr/local/bin cocoapods$ pod setup这个过程会很慢，据说大多都是挂机一晚上才装好的，继续往下看吧，总有更好的。 选择二：1234561.执行：$ git clone https://git.coding.net/CocoaPods/Specs.git ~/.cocoapods/repos/master2.切记要：$ pod repo update感觉也就几分钟的样子， 先随便搜索一个第三方库，如：12$ pod search AFNetWorking有结果不报错说明已经安装成功了。 选择三：1234把你同事已经装好了CocoaPodscocoapods目录下的 repo 目录拷贝下来，放进自己的目录里。再 $ pod setup。 验证是否安装成功1234$ pod --version如果验证成功，显示版本号，如，0.39.0，说明可以安装全部完成.如果显示-bash: po: command not found，说明没有装好 Getting Started【开始使用】 第一步 ：我们先创建这个神奇的 PodFile。在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile123456789101.cd 到目录文件夹$ cd /Users/ln/Desktop/LNTestDemo2.提示如果不知道第三方库版本的情况下，建议先查找一下当前所需第三方库的最新版本，如：$ pod search &apos;AFNetworking&apos;3.创建 Podfile 配置文件$ vim Podfile 第二步 ：键盘输入 i ，进入 Podfile 配置文件的编辑模式Podfile 配置文件固定语句： 12345678910111213141516171819说明：可能有些人看到的固定语句不一样，但是大同小异，基本上都能实现最终效果。(~&gt; 可以指定对应版本，不指定默认为最新版本)# Uncomment this line to define a global platform for your projectplatform :ios, &apos;8.0&apos;target &apos;LNTestDemo&apos; do // 你的项目名称,自行替换# Uncomment this line if you&apos;re using Swift or would like to use dynamic frameworks# Pods for LNTestDemopod &apos;AFNetworking&apos;, &apos;~&gt;3.1.0&apos;pod &apos;SDWebImage&apos;pod &apos;MBProgressHUD&apos;pod &apos;FMDB&apos;pod &apos;Masonry&apos;pod &apos;MJExtension&apos;pod &apos;MJRefresh&apos;# use_frameworks!# pod &apos;ReactiveCocoa&apos;end 按一次 Esc 按键退出编辑模式12保存并退出:wq 这时候，你会发现你的项目目录中，出现一个名字为Podfile的文件，而且文件内容就是你刚刚输入的内容。注意，Podfile文件应该和你的工程文件.xcodeproj在同一个目录下。 现在，你就可以利用CocoPods下载AFNetworking等类库了。还是在终端中的当前项目目录下，运行以下命令：12下载第三方库文件到项目工程中$ pod install 注意： 1、以后打开项目就用 CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。否则无法关联pod下来的类库。 2、每次更改了Podfile文件,你需要重新执行一次pod update命令。 3、CocoaPods在执行pod install和pod update时，会默认先更新一次CocoPods的spec仓库索引。使用--no-repo-update参数可以禁止其做索引更新操作12$ pod install --no-repo-update$ pod update --no-repo-update 4、验证框架是否支持cocoaPods1$ pod search MJRefresh 提供：在线搜索验证在线，能搜出说明支持 https://cocoapods.org 5、cocoaPods 隐藏目录 前往—&gt;个人—&gt;.cocoapods .cocoapods/repos/master/Specs放着所有第三方库的索引文件，如下图 技巧：如果master/Specs下载不成功，试着，手动拷贝这个目录试试 6、【卸载 CocoaPods 安装】和【回退到指定 CocoaPods 版本】12345卸载 CocoaPods 安装$ sudo gem uninstall cocoa pods回退到指定 CocoaPods 版本$ sudo gem install -n /usr/local/bin cocoapods --version 0.39 7、查看 CocoaPods 下载进度还有一点需要注意，pod setup在执行时，会输出Setting up CocoaPods master repo，但是会等待比较久的时间。这步其实是 Cocoapods 在将它的信息下载到 ~/.cocoapods目录下，如果你等太久，可以试着 cd 到那个目录，用du -sh *来查看下载进度12执行语句$ sudo gem install -n /usr/local/bin cocoapods 8、在使用时，导入第三方库，应是&lt; &gt;12#import &lt;UIImageView+WebCache.h&gt;#import &lt;AFNetworking.h&gt; 9、使用pod install命令安装框架后的大致过程：1234567891.分析依赖:该步骤会分析Podfile,查看不同类库之间的依赖情况。如果有多个类库依赖于同一个类库，但是依赖于不同的版本，那么cocoaPods会自动设置一个兼容的版本。2.下载依赖:根据分析依赖的结果，下载指定版本的类库到本地项目中。3.生成Pods项目：创建一个Pods项目专门用来编译和管理第三方框架，CocoaPods会将所需的框架，库等内容添加到项目中，并且进行相应的配置。4.整合Pods项目：将Pods和项目整合到一个工作空间中，并且设置文件链接。 CocoaPods【安装过程中报错问题解决】说明：此部分所列举的问题均是在执行相关指令时出现的报错1、Rvm 环境搭建1234567891011121314151617181920211.报错指令：$ rvm install 2.3.02.报错问题：Error running &apos;requirements_osx_brew_update_system ruby-2.3.0&apos;,showing last 15 lines of /Users/jijiucheng/.rvm/log/1475769205_ruby-2.3.0/update_system.log............Requirements installation failed with status: 1.curl: (35) Server aborted the SSL handshake3.报错原因：网络问题，因为需要翻墙，所以网络不稳定；建议选择 VPN，保证线路的稳定性。4.问题解决：（指令一行一行输入）$ cd /usr/local$ git remote set-url origin git://mirrors.ustc.edu.cn/brew.git$ echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.bashrc5.解决方案： 解决方案连接：https://segmentfault.com/q/1010000004276750 1234567891011121314151.报错指令：$ rvm install 2.3.02.报错信息：Error running &apos;__rvm_make -j 1&apos;,showing last 15 lines of /Users/jijiucheng/.rvm/log/1475769349_ruby-2.3.0/make.log............There has been an error while running make. Halting the installation.3.报错原因：缺少 Xcode 工具，xcode command line4.问题解决：$ xcode-select --install 解决方案连接1：http://stackoverflow.com/questions/35228481/error-running-rvm-make-install解决方案连接2：http://www.th7.cn/Program/Ruby/201609/966343.shtml 12345678910111213141516171.报错指令：$ rvm install 2.3.02.报错信息：muxuguixiandeMacBook-Pro:local jijiucheng$ rvm install 2.3.0Already installed ruby-2.3.0.To reinstall use:.rvm reinstall ruby-2.3.0.Gemset &apos;&apos; does not exist, &apos;rvm ruby-2.3.0 do rvm gemset create &apos; first, or append &apos;--create&apos;.3.报错原因：指令不对，已经存在 ruby-2.3.0 的文件残留，需要重新安装；4.问题解决：$ rvm reinstall ruby-2.3.0 2、Ruby 环境搭建待总结 ~ ~欢迎你补充，我会及时加上，相互学习，我们的分享会让很多人少踩一些坑，少花费一点时间，学习到实用的知识。可下面留言~ 3、CocoaPods 配置使用1234567891011121314151617181920211.报错指令：$ pod install2.报错信息：muxuguixiandeMacBook-Pro:NFCustomer jijiucheng$ pod installSetting up CocoaPods master repo[!] Unable to add a source with url `https://github.com/CocoaPods/Specs.git` named `master`.You can try adding it manually in `~/.cocoapods/repos` or via `pod repo add`.3.报错原因：由于安装了多个Xcode导致路径变了，需要变换路径：sudo xcode-select -switch /Applications/Xcode.app sudo xcode-select -switch /Applications/Xcode\ 2.app4.问题解决：$ sudo xcode-select -switch /Applications/Xcode.app5.资料补充：出现 Setting up CocoaPods master repo，说明 Cocoapods 在将它的信息下载到 ~/.cocoapods 里；新创建终端窗口，输入 cd ~/.cocoapods ，回车，输入 du -sh * 命令来查看文件大小，每隔几分钟查看一次，这个目录最终大小是100多M（ 本人这里大概 800M + ），就是完成了。 解决方案连接1：https://zhidao.baidu.com/question/2205760733872673348.html解决方案连接2：http://blog.csdn.net/zhangjunjian127/article/details/47954981 instruction【指令补充】 1、Rvm 指令库12345678910111213$ ruby -v # 查看ruby 版本 $ rvm list known # 列出已知的 ruby 版本$ rvm install 2.3.0 # 选择指定 ruby 版本进行更新 $ rvm get stable # 更新 rvm$ rvm use 2.2.2 # 切换到指定 ruby 版本$ rvm use 2.2.2 --default # 设置指定 ruby 版本为默认版本 $ rvm list # 查询已安装的 ruby 版本 $ rvm remove 1.9.2 # 卸载移除 指定 ruby 版本$ curl -L https://get.rvm.io | bash -s stable # 安装 rvm 环境$ curl -sSL https://get.rvm.io | bash -s stable --ruby # 默认安装 rvm 最新版本$ curl -sSL https://get.rvm.io | bash -s stable --ruby=2.3.0 # 安装 rvm 指定版本$ source ~/.rvm/scripts/rvm # 载入 rvm 2、gem 指令库123456789101112131415161718192021222324252627282930313233343536373839$ gem -v # 查看 gem 版本$ gem source # 查看 gem 配置源$ gem source -l # 查看 gem 配置源目录$ gem sources -a url # 添加 gem 配置源（url 需换成网址）$ gem sources --add url # 添加 gem 配置源（url 需换成网址）$ gem sources -r url # 删除 gem 配置源（url 需换成网址）$ gem sources --remove url # 删除 gem 配置源（url 需换成网址）$ gem update # 更新 所有包$ gem update --system # 更新 Ruby Gems 软件$$ gem install rake # 安装 rake，从本地或远程服务器$ gem install rake --remote # 安装 rake，从远程服务器$ gem install watir -v 1.6.2 # 安装 指定版本的 watir$ gem install watir --version 1.6.2 # 安装 指定版本的 watir$ gem uninstall rake # 卸载 rake 包$ gem list d # 列出 本地以 d 打头的包$ gem query -n &apos;&apos;[0-9]&apos;&apos; --local # 查找 本地含有数字的包$ gem search log --both # 查找 从本地和远程服务器上查找含有 log 字符串的包$ gem search log --remoter # 查找 只从远程服务器上查找含有 log 字符串的包$ gem search -r log # 查找 只从远程服务器上查找含有log字符串的包$$ gem help # 提醒式的帮助$ gem help install # 列出 install 命令 帮助$ gem help examples # 列出 gem 命令使用一些例子$ gem build rake.gemspec # 把 rake.gemspec 编译成 rake.gem$ gem check -v pkg/rake-0.4.0.gem # 检测 rake 是否有效$ gem cleanup # 清除 所有包旧版本，保留最新版本$ gem contents rake # 显示 rake 包中所包含的文件$ gem dependency rails -v 0.10.1 # 列出 与 rails 相互依赖的包$ gem environment # 查看 gem 的环境$$ sudo gem -v # 查看 gem 版本（以管理员权限）$ sudo gem install cocoa pods # 安装 CocoaPods（以管理员权限）$ sudo gem install cocoapods # 安装 CocoaPods（以管理员权限）$ sudo gem install cocoapods --pre # 安装 CocoaPods 至预览版（以管理员权限）$ sudo gem install cocoapods -v 0.39.0 # 安装 CocoaPods 指定版本（以管理员权限）$ sudo gem update cocoapods # 更新 CocoaPods 至最新版（以管理员权限）$ sudo gem update cocoapods --pre # 更新 CocoaPods 至预览版（以管理员权限）$ sudo gem uninstall cocoapods -v 0.39.0 # 移除 CocoaPods 指定版本（以管理员权限） 3、pod 指令库123456$ pod setup # CocoaPods 将信息下载到~/.cocoapods/repos 目录下。如果安装 CocoaPods 时不执行此命令，在初次执行 pod intall 命令时，系统也会自动执行该指令$ pod --version # 检查 CocoaPods 是否安装成功及其版本号$ pod install # 安装 CocoaPods 的配置文件 Podfile CocoaPods 均可参考的资料 01 rvm、Ruby环境和CocoaPods安装使用及相关报错问题解决02 2017最新CocoaPods安装03 CocoaPods: pod search 搜索类库失败的解决办法04 整理Cocoapods安装05 cocoa pods安装报错06 新手安装CocoaPods07 安装cocoaPods以及在OSX10.11.5问题总结08 CocoaPods安装过程与问题解决09 Cocoapods 的安装和使用以及问题解决10 最新cocoapods步骤（主要针对Xcode8以上）11 创建CocoaPods的制作过程12 CocoaPods新版使用，遇到的那些坑！13 Write in the last 附上一张图： 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>工具&amp;插件</category>
      </categories>
      <tags>
        <tag>工具&amp;插件</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 核心动画—「CALayer图层」]]></title>
    <url>%2FiOSNET%2FCALayer.html</url>
    <content type="text"><![CDATA[本篇文章主要从【Core Animation 之 CALayer】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： UIView和CALayer的类定义 UIView和CALayer的区别和选择 CALayer的基本操作 CATransform3D CGAffineTransform 真正的高阶技巧 iOS Core Animation 1.UIView和CALayer的类定义1.CALayer的介绍CALayer 是定义在 QuartzCore 框架中，从下图可以看出UIView内部定义了一个CALayer对象，它是用来在屏幕上显示内容展示的矩形区域；CALayer是个与UIView很类似的概念，同样有backgroundColor、frame等相似的属性，我们可以将UIView看做一种特殊的CALayer。但实际上UIView是对CALayer封装，在CALayer的基础上再添加交互功能。UIView的显示必须依赖于CALayer。我们同样可以跟新建view一样新建一个layer，然后添加到某个已有的layer上，同样可以对layer调整大小、位置、透明度等。一layer可以有两种用途：一是对view相关属性的设置，包括圆角、阴影、边框等参数；二是实现对view的动画操控。因此对一个view进行动画，本质上是对该view的.layer进行动画操作； 2.UIView和CALayer的区别和选择UIView和CALayer区别1.在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，CALayer 在背后提供内容的绘制和显示；两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint(锚点)。 2.当UIView需要显示到屏幕上时（UIView 做为 Layer 的 CALayerDelegate，View 显示内容由CALayer 的 display），会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。换句话说，UIView本身不具备显示的功能，是因为它内部的图层（CALayer）才有显示功能 3.Layer 的 frame 是由它的 bounds、position、anchorPoint 和 transform 共同决定的；View 的 frame 只是简单的返回 Layer的 frame，同样 View 的 bounds 和 center 也是返回 Layer 的一些属性。 4.UIView 多了一个事件处理的功能,也就是说 UIView 可以处理用户的触摸事件,而 CALayer 不可以。 UIView和CALayer选择通过CALayer，也能做出和 UIImageView 一样的效果，相比较UIView多了一个事件处理的功能； 所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要进行交互，用UIView和CALayer都可以； 当然，CALayer 的性能会高一些，因为它少了事件处理的功能，更轻量级(实际开发中还是建议使用UIView,可扩展性强)； 2.CALayer的基本操作1.CALayer的常用属性 属性 描述 bounds 图层大小 position 图层中心点位置，相当于UIView的center opacity 透明度，相当于UIView的alpha anchorPoint 和中心position重合的点，称为锚点，范围在(0~1,0~1)，默是（0.5,0.5） contents image添加到layer的contents opacity 透明度，相当于UIView的alpha contentsRect 设置图片显示的尺寸，取值0~1(x0, y0, W1, H1)，如 CGRectMake(0, 0, 1, 0.5);只将图像的上半部分显示在整个layer中； CATransform3D 形变属性(设置平移、缩放和旋转时的 3D效果) cornerRadius / masksToBounds 圆角半径 / 属性为YES才显示圆角效果 2.创建自定义的CALayer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// layer基本使用- (void)layerWithUIView&#123; // 自定义图层 CALayer *layer = [CALayer layer]; layer.bounds = CGRectMake(0, 0, 100, 100); layer.contents = (id)[UIImage imageNamed:@"阿狸头像"].CGImage;? layer.backgroundColor = [UIColor redColor].CGColor;? layer.position = self.view.center; layer.anchorPoint = CGPointMake(0.5, 1); // 默认是自带阴影的效果, 默认为0. self.redView.layer.shadowOpacity = 1; // 添加图层到根图层 [self.view.layer addSublayer:layer]; ***********其它属性**************** // 设置阴影的颜色 layer.shadowColor = [UIColor blackColor].CGColor; // 设置阴影的偏移量((x,y) 例:右下) layer.shadowOffset = CGSizeMake(10, 10); // 设置阴影的模糊程度 layer.shadowRadius = 10; // 设置边框的宽度(注意:是往里面走的) 和 颜色 layer.borderWidth = 5; layer.borderColor = [UIColor blueColor].CGColor; // 设置圆角半径 layer.cornerRadius = 50; // 图层中绘制的图片无法正确显示，解决:把超过根层以外的东西剪切掉(UIView自带的层,我们称为是根层) layer.masksToBounds = YES; // 设置图层的代理 layer.delegate = self; // setNeedsDisplayh会调用drawRect:方法 [layer setNeedsDisplay];&#125;``` 注解：- 1、阴影效果无法 和 `masksToBounds`同时使用;- 2、裁剪：`masksToBounds` 是 `CALayer` 的属性；`clipsToBounds` 是 `UIView` 的属性；- 3、`CGImage` 和 `CGColor` 的解释： - `CALayer`是定义在`QuartzCore`框架中的`CGImageRef`、`CGColorRef`两种数据类型是定义在`CoreGraphics`框架中的 - `UIColor`、`UIImage`是定义在`UIKit`框架中的`QuartzCore`框架和`CoreGraphics`框架是可以跨平台使用的，在`iOS`和`Mac OS X`上都能使用，但是`UIKit`只能在`iOS`中使用，为了保证可移植性，`QuartzCore`不能使用`UIImage`、`UIColor`，只能使用`CGImageRef`、`CGColorRef`，即需要：`.CGImage` 和 `.CGColor`. #### 3.CATransform3D&gt;注意：使用KVC快速设置时，Key Paths值一定不要写错```objc// 触摸开始调用- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // CATransform3D，设置平移、缩放和旋转时的 3D效果 [UIView animateWithDuration:1 animations:^&#123; // 方式一：CATransform3D普通设置 // 平移 (CGFloat sx, CGFloat sy, CGFloat sz) self.imageView.layer.transform = CATransform3DTranslate(self.imageView.layer.transform, 10, 0, 0); // 缩放 self.imageView.layer.transform = CATransform3DScale(self.imageView.layer.transform, 1.2, 1.2, 0); // 旋转 self.imageView.layer.transform = CATransform3DMakeRotation(M_PI, 0, 0, 1); // 方式二：CATransform3D KVC快速设置 // 把结构体转成对象 //NSValue *value = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI, 0, 0, 1)]; //[self.imageView.layer setValue:value forKeyPath:@"transform"]; // 通过KVC快速平移(translation)、缩放(sacle)、旋转(rotation) // 平移 [self.imageView.layer setValue:@(100) forKeyPath:@"transform.translation.y"]; // 缩放 [self.imageView.layer setValue:@(0.5) forKeyPath:@"transform.scale"]; // 旋转 [self.imageView.layer setValue:@(M_PI_4) forKeyPath:@"transform.rotation"]; &#125;];&#125; PS.在这里我就不用图片了，我就劳动一下吧(图片的不好复制不是吗)，福利奉上转场效果key paths Transform field value key paths Field Key Path Description translation.x 设置为一个NSNumber对象的值是沿着x轴平移。 translation.y 设置为一个NSNumber对象的值沿y轴平移。 translation.z 设置为一个NSNumber对象的值沿z轴平移。 translation 设置为一个NSValue对象包含一个NSSize或CGSize数据类型。数据类型表示将在x和y轴。 scale.x 设置为一个NSNumber对象的值是x轴缩放。 scale.y 设置为一个NSNumber对象的值是y轴缩放。 scale.z 设置为一个NSNumber对象的值是z轴缩放。 scale 设置为一个NSNumber对象的值是所有三个规模因素的平均值。 rotation.x 设置为一个NSNumber对象的值是旋转,弧度,x轴。 rotation.y 设置为一个NSNumber对象的值是旋转,弧度,y轴。 rotation.z 设置为一个NSNumber对象的值是旋转,弧度,z轴。 rotation 设置为一个NSNumber对象的值是旋转,弧度,z轴。这个字段是一样设置旋转。z域。 4.CGAffineTransform1234567891011121314// 旋转，参数指定为弧度，M_PI &lt;－&gt; 180CGAffineTransformMakeRotation(CGFloat angle);// 缩放, sx：指x轴缩放的比例,sy 在y轴上的缩放比例CGAffineTransformMakeScale(CGFloat sx, CGFloat sy);// 平移 tx：在x轴上平移 ty 是在y上平移CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty);// 让你的view回到最原始的状态，没有缩放，没有旋转，没有平移ballView.transform = CGAffineTransformIdentity;// 指定在y轴上 平移ballView.transform = CGAffineTransformMakeTranslation(0, -300); 真正的高阶技巧 iOS Core Animation强力推荐👍《iOS Core Animation: Advanced Techniques》这本书很深入的将了Core Animation的原理性的东西，是一本讲解Core Animation原理非常深入的书，如果把整本书全部读完，理解，我相信iOS 中的动画就是件很轻松的事情了，可惜是英文的; 在网上也找到了这本书完整的中文翻译，如果感兴趣，可以去看看 ios核心动画高级技巧 最后附上这张图： 期待 如果在阅读过程中遇到 error，希望你能 Issues 我，谢谢。 如果你想为【本文相关】分享点什么，也希望你能 Issues 我，我非常想为这篇文章增加更多实用的内容，谢谢。 「博客原文」，对本文我会【不定时、持续更新、一些 学习心得与文章、实用才是硬道理】^_^. Write in the first【写在最前】 iOS 动画主要是指 Core Animation 框架。官方使用文档地址为: Core Animation Guide。 Core Animation 是iOS和macOS平台上负责图形渲染与动画的基础框架。Core Animation 可以作用与动画视图或者其他可视元素，为你完成了动画所需的大部分绘帧工作。你只需要配置少量的动画参数（如开始点的位置和结束点的位置）即可使用 Core Animation 的动画效果。 Core Animation 将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。|这种自动化的图形加速技术让动画拥有更高的帧率并且显示效果更加平滑，不会加重CPU的负担而影响程序的运行速度。 本篇文章主要从【iOS动画 Core Animation】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： 系统自带的 animationImages UIView代码块加Block UIView [begin commit]模式 使用CoreAnimation中的类1.CATransition 转场动画1.CATransaction动画事务2.CABasicAnimation 基础动画2.CASpringAnimation 弹簧动画3.CAKeyframeAnimation 关键帧动画4.CAAnimationGroup 动画组5.AnimationWithKeyPath的值 物理动效(重力、碰撞、吸附、推力、关联)1.UICollisionBehavior碰撞2.UISnapBehavior吸附3.UIPushBehavior推力4.UIAttachmentBehavior关联 粒子系统 facebook pop动画 iOS动画调用方式1.系统自带的 animationImages1234UIImageView *imageView;imageView.animationImages = @[image1,image2...];[imageView startAnimating];[imageView stopAnimating]; 2.UIView代码块加Block123456789101112131415161718192021222324/** Duration 动画持续时间 animations 动画过程 */[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; animations:&lt;#^(void)animations#&gt;];// 执行动画 和 动画完成的回调[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;];/** delay 等待时间 options 动画类型 */[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; options:&lt;#(UIViewAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;];/** 弹性动画 damping 阻尼，范围0-1，阻尼越接近于0，弹性效果越明显 velocity 弹性复位的速度 */[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; usingSpringWithDamping:&lt;#(CGFloat)#&gt; initialSpringVelocity:&lt;#(CGFloat)#&gt; options:&lt;#(UIViewAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;];// 关键帧动画[UIView animateKeyframesWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; options:&lt;#(UIViewKeyframeAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;]; 3.UIView [begin commit]模式123456789101112131415161718192021222324#pragma mark - 使用UIView [begin,commit]模式- (void)uiViewAnimation &#123; // 可以嵌套但是必须成对出现 UIViewAnimationTransition type = UIViewAnimationTransitionNone; [UIView beginAnimations:nil context:nil]; // 动画的持续时间 [UIView setAnimationDuration:1]; // 动画类型 [UIView setAnimationTransition:type forView:_redView cache:YES]; // 动画代理 //[UIView setAnimationDelegate:self]; //[UIView setAnimationWillStartSelector:@selector(annimationStart)]; //[UIView setAnimationDidStopSelector:@selector(annimationStop)]; [UIView commitAnimations];&#125;- (void)animationDidStart:(CAAnimation *)anim &#123; NSLog(@"%s, line = %d",__FUNCTION__,__LINE__);&#125;- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag &#123; NSLog(@"%s, line = %d",__FUNCTION__,__LINE__);&#125; 4.使用CoreAnimation中的类 1.CATransition 转场动画 CATransition属性 描述 type 过渡的类型 subType 过渡的方向 startProgress 动画起点(在整体动画的百分比) endProgress 动画终点(在整体动画的百分比) addAnimation: forKey: 把转场动画添加到layer上 创建步骤 1.创建动画对象 2.设置转场类型 3.给图层添加动画 示例代码：123456789101112131415#pragma mark - 交叉淡化过渡-(void)fadeAnimation&#123; [self changeShowContens]; // 1.创建动画对象 CATransition *anima = [CATransition animation]; // 2.设置转场类型 anima.type = kCATransitionFade;// 设置动画的类型 //anima.type = @"cube";// 设置动画的类型 anima.subtype = kCATransitionFromRight; // 设置动画的方向 //anima.startProgress = 0.3;// 设置动画起点 //anima.endProgress = 0.8;// 设置动画终点 anima.duration = 1.0f;// 设置动画执行时长 // 3.给图层添加动画 [_imageView.layer addAnimation:anima forKey:@"fadeAnimation"];&#125; 效果： 2.CATransition转场动画过渡类型在这里我就不用图片了，我就劳动一下吧(图片的不好复制不是吗)，奉上转场效果 api 类型字符串 效果说明 关键字 方向 fade 交叉淡化过渡 YES push 新视图把旧视图推出去 YES moveIn 新视图移到旧视图上面 YES reveal 将旧视图移开,显示下面的新视图 YES cube 立方体翻滚效果 oglFlip 上下左右翻滚效果 suckEffect 收缩效果,如一块布被抽走 NO rippleEffect 水滴效果 NO pageCurl 向上翻页效果 pageUnCurl 向下翻页效果 cameraIrisHollowOpen 相机镜头打开效果 NO cameraIrisHollowClose 相机镜头关闭效果 NO 动画常用属性 描述 rotation.x 设置为一个NSNumber对象的值是旋转,弧度,x轴。 duration 动画的持续时间 beginTime 动画的开始时间 repeatCount 动画的重复次数 autoreverses 执行的动画按照原动画返回执行 timingFunction 控制动画的显示节奏 Linear 匀速，EaseIn 先慢后快，EaseOut 先快后慢，EaseInEaseOut 先慢后快再慢，Default 默认中间比较快 3.CATransaction动画事务事务(CATransaction)负责协调多个动画原子更新的显示操作,是动画里面的一个基本单元，动画的产生必然伴随着layer的Animatable属性的变化，而layer属性的变化必须属于某一个事务。因此 ，核心动画依赖于事务。可以通过事物关闭隐式动画:1234567891011121314151617181920212223241、事务的作用：保证一个或多个layer的一个或多个属性变化同时进行。2、事务的种类：隐式和显示3、隐式：没有明显调用事务的方法，由系统自动生成事务。比如上面提到的设置一个layer的position属性，则会在当前线程自动生成一个事务，并在下一个runLoop中自动commit.通过如下方法可以关闭隐式动画的设置:[CATransaction begin];// 开启事务[CATransaction setDisableActions:YES];// 关闭隐式动画self.myview.layer.position = CGPointMake(10, 10);[CATransaction commit];// 提交事务4、显示:明显调用事务的方法[CATransaction begin] 和 [CATransaction commit]，必须写在两者之间.5、CA事务的可设置属性(会覆盖隐式动画的设置)animationDuration：动画时间animationTimingFunction：动画时间曲线disableActions：是否关闭动画completionBlock：动画执行完毕的回调事务支持嵌套使用:当最外层的事务commit后动画才会开始。6、通过修改layer上的属性产生的动画效果，称之为 隐式动画通过手动添加动画对象产生的动画，称之为 显式动画 4.CABasicAnimation 基础动画 CABasicAnimation重要属性 描述 fromValue keyPath对应的初始值 toValue keyPath对应的结束值 removedOnCompletion 动画完成时,是否删除动画 fillMode 设置让动画效果最后执行状态 基础动画创建步骤 1、初始化动画并设置动画属性 2、设置动画属性初始值（可以省略）、结束值以及其他动画属性 3、给图层添加动画 我们先看下面这个移动动画实例：12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma mark - 位移动画- (void)positionAnimation &#123; // 1.创建动画对象并设置动画属性 CABasicAnimation *basicAnimation = [CABasicAnimation animationWithKeyPath:@"position"]; // 2.设置动画 初始值(可以省略) 和 结束值 // 把CGPoint转换成id类型,使用NSValue basicAnimation.fromValue = [NSValue valueWithCGPoint:CGPointMake(50, kScreenHeight/2)]; basicAnimation.toValue = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth- 50, kScreenHeight/2)]; // 设置动画的其他属性值 // 动画执行时长2秒（默认0.2s) basicAnimation.duration = 1.0f; // 设置重复次数,HUGE_VALF可看做无穷大 //basicAnimation.repeatCount = HUGE_VALF; // 设置重复时间（重复时间 / 执行时长 = 重复次数) //basicAnimation.repeatDuration = 4; // 设置延迟执行2秒 //basicAnimation.beginTime = CACurrentMediaTime() + 2; // 动画时间曲线 kCAMediaTimingFunctionLinear 线性变换 平缓 //basicAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]; // 自动反转(怎么去就怎么回来) //basicAnimation.autoreverses = YES; // 设置动画代理 //basicAnimation.delegate = self; /** 如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。(不设置这两个属性值默认回到原始位置) 2016-06-15 13:15:24.350 iOS常用动画[14625:325800] 动画前X = 137.500000 2016-06-15 13:15:24.350 iOS常用动画[14625:325800] 动画后X = 137.500000 */ //basicAnimation.removedOnCompletion = NO;// 动画完成时,会自动删除动画 //basicAnimation.fillMode = kCAFillModeForwards;// 设置让动画效果最后执行状态 // 3.给图层添加动画（注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取） [self.redView.layer addAnimation:basicAnimation forKey:@"positionAnimation"]; // 移除动画 //[self.redView.layer removeAnimationForKey:@"positionAnimation"]; //[self.redView.layer removeAllAnimations];&#125; 效果： CASpringAnimation 弹簧动画 属性 描述 mass 质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大 stiffnes 刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快 damping 阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快 initivelocity 初始速率，动画视图的初始速度大小;速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反 settingDuration 结算时间(根据动画相关参数估算弹簧开始运动到停止的时间，动画设置的时间最好根据此时间来设置) CASpringAnimation和UIView的SpringAnimation对比:CASpringAnimation 可以设置更多弹簧动画效果的属性，可以实现更复杂的弹簧效果，可以和其他动画组合UIView的SpringAnimation实际上就是通过CASpringAnimation来实现的。 代码示例：12345678910111213141516171819202122#pragma mark - 弹簧动画- (void)springAnimation &#123; CASpringAnimation * springAnimation = [CASpringAnimation animationWithKeyPath:@"transform.scale"]; // 质量,越大弹簧幅度越大 springAnimation.mass = 10.0; // 弹性系数,越大运动越快 springAnimation.stiffness = 500; // 阻尼系数,越大停止越快 springAnimation.damping = 100.0; // 初始速率,正方向相同、负方向相反 springAnimation.initialVelocity = 30.f; springAnimation.duration = springAnimation.settlingDuration; springAnimation.toValue = [NSNumber numberWithFloat:1.5]; //springAnimation.removedOnCompletion = NO; //springAnimation.fillMode = kCAFillModeForwards; springAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; [self.redView.layer addAnimation:springAnimation forKey:@"boundsAni"];&#125; 效果： 3.CAKeyframeAnimation 关键帧动画可以让我们在更细的粒度上控制动画的行为，关键帧动画需要指定几个关键的点，从而让动画沿着这些点运动，这几个点就称之为 关键帧 CAKeyframeAnimation属性 描述 values 指定关键点的值 path 可以设置一个CGPathRef / CGMutablePathRef，让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略. keyTimes 是走到某一个关键点花费的时间百分比(0～1)，keyTimes中的每一个时间值都对应values中的每一帧(两个数组的个数必须一致)，当keyTimes没有设置的时候,各个关键帧的时间是平分的。 通过 设置不同的属性值values 动画 关键帧动画创建第一种方式 通过 绘制路径path 动画 关键帧动画创建第二种方式 代码示例：12345678910111213141516171819202122232425// 角度转弧度#define angleToRadian(angle) ((angle) / 180.0 * M_PI)#pragma mark 关键帧动画values- (void)valuesAnimation &#123; // 1.创建动画对象 CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"transform.rotation"]; // 2.设置动画属性值 //NSValue *value1 = [NSValue valueWithCGPoint:&lt;#(CGPoint)#&gt;]; animation.values = @[@(angleToRadian(-5)),@(angleToRadian(5)),@(angleToRadian(-5))]; animation.duration = 1; animation.repeatCount = MAXFLOAT; //animation.keyTimes = @[@(0.0),@(1),@(0.1)]; // 如果不用反转,也可以在values里面写 //animation.autoreverses = YES; // 动画结束时的状态（不设置回到原始位置） //anim.removedOnCompletion = NO; //anim.fillMode = kCAFillModeForwards; // 3.给图层添加动画 [self.iconImage.layer addAnimation:animation forKey:@"valuesAnimation"];&#125; 代码示例：1234567891011121314151617181920212223242526#pragma mark 关键帧动画第二种方式- (void)translationAnimation2 &#123; // 1.创建关键帧动画并设置动画属性 CAKeyframeAnimation *moveAnimation = [CAKeyframeAnimation animationWithKeyPath:@"position"]; moveAnimation.duration = 2; // 2.设置关键帧动画的行进路径（绘制贝塞尔曲线） moveAnimation.path = self.path.CGPath; // 3.添加动画到图层，添加动画后就会执行动画 [self.ballView.layer addAnimation:moveAnimation forKey:nil]; // 设置最终的状态(不设置就是回到原始位置) self.ballView.layer.position = CGPointMake(330, 200);&#125;// 绘制贝塞尔曲线- (void)drawRect:(CGRect)rect &#123; self.path = [[UIBezierPath alloc]init]; [[UIColor redColor] setStroke]; self.path.lineWidth = 5; [self.path moveToPoint:CGPointMake(30, 200)]; [self.path addCurveToPoint:CGPointMake(330, 200) controlPoint1:CGPointMake(100, 50) controlPoint2:CGPointMake(200, 300)]; [self.path stroke];&#125; 效果： 4.CAAnimationGroup 动画组 CAAnimationGroup属性 描述 animations 用来保存一组动画对象的NSArray CFTimeInterval 时间间隔 代码示例：123456789101112131415161718192021222324252627#pragma mark 动画组(同时)- (void)groupAnimation1 &#123; // 位移动画 CAKeyframeAnimation *animation1 = [CAKeyframeAnimation animationWithKeyPath:@"position"]; NSValue *value0 = [NSValue valueWithCGPoint:CGPointMake(0, kScreenHeight/2-50)]; NSValue *value1 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth/3, kScreenHeight/2-50)]; NSValue *value2 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth/3, kScreenHeight/2+50)]; NSValue *value3 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth*2/3, kScreenHeight/2+50)]; NSValue *value4 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth*2/3, kScreenHeight/2-50)]; NSValue *value5 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth, kScreenHeight/2-50)]; animation1.values = @[value0,value1,value2,value3,value4,value5]; // 缩放动画 CABasicAnimation *animation2 = [CABasicAnimation animationWithKeyPath:@"transform.scale"]; animation2.fromValue = [NSNumber numberWithFloat:0.8f]; animation2.toValue = [NSNumber numberWithFloat:2.0f]; // 旋转动画 CABasicAnimation *animation3 = [CABasicAnimation animationWithKeyPath:@"transform.rotation"]; animation3.toValue = [NSNumber numberWithFloat:M_PI *4]; // 创建动画组 CAAnimationGroup *groupAnimation = [CAAnimationGroup animation]; groupAnimation.animations = @[animation1,animation2,animation3]; groupAnimation.duration = 4; [self.redView.layer addAnimation:groupAnimation forKey:@"groupAnimation"];&#125; 效果： 5.AnimationWithKeyPath的值在这里我就不用图片了，我就劳动一下吧(图片的不好复制不是吗)，福利奉上转场效果 key pathsTransform field value key paths Field Key Path Description rotation.x 设置为一个NSNumber对象的值是旋转,弧度,x轴。 rotation.y 设置为一个NSNumber对象的值是旋转,弧度,y轴。 rotation.z 设置为一个NSNumber对象的值是旋转,弧度,z轴。 rotation 设置为一个NSNumber对象的值是旋转,弧度,z轴。这个字段是一样设置旋转。z域。 scale.x 设置为一个NSNumber对象的值是x轴的比例因子。 scale.y 设置为一个NSNumber对象的值是y轴的比例因子。 scale.z 设置为一个NSNumber对象的值是z轴的比例因子。 scale 设置为一个NSNumber对象的值是所有三个规模因素的平均值。 translation.x 设置为一个NSNumber对象的值是沿着x轴。 translation.y 设置为一个NSNumber对象的值沿y轴。 translation.z 设置为一个NSNumber对象的值沿z轴。 translation 设置为一个NSValue对象包含一个NSSize或CGSize数据类型。数据类型表示将在x和y轴。 核心动画综合案例 5.物理动效(重力、碰撞、吸附、推力、关联)123456ios7之后提供的物理动效UIGravityBehavior 重力UICollisionBehavior 碰撞UISnapBehavior 吸附UIPushBehavior 推力UIAttachmentBehavior 关联 以下示例，我们就直接来代码，看效果了，中间会有部分解释； 1.UICollisionBehavior碰撞，示例：模仿重力 + 碰撞 的行为12345678910111213141516171819202122232425262728// 先指定一个参考视图来初始化animatorself.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];#pragma mark 模仿重力 和 碰撞效果- (void)animations &#123; // 添加重力 UIGravityBehavior *gravity = [[UIGravityBehavior alloc]initWithItems:@[self.ballView]]; // 添加碰撞 UICollisionBehavior *collision = [[UICollisionBehavior alloc]initWithItems:@[self.ballView]]; // 把参考视图的边界作为我的碰撞边界 collision.translatesReferenceBoundsIntoBoundary = YES; // 添加一个自定义的行为，修改动效参数 UIDynamicItemBehavior *itemBehavior = [[UIDynamicItemBehavior alloc]initWithItems:@[self.ballView]]; /** 弹性系数 density 1.0 密度 elasticity 0.0 弹性 friction 0.0 摩擦 resistance 0.0 阻力 */ itemBehavior.elasticity = 0.5; // 把重力和碰撞行为添加到动画执行者中 [self.animator addBehavior:gravity]; [self.animator addBehavior:collision]; [self.animator addBehavior:itemBehavior];&#125; 效果： 2.UISnapBehavior吸附，示例：模仿吸附 + 重力 的行为123456789101112- (void)doAnimation&#123; //[self.animator removeAllBehaviors]; // 添加一个吸附行为，指定吸附的点 UISnapBehavior *snap = [[UISnapBehavior alloc]initWithItem:self.ballView snapToPoint:CGPointMake(self.view.frame.size.width *0.5, self.view.frame.size.height - 100)]; // 添加一个重力的行为 UIGravityBehavior *gravity = [[UIGravityBehavior alloc]initWithItems:@[self.ballView]]; [self.animator addBehavior:snap]; [self.animator addBehavior:gravity];&#125; 效果： 3.UIPushBehavior推力，示例：模仿推力 + 碰撞 的行为123456789101112131415161718192021222324252627282930313233#pragma mark 添加点击手势- (void)addTapGestrue &#123; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(handleTapGestrue:)]; [self.ballView addGestureRecognizer:tap];&#125;- (void)handleTapGestrue:(UITapGestureRecognizer*)gesture&#123; // 球的中心点 CGPoint ballCenter = self.ballView.center; // 点击点 CGPoint tapPoint = [gesture locationInView:self.view]; CGFloat offsetX = tapPoint.x - ballCenter.x; CGFloat offsetY = tapPoint.y - ballCenter.y; CGFloat angle = atan2(offsetY, offsetX); CGFloat distance = sqrt(pow(offsetX, 2) + pow(offsetY, 2)); // 添加推力行为 UIPushBehavior *push = [[UIPushBehavior alloc]initWithItems:@[self.ballView] mode:UIPushBehaviorModeInstantaneous]; // 设置角度 [push setAngle:angle]; // 设置推力大小 // 每1个magnigude将会引起100/平方秒的加速度 [push setMagnitude:distance/100]; // 添加碰撞行为 UICollisionBehavior *collision = [[UICollisionBehavior alloc]initWithItems:@[self.ballView]]; collision.translatesReferenceBoundsIntoBoundary = YES; [self.animator addBehavior:push]; [self.animator addBehavior:collision];&#125; 效果： 4.UIAttachmentBehavior关联，示例：模仿推力 + 碰撞 的行为123456789- (void)doAnimation&#123; // UIAttachmentBehavior 可以设置和某一个点 UIAttachmentBehavior *attachment = [[UIAttachmentBehavior alloc]initWithItem:self.blueView attachedToItem:self.ballView]; // 关联的长度 [attachment setLength:100]; UIGravityBehavior *gravity = [[UIGravityBehavior alloc]initWithItems:@[self.blueView]]; [self.animator addBehavior:attachment]; [self.animator addBehavior:gravity];&#125; 效果： 6.粒子系统12CAEmitterCellCAEmitterLayer 7.facebook pop动画123456使用之前先讨论以下POP和核心动画的主要区别CoreAnimation 的动画是加在layer上CoreAnimation的动画只是表面而已，并没有真正的修改frame等属性值pop的动画可以添加到任何对象pop的底层是基于CADisplaylinkpop的动画真正的修改frame等属性值 pop使用：1234POP默认支持三种动画，但同时也支持自定义动画POPDecayAnimation 减速动画POPSpringAnimation 弹簧效果POPSpringAnimation 飞入效果 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>核心动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 核心动画—「Core Animation动画基础框架」]]></title>
    <url>%2FiOSNET%2FCoreAnimation.html</url>
    <content type="text"><![CDATA[Write in the first iOS 动画主要是指 Core Animation 框架。官方使用文档地址为: Core Animation Guide。 Core Animation 是iOS和macOS平台上负责图形渲染与动画的基础框架。Core Animation 可以作用与动画视图或者其他可视元素，为你完成了动画所需的大部分绘帧工作。你只需要配置少量的动画参数（如开始点的位置和结束点的位置）即可使用 Core Animation 的动画效果。 Core Animation 将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。|这种自动化的图形加速技术让动画拥有更高的帧率并且显示效果更加平滑，不会加重CPU的负担而影响程序的运行速度。 本篇文章主要从【iOS动画 Core Animation】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： 系统自带的 animationImages UIView代码块加Block UIView [begin commit]模式 使用CoreAnimation中的类1.CATransition 转场动画1.CATransaction动画事务2.CABasicAnimation 基础动画2.CASpringAnimation 弹簧动画3.CAKeyframeAnimation 关键帧动画4.CAAnimationGroup 动画组5.AnimationWithKeyPath的值 物理动效(重力、碰撞、吸附、推力、关联)1.UICollisionBehavior碰撞2.UISnapBehavior吸附3.UIPushBehavior推力4.UIAttachmentBehavior关联 粒子系统 facebook pop动画 iOS动画调用方式1.系统自带的 animationImages1234UIImageView *imageView;imageView.animationImages = @[image1,image2...];[imageView startAnimating];[imageView stopAnimating]; 2.UIView代码块加Block123456789101112131415161718192021222324/** Duration 动画持续时间 animations 动画过程 */[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; animations:&lt;#^(void)animations#&gt;];// 执行动画 和 动画完成的回调[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;];/** delay 等待时间 options 动画类型 */[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; options:&lt;#(UIViewAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;];/** 弹性动画 damping 阻尼，范围0-1，阻尼越接近于0，弹性效果越明显 velocity 弹性复位的速度 */[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; usingSpringWithDamping:&lt;#(CGFloat)#&gt; initialSpringVelocity:&lt;#(CGFloat)#&gt; options:&lt;#(UIViewAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;];// 关键帧动画[UIView animateKeyframesWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; options:&lt;#(UIViewKeyframeAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;]; 3.UIView [begin commit]模式123456789101112131415161718192021222324#pragma mark - 使用UIView [begin,commit]模式- (void)uiViewAnimation &#123; // 可以嵌套但是必须成对出现 UIViewAnimationTransition type = UIViewAnimationTransitionNone; [UIView beginAnimations:nil context:nil]; // 动画的持续时间 [UIView setAnimationDuration:1]; // 动画类型 [UIView setAnimationTransition:type forView:_redView cache:YES]; // 动画代理 //[UIView setAnimationDelegate:self]; //[UIView setAnimationWillStartSelector:@selector(annimationStart)]; //[UIView setAnimationDidStopSelector:@selector(annimationStop)]; [UIView commitAnimations];&#125;- (void)animationDidStart:(CAAnimation *)anim &#123; NSLog(@"%s, line = %d",__FUNCTION__,__LINE__);&#125;- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag &#123; NSLog(@"%s, line = %d",__FUNCTION__,__LINE__);&#125; 4.使用CoreAnimation中的类 1.CATransition 转场动画 CATransition属性 描述 type 过渡的类型 subType 过渡的方向 startProgress 动画起点(在整体动画的百分比) endProgress 动画终点(在整体动画的百分比) addAnimation: forKey: 把转场动画添加到layer上 创建步骤 1.创建动画对象 2.设置转场类型 3.给图层添加动画 示例代码：123456789101112131415#pragma mark - 交叉淡化过渡-(void)fadeAnimation&#123; [self changeShowContens]; // 1.创建动画对象 CATransition *anima = [CATransition animation]; // 2.设置转场类型 anima.type = kCATransitionFade;// 设置动画的类型 //anima.type = @"cube";// 设置动画的类型 anima.subtype = kCATransitionFromRight; // 设置动画的方向 //anima.startProgress = 0.3;// 设置动画起点 //anima.endProgress = 0.8;// 设置动画终点 anima.duration = 1.0f;// 设置动画执行时长 // 3.给图层添加动画 [_imageView.layer addAnimation:anima forKey:@"fadeAnimation"];&#125; 效果： 2.CATransition转场动画过渡类型在这里我就不用图片了，我就劳动一下吧(图片的不好复制不是吗)，奉上转场效果 api 类型字符串 效果说明 关键字 方向 fade 交叉淡化过渡 YES push 新视图把旧视图推出去 YES moveIn 新视图移到旧视图上面 YES reveal 将旧视图移开,显示下面的新视图 YES cube 立方体翻滚效果 oglFlip 上下左右翻滚效果 suckEffect 收缩效果,如一块布被抽走 NO rippleEffect 水滴效果 NO pageCurl 向上翻页效果 pageUnCurl 向下翻页效果 cameraIrisHollowOpen 相机镜头打开效果 NO cameraIrisHollowClose 相机镜头关闭效果 NO 动画常用属性 描述 rotation.x 设置为一个NSNumber对象的值是旋转,弧度,x轴。 duration 动画的持续时间 beginTime 动画的开始时间 repeatCount 动画的重复次数 autoreverses 执行的动画按照原动画返回执行 timingFunction 控制动画的显示节奏 Linear 匀速，EaseIn 先慢后快，EaseOut 先快后慢，EaseInEaseOut 先慢后快再慢，Default 默认中间比较快 3.CATransaction动画事务事务(CATransaction)负责协调多个动画原子更新的显示操作,是动画里面的一个基本单元，动画的产生必然伴随着layer的Animatable属性的变化，而layer属性的变化必须属于某一个事务。因此 ，核心动画依赖于事务。可以通过事物关闭隐式动画:1234567891011121314151617181920212223241、事务的作用：保证一个或多个layer的一个或多个属性变化同时进行。2、事务的种类：隐式和显示3、隐式：没有明显调用事务的方法，由系统自动生成事务。比如上面提到的设置一个layer的position属性，则会在当前线程自动生成一个事务，并在下一个runLoop中自动commit.通过如下方法可以关闭隐式动画的设置:[CATransaction begin];// 开启事务[CATransaction setDisableActions:YES];// 关闭隐式动画self.myview.layer.position = CGPointMake(10, 10);[CATransaction commit];// 提交事务4、显示:明显调用事务的方法[CATransaction begin] 和 [CATransaction commit]，必须写在两者之间.5、CA事务的可设置属性(会覆盖隐式动画的设置)animationDuration：动画时间animationTimingFunction：动画时间曲线disableActions：是否关闭动画completionBlock：动画执行完毕的回调事务支持嵌套使用:当最外层的事务commit后动画才会开始。6、通过修改layer上的属性产生的动画效果，称之为 隐式动画通过手动添加动画对象产生的动画，称之为 显式动画 4.CABasicAnimation 基础动画 CABasicAnimation重要属性 描述 fromValue keyPath对应的初始值 toValue keyPath对应的结束值 removedOnCompletion 动画完成时,是否删除动画 fillMode 设置让动画效果最后执行状态 基础动画创建步骤 1、初始化动画并设置动画属性 2、设置动画属性初始值（可以省略）、结束值以及其他动画属性 3、给图层添加动画 我们先看下面这个移动动画实例：12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma mark - 位移动画- (void)positionAnimation &#123; // 1.创建动画对象并设置动画属性 CABasicAnimation *basicAnimation = [CABasicAnimation animationWithKeyPath:@"position"]; // 2.设置动画 初始值(可以省略) 和 结束值 // 把CGPoint转换成id类型,使用NSValue basicAnimation.fromValue = [NSValue valueWithCGPoint:CGPointMake(50, kScreenHeight/2)]; basicAnimation.toValue = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth- 50, kScreenHeight/2)]; // 设置动画的其他属性值 // 动画执行时长2秒（默认0.2s) basicAnimation.duration = 1.0f; // 设置重复次数,HUGE_VALF可看做无穷大 //basicAnimation.repeatCount = HUGE_VALF; // 设置重复时间（重复时间 / 执行时长 = 重复次数) //basicAnimation.repeatDuration = 4; // 设置延迟执行2秒 //basicAnimation.beginTime = CACurrentMediaTime() + 2; // 动画时间曲线 kCAMediaTimingFunctionLinear 线性变换 平缓 //basicAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]; // 自动反转(怎么去就怎么回来) //basicAnimation.autoreverses = YES; // 设置动画代理 //basicAnimation.delegate = self; /** 如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。(不设置这两个属性值默认回到原始位置) 2016-06-15 13:15:24.350 iOS常用动画[14625:325800] 动画前X = 137.500000 2016-06-15 13:15:24.350 iOS常用动画[14625:325800] 动画后X = 137.500000 */ //basicAnimation.removedOnCompletion = NO;// 动画完成时,会自动删除动画 //basicAnimation.fillMode = kCAFillModeForwards;// 设置让动画效果最后执行状态 // 3.给图层添加动画（注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取） [self.redView.layer addAnimation:basicAnimation forKey:@"positionAnimation"]; // 移除动画 //[self.redView.layer removeAnimationForKey:@"positionAnimation"]; //[self.redView.layer removeAllAnimations];&#125; 效果： CASpringAnimation 弹簧动画 属性 描述 mass 质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大 stiffnes 刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快 damping 阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快 initivelocity 初始速率，动画视图的初始速度大小;速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反 settingDuration 结算时间(根据动画相关参数估算弹簧开始运动到停止的时间，动画设置的时间最好根据此时间来设置) CASpringAnimation和UIView的SpringAnimation对比:CASpringAnimation 可以设置更多弹簧动画效果的属性，可以实现更复杂的弹簧效果，可以和其他动画组合UIView的SpringAnimation实际上就是通过CASpringAnimation来实现的。 代码示例：12345678910111213141516171819202122#pragma mark - 弹簧动画- (void)springAnimation &#123; CASpringAnimation * springAnimation = [CASpringAnimation animationWithKeyPath:@"transform.scale"]; // 质量,越大弹簧幅度越大 springAnimation.mass = 10.0; // 弹性系数,越大运动越快 springAnimation.stiffness = 500; // 阻尼系数,越大停止越快 springAnimation.damping = 100.0; // 初始速率,正方向相同、负方向相反 springAnimation.initialVelocity = 30.f; springAnimation.duration = springAnimation.settlingDuration; springAnimation.toValue = [NSNumber numberWithFloat:1.5]; //springAnimation.removedOnCompletion = NO; //springAnimation.fillMode = kCAFillModeForwards; springAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; [self.redView.layer addAnimation:springAnimation forKey:@"boundsAni"];&#125; 效果： 3.CAKeyframeAnimation 关键帧动画可以让我们在更细的粒度上控制动画的行为，关键帧动画需要指定几个关键的点，从而让动画沿着这些点运动，这几个点就称之为 关键帧 CAKeyframeAnimation属性 描述 values 指定关键点的值 path 可以设置一个CGPathRef / CGMutablePathRef，让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略. keyTimes 是走到某一个关键点花费的时间百分比(0～1)，keyTimes中的每一个时间值都对应values中的每一帧(两个数组的个数必须一致)，当keyTimes没有设置的时候,各个关键帧的时间是平分的。 通过 设置不同的属性值values 动画 关键帧动画创建第一种方式 通过 绘制路径path 动画 关键帧动画创建第二种方式 代码示例：12345678910111213141516171819202122232425// 角度转弧度#define angleToRadian(angle) ((angle) / 180.0 * M_PI)#pragma mark 关键帧动画values- (void)valuesAnimation &#123; // 1.创建动画对象 CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"transform.rotation"]; // 2.设置动画属性值 //NSValue *value1 = [NSValue valueWithCGPoint:&lt;#(CGPoint)#&gt;]; animation.values = @[@(angleToRadian(-5)),@(angleToRadian(5)),@(angleToRadian(-5))]; animation.duration = 1; animation.repeatCount = MAXFLOAT; //animation.keyTimes = @[@(0.0),@(1),@(0.1)]; // 如果不用反转,也可以在values里面写 //animation.autoreverses = YES; // 动画结束时的状态（不设置回到原始位置） //anim.removedOnCompletion = NO; //anim.fillMode = kCAFillModeForwards; // 3.给图层添加动画 [self.iconImage.layer addAnimation:animation forKey:@"valuesAnimation"];&#125; 代码示例：1234567891011121314151617181920212223242526#pragma mark 关键帧动画第二种方式- (void)translationAnimation2 &#123; // 1.创建关键帧动画并设置动画属性 CAKeyframeAnimation *moveAnimation = [CAKeyframeAnimation animationWithKeyPath:@"position"]; moveAnimation.duration = 2; // 2.设置关键帧动画的行进路径（绘制贝塞尔曲线） moveAnimation.path = self.path.CGPath; // 3.添加动画到图层，添加动画后就会执行动画 [self.ballView.layer addAnimation:moveAnimation forKey:nil]; // 设置最终的状态(不设置就是回到原始位置) self.ballView.layer.position = CGPointMake(330, 200);&#125;// 绘制贝塞尔曲线- (void)drawRect:(CGRect)rect &#123; self.path = [[UIBezierPath alloc]init]; [[UIColor redColor] setStroke]; self.path.lineWidth = 5; [self.path moveToPoint:CGPointMake(30, 200)]; [self.path addCurveToPoint:CGPointMake(330, 200) controlPoint1:CGPointMake(100, 50) controlPoint2:CGPointMake(200, 300)]; [self.path stroke];&#125; 效果： 4.CAAnimationGroup 动画组 CAAnimationGroup属性 描述 animations 用来保存一组动画对象的NSArray CFTimeInterval 时间间隔 代码示例：123456789101112131415161718192021222324252627#pragma mark 动画组(同时)- (void)groupAnimation1 &#123; // 位移动画 CAKeyframeAnimation *animation1 = [CAKeyframeAnimation animationWithKeyPath:@"position"]; NSValue *value0 = [NSValue valueWithCGPoint:CGPointMake(0, kScreenHeight/2-50)]; NSValue *value1 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth/3, kScreenHeight/2-50)]; NSValue *value2 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth/3, kScreenHeight/2+50)]; NSValue *value3 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth*2/3, kScreenHeight/2+50)]; NSValue *value4 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth*2/3, kScreenHeight/2-50)]; NSValue *value5 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth, kScreenHeight/2-50)]; animation1.values = @[value0,value1,value2,value3,value4,value5]; // 缩放动画 CABasicAnimation *animation2 = [CABasicAnimation animationWithKeyPath:@"transform.scale"]; animation2.fromValue = [NSNumber numberWithFloat:0.8f]; animation2.toValue = [NSNumber numberWithFloat:2.0f]; // 旋转动画 CABasicAnimation *animation3 = [CABasicAnimation animationWithKeyPath:@"transform.rotation"]; animation3.toValue = [NSNumber numberWithFloat:M_PI *4]; // 创建动画组 CAAnimationGroup *groupAnimation = [CAAnimationGroup animation]; groupAnimation.animations = @[animation1,animation2,animation3]; groupAnimation.duration = 4; [self.redView.layer addAnimation:groupAnimation forKey:@"groupAnimation"];&#125; 效果： 5.AnimationWithKeyPath的值在这里我就不用图片了，我就劳动一下吧(图片的不好复制不是吗)，福利奉上转场效果 key pathsTransform field value key paths Field Key Path Description rotation.x 设置为一个NSNumber对象的值是旋转,弧度,x轴。 rotation.y 设置为一个NSNumber对象的值是旋转,弧度,y轴。 rotation.z 设置为一个NSNumber对象的值是旋转,弧度,z轴。 rotation 设置为一个NSNumber对象的值是旋转,弧度,z轴。这个字段是一样设置旋转。z域。 scale.x 设置为一个NSNumber对象的值是x轴的比例因子。 scale.y 设置为一个NSNumber对象的值是y轴的比例因子。 scale.z 设置为一个NSNumber对象的值是z轴的比例因子。 scale 设置为一个NSNumber对象的值是所有三个规模因素的平均值。 translation.x 设置为一个NSNumber对象的值是沿着x轴。 translation.y 设置为一个NSNumber对象的值沿y轴。 translation.z 设置为一个NSNumber对象的值沿z轴。 translation 设置为一个NSValue对象包含一个NSSize或CGSize数据类型。数据类型表示将在x和y轴。 核心动画综合案例 5.物理动效(重力、碰撞、吸附、推力、关联)123456ios7之后提供的物理动效UIGravityBehavior 重力UICollisionBehavior 碰撞UISnapBehavior 吸附UIPushBehavior 推力UIAttachmentBehavior 关联 以下示例，我们就直接来代码，看效果了，中间会有部分解释； 1.UICollisionBehavior碰撞，示例：模仿重力 + 碰撞 的行为12345678910111213141516171819202122232425262728// 先指定一个参考视图来初始化animatorself.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];#pragma mark 模仿重力 和 碰撞效果- (void)animations &#123; // 添加重力 UIGravityBehavior *gravity = [[UIGravityBehavior alloc]initWithItems:@[self.ballView]]; // 添加碰撞 UICollisionBehavior *collision = [[UICollisionBehavior alloc]initWithItems:@[self.ballView]]; // 把参考视图的边界作为我的碰撞边界 collision.translatesReferenceBoundsIntoBoundary = YES; // 添加一个自定义的行为，修改动效参数 UIDynamicItemBehavior *itemBehavior = [[UIDynamicItemBehavior alloc]initWithItems:@[self.ballView]]; /** 弹性系数 density 1.0 密度 elasticity 0.0 弹性 friction 0.0 摩擦 resistance 0.0 阻力 */ itemBehavior.elasticity = 0.5; // 把重力和碰撞行为添加到动画执行者中 [self.animator addBehavior:gravity]; [self.animator addBehavior:collision]; [self.animator addBehavior:itemBehavior];&#125; 效果： 2.UISnapBehavior吸附，示例：模仿吸附 + 重力 的行为123456789101112- (void)doAnimation&#123; //[self.animator removeAllBehaviors]; // 添加一个吸附行为，指定吸附的点 UISnapBehavior *snap = [[UISnapBehavior alloc]initWithItem:self.ballView snapToPoint:CGPointMake(self.view.frame.size.width *0.5, self.view.frame.size.height - 100)]; // 添加一个重力的行为 UIGravityBehavior *gravity = [[UIGravityBehavior alloc]initWithItems:@[self.ballView]]; [self.animator addBehavior:snap]; [self.animator addBehavior:gravity];&#125; 效果： 3.UIPushBehavior推力，示例：模仿推力 + 碰撞 的行为123456789101112131415161718192021222324252627282930313233#pragma mark 添加点击手势- (void)addTapGestrue &#123; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(handleTapGestrue:)]; [self.ballView addGestureRecognizer:tap];&#125;- (void)handleTapGestrue:(UITapGestureRecognizer*)gesture&#123; // 球的中心点 CGPoint ballCenter = self.ballView.center; // 点击点 CGPoint tapPoint = [gesture locationInView:self.view]; CGFloat offsetX = tapPoint.x - ballCenter.x; CGFloat offsetY = tapPoint.y - ballCenter.y; CGFloat angle = atan2(offsetY, offsetX); CGFloat distance = sqrt(pow(offsetX, 2) + pow(offsetY, 2)); // 添加推力行为 UIPushBehavior *push = [[UIPushBehavior alloc]initWithItems:@[self.ballView] mode:UIPushBehaviorModeInstantaneous]; // 设置角度 [push setAngle:angle]; // 设置推力大小 // 每1个magnigude将会引起100/平方秒的加速度 [push setMagnitude:distance/100]; // 添加碰撞行为 UICollisionBehavior *collision = [[UICollisionBehavior alloc]initWithItems:@[self.ballView]]; collision.translatesReferenceBoundsIntoBoundary = YES; [self.animator addBehavior:push]; [self.animator addBehavior:collision];&#125; 效果： 4.UIAttachmentBehavior关联，示例：模仿推力 + 碰撞 的行为123456789- (void)doAnimation&#123; // UIAttachmentBehavior 可以设置和某一个点 UIAttachmentBehavior *attachment = [[UIAttachmentBehavior alloc]initWithItem:self.blueView attachedToItem:self.ballView]; // 关联的长度 [attachment setLength:100]; UIGravityBehavior *gravity = [[UIGravityBehavior alloc]initWithItems:@[self.blueView]]; [self.animator addBehavior:attachment]; [self.animator addBehavior:gravity];&#125; 效果： 6.粒子系统12CAEmitterCellCAEmitterLayer 7.facebook pop动画123456使用之前先讨论以下POP和核心动画的主要区别CoreAnimation 的动画是加在layer上CoreAnimation的动画只是表面而已，并没有真正的修改frame等属性值pop的动画可以添加到任何对象pop的底层是基于CADisplaylinkpop的动画真正的修改frame等属性值 pop使用：1234POP默认支持三种动画，但同时也支持自定义动画POPDecayAnimation 减速动画POPSpringAnimation 弹簧效果POPSpringAnimation 飞入效果 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>核心动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 伐码猿自检—「Masonry约束」]]></title>
    <url>%2FToolsAndPlugins%2FMasonry.html</url>
    <content type="text"><![CDATA[本篇文章主要从【Masonry 使用】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： Masonry简明介绍 导入Masonry框架 Masonry 常用API &amp; 特性1.基础API2.4种设置常量的方法3.简化前缀的宏定义 &amp; 简写4.更新约束和布局 Masonry常用方法1.基本使用：设置内边距2.简单动画：priority优先级3.更新约束 mas_updateConstraints4.重写约束 mas_remakeConstraints5.比例使用 multipliedBy6.大于等于和小于等于某个值的约束 Demo小样 重要的部分代码中都有相应的注解和文字打印，运行程序可以很直观的表现 Star 在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量@jianshu - 白开水ln。 Masonry简明介绍 Masonry是一个轻量级的布局框架，适用于iOS以及OS X。它用简洁的语法对官方的AutoLayout进行了封装。 Masonry有它自己的一套框架用来描述NSLayoutConstraints布局的DSL，提高了约束代码的简洁性与可读性。 导入Masonry框架 使用Cocoapods来导入框架，在使用到该框架的文件中添加主头文件：#import &lt;Masonry/Masonry.h&gt;。 使用直接拖拽的方式拉入框架文件夹，在使用到该框架的文件中添加主头文件：#import &quot;Masonry.h&quot;。 Masonry 常用API &amp; 特性 基础API123456789mas_makeConstraints() 添加约束mas_remakeConstraints() 移除之前的约束，重新添加新的约束mas_updateConstraints() 更新约束equalTo() 参数是对象类型，一般是视图对象或者mas_width这样的坐标系对象mas_equalTo() 和上面功能相同，参数可以传递基础数据类型对象，可以理解为比上面的API更强大width() 用来表示宽度，例如代表view的宽度mas_width() 用来获取宽度的值。和上面的区别在于，一个代表某个坐标系对象，一个用来获取坐标系对象的值 Constant：Masonry提供了4种设置constant的方法1234567- (MASConstraint * (^)(MASEdgeInsets insets))insets;- (MASConstraint * (^)(CGSize offset))sizeOffset;- (MASConstraint * (^)(CGPoint offset))centerOffset;- (MASConstraint * (^)(CGFloat offset))offset; 注解： insets: 用来设置left, right, top, bottom。接受MASEdgeInsets类型值 sizeOffset: 用来设置width, height。接受CGSize类型的值 centerOffset: 用来设置centerX, centerY。接受CGPoint类型的值 offset: 可以用来设置所有的东西。接受CGFloat类型的值 简化前缀的宏定义 &amp; 简写1234// 定义这个常量，就可以不用在开发过程中使用"mas_"前缀。#define MAS_SHORTHAND// 定义这个常量，就可以让Masonry帮我们自动把基础数据类型的数据，自动装箱为对象类型。#define MAS_SHORTHAND_GLOBALS 注解：这两个宏如果想有效使用，必须要在添加Masonry头文件之前导入进去。 1234567891011121314// 完整的make.left.equalTo(view1.superview.mas_left).offset(0);//省略Attribute的make.left.equalTo(view1.superview).offset(0);//省略equalTo的make.left.offset(0);//使用equalTo替代offset的make.left.equalTo(@0);//省略所有的... 可惜会有warningmake.left; 更新约束和布局 对于约束的设置，Masonry提供了3种方法，分别为设置约束、更新约束、重写设置约束 123456789101112131415161718// 设置约束 - (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;// 更新约束- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;// 重新设置约束- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;注解：mas_makeConstraints: 初次设置约束使用。mas_updateConstraints: 更新约束时使用。如果找不着这条约束，会新增，相当于mas_makeConstraints。mas_remakeConstraints: 重新设置约束。先将view上所有约束移除，再新增约束注意：mas_updateConstraints只能更新已有约束。如果第一次使用的是left, right设置的相对宽度。更新的时候想换成使用width。不能使用mas_updateConstraints，因为已有约束里面没有width的约束，新增width之后会跟原有left, right约束冲突。此时应该使用mas_remakeConstraints 关于更新约束布局相关的API，主要用以下四个API： - (void)updateConstraintsIfNeeded 调用此方法，如果有标记为需要重新布局的约束，则立即进行重新布局，内部会调用updateConstraints方法。 - (void)updateConstraints 重写此方法，内部实现自定义布局过程。 - (BOOL)needsUpdateConstraints 当前是否需要重新布局，内部会判断当前有没有被标记的约束。 - (void)setNeedsUpdateConstraints 标记需要进行重新布局。 关于UIView重新布局相关的API，主要用以下三个API： - (void)setNeedsLayout 标记为需要重新布局。 - (void)layoutIfNeeded 查看当前视图是否被标记需要重新布局，有则在内部调用layoutSubviews方法进行重新布局。 - (void)layoutSubviews 重写当前方法，在内部完成重新布局操作。 Masonry给我们提供了4个设置优先级接口 1234567891011// 可以设置任意的优先级，接受的参数是0-1000的数字- (MASConstraint * (^)(MASLayoutPriority priority))priority; // 设置低优先级，优先级为250- (MASConstraint * (^)())priorityLow; // 设置中优先级，优先级为500- (MASConstraint * (^)())priorityMedium; // 设置高优先级，优先级为750- (MASConstraint * (^)())priorityHigh; Masonry常用方法 基本使用：设置内边距效果图往下看：创建一个View，左右上下空出10个像素 123456789101112[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.view.mas_top).with.offset(150); make.left.equalTo(self.view.mas_left).with.offset(30); make.bottom.equalTo(self.view.mas_bottom).with.offset(30); make.right.equalTo(self.view.mas_right).with.offset(30);&#125;];//【通过insets简化设置内边距的方式】，一句代码代替上面的多行[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(self.view).with.insets(UIEdgeInsetsMake(150, 30, 30, 30));&#125;]; 简单动画：priority优先级效果图往下看：优先级约束一般放在一个控件约束的最后面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950- (void)testView2 &#123; // 红色View UIView *redView = [[UIView alloc]init]; redView.backgroundColor = [UIColor redColor]; [self.view addSubview:redView]; // 蓝色View self.blueView = [[UIView alloc]init]; self.blueView.backgroundColor = [UIColor blueColor]; [self.view addSubview:self.blueView]; // 黄色View UIView *yellowView = [[UIView alloc]init]; yellowView.backgroundColor = [UIColor yellowColor]; [self.view addSubview:yellowView]; // ---红色View--- 添加约束 [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.view.mas_left).with.offset(20); make.bottom.equalTo(self.view.mas_bottom).with.offset(-80); make.height.equalTo([NSNumber numberWithInt:50]); &#125;]; // ---蓝色View--- 添加约束 [self.blueView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.mas_equalTo(redView.mas_right).with.offset(40); make.bottom.width.height.mas_equalTo(redView); &#125;]; // ---黄色View--- 添加约束 [yellowView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.mas_equalTo(self.blueView.mas_right).with.offset(40); make.right.mas_equalTo(self.view.mas_right).with.offset(-20); make.bottom.width.height.mas_equalTo(redView); // 【优先级设置为250，最高1000（默认)】 make.left.mas_equalTo(redView.mas_right).with.offset(100).priority(250); &#125;]; NSLog(@"%@",redView);&#125;// 点击屏幕移除蓝色View- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; [self.blueView removeFromSuperview]; [UIView animateWithDuration:1.0 animations:^&#123; [self.view layoutIfNeeded]; &#125;];&#125; 注解： 这里的三个View的宽度是根据约束自动推断设置的，对黄色的View设置了一个与红色View有关的priority(250)的优先级， 它同时有对蓝色View有个最高的优先级约束（make.left.mas_equalTo(self.blueView.mas_right).with.offset(40);）。 当点击屏幕是，我将蓝色View移除，此时第二优先级就是生效。 更新约束 mas_updateConstraints效果图往下看：创建一个按钮，约束好它的位置（居中，宽高等于100且小于屏幕宽高值）。每次点击一次这个按钮，其宽高将增大一定的倍数，最终其宽高等于屏幕宽高时将不再变化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)testView3 &#123; self.growingButton = [UIButton buttonWithType:UIButtonTypeSystem]; [self setWithButton:self.growingButton title:@"mas_updateConstraints更新约束-点我放大"]; [self.growingButton addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:self.growingButton]; self.scacle = 1.0; [self.growingButton mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.mas_equalTo(self.view); // 初始宽、高为100，优先级最低 make.width.height.mas_equalTo(100 * self.scacle); // 最大放大到整个view + make.width.height.lessThanOrEqualTo(self.view); &#125;];&#125;- (void)buttonClick &#123; self.scacle += 1.0; // 告诉self.view约束需要更新 [self.view setNeedsUpdateConstraints]; // 调用此方法告诉self.view检测是否需要更新约束，若需要则更新，下面添加动画效果才起作用 [self.view updateConstraintsIfNeeded]; [UIView animateWithDuration:0.3 animations:^&#123; [self.view layoutIfNeeded]; &#125;];&#125;#pragma mark - updateViewConstraints// 重写该方法来更新约束- (void)updateViewConstraints &#123; [self.growingButton mas_updateConstraints:^(MASConstraintMaker *make) &#123; // 这里写需要更新的约束，不用更新的约束将继续存在 // 不会被取代，如：其宽高小于屏幕宽高不需要重新再约束 make.width.height.mas_equalTo(100 * self.scacle); &#125;]; [super updateViewConstraints];&#125; 重写约束 mas_remakeConstraints创建一个按钮，约束好其位置（与屏幕上左右的距离为0，与屏幕底部距离为350），点击按钮后全屏展现（即与屏幕底部距离为0）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)testView4 &#123; self.isExpanded = NO; self.growingButton = [UIButton buttonWithType:UIButtonTypeSystem]; [self setWithButton:self.growingButton title:@"mas_remakeConstraints重写约束-点我展开"]; [self.growingButton addTarget:self action:@selector(testView4BtnClick) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:self.growingButton]; [self.growingButton mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.mas_equalTo(0); make.left.right.mas_equalTo(0); make.bottom.mas_equalTo(-350); &#125;]; &#125;- (void)testView4BtnClick &#123; self.isExpanded = !self.isExpanded; if (!self.isExpanded) &#123; [self.growingButton setTitle:@"mas_remakeConstraints重写约束-点我展开" forState:UIControlStateNormal]; &#125; else &#123; [self.growingButton setTitle:@"mas_remakeConstraints重写约束-点我收起" forState:UIControlStateNormal]; &#125; // 告诉self.view约束需要更新 [self.view setNeedsUpdateConstraints]; // 调用此方法告诉self.view检测是否需要更新约束，若需要则更新，下面添加动画效果才起作用 [self.view updateConstraintsIfNeeded]; [UIView animateWithDuration:0.3 animations:^&#123; [self.view layoutIfNeeded]; &#125;];&#125;#pragma mark - updateViewConstraints- (void)updateViewConstraints &#123; // 这里使用update也能实现效果 // remake会将之前的全部移除，然后重新添加 __weak __typeof(self) weakSelf = self; [self.growingButton mas_remakeConstraints:^(MASConstraintMaker *make) &#123; // 这里重写全部约束，之前的约束都将失效 make.top.mas_equalTo(0); make.left.right.mas_equalTo(0); if (weakSelf.isExpanded) &#123; make.bottom.mas_equalTo(0); &#125; else &#123; make.bottom.mas_equalTo(-350); &#125; &#125;]; [super updateViewConstraints];&#125; 注解： mas_remakeConstraints和mas_updateConstraints 的区别在于 前者重新对视图进行了约束（抛弃了之前的约束），后者是更新约束条件（保留未更新的约束)， 如：这次更新了对 height 的约束，其他对X&amp;Y以及宽的约束不变）。 比例使用 multipliedBy使用multipliedBy必须是对同一个控件本身，如果修改成相对于其它控件会出导致Crash。 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)testView5 &#123; UIView *topView = [[UIView alloc]init]; [topView setBackgroundColor:[UIColor redColor]]; [self.view addSubview:topView]; UIView *topInnerView = [[UIView alloc]init]; [topInnerView setBackgroundColor:[UIColor greenColor]]; [topView addSubview:topInnerView]; UIView *bottomView = [[UIView alloc]init]; [bottomView setBackgroundColor:[UIColor blueColor]]; [self.view addSubview:bottomView]; UIView *bottomInnerView = [[UIView alloc]init]; [bottomInnerView setBackgroundColor:[UIColor blackColor]]; [bottomView addSubview:bottomInnerView]; [topView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.left.right.mas_equalTo(0); make.height.mas_equalTo(bottomView); &#125;]; [topInnerView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.right.mas_equalTo(0); // 求解❓ make.width.mas_equalTo(topInnerView.mas_height).multipliedBy(2); make.center.mas_equalTo(topView); &#125;]; [bottomView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.bottom.right.mas_equalTo(0); make.height.mas_equalTo(topView); make.top.mas_equalTo(topView.mas_bottom); &#125;]; [bottomInnerView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.bottom.mas_equalTo(bottomView); make.height.mas_equalTo(bottomInnerView.mas_width).multipliedBy(4); make.center.mas_equalTo(bottomView); &#125;]; // NSLog(@"%@",NSStringFromCGRect(topInnerView.bounds));&#125; 大于等于和小于等于某个值的约束 参考：http://www.jianshu.com/p/99c418cd11f7 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>工具&amp;插件</category>
      </categories>
      <tags>
        <tag>Masonry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 模块详解—「多线程面试、工作」看我就 🐒 了 ^_^.]]></title>
    <url>%2FiOSNET%2FMultithreading.html</url>
    <content type="text"><![CDATA[引导 谈到iOS多线程，想必大家第一反应就是多线程4种实现方案 1.pthread、2.NSThread、3.GCD、4.NSOperation；它们每个的用法、特点、应用场景及注意点，文章会一一讲到。 本篇文章主要从【iOS多线程模块】学习总结，在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： 多线程相关概念1.进程和线程概念2.多线程概念3.主线程4.GCD相关概念 pthread &amp; NSThread1.pthread2.NSThread1&gt; NSThread创建线程有3个方法2&gt; NSThread其它方法3&gt; NSThread线程安全4&gt; NSThread线程间通信5&gt; NSThread线程状态转换 GCD中枢调度器1.什么是GCD2.GCD基本概念3.任务&amp;队列组合使用4.GCD的优势5.GCD基本使用6.GCD常见用法和应用场景7.内存和安全8.单例模式9.总结 NSOperation操作队列1.什么是NSOperation2.NSOperation相关概念3.NSInvocationOperation &amp; NSBlockOperation4.NSOperation优势5.NSOperation基本使用6.NSOperation结合NSOperationQueue使用7.非主队列控制串行和并行执行的关键8.添加操作依赖和操作监听9.NSOperation线程间通信10.管理操作：是操作队列的方法 多线程相关概念篇 1.进程进程是指在系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。 2.线程基本概念：1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程），线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。线程的串行：1个线程中的任务的执行是串行(按顺序地执行)，如果要在1个线程中执行多个任务，那么只能一个一个按顺序执行这些任务（也就是说，在同一时间内，1个线程只能执行一个任务） 3.进程和线程的比较1、进程是CPU分配资源和调度的单位2、线程是CPU调用(执行任务)的最小单位3、一个程序可以对应多个进程，一个进程中可以有多个线程，但至少要有一个线程4、同一个进程内的线程共享进程的资源 多线程概念多线程概念：即1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务多线程并发执行：在同一时间里，CPU只能处理1条线程，只有1条线程在工作（执行）；多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。 多线程优缺点：优点：1、能适当提高程序的执行效率2、能适当提高资源利用率（CPU、内存利用率）缺点：1、开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能2、线程越多，CPU在调度线程上的开销就越大3、程序设计更加复杂：比如线程之间的通信、多线程的数据共享 主线程主线程：程序运行后，默认会开启1条线程作用：刷新显示UI,处理UI事件使用注意：1、不要将耗时操作放到主线程中去处理，会卡住线程，严重影响UI界面的流畅度，给用户界面卡顿的现象(放到子线程中执行)；2、和UI相关的刷新操作必须放到主线程中进行处理 多线程实现方案 特点 语言 频率 线程生命周期 pthread 1、一套通用的多线程API 2、适用于Unix\Linux\Windows等系统 3、跨平台\可移植 4、使用难度大 c语言 几乎不用 由程序员进行管理 NSThread 1、使用更加面向对象 2、简单易用，可直接操作线程对象 OC语言 偶尔使用 由程序员进行管理 GCD 1、旨在替代NSThread等线程技术 2、充分利用设备的多核（自动） C语言 经常使用 自动管理 NSOperation 1、基于GCD（底层是GCD） 2、比GCD多了一些更简单实用的功能 3、使用更加面向对象 OC语言 经常使用 自动管理 GCD相关概念初学GCD的时候，肯定会纠结一些看似很关键但却毫无意义的问题(不要纠结，概念理解的基础+实战，就会解决你的疑惑)，对于GCD需要关注的只有两个概念：任务、队列。 1.任务linux内核中的任务的定义是描述进程的一种结构体，而GCD中的任务只是一个代码块，它可以指一个block或者函数指针。根据这个代码块添加进入队列的方式，将任务分为异步任务和同步任务：异步任务：使用dispatch_async将任务加入队列。将异步任务加入并发队列，会开启多条线程且任务是并发执行(这也是我们最常用的一种方式)；将异步任务加入串行队列，会开启一条线程且任务是串行执行(按顺序执行)；将异步任务加入主队列，不会开启线程且任务都在主线程中执行。同步任务：使用dispatch_sync将任务加入队列。将同步任务加入并发队列，不会开启线程且任务是串行执行；将同步任务加入串行队列，不会开启线程且任务是串行执行(也没什么意义是吧)；将同步任务加入主队列，不会开启线程且任务都在主线程中执行（注意：方法在主线程调用会造成死锁，在子线程中调用不会造成死锁）。 2.队列调度队列是一个对象，它会以first-in、first-out的方式管理您提交的任务。GCD有三种队列类型并行队列：并发队列虽然是能同时执行多个任务，但这些任务仍然是按照先到先执行(FIFO)的顺序来执行的。并发队列会基于系统负载来合适地选择并发执行这些任务。并发队列一般指的就是全局队列(Global queue)，进程中存在四个全局队列：高、中(默认)、低、后台四个优先级队列，可以调用dispatch_get_global_queue函数传入优先级来访问队列。当然我们也可以用dispatch_queue_create，并指定队列类型DISPATCH_QUEUE_CONCURRENT，来自己创建一个并发队列。 串行队列：串行队列将任务以先进先出(FIFO)的顺序来执行，所以串行队列经常用来做访问某些特定资源的同步处理。你可以也根据需要创建多个队列，而这些队列相对其他队列都是并发执行的。换句话说，如果你创建了4个串行队列，每一个队列在同一时间都只执行一个任务，对这四个任务来说，他们是相互独立且并发执行的。如果需要创建串行队列，一般用dispatch_queue_create这个方法来实现，并指定队列类型DISPATCH_QUEUE_SERIAL。 主队列：主队列，与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。main queue可以调用dispatch_get_main_queue()来获得。因为main queue是与主线程相关的，所以这是一个串行队列。和其它串行队列一样，这个队列中的任务一次只能执行一个。它能保证所有的任务都在主线程执行，而主线程是唯一可用于更新 UI 的线程。 注：队列间的执行是并行的，但是也存在一些限制。比如，并行执行的队列数量受到内核数的限制，无法真正做到大量队列并行执行；比如，对于并行队列中的全局队列而言，其存在优先级关系，执行的时候也会遵循其优先顺序，而不是并行。 以上概念文言文你也许感到有点什么，下面总结简单小表格方便你查看 3.GCD总结小表格 GCD 特点 核心概念 任务：执行什么操作 队列：用来存放任务 函数 异步：可以在新的线程中执行任务，具备开启新线程的能力 同步：只能在当前线程中执行任务，不具备开启新线程的能力 队列 并发：允许多个任务并发（同时）执行（自动开启多个线程同时执行任务），并发功能只有在异步函数下才有效 串行：一个任务执行完毕后，再执行下一个任务（按顺序执行） 全局并发队列 特点：存在优先级关系（DEFAULT默认的、HIGH高的、LOW低的、BACKGROUND最低的） 主队列 特点：添加到主队列上的任务，必须在主线程执行。如果主队列发现当前主线程有任务在执行，那么主队列会暂停调用队列中的任务，直到主线程空闲为止 对于 任务与队列 之间的关系，下面总结简单小表格方便你查看 任务 &amp; 队列 并发队列(concurrent) 串行队列(serial) 主队列(get_main) 异步函数(async) 会开启多条线程，队列中的任务是并发执行 会开启一条线程，队列中的任务是串行执行 不会开启线程，所有任务都在主线程中执行 同步函数(sync) 不会开启线程，队列中的任务是串行执行 不会开启线程，队列中的任务是串行执行 不会开启线程，所有任务都在主线程中执行（注意：在主线程调用会造成死锁，在子线程中调用不会造成死锁） pthread &amp; NSThread篇 1.pthread其实这个方案开发几乎不用，只是拿来充个数，为让大家了解一下就好了简单介绍下，pthread是一套通用的多线程的API，可以在Unix / Linux / Windows 等系统跨平台使用，使用C语言编写，需要程序员自己管理线程的生命周期，使用难度较大，所以仅了解，看一遍有个印象。 pthread使用方法1234567891011121314#pragma mark - pthread创建子线程- (void)pthread &#123; //1.创建线程对象 pthread_t thread; //2.创建线程 //参数:线程对象(传递地址)，线程的属性(NULL)，指向函数的指针，函数需要接受的参数 pthread_create(&amp;thread, NULL, task, NULL);&#125;void *task(void *param) &#123; NSLog(@"%@",[NSThread currentThread]); return NULL;&#125; 打印输出：12016-02-10 19:10:36.902 多线程2.4[9565:222926] &lt;NSThread: 0x600000275540&gt;&#123;number = 3, name = (null)&#125; 应用场景：我们在iOS开发中几乎不使用pthread 2.NSThread这个方案是经过苹果封装后的，使用更加面向对象，简单易用可直接操作线程对象，但是，它的生命周期还是需要我们手动管理，所以这个方案也是偶尔用用，比如 [NSThread currentThread]用来获得当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便。下面来看看它的一些用法 1.NSThread创建线程有3个方法首先要包含头文件#import &lt;pthread.h&gt; 方法一：创建线程且手动启动12NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(task:) object:nil];[thread start]; 方法二：分离子线程并自动启动1[NSThread detachNewThreadSelector:@selector(thread:) toTarget:self withObject:nil]; 方法三：后台线程并自动启动1[self performSelectorInBackground:@selector(thread:) withObject:@"开启后台线程"]; 2.NSThread其他方法除了创建启动外，NSThread 还以很多方法，下面我列举一些常见的方法，当然我列举的并不完整，更多方法大家可以去类的定义里去看1234567891011121314151617181920212223242526272829303132333435// 取消线程- (void)cancel;// 启动线程- (void)start;// 强制停止线程+ (void)exit;// 判断某个线程的状态的属性@property (readonly, getter=isExecuting) BOOL executing;@property (readonly, getter=isFinished) BOOL finished;@property (readonly, getter=isCancelled) BOOL cancelled;// 设置和获取线程名字-(void)setName:(NSString *)n;-(NSString *)name;// 设置优先级（取值范围 0.0 ~ 1.0 之间 最高是1.0 默认优先级是0.5）+ (double)threadPriority;+ (BOOL)setThreadPriority:(double)p;// 获取当前线程信息+ (NSThread *)currentThread;// 获取主线程信息+ (NSThread *)mainThread;// 判断是否为主线程(对象方法)- (BOOL)isMainThread;// 判断是否为主线程(类方法)+ (BOOL)isMainThread;// 阻塞线程（延迟执行）+ (void)sleepForTimeInterval:(NSTimeInterval)time;+ (void)sleepUntilDate:(NSDate *)date; 2.NSThread线程安全 线程安全，解决方法采用线程加锁，需了解互斥锁 互斥锁使用格式:@synchronized (self) {// 需要锁定的代码 }注意：锁定一份代码只用一把锁，用多把锁是无效的 互斥锁的优缺点:优点:能有效防止因多线程抢夺资源造成的数据安全问题缺点:需要消耗大量的CPU资源 互斥锁注意点:锁:必须是全局唯一的（通常用self）1.注意加锁的位置2.注意加锁的前提条件,多线程共享同一块资源3.注意加锁是需要代价的,需要耗费性能的4.加锁的结果:线程同步（按顺序执行） 补充:我们知道, 属性中有atomic和nonatomic属性 atomic : setter方法线程安全, 需要消耗大量的资源 nonatomic : setter方法非线程安全, 适合内存小的移动设备 3.NSThread线程间通信线程间通信：任务从子线程回到主线程1234567/** 线程间通信(回到主线程刷新UI) 参数：回到主线程要调用那个方法、前面方法需要传递的参数、是否等待（YES执行完再执行下面代码，NO可先执行下面代码）*/[self performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:NO];[self performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:NO]; 4.NSThread线程状态转换 GCD中枢调度器 1.什么是GCD GCD全称 Grand Central Dispath，可译为”强大的中枢调度器”，基于libdispatch 纯C语言，里面包含了许多多线程相关非常强大的函数. 程序员可以既不写一句线程管理的代码又能很好地使用多线程执行任务。 2.GCD基本概念初学GCD的时候，肯定会纠结一些看似很关键但却毫无意义的问题(不要纠结，概念理解的基础+实战，就会解决你的疑惑)，对于GCD需要关注的只有两个概念：任务 &amp; 队列。而对于GCD相关的概念解读，如果你对这些都已有了解 可以忽略，如果还有疑虑可以参考一下 「iOS多线程—夯实基础「多线程基本概念」 在这里就提供 GCD主要概念简单总结小表格，方便你查看。 GCD 特点 核心概念 任务：执行什么操作 队列：用来存放任务 函数 异步：可以在新的线程中执行任务，具备开启新线程的能力 同步：只能在当前线程中执行任务，不具备开启新线程的能力 队列 并发：允许多个任务并发（同时）执行（自动开启多个线程同时执行任务），并发功能只有在异步函数下才有效 串行：一个任务执行完毕后，再执行下一个任务（按顺序执行） 全局并发队列 特点：存在优先级关系（DEFAULT默认的、HIGH高的、LOW低的、BACKGROUND最低的） 主队列 特点：添加到主队列上的任务，必须在主线程执行。如果主队列发现当前主线程有任务在执行，那么主队列会暂停调用队列中的任务，直到主线程空闲为止 3.任务&amp;队列组合使用下面总结简单小表格方便你查看 任务 &amp; 队列 并发队列(concurrent) 串行队列(serial) 主队列(get_main) 异步函数(async) 会开启多条线程，队列中的任务是并发执行 会开启一条线程，队列中的任务是串行执行 不会开启线程，所有任务都在主线程中执行 同步函数(sync) 不会开启线程，队列中的任务是串行执行 不会开启线程，队列中的任务是串行执行 不会开启线程，所有任务都在主线程中执行（注意：在主线程调用会造成死锁，在子线程中调用不会造成死锁） 4.GCD的优势易用: GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱,而是因为基于block，它能极为简单得在不同代码作用域之间传递上下文。灵活: GCD 具有在常见模式(比如互斥锁、单例模式)上的特点，且会自动管理线程的生命周期创建线程、调度任务、销毁线程），用更高性能的方法优化代码，而且GCD(C API)能提供更多的控制权力以及大量的底层函数。性能: GCD 会自动利用更多的CPU内核（比如双核、四核）,且自动根据系统负载来增减线程数量，这就减少了线程间切换以及增加了计算效率。 怎么样? 心动不, 迫不及待想要知道怎么使用GCD了吧, 那我们正式投入GCD的怀抱了~我会通过代码展示。 5.GCD基本使用12345678910111213141516171819/** 1.创建队列 queue1:全局并行队列（默认优先级，可为0）、queue2:主队列、queue3:未指定type则为串行队列、queue4:指定串行队列、queue5:指定并发队列 */dispatch_queue_t queue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_queue_t queue2 = dispatch_get_main_queue();dispatch_queue_t queue3 = dispatch_queue_create("queue3", NULL);dispatch_queue_t queue4 = dispatch_queue_create("queue4", DISPATCH_QUEUE_SERIAL);dispatch_queue_t queue5 = dispatch_queue_create("queue5", DISPATCH_QUEUE_CONCURRENT);// 2.封装异步任务添加到队列dispatch_async(queue1, ^&#123; // 任务&#125;);// 封装同步任务添加到队列dispatch_sync(queue1, ^&#123; // 任务&#125;); 6.GCD常见用法和应用场景1.dispatch_async 异步函数使用方法:(线程间通信)12345678// 1.创建子线程dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // 执行任务 ... dispatch_async(dispatch_get_main_queue(), ^&#123; // 回到主线程刷新UI ... &#125;);&#125;); 应用场景:这种用法非常常见，比如开启一个异步的网络请求，待数据返回后返回主队列刷新UI；又比如请求图片，待图片返回刷新UI或是耗时文件操作等等。 2.dispatch_after 延迟执行使用方法:(多个方法，好对比)123456789101112131415161718// 方法一:调用NSObject的方法//[self performSelector:@selector(task) withObject:nil afterDelay:2.0];// 方法二:使用NSTimer//[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(task) userInfo:nil repeats:YES];// 方法三:使用GCD(优点:可以控制任务在那个线程执行)//dispatch_queue_t queue = dispatch_get_main_queue();dispatch_queue_t queue = dispatch_get_global_queue(0, 0);/* 第一个参数:DISPATCH_TIME_NOW 从现在开始计算时间 第二个参数:延迟的时间 2.0 GCD时间单位:纳秒 第三个参数:队列 */dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), queue, ^&#123; NSLog(@"GCD----%@",[NSThread currentThread]);&#125;); 应用场景:这为我们提供了一个简单的延迟执行的方式，比如在view加载结束延迟执行一个动画等等 3.dispatch_time 延迟时间使用方法:123456789// dispatch_time_t一般在dispatch_after和dispatch_group_wait等方法里作为参数使用。这里最需要注意的是一些宏的含义。// NSEC_PER_SEC，每秒有多少纳秒。// USEC_PER_SEC，每秒有多少毫秒。// NSEC_PER_USEC，每毫秒有多少纳秒。// DISPATCH_TIME_NOW 从现在开始// DISPATCH_TIME_FOREVE 永久// time为2s的写法dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC); 4.dispatch_once_t 一次性代码使用方法:(保证某段代码在程序运行过程中只被执行1次)123456// onceToken用来记录该部分的代码是否被执行过static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; // 只执行1次的代码(这里面默认是线程安全的) NSLog(@"---once----");&#125;); 应用场景:可以使用其创建一个单例，也可以做一些其他只执行一次的代码，注意:看到一次性代码你可能会想到懒加载，提醒dispatch_once_t 不能放在懒加载中的 5.dispatch_barrier_async 栅栏函数使用方法:1234567891011121314151617181920212223// dispatch_barrier_async 作用可一个词概括一一承上启下- (void)barrier &#123; // 注意:栅栏函数(不能使用全局并发队列) //dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_queue_t queue = dispatch_queue_create("concurrent", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; NSLog(@"download1---%@",[NSThread currentThread]); &#125;); [NSThread sleepForTimeInterval:5];// 睡眠5s dispatch_async(queue, ^&#123; NSLog(@"download2---%@",[NSThread currentThread]); &#125;); [NSThread sleepForTimeInterval:5]; // 栅栏函数 dispatch_barrier_async(queue, ^&#123; NSLog(@"++++++++++++++++++++++"); &#125;); dispatch_async(queue, ^&#123; NSLog(@"download3---%@",[NSThread currentThread]); &#125;);&#125; 栅栏函数使用全局并发队列，打印输出12342016-02-11 14:45:43.228 多线程2.4[17420:450903] download1---&lt;NSThread: 0x60800007dd00&gt;&#123;number = 3, name = (null)&#125;2016-02-11 14:45:43.228 多线程2.4[17420:450906] ++++++++++++++++++++++2016-02-11 14:45:43.228 多线程2.4[17420:450943] download3---&lt;NSThread: 0x600000264440&gt;&#123;number = 5, name = (null)&#125;2016-02-11 14:45:43.228 多线程2.4[17420:450904] download2---&lt;NSThread: 0x600000260b40&gt;&#123;number = 4, name = (null)&#125; 栅栏函数使用手动创建并发队列，打印输出12342016-02-11 14:51:27.502 多线程2.4[17537:454708] download2---&lt;NSThread: 0x60000007e6c0&gt;&#123;number = 4, name = (null)&#125;2016-02-11 14:51:27.502 多线程2.4[17537:454709] download1---&lt;NSThread: 0x60800007f5c0&gt;&#123;number = 3, name = (null)&#125;2016-02-11 14:51:27.502 多线程2.4[17537:454709] ++++++++++++++++++++++2016-02-11 14:51:27.503 多线程2.4[17537:454709] download3---&lt;NSThread: 0x60800007f5c0&gt;&#123;number = 3, name = (null)&#125; 应用场景:和dispatch_group类似，dispatch_barrier也是异步任务间的一种同步方式，可以在比如文件的读写操作时使用，保证读操作的准确性。注意:dispatch_barrier_async只在自己创建的并发队列上有效。 6.dispatch_apply 快速迭代使用方法:1234567891011// 注意:会开子线程和主线程一起完成遍历任务，任务的执行是并发的- (void)apply &#123; /** iterations 遍历的次数 queue 队列(只能是并发队列，传主队列会造成死锁，传串行队列无效果) index 索引 */ dispatch_apply(4, dispatch_get_global_queue(0, 0), ^(size_t index) &#123; NSLog(@"download--%zd--%@",index,[NSThread currentThread]); &#125;);&#125; 打印输出:12342016-02-11 15:19:53.490 多线程2.4[18411:477679] download--3--&lt;NSThread: 0x608000073940&gt;&#123;number = 5, name = (null)&#125;2016-02-11 15:19:53.490 多线程2.4[18411:477641] download--0--&lt;NSThread: 0x608000066c00&gt;&#123;number = 1, name = main&#125;2016-02-11 15:19:53.490 多线程2.4[18411:477682] download--1--&lt;NSThread: 0x600000076f00&gt;&#123;number = 3, name = (null)&#125;2016-02-11 15:19:53.490 多线程2.4[18411:477680] download--2--&lt;NSThread: 0x600000077100&gt;&#123;number = 4, name = (null)&#125; 应用场景:dispatch_apply并行的运行机制，效率一般快于for循环的类串行机制（在for一次循环中的处理任务很多时差距比较大）。比如这可以用来拉取网络数据后提前算出各个控件的大小，防止绘制时计算，提高表单滑动流畅性，如果用for循环，耗时较多，并且每个表单的数据没有依赖关系，所以用dispatch_apply比较好。 7.dispatch_group_t 队列组使用方法:123456789101112131415161718192021222324252627282930// 队列组：会监听任务的执行情况，通知group- (void)group1 &#123; dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^&#123; NSLog(@"1-----%@", [NSThread currentThread]); &#125;); [NSThread sleepForTimeInterval:2]; dispatch_group_async(group, queue, ^&#123; NSLog(@"2-----%@", [NSThread currentThread]); &#125;); [NSThread sleepForTimeInterval:2]; dispatch_group_async(group, queue, ^&#123; NSLog(@"3-----%@", [NSThread currentThread]); &#125;); [NSThread sleepForTimeInterval:2]; // 方法一:组通知 // 拦截通知，当队列组中所有的任务都执行完毕的时候回进入到这个方法 //dispatch_group_notify(group, queue, ^&#123; // NSLog(@"----group_notify---"); //&#125;); // 方法二:组等待 dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@"----end----");&#125; group_notify 打印输出:123452016-02-11 15:40:30.083 多线程2.4[19029:495158] 1-----&lt;NSThread: 0x608000073ac0&gt;&#123;number = 3, name = (null)&#125;2016-02-11 15:40:32.084 多线程2.4[19029:495158] 2-----&lt;NSThread: 0x608000073ac0&gt;&#123;number = 3, name = (null)&#125;2016-02-11 15:40:34.084 多线程2.4[19029:495158] 3-----&lt;NSThread: 0x608000073ac0&gt;&#123;number = 3, name = (null)&#125;2016-02-11 15:40:36.085 多线程2.4[19029:494872] ----end----2016-02-11 15:40:36.085 多线程2.4[19029:495158] ----group_notify--- group_wait 打印输出:12342016-02-11 15:38:30.374 多线程2.4[18909:492794] 1-----&lt;NSThread: 0x608000266900&gt;&#123;number = 3, name = (null)&#125;2016-02-11 15:38:35.374 多线程2.4[18909:492794] 2-----&lt;NSThread: 0x608000266900&gt;&#123;number = 3, name = (null)&#125;2016-02-11 15:38:40.376 多线程2.4[18909:492794] 3-----&lt;NSThread: 0x608000266900&gt;&#123;number = 3, name = (null)&#125;2016-02-11 15:38:45.377 多线程2.4[18909:492734] ----end---- 注意:group_notify 拦截通知，当队列组中所有的任务都执行完毕的时候回进入到这个方法，问题? 该方法是阻塞的吗? –&gt; 内部本身是异步的。group_wait 等待.死等. 直到队列组中所有的任务都执行完毕之后才能执行，(DISPATCH_TIME_NOW : 现在，DISPATCH_TIME_FOREVER : 永远) 作用：阻塞。 8.dispatch_sync 死锁怎样会造成死锁 &amp; 如何避开死锁使用方法:12345678910111213141516- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 直接调用，主线程调用 会造成死锁 //[self syncMain]; // 正确调用，子线程中调用 不会造成死锁 [NSThread detachNewThreadSelector:@selector(syncMain) toTarget:self withObject:nil]; &#125;- (void)syncMain &#123; // 1.获得主队列 dispatch_queue_t queue = dispatch_get_main_queue(); // 2.同步函数 dispatch_sync(queue, ^&#123; NSLog(@"download1---%@",[NSThread currentThread]); &#125;); 打印输出:12341.在主线程调用 会造成死锁2.在子线程中调用 不会造成死锁2016-02-11 16:29:59.410 多线程2.4[19986:525068] download1---&lt;NSThread: 0x60800007a640&gt;&#123;number = 1, name = main&#125; 下面这种情况，也会造成死锁123456789101112// 死锁- (void)syncMain2 &#123; // 因为dispatch_apply会卡住当前线程，内部的dispatch_apply会等待外部，外部的等待内部，所以死锁。 dispatch_queue_t queue = dispatch_queue_create("queue", DISPATCH_QUEUE_SERIAL); dispatch_apply(4, queue, ^(size_t index) &#123; NSLog(@"download1--%zd--%@",index,[NSThread currentThread]); NSLog(@"+++++++++++++++"); dispatch_apply(4, queue, ^(size_t index) &#123; NSLog(@"download2--%zd--%@",index,[NSThread currentThread]); &#125;); &#125;);&#125; 9.dispatch_suspend&amp;dispatch_resume 挂起队列和恢复队列使用方法:123dispatch_queue_t queue = dispatch_get_main_queue();dispatch_suspend(queue); // 挂起(暂停)队列dispatch_resume(queue); // 恢复队列 应用场景:有时候，我们不想让队列中的某些任务马上执行，这时我们可以通过挂起操作来阻止一个队列中将要执行的任务。注意:执行挂起操作不会对已经开始执行的任务起作用，它仅仅只会阻止将要进行但是还未开始的任务。 7.内存和安全内存MRC：用dispatch_retain和dispatch_release管理dispatch_object_t内存。ARC：ARC在编译时刻自动管理dispatch_object_t内存，使用retain和release会报错。 安全dispatch_queue是线程安全的，你可以随意往里面添加任务。 补充1.注意ARC不是垃圾回收机制，是编译器特性配置MRC环境：build setting -&gt;搜索automatic ref-&gt;修改为NO 2.在MRC环境下，如果用户retain了一次，那么直接返回instance变量，不对引用计数器+1如果用户release了一次，那么什么都不做，因为单例模式在整个程序运行过程中都拥有且只有一份，程序退出之后被释放，所以不需要对引用计数器操作 8.单例模式单例也就是在程序的整个生命周期中, 该类有且仅有一个实例对象, 此时为了保证只有一个实例对象, 我们这里用到了dispatch_once函数 在这里我就整理好吧，就不直接粘上代码了，可能会很多地方用到，到时会很麻烦。下面整理了单例模式通用的宏，如果你需要可以直接拷走，是吧~1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 定义带参数的宏// MRC单例模式 &amp; ARC单例模式#define SingleH(name) +(instancetype)share##name;#if __has_feature(objc_arc)//条件满足 ARC#define SingleM(name) static id _instance;\+(instancetype)allocWithZone:(struct _NSZone *)zone\&#123;\ static dispatch_once_t onceToken;\ dispatch_once(&amp;onceToken, ^&#123;\ _instance = [super allocWithZone:zone];\ &#125;);\ return _instance;\&#125;\+(instancetype)share##name\&#123;\ return [[self alloc]init];\&#125;\-(id)copyWithZone:(NSZone *)zone\&#123;\ return _instance;\&#125;\-(id)mutableCopyWithZone:(NSZone *)zone\&#123;\ return _instance;\&#125;#else//MRC#define SingleM(name) static id _instance;\+(instancetype)allocWithZone:(struct _NSZone *)zone\&#123;\ static dispatch_once_t onceToken;\ dispatch_once(&amp;onceToken, ^&#123;\ _instance = [super allocWithZone:zone];\ &#125;);\ return _instance;\&#125;\+(instancetype)share##name\&#123;\ return [[self alloc]init];\&#125;\-(id)copyWithZone:(NSZone *)zone\&#123;\ return _instance;\&#125;\-(id)mutableCopyWithZone:(NSZone *)zone\&#123;\ return _instance;\&#125;\-(oneway void)release&#123;&#125;\-(instancetype)retain\&#123;\ return _instance;\&#125;\-(NSUInteger)retainCount\&#123;\ return MAXFLOAT;\&#125;#endif 9.总结GCD可进行线程间通信GCD可以办到线程安全GCD可用于延迟执行GCD需要注意死锁问题(不要在当前队列调用同步函数) NSOperation操作队列篇 1.什么是NSOperationNSOperation是苹果提供给我们的一套多线程解决方案。实际上NSOperation是基于GCD 的封装，完全面向对象，但是比GCD更简单易用、代码可读性也更高，使用也更好理解。使用起来也和GCD差不多，其中 NSOperation相当于GCD中的任务，而NSOperationQueue则相当于GCD中的队列。注意:NSOperation需要配合NSOperationQueue来实现多线程（1.将要操作任务封装到一个NSOperation对象中，2.将此任务添加到一个NSOperationQueue对象中，然后系统就会自动在执行任务）。因为默认情况下，NSOperation单独使用时系统同步执行操作，并没有开辟新线程的能力，只有配合NSOperationQueue才能实现异步执行。 2.NSOperation相关概念 并行(Concurrent) &amp; 串行(Serial)并行和串行描述的是任务和任务之间的执行方式，并行是任务A和任务B可以同时执行，串行是任务A执行完了任务B才能执行(按顺序执行)。 异步(Asynchronous) &amp; 同步(Synchronous)异步和同步描述的其实就是函数什么时候返回. 比如用来下载图片的函数: 同步函数只有在image下载结束之后才返回, 下载的这段时间函数只能等待，而异步函数,不会去等它完成(异步函数不会堵塞当前线程去执行下一个函数)。 并发(Concurrency) &amp; 并行(Parallelism)这个更容易混淆了, 并发和并行都是用来让不同的任务可以”同时执行”。 只是并行是真同时，而并发是假同时(是CPU地在各个进程之间快速切换, 给人一种能同时处理多任务的错觉)。 3.NSInvocationOperation&amp; NSBlockOperationNSOperation是一个抽象类,它不能直接使用,所以你必须使用NSOperation子类,系统已经给我们封装了NSBlockOperation和 NSInvocationOperation这两个实体类，不过我们更多的使用是自己继承并定制自己的操作。 1.NSInvocationOperation：使用这个类来初始化一个操作,它包括指定对象的调用selector。 2.NSBlockOperation：使用这个类来用一个或多个block初始化操作,操作本身可以包含多个块。当所有block被执行操作将被视为完成。 4.NSOperation优势 NSOperation是基于GCD的封装, 拥有更多的API(suspended, cancelled). 在NSOperationQueue中, 可以指定各个NSOperation之间的依赖关系(注意:不能相互依赖). 用KVO可以方便的监测NSOperation的状态(isExecuted, isFinished, isCancelled). 更高的可定制能力, 你可以继承NSOperation实现可复用的逻辑模块. 5.NSOperation基本使用在不使用NSOperationQueue，需要调用 start 方法来启动任务，不开启新线程，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。 1.NSInvocationOperation12345678910NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(download) object:nil];[op1 start];// 启动``` 2.NSBlockOperation```objcNSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(download) object:nil];[op1 start]; 这里，NSBlockOperation 还有一个方法：addExecutionBlock:(追加任务)，通过这个方法可以给 NSBlockOperation 添加多个执行 Block。额外操作中的任务 会开子线程并发执行任务(这里可能是子线程也可能是主线程执行) 注意下面的打印结果：1234567891011121314151617181920212223242526// 1.创建操作,封装任务NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"1----%@",[NSThread currentThread]);&#125;];NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"2----%@",[NSThread currentThread]);&#125;];NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"3----%@",[NSThread currentThread]);&#125;];// 2.追加任务[op3 addExecutionBlock:^&#123; NSLog(@"4----%@",[NSThread currentThread]);&#125;];[op3 addExecutionBlock:^&#123; NSLog(@"5----%@",[NSThread currentThread]);&#125;];[op3 addExecutionBlock:^&#123; NSLog(@"6----%@",[NSThread currentThread]);&#125;];// 3.启动[op1 start];[op2 start];[op3 start]; 打印输出:1234562016-02-13 16:13:15.690 多线程2.4[6890:173737] 1----&lt;NSThread: 0x60000006be40&gt;&#123;number = 1, name = main&#125;2016-02-13 16:13:15.691 多线程2.4[6890:173737] 2----&lt;NSThread: 0x60000006be40&gt;&#123;number = 1, name = main&#125;2016-02-13 16:13:15.692 多线程2.4[6890:173737] 3----&lt;NSThread: 0x60000006be40&gt;&#123;number = 1, name = main&#125;2016-02-13 16:13:15.692 多线程2.4[6890:174061] 4----&lt;NSThread: 0x600000079d00&gt;&#123;number = 3, name = (null)&#125;2016-02-13 16:13:15.692 多线程2.4[6890:173737] 6----&lt;NSThread: 0x60000006be40&gt;&#123;number = 1, name = main&#125;2016-02-13 16:13:15.692 多线程2.4[6890:174072] 5----&lt;NSThread: 0x600000079080&gt;&#123;number = 4, name = (null)&#125; 3.自定义子类继承NSOperation,实现内部相应的方法(重写main)1234567891011121314151617// LNOperation.m#import "LNOperation.h"@implementation LNOperation- (void)main &#123; NSLog(@"自定义NSOperation----%@",[NSThread currentThread]);&#125;// **********************我是分割线***************************//// 1.封装操作LNOperation *op1 = [[LNOperation alloc] init];LNOperation *op2 = [[LNOperation alloc] init];// 2.创建队列[op1 start];[op2 start]; 打印输出:122016-02-13 16:18:28.687 多线程2.4[7015:177012] 自定义NSOperation----&lt;NSThread: 0x60800007f780&gt;&#123;number = 1, name = main&#125;2016-02-13 16:18:28.688 多线程2.4[7015:177012] 自定义NSOperation----&lt;NSThread: 0x60800007f780&gt;&#123;number = 1, name = main&#125; 6.NSOperation结合NSOperationQueue使用NSOperationQueue 按类型来说共有两种类型：主队列、其他队列。只要添加到队列，会自动调用任务的 start 方法。1.主队列凡是添加到主队列中的任务（NSOperation），都会放到主线程中 串行执行。NSOperationQueue *queue1 = [NSOperationQueue mainQueue];2.其他队列（非主队列）添加到这种队列中的任务（NSOperation），就会自动放到子线程中 并发执行，同时具有：串行、并发功能。NSOperationQueue *queue = [[NSOperationQueue alloc] init]; 结合使用:1.添加任务到队列中 addOperation:12345678910111213141516171819202122- (void)addOperationQueue &#123; // 1.创建队列 //NSOperationQueue *queue = [NSOperationQueue mainQueue]; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.封装操作 NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task) object:nil]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@"op2--%@", [NSThread currentThread]); &#125; &#125;]; // 3.添加操作到队列 [queue addOperation:op1]; [queue addOperation:op2];&#125;- (void)task &#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@"op1--%@", [NSThread currentThread]); &#125;&#125; 使用非主队列打印输出:12342016-02-13 16:54:53.312 多线程2.4[7731:198138] op1--&lt;NSThread: 0x60800026f400&gt;&#123;number = 3, name = (null)&#125;2016-02-13 16:54:53.312 多线程2.4[7731:198134] op2--&lt;NSThread: 0x6000002662c0&gt;&#123;number = 4, name = (null)&#125;2016-02-13 16:54:53.313 多线程2.4[7731:198138] op1--&lt;NSThread: 0x60800026f400&gt;&#123;number = 3, name = (null)&#125;2016-02-13 16:54:53.313 多线程2.4[7731:198134] op2--&lt;NSThread: 0x6000002662c0&gt;&#123;number = 4, name = (null)&#125; 使用主队列打印输出:12342016-02-13 17:34:30.241 多线程2.4[8595:228001] op1--&lt;NSThread: 0x600000072340&gt;&#123;number = 1, name = main&#125;2016-02-13 17:34:30.241 多线程2.4[8595:228001] op1--&lt;NSThread: 0x600000072340&gt;&#123;number = 1, name = main&#125;2016-02-13 17:34:30.242 多线程2.4[8595:228001] op2--&lt;NSThread: 0x600000072340&gt;&#123;number = 1, name = main&#125;2016-02-13 17:34:30.242 多线程2.4[8595:228001] op2--&lt;NSThread: 0x600000072340&gt;&#123;number = 1, name = main&#125; 2.添加任务到队列中 addOperationWithBlock:,简易方法:12345678910111213NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 添加任务到队列中[queue addOperationWithBlock:^&#123; for (NSInteger i= 0; i &lt;2; i++) &#123; NSLog(@"op1--%@", [NSThread currentThread]); &#125;&#125;];[queue addOperationWithBlock:^&#123; for (NSInteger i= 0; i &lt;2; i++) &#123; NSLog(@"op2--%@", [NSThread currentThread]); &#125;&#125;]; 打印输出:12342016-02-13 17:28:12.586 多线程2.4[8446:222668] op1--&lt;NSThread: 0x600000262740&gt;&#123;number = 3, name = (null)&#125;2016-02-13 17:28:12.586 多线程2.4[8446:222667] op2--&lt;NSThread: 0x608000263d40&gt;&#123;number = 4, name = (null)&#125;2016-02-13 17:28:12.587 多线程2.4[8446:222668] op1--&lt;NSThread: 0x600000262740&gt;&#123;number = 3, name = (null)&#125;2016-02-13 17:28:12.587 多线程2.4[8446:222667] op2--&lt;NSThread: 0x608000263d40&gt;&#123;number = 4, name = (null)&#125; 7.非主队列控制串行和并行执行的关键NSOperationQueue创建的其他队列 同时具有串行、并发功能，上边我们演示了并发功能，那么下面讲讲串行功能，这里有个关键参数：maxConcurrentOperationCount 队列最大并发数(同一时间最多几个任务可以执行)误区:串行执行任务不等于只开一条线程(线程同步,要看任务的执行方式是顺序还是并发的) maxConcurrentOperationCount 描述 .&gt; 1 并发队列 = 1 串行队列 = 0 不会执行任务 = -1 特殊意义,最大值表示不受限制 123456789101112131415161718192021// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 2.设置队列最大并发数(同一时间最多几个任务可以执行)queue.maxConcurrentOperationCount = 1;// 串行// 3.封装操作NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"1---- %@",[NSThread currentThread]);&#125;];NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"2---- %@",[NSThread currentThread]);&#125;];NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"3---- %@",[NSThread currentThread]);&#125;];// 4.添加到队列[queue addOperation:op1];[queue addOperation:op2];[queue addOperation:op3]; 最大并发数 =1，打印输出:1232016-02-13 17:59:24.702 多线程2.4[9096:244592] 1---- &lt;NSThread: 0x600000071e80&gt;&#123;number = 3, name = (null)&#125;2016-02-13 17:59:24.703 多线程2.4[9096:244593] 2---- &lt;NSThread: 0x608000077080&gt;&#123;number = 4, name = (null)&#125;2016-02-13 17:59:24.703 多线程2.4[9096:244592] 3---- &lt;NSThread: 0x600000071e80&gt;&#123;number = 3, name = (null)&#125; 最大并发数 =2，打印输出:1232016-02-13 18:03:17.608 多线程2.4[9178:246935] 2---- &lt;NSThread: 0x600000267d80&gt;&#123;number = 4, name = (null)&#125;2016-02-13 18:03:17.608 多线程2.4[9178:246936] 1---- &lt;NSThread: 0x600000262280&gt;&#123;number = 3, name = (null)&#125;2016-02-13 18:03:17.612 多线程2.4[9178:246936] 3---- &lt;NSThread: 0x600000262280&gt;&#123;number = 3, name = (null)&#125; 8.添加操作依赖和操作监听NSOperation 有一个非常实用的功能，那就是 添加依赖addDependency:（也可以跨队列依赖），注意:这里不能相互依赖。只有所有依赖的对象都已经完成操作，当前NSOperation对象才会开始执行操作。需要先添加依赖关系,再将操作添加到队列中。另外，通过removeDependency方法来删除依赖对象。给操作任务 添加监听addExecutionBlock:，当任务完成后就会，走到这个Block块里面，具体怎么添加依赖和监听如下：12345678910111213141516171819202122232425262728293031323334- (void)addDependency &#123; // 1.创建队列 NSOperationQueue *queue1 = [[NSOperationQueue alloc] init]; NSOperationQueue *queue2 = [[NSOperationQueue alloc] init]; // 2.封装操作 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"1---- %@",[NSThread currentThread]); &#125;]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"2---- %@",[NSThread currentThread]); &#125;]; NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"3---- %@",[NSThread currentThread]); &#125;]; NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"4---- %@",[NSThread currentThread]); &#125;]; // 3.添加操作依赖,也可以跨队列依赖(注意：这里不能相互依赖) [op1 addDependency:op4]; [op4 addDependency:op3]; // 4.添加操作监听 [op2 addExecutionBlock:^&#123; NSLog(@"监听op2--%@",[NSThread currentThread]); &#125;]; // 5.添加到队列 [queue1 addOperation:op1]; [queue1 addOperation:op2]; [queue1 addOperation:op3]; [queue2 addOperation:op4];&#125; 打印输出:123452016-02-13 19:04:12.166 多线程2.4[10372:280459] 2---- &lt;NSThread: 0x60800007c440&gt;&#123;number = 3, name = (null)&#125;2016-02-13 19:04:12.166 多线程2.4[10372:280473] 监听op2-- &lt;NSThread: 0x60800007cbc0&gt;&#123;number = 5, name = (null)&#125;2016-02-13 19:04:12.166 多线程2.4[10372:280462] 3---- &lt;NSThread: 0x60000007aa40&gt;&#123;number = 4, name = (null)&#125;2016-02-13 19:04:12.168 多线程2.4[10372:280459] 4---- &lt;NSThread: 0x60800007c440&gt;&#123;number = 3, name = (null)&#125;2016-02-13 19:04:12.169 多线程2.4[10372:280473] 1---- &lt;NSThread: 0x60800007cbc0&gt;&#123;number = 5, name = (null)&#125; 9.NSOperation线程间通信12345678910111213141516// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 2.封装任务NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSURL *url = [NSURL URLWithString:@"http://s15.sinaimg.cn/bmiddle/4c0b78455061c1b7f1d0e"]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; self.imageView.image = image; NSLog(@"UI-- %@",[NSThread currentThread]); &#125;];&#125;]; // 3.添加操作到队列 [queue addOperation:op1]; 打印输出:12016-02-13 19:13:29.759 多线程2.4[10553:285311] UI-- &lt;NSThread: 0x60800006d2c0&gt;&#123;number = 1, name = main&#125; 10.管理操作：是操作队列的方法队列中的任务也是有状态：已经执行完成的、正在执行、等待执行 应用场景：提高用户体验第一，当用户操作时，取消一切跟用户当前操作无关的进程，提升流畅度。（开始滚动的时候 暂停操作、滑动结束的时候 恢复操作、接收到内存警告 取消所有操作）1.添加操作依赖2.管理操作：重点！是操作队列的方法 暂停/恢复 取消操作，(暂停和取消,不能暂停或取消正在执行状态的任务，且取消不可以恢复) 开启合适的线程数量！（最多不超过6条） 一般开发的时候，会将操作队列设置成一个全局的变量（属性） 方法：123456// 判断暂停状态,YES暂停 NO恢复@property (getter=isSuspended) BOOL suspended;// 取消(不可以恢复)// 该方法内部调用了所有操作的cancel方法- (void)cancelAllOperations; 好了，就到这里吧。当然，我讲的并不完整，可能有一些知识我并没有讲到，但作为常用方法，这些已经足够了。不过我在这里只是告诉你了一些方法的功能，只是怎么把他们用到合适的地方，就需要多多实践了，看我写的这么卖力，不打赏的话得点个喜欢也是极好的。 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 网络请求—「NSURLSession会话」]]></title>
    <url>%2FiOSNET%2FNSURLSession.html</url>
    <content type="text"><![CDATA[Write in the first 苹果在 iOS9 之后已经废弃了 NSURLConnection，所以在现在的实际开发中，除了大家常见的 AFN 框架，一般使用的是 iOS7 之后推出的 NSURLSession，作为一名【iOS 开发者】，如果你只知道 AFN 框架 来进行网络请求，那就 X x 了。 本篇文章主要从【NSURLSession 详解使用】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录: NSURLSession 介绍 NSURLSession 优势 NSURLSession 子类基本使用 NSURLSessionDownloadTask 大文件下载 NSURLSessionDataTask 断点下载 | 支持离线 URLSessionDataTask 断点下载效果 1. NSURLSession 介绍1234567891011关于taskNSURLSessionTask 是一个抽象类，是一个抽象类，本身不能使用，只能使用它的子类NSURLSessionTask 有两个子类1.NSURLSessionDataTask：可以用来处理一般的网络请求，如 GET | POST 请求DataTask子类 NSURLSessionUploadTask：用于处理上传请求的时候有优势2.NSURLSessionDownloadTask：主要用于处理下载请求，有很大的优势使用步骤1.使用NSURLSession创建task2.执行task [dataTask resume] Task的类型 2. NSURLSession 优势1234561.NSURLSession 支持 http2.0 协议2.在处理下载任务的时候可以直接把数据下载到磁盘3.支持后台下载|上传4.同一个 session 发送多个请求，只需要建立一次连接（复用了TCP）5.提供了全局的 session 并且可以统一配置，使用更加方便6.下载的时候是多线程异步处理，效率更高 3. NSURLSession 子类基本使用1.GET请求12345678910111213141516171819202122232425262728293031323334353637// 1.确定urlNSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/login?username=520it&amp;pwd=520it&amp;type=JSON"];// 2.创建请求对象NSURLRequest *request = [NSURLRequest requestWithURL:url];// 3.创建Session会话对象（可以获取单例对象）NSURLSession *session = [NSURLSession sharedSession];// 4.创建Task/** Request:请求对象 completionHandler 当请求完成之后调用 data:响应体信息 response:响应头信息 error:错误信息当请求失败的时候,error有值 */// 方法一：dataTaskWithRequest: completionHandler:NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; // 拿到响应头信息 NSHTTPURLResponse *res = (NSHTTPURLResponse *)response; // 6.解析数据 NSLog(@"%@\n%@",[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding],res.allHeaderFields);&#125;];-----------------------------------------// 方法二：dataTaskWithURL: completionHandler:// 注意:dataTaskWithURL 内部会自动的将请求路径作为参数创建一个请求对象NSURLSessionDataTask *dataTask = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;&#125;];// 5.执行Task[dataTask resume];//[dataTask cancel];// 取消任务//[dataTask suspend];// 暂停任务 2.POST请求12345678910111213141516171819202122232425// 1.确定urlNSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/login"];// 2.创建请求对象NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];// 3.创建Session会话对象（可以获取单例对象）NSURLSession *session = [NSURLSession sharedSession];// 设置 请求方法request.HTTPMethod = @"POST";// 设置 请求体request.HTTPBody = [@"username=520&amp;pwd=520&amp;type=JSON" dataUsingEncoding:NSUTF8StringEncoding];// 设置 请求超时//request.timeoutInterval = 10;// 设置 请求头User-Agent// 注意:key一定要一致(用于传递数据给后台)//[request setValue:@"ios 10.1" forHTTPHeaderField:@"User-Agent"];// 4.创建Task// 注意：如果要发送POST请求，那么请使用dataTaskWithRequest,设置一些请求属性NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; // 6.解析数据&#125;];// 5.执行Task[dataTask resume]; 3.设置代理发送请求1234567891011121314151617// 1.确定URLNSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/login?username=520it&amp;pwd=520it&amp;type=JSON"];// 2.创建请求对象NSURLRequest *request = [NSURLRequest requestWithURL:url];// 3.创建会话对象,设置代理/** Configuration:配置信息,用默认的即可 delegate:代理 delegateQueue:设置代理方法在哪个线程中执行 */NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];// 4.创建TaskNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request];// 5.执行Task[dataTask resume]; 遵守&lt;NSURLSessionDataDelegate&gt; 实现 代理方法123456789101112131415161718192021222324252627282930// 1.接收到服务器的时候/** session 会话对象 dataTask 请求任务 response 响应头信息 completionHandler 回调,传给系统 */- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler &#123; /** NSURLSessionResponseCancel = 0, 取消请求,默认 NSURLSessionResponseAllow = 1, 接收数据 NSURLSessionResponseBecomeDownload = 2, 变成下载任务 NSURLSessionResponseBecomeStream 变成下载任务 9.0之后可以用 */ completionHandler(NSURLSessionResponseAllow);&#125;// 2.接收到服务器返回的数据,会调用多次（data可能是部分）- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123; // 拼接数据 [self.fileData appendData:data];&#125;// 3.请求完成 或 失败的时候调用- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; if (error) &#123; return; &#125; else &#123; // 解析数据 NSLog(@&quot;%@&quot;,[[NSString alloc] initWithData:self.fileData encoding:NSUTF8StringEncoding]); &#125;&#125; 4. 设置代理之后的强引用问题1234567问题：`NSURLSession` 对象在使用的时候，如果设置了代理， 那么 session 会对代理对象保持一个强引用，在不用的时候应该主动进行释放解决：在`dealloc`方法中进行释放， 可以通过调用 `finishTasksAndInvalidate`或`resetWithCompletionHandler` 来释放对代理对象的强引用[self.session finishTasksAndInvalidate]; 4. NSURLSessionDownloadTask 大文件下载1.DownloadTask:Block方式12345678910111213141516171819202122232425262728// 1.确定URLNSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/resources/images/minion_03.png"];// 2.创建请求对象NSURLRequest *request = [NSURLRequest requestWithURL:url];// 3.创建会话对象NSURLSession *session = [NSURLSession sharedSession];// 4.创建Task/** downloadTaskWithRequest: Block方式 注意:该方法内部已经实现了边接受数据边写入沙盒(tmp临时文件目录)的操作, 需要剪切文件,把它移动到我们指定的位置。 */NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:request completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; // 6.数据解析 NSLog(@"%@---%@",location,[NSThread currentThread]); // 7.拼接文件全路径 // 拼接文件后的本地名称:FileName @"123.png"或 [url lastPathComponent] 获取URL最后一个字节命名 NSString *fullPath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:[url lastPathComponent]]; // 8.剪切文件 [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:fullPath] error:nil]; NSLog(@"%@",fullPath);&#125;];// 5.执行Task[downloadTask resume]; 注DownloadTask:Block方式优点:不需要担心内存(边接受数据边写入沙盒(tmp临时文件目录)的操作)缺点:无法监听文件下载进度 2.DownloadTask:Dlegate方式遵守&lt;NSURLSessionDownloadDelegate&gt;协议，实现代理方法。可以在didWriteData(写数据)代理方法，监听下载进度12345678NSURL *url = [NSURL URLWithString:@"[http://120.25.226.186:32812/resources/images/minion_03.png"];](http://120.25.226.186:32812/resources/images/minion_03.png%22];)// Configuration:配置信息,用默认的即可NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:[NSURLRequest requestWithURL:url]];[downloadTask resume];// 执行Task 注DownloadTask:Dlegate方式，解决了无法监听下载进度的问题 5.DownloadTask断点下载1234567891011121314151617181920212223242526272829303132333435// 开始下载- (IBAction)starBtnClick:(id)sender &#123; NSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/resources/videos/minion_01.mp4"]; self.session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]]; self.downloadTask = [self.session downloadTaskWithRequest:[NSURLRequest requestWithURL:url]]; [self.downloadTask resume];&#125;// 暂停下载(是可以恢复的)- (IBAction)suspendBtnClick:(id)sender &#123; NSLog(@"+++++++++++++++++++暂停"); [self.downloadTask suspend];&#125;// 取消下载(注意)// cancel:取消是不能恢复// cancelByProducingResumeData:是可以恢复- (IBAction)cancelBtnClick:(id)sender &#123; NSLog(@"+++++++++++++++++++取消"); //[self.downloadTask cancel]; [self.downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) &#123; self.resumData = resumeData; &#125;];&#125;// 继续下载- (IBAction)goOnBtnClick:(id)sender &#123; NSLog(@"+++++++++++++++++++继续下载"); if (self.resumData) &#123; // 恢复下载数据(文件保存信息,保存到那个字节) != 文件数据 self.downloadTask = [self.session downloadTaskWithResumeData:self.resumData]; &#125; [self.downloadTask resume];&#125; NSURLSessionDownloadDelegate代理方法123456789101112131415161718192021222324252627282930313233343536373839404142434445/** 1.写数据(监听下载进度) session 会话对象 downloadTask 下载任务 bytesWritten 本次写入的数据大小 totalBytesWritten 下载的数据总大小 totalBytesExpectedToWrite 文件的总大小 */-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite &#123; // 获得文件的下载进度 NSLog(@"%f",1.0 * totalBytesWritten/totalBytesExpectedToWrite); self.proessView.progress = 1.0 * totalBytesWritten/totalBytesExpectedToWrite;&#125;/** 2.当恢复下载的时候调用方法 fileOffset 从什么地方下载 expectedTotalBytes 文件的总大小 */-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes &#123; NSLog(@"恢复下载--%s",__func__);&#125;/** 3.当下载完成的时候调用 location 文件的临时存储路径 */-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location &#123; NSLog(@"文件的临时存储路径--%@",location); // 1.拼接文件全路径 // downloadTask.response.suggestedFilename 文件名称 NSString *fullPath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename]; // 2.剪切文件 [[NSFileManager defaultManager]moveItemAtURL:location toURL:[NSURL fileURLWithPath:fullPath] error:nil]; NSLog(@"%@",fullPath);&#125;/** 4.请求失败 */-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; NSLog(@"didCompleteWithError");&#125; 注123局限性:1.如果用户点击暂停之后退出程序，那么需要把恢复下载的数据写一份到沙盒，代码复杂度高2.如果用户在下载中途未保存恢复下载数据即退出程序，则不具备可操作性 6. NSURLSessionDataTask 断点下载 | 支持离线 NSURLSessionDataTask 实现大文件1.开始下载、暂停下载、取消下载、恢复下载2.支持后台下载|上传（离线 断点）3.在处理下载任务的时候可以直接把数据下载到磁盘4.下载的时候 是子线程异步处理，效率更高 属性定义:123456789101112131415@interface DataTaskViewController ()&lt;NSURLSessionDataDelegate&gt;@property (weak, nonatomic) IBOutlet UIProgressView *proessView;/** 创建文件句柄 */@property (nonatomic, strong) NSFileHandle *handle;/** 文件的总大小 */@property (nonatomic, assign) NSInteger totalSize;/** 当前下载数据大小 */@property (nonatomic, assign) NSInteger currentSize;/** 获得文件全路径 */@property (nonatomic, strong) NSString *fullPath;/** 创建Task */@property (nonatomic, strong) NSURLSessionDataTask *dataTask;/** 创建会话对象 */@property (nonatomic, strong) NSURLSession *session; 懒加载（方法的独立与抽取）:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849-(NSString *)fullPath &#123; if (!_fullPath) &#123; // 获得文件全路径 // 拼接文件后的本地名称 FileName @"123.mp4" 或者 [url lastPathComponent] 获取URL最后一个字节命名 _fullPath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:FileName]; &#125; return _fullPath;&#125;-(NSURLSession *)session &#123; if (!_session) &#123; // 创建会话对象,设置代理 /* Configuration:配置信息 [NSURLSessionConfiguration defaultSessionConfiguration] delegate:代理 delegateQueue:设置代理方法在哪个线程中调用 */ _session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]]; &#125; return _session;&#125;-(NSURLSessionDataTask *)dataTask &#123; if (!_dataTask) &#123; // 1.确定url NSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/resources/videos/minion_01.mp4"]; // 2.创建请求对象 NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; // 3 设置请求头信息,告诉服务器请求那一部分数据 self.currentSize = [self getFileSize]; NSString *range = [NSString stringWithFormat:@"bytes=%zd-",self.currentSize]; [request setValue:range forHTTPHeaderField:@"Range"]; // 4.创建Task _dataTask = [self.session dataTaskWithRequest:request]; &#125; return _dataTask;&#125;-(NSInteger)getFileSize &#123; // 获得指定文件路径对应文件的数据大小 NSDictionary *fileInfoDict = [[NSFileManager defaultManager]attributesOfItemAtPath:self.fullPath error:nil]; NSLog(@"%@",fileInfoDict); NSInteger currentSize = [fileInfoDict[@"NSFileSize"] integerValue]; return currentSize;&#125; NSURLSessionDataDelegate 代理方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#pragma mark - NSURLSessionDataDelegate// 1.接收到服务器的响应 它默认会取消该请求/** session 会话对象 dataTask 请求任务 response 响应头信息 completionHandler 回调 传给系统 expectedContentLength 本次请求的数据大小 */-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler &#123; // 获得文件的总大小 self.totalSize = response.expectedContentLength + self.currentSize; if (self.currentSize == 0) &#123; // 创建空的文件 [[NSFileManager defaultManager]createFileAtPath:self.fullPath contents:nil attributes:nil]; &#125; // 创建文件句柄 self.handle = [NSFileHandle fileHandleForWritingAtPath:self.fullPath]; // 移动指针(每接收到服务器的响应，就移动指针指向文件末尾) [self.handle seekToEndOfFile]; /* NSURLSessionResponseCancel = 0,取消 默认 NSURLSessionResponseAllow = 1,接收 NSURLSessionResponseBecomeDownload = 2,变成下载任务 NSURLSessionResponseBecomeStream 变成流 */ completionHandler(NSURLSessionResponseAllow);&#125;// 2.接收到服务器返回的数据 调用多次/** session 会话对象 dataTask 请求任务 data 本次下载的数据 */-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123; // 写入数据到文件 [self.handle writeData:data]; // 计算文件的下载进度 self.currentSize += data.length; NSLog(@"%f",1.0 * self.currentSize / self.totalSize); self.proessView.progress = 1.0 * self.currentSize / self.totalSize;&#125;// 3.请求完成 或者 失败的时候调用/** session 会话对象 dataTask 请求任务 error 错误信息 */-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; // 关闭文件句柄（创建句柄,要记得在完成方法里 关闭句柄置空） [self.handle closeFile]; self.handle = nil; NSLog(@"%@",self.fullPath);&#125;// 4.清理工作/** NSURLSession,如果设置代理的话会有一个强引用不会被释放掉,当不用Session的时候， 一定要调用finishTasksAndInvalidate 和 invalidateAndCancel 释放掉. */-(void)dealloc &#123; //finishTasksAndInvalidate [self.session invalidateAndCancel];&#125; 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 网络请求—「NSURLConnection连接」]]></title>
    <url>%2FiOSNET%2FNSURLConnection.html</url>
    <content type="text"><![CDATA[本篇文章主要从【NSURLConnection 详解使用】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： 文件下载分类 使用步骤 NSData(小文件下载) NSURLConnection使用1.NSURLConnection异步GET请求2.NSURLConnection代理GET请求3.NSURLConnection相关代理方法4.NSURLConnectionPOST请求 http通信过程 GET 和 POST 区别 大文件断点下载 文件上传步骤 多线程下载文件思路 1.文件下载分类 按照开发中实际需求，如果按下载的 [文件大小] 划分，可以分为：小文件下载、大文件下载。因为小文件下载基本不需要等待，可以使用返回整个文件的下载方式来进行文件下载，比如说图片。但是大文件下载需要考虑很多情况来改善用户体验，比如说：下载进度的显示、暂停下载以及断点续传、离线断点续传，还有下载时占用手机内存情况等等。 按照开发中请求方式，如果按开发 [实现方案] 划分，可以分为：NSData、NSURLConnection（iOS9.0之后舍弃）、NSURLSession（推荐），以及使用第三方框架AFNetworking 方式下载文件。 2.使用步骤NSURLConnection发送请求步骤： 创建一个NSURL对象，设置请求路径 传入NSURL创建一个NSURLRequest对象，设置请求头和请求体 使用NSURLConnection发送请求 NSURLConnection发送请求方法：1234567891.同步请求+ (NSData *)sendSynchronousRequest:(NSURLRequest *)request returningResponse:(NSURLResponse **)response error:(NSError **)error;2.异步请求：根据对服务器返回数据的处理方式的不同block回调：+ (void)sendAsynchronousRequest:(NSURLRequest*) request queue:(NSOperationQueue*) queue completionHandler:(void (^)(NSURLResponse* response, NSData* data, NSError* connectionError)) handler;delegate异步：设置代理，通过代理方法 3.NSData(小文件下载)12345NSURL *url = [NSURL URLWithString:@"[http://pic73.nipic.com/file/20150724/18576408_175304314596_2.jpg"];](http://pic73.nipic.com/file/20150724/18576408_175304314596_2.jpg%22];)NSData *data = [NSData dataWithContentsOfURL:url];UIImage *image = [UIImage imageWithData:data];self.imageView.image = image;刷新UI要放在主线程 4.NSURLConnection使用NSURLConnection异步GET请求123456789101112131415161718192021222324// 1.确定请求路径NSURL *url = [NSURL URLWithString:@"[http://120.25.226.186:32812/login?username=520it&amp;pwd=520it&amp;type=JSON"];](http://120.25.226.186:32812/login?username=520it&amp;pwd=520it&amp;type=JSON%22];)// 2.创建请求对象NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url];// 3.发送异步请求/* Request:请求对象 queue:队列（决定代码块completionHandler的在那个线程调用） completionHandler:当请求完成(成功|失败)的时候回调 response:响应头 data:响应体 connectionError:错误信息 */[NSURLConnection sendAsynchronousRequest:request queue:[[NSOperationQueue alloc]init] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; // 4.解析数据 NSLog(@"%@",[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]); NSLog(@"%@",[NSThread currentThread]); // 转换并打印响应头信息 NSHTTPURLResponse *r = (NSHTTPURLResponse *)response; NSLog(@"--%zd---%@--",r.statusCode,r.allHeaderFields);&#125;]; NSURLConnection代理GET请求12345678910// 1.确定urlNSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/resources/videos/minion_11.mp4"];// 2.异步(自动)发送GET请求，并实现相应的代理方法// 该方法iOS9.0之后废除了（推荐使用NSURLSession）。NSURLConnection * connect = [NSURLConnection connectionWithRequest:[NSURLRequest requestWithURL:url] delegate:self];// 设置代理方法的执行队列// 说明：默认情况下，代理方法会在主线程中进行调用（为了方便开发者拿到数据后处理一些刷新UI的操作不需要考虑到线程间通信）[connect setDelegateQueue:[[NSOperationQueue alloc]init]]; NSURLConnection相关代理方法1234567891011121314151617#pragma mark - NSURLConnectionDataDelegate// 1.当 接收到服务器响应 的时候调用-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123;&#125;;// 2.接收到服务器返回数据 的时候调用,调用多次（返回的NSData二进制数据(可能是片段)）-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123; // 拼接数据 [self.resultData appendData:data];&#125;// 3.请求完成 的时候调用（通常在该方法中解析服务器返回的数据）-(void)connectionDidFinishLoading:(NSURLConnection *)connection &#123; NSLog(@"%@",[[NSString alloc]initWithData:self.resultData encoding:NSUTF8StringEncoding]);&#125;// 4.当请求失败 的时候调用-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123;&#125;; NSURLConnectionPOST请求12345678910111213141516171819202122232425// 1.确定请求路径NSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/login"];// 2.创建可变请求对象NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];// 3.设置 NSMutableURLRequest 属性// 请求方法（POST必须大写）request.HTTPMethod = @"POST";// 请求超时request.timeoutInterval = 10;// 请求头User-Agent（注意:key一定要一致(用于传递数据给后台)）[request setValue:@"ios 10.1" forHTTPHeaderField:@"User-Agent"];// 请求体信息,字符串---&gt;NSDatarequest.HTTPBody = [@"username=520it&amp;pwd=123&amp;type=JSON" dataUsingEncoding:NSUTF8StringEncoding];// 4.发送请求[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; if (connectionError) &#123; NSLog(@"--请求失败--"); &#125; else &#123; // 5.解析数据 NSLog(@"%@",[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]); &#125;&#125;]; 5.http通信过程1234567请求：请求头(NSURLRequest默认包含)+请求体(GET没有)响应：响应头(真实类型-&gt;NSHTTPURLResponse)+响应体(要解析的数据)GET：http://120.25.226.186:32812/login?username=123&amp;pwd=456&amp;type=JSON协议+主机地址+接口名称+?+参数1&amp;参数2&amp;参数3POST：http://120.25.226.186:32812/login协议+主机地址+接口名称 6.GET 和 POST 区别123456781.get请求和post请求都可以用于做获取数据请求2.在请求数据安全方面post请求比get请求安全 1).get是以明文的方式向服务器发送请求 2).post是包装到请求体body中后，在向服务器发送请求 3).get请求的参数全部暴露在接口中，一般叫做明文请求或者傻瓜式请求，post请求的参数一般是以字典的方式进行拼接，相对于get比较安全3.get请求的URL在使用过程中，会限制长度，因此长度非常长的请求建议用post请求4.对文件大小的请求：get不允许向服务器上传文件(图片，pdf，音视频)5.如果从服务器获取数据，或者查询数据，使用get请求;如果上传数据到服务器或者修改服务器上传数据使用post请求 7.大文件断点下载12341.实现思路在下载文件的时候不再是整块的从头开始下载，而是看当前文件已经下载到哪个地方，然后从该地方接着往后面下载。2.解决方案（通过设置请求头中的Range告诉服务器值请求一部分数据 来实现）边下载变写入沙盒，采用追加的方式。(这里是一个线程) 8.文件上传步骤123456789101.确定请求路径2.根据URL创建一个可变的请求对象3.设置请求对象，修改请求方式为POST4.设置请求头，告诉服务器我们将要上传文件（Content-Type）5.设置请求体（在请求体中按照既定的格式拼接要上传的文件参数和非文件参数等数据）1).拼接文件参数2).拼接非文件参数3).添加结尾标记6.使用NSURLConnection sendAsync发送异步请求上传文件7.解析服务器返回的数据 9.多线程下载文件思路12345678910需求:优化下载解决:开启多个线程下载注意:1.目前是多个线程同时工作且异步执行的，这时就不能采用直接追加的方式了(会出现数据错乱的现象)1.开启多条线程，每条线程都只下载文件的一部分（采用:通过设置请求头中的Range告诉服务器值请求一部分数据 来实现）2.创建一个和需要下载文件大小一致的文件，判断当前是那个线程，根据当前的线程来判断下载的数据应该写入到文件中的哪个位置。（假设开5条线程来下载10M的文件，那么线程1下载0-2M，线程2下载2-4M一次类推，当接收到服务器返回的数据之后应该先判断当前线程是哪个线程，假如当前线程是线程2，那么在写数据的时候就从文件的2M位置开始写入）3.代码相关：使用NSFileHandle这个类的seekToFileOfSet方法，来向文件中特定的位置写入数据。4.技术相关1).每个线程通过设置请求头下载文件中的某一个部分2).通过NSFileHandle向文件中的指定位置写数据 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage框架学习]]></title>
    <url>%2FSourceAnnotations%2FSDLibrary.html</url>
    <content type="text"><![CDATA[Write in the first SDWebImage 是我们经常使用的一个异步图片加载库，在项目中使用SDWebImage来管理图片加载相关操作可以极大地提高开发效率，让我们更加专注于业务逻辑实现。像这种经常用又比较重要的内容，我觉得要做到初步理解，然后梳理总结常用方法，到最后夯实基础、活学活用。为此，自己本着好好学习，了解权威的目的，决定解读 SDWebImage框架。 本篇文章主要从【SD 框架结构】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： SDWebImage的概论 SDWebImage的内部结构 SDWebImage的实现原理 SDWebImage的工作流程 SDWebImage框架基本使用 SDWebImage框架内部细节 1. SDWebImage的概论 提供了一个UIImageView的category用来加载网络图片并且对网络图片的缓存进行管理 采用异步方式来下载网络图片 采用异步方式，使用memory＋disk来缓存网络图片，自动管理缓存。 支持GIF动画 支持WebP格式 同一个URL的网络图片不会被重复下载 失效的URL不会被无限重试 耗时操作都在子线程，确保不会阻塞主线程 使用GCD和ARC 支持Arm64 2. SDWebImage的内部结构 3. SDWebImage的实现原理SDWebImage 是由一个 SDImageCache(一个处理缓存的类) 和 SDWebImageDownloader(负责下载网络图片) ，而 SDWebImageManager则是管理者将前两者结合起来完成整个工作流程。 通过对UIImageView的类别扩展来实现异步加载替换图片的工作。主要用到的对象： 1.UIImageView (WebCache)类别，入口封装，实现读取图片完成后的回调 2.SDWebImageManager，对图片进行管理的中转站，记录那些图片正在读取。向下层读取Cache（调用SDImageCache），或者向网络读取对象（调用SDWebImageDownloader）。实现SDImageCache和SDWebImageDownloader的回调。 3.SDImageCache，根据URL的MD5摘要对图片进行存储和读取（实现存在内存中或者存在硬盘上两种实现）实现图片和内存清理工作。 4.SDWebImageDownloader，根据URL向网络读取数据（实现部分读取和全部读取后再通知回调两种方式 4. SDWebImage的工作流程 SDWebImage是一个成熟而且比较庞大的框架，但是在使用过程中并不需要太多的接口,这算是一种代码封装程度的体现。这里就介绍比较常用的几个接口。123456789101112131415161718192021222324252627282930313233343536梳理SDWebImage的 工作流程1.入口方法：调用 UIImageView+WebCache 的分类方法self.imageView： sd_setImageWithURL: placeholderImage: options: progress: completed:这个方法，如果传入的下载策略不是SDWebImageDelayPlaceholder 延迟显示占位图片，默认情况下先显示 placeholderImage ，同时由SDWebImageManager根据 URL 来在本地查找图片。2.进入方法：初始化 SDWebImageManager 管理器并调用：SDWebImageManager：downloadImageWithURL: options: progress: completed:1). SDWebImageManager 是将UIImageView+WebCache同SDImageCache 链接起来的类，图片缓存是在内存缓存一份,在磁盘缓存一份.3.SDImageCache：queryDiskCacheForKey: done:该方法查找 cacheKey(URL对应的缓存KEY) 对应下载图片的缓存情况，先检查是否有内存缓存4.检查该`cacheKey`对应的内存缓存，如果存在内存缓存，则直接返回，并把图片和存储方式（内存缓存）通过block块以参数的形式传递。前端来显示图片。5.如果缓存对应的key为空，那么创建一个操作NSOperation 添加到串行队列，从磁盘查找图片是否已被下载缓存。6.检查该 cacheKey 在硬盘缓存目录下尝试读取图片文件，这里回调doneBlock 结果，要在主线程中回调。7.如果存在磁盘缓存，且应该把该图片保存一份到内存缓存中（则先计算该图片的cost(成本)，如果空闲内存过小，会先清空内存缓存）。然后并把图片和存储方式（磁盘缓存）通过block块以参数的形式传递，展示图片。8.如果从硬盘缓存目录没有读取到图片,说明所有缓存都不存在该图片(无缓存)，需要下载图片。9.使用异步下载器下载图片：初始化 SDWebImageDownloader 并创建新的图片下载任务，得到一的 SDWebImageOperation 对象。SDWebImageDownloader：downloadImageWithURL: options: progress: completed: 图像下载完成或者出现错误时会通知代理10.核心方法：下载图片的操作把 SDWebImageOperation 对象添加到 NSOperationQueue 队列中开始异步下载，会调用 start 方法：SDWebImageDownloaderOperation ：在 start 方法中处理图片下载操作创建 NSURLConnection链接对象发送请求，并设置代理 5. SDWebImage框架基本使用UIImageView+WebCache.h 下载图片12345678910111213141516171819202122232425262728293031323334353637383940//下载图片的核心方法/* * 下载图片且需要获取下载进度(内存缓存&amp;磁盘缓存) * 根据图片的url下载图片并设置到ImageView上面去，异步下载并缓存 * * @param url 图片的URL地址 * @param options 图片下载选项（策略）,参考SDWebImageOptions的枚举值 * @param progressBlock 下载进度回调 * receivedSize 已经下载的数据大小 * expectedSize 要下载图片的总大小 * @param completedBlock 操作成功回调回调,该回调没有返回值 * Image：请求的 UIImage，如果出现错误，image参数是nil * error：如果图片下载成功则error为nil,否则error有值 * @param cacheType：图片缓存类型（内存缓存|沙盒缓存|直接下载）,SDImageCacheType枚举 * SDImageCacheTypeNone：从网络下载 * SDImageCacheTypeDisk：从本地缓存加载 * SDImageCacheTypeMemory：从内存缓存加载 * @param imageURL：图片的URL地址 */- (void)download1 &#123; [self.imageView sd_setImageWithURL:[NSURL URLWithString:@"http://img4.duitang.com/uploads/blog/201310/18/20131018213446_smUw4.thumb.600_0.jpeg"] placeholderImage:[UIImage imageNamed:@"placeholder"] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; NSLog(@"%f",1.0 * receivedSize / expectedSize); &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123; self.imageView.image = image; NSLog(@"download3--%@",[NSThread currentThread]); switch (cacheType) &#123; case SDImageCacheTypeNone: NSLog(@"网络下载"); break; case SDImageCacheTypeDisk: NSLog(@"使用磁盘缓存"); break; case SDImageCacheTypeMemory: NSLog(@"使用内存缓存"); break; default: break; &#125; &#125;];&#125; SDWebImageManager 管理者123456789101112131415161718192021222324252627282930313233/* * 只需要简单获得一张图片,不设置（内存缓存&amp;磁盘缓存） * 如果URL对应的图像在缓存中不存在，那么就下载指定的图片，否则返回缓存的图像 * * @param finished： * 1.如果图像下载完成则为YES * 2.如果没有使用 SDWebImageDownloaderProgressiveDownload，最后一个参数一直是 YES * 3.如果使用了 SDWebImageDownloaderProgressiveDownload 选项，此 block 会被重复调用 * 1)下载完成前，image 参数是部分图像，finished 参数是 NO * 2)最后一次被调用时，image 参数是完整图像，而 finished 参数是 YES * 3)如果出现错误，那么finished 参数也是 YES */- (void)download2 &#123; [[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:@"http://img4.duitang.com/uploads/blog/201310/18/20131018213446_smUw4.thumb.600_0.jpeg"] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; NSLog(@"%f",1.0 * receivedSize / expectedSize); &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; self.imageView.image = image; NSLog(@"download2--%@",[NSThread currentThread]); switch (cacheType) &#123; case SDImageCacheTypeNone: NSLog(@"网络下载"); break; case SDImageCacheTypeDisk: NSLog(@"使用磁盘缓存"); break; case SDImageCacheTypeMemory: NSLog(@"使用内存缓存"); break; default: break; &#125; &#125;];&#125; SDWebImageDownloader 工具类(文件下载)12345678910111213141516171819// 下载图片的核心方法/* * 不需要任何的缓存处理(没有做任何缓存处理) * 使用给定的 URL 创建 SDWebImageDownloader 异步下载器实例 */- (void)download3 &#123; [[SDWebImageDownloader sharedDownloader] downloadImageWithURL:[NSURL URLWithString:@"http://img4.duitang.com/uploads/blog/201310/18/20131018213446_smUw4.thumb.600_0.jpeg"] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; NSLog(@"%f",1.0 * receivedSize / expectedSize); &#125; completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123; /** 注意:completed完成后这里是在子线程中执行的 */ // 线程间通信(回到主线程刷新UI) [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; self.imageView.image = image; NSLog(@"download3--%@",[NSThread currentThread]); &#125;]; &#125;];&#125; 6. SDWebImage框架内部细节1.SDImageCache是怎么做数据管理的? SDImageCache分两个部分，一个是内存层面的，一个是磁盘层面的。内存层面的相当是个缓存器，以Key-Value的形式存储图片。当内存不够的时候会清除所有缓存图片。用搜索文件系统的方式做管理，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。当SDWebImageManager向SDImageCache要资源时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从磁盘读取出来，将图片对象放到内存层面做备份，再返回调用层 2.系统级内存警告如何处理（面试）?123456789// 1.清空缓存// clearDisk 清除磁盘缓存,直接删除然后重新创建(所有缓存目录中的文件全部删除，再创建一个同名空目录)// cleanDisk 清除过期的磁盘缓存,计算当前缓存的大小,和设置的最大缓存数量比较, 如果超出那么会继续删除(按照文件的创建的先后顺序)，直到小于最大缓存数量 过期是 maxCacheAge =7天[[SDWebImageManager sharedManager].imageCache cleanDisk]; // 2.取消当前所有的操作[[SDWebImageManager sharedManager] cancelAll]; 3.该框架内部对内存警告的处理方式?内部通过监听通知的方式清理缓存 1.监听到UIApplicationDidReceiveMemoryWarningNotification接收到内存警告的通知后，调用 clearMemory 方法,清除内存缓存 2.当监听到UIApplicationWillTerminateNotification接收到应用程序将要终止通知，调用 cleanDisk 方法,清理过期(默认大于一周)的磁盘缓存 3.当监听到UIApplicationDidEnterBackgroundNotification接收到应用程序进入后台通知，调用 backgroundCleanDisk 方法,清理过期磁盘缓存 补充：内存缓存: 使用NSCahce对象实现，最大内存缓存值以像素为单位磁盘缓存: 使用 NSFileManager 存储在 Cache 目录中，最大磁盘缓存是以字节为单位，最大磁盘缓存的时间默认为1周 4.最大并发数量1maxConcurrentOperationCount = 6 5.缓存文件的保存名称如何处理?SDImageCache，拿到图片的URL路径,对该路径进行MD5加密对图片进行存储和读取。 6.该框架进行缓存处理的方式?可变字典—&gt;NSCache 7.如何判断图片的类型?12345678910111213141516在判断图片类型的时候，只匹配第一个字节#import "NSData+ImageContentType.h"// 判断图片类型拿到文件的二进制数据，取出第一个字节和switch里的分支比较来判断PNG：压缩比没有JPG高，但是无损压缩，解压缩性能高，苹果推荐的图像格式！JPG：压缩比最高的一种图片格式，有损压缩！最多使用的场景，照相机！解压缩的性能不好！GIF：序列桢动图，特点：只支持256种颜色！最流行的时候在1998～1999，有专利的！SDWebImage缓存图片的名称是用URL的md5加密后生成的32位字符串作为文件名的利用通知中心观察，能够保证缓存文件的大小始终在控制范围之内！``` 示例：```objc// 5.判断图片类型NSData *imageData = [NSData dataWithContentsOfFile:@"/Users/sunhui/Desktop/Snip20170209_1.png"];NSString *typeStr = [NSData sd_contentTypeForImageData:imageData];NSLog(@"%@",typeStr);// image/png 8.播放Gif图片?1234#import "UIImage+GIF.h"// 播放Gif图片UIImage *image = [UIImage sd_animatedGIFNamed:@"imageGif"];self.imageView.image = image; 9.队列中任务的处理方式?FIFO,下载任务的执行方式：默认为先进先出 10.请求超时的时间?1downloadTimeout 默认：15秒 PS.最后分享一下学习多线程自定义NSOperation下载图片思路： 文字解析: 1.根据图片的url先去检查images(内存缓存)中该图片是否存在，如果存在就直接显示到cell上；否则去检查磁盘缓存(沙盒)。 2.如果有磁盘缓存(沙盒)，加载沙盒中对应的图片显示到cell上，再保存一份到内存缓存；否则先显示占位图片，再检查operations(操作缓存)中该图片是否正在下载，如果是 就等待下载；否则创建下载operations操作任务,保存到操作缓存中去下载。 3.下载完成后(需要主动刷新显示(采用局部刷新))，将操作从操作缓存中移除，将图片在内存缓存(先) 和 沙盒(后)中各保存一份。 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIViewApple译文]]></title>
    <url>%2FAppleTranslation%2FUIViewApple.html</url>
    <content type="text"><![CDATA[📌 导语在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。  首先附上官方原文地址 API Reference - UIView Class Relationships Inherits From 继承自: UIResponder : NSObject Conforms To 遵守: UICoordinateSpace，UIDynamicItem，UIFocusItem，UITraitEnvironment，CALayerDelegate，NSCoding，UIAppearance，UIAppearanceContainer Framework SDKs iOS 2.0+ Class📌 UIView The UIView class defines a rectangular area on the screen and the interfaces for managing the content in that area. UIView 类在屏幕和界面上定义了一块矩形区域，用来管理那块区域的内容。 📌 Overview At runtime, a view object handles the rendering of any content in its area and also handles any interactions with that content. The UIView class itself provides basic behavior for filling its rectangular area with a background color. More sophisticated content can be presented by subclassing UIView and implementing the necessary drawing and event-handling code yourself. The UIKit framework also includes a set of standard subclasses that range from simple buttons to complex tables and can be used as-is. For example, a UILabel object draws a text string and a UIImageView object draws an image. 在运行时，一个View对象处理它所在区域的内容渲染和交互。UIView类会使用背景颜色填充所在的矩形区域。更复杂的内容可以用UIView的子类来呈现，你自己来实现必要的绘画和事件处理代码。UIKit框架同时提供了一些标准子类，从简单的按钮到复杂的表格，你可以直接使用。如，UILabel 对象画文本字符串，UIImageView 对象画图像。 🏷Because view objects are the main way your application interacts with the user, they have a number of responsibilities. Here are just a few: Drawing and animation Views draw content in their rectangular area using technologies such as UIKit, Core Graphics, and OpenGL ES. Some view Declared property can be animated to new values. Layout and subview management A view may contain zero or more subviews. Each view defines its own default resizing behavior in relation to its parent view. A view can define the size and position of its subviews as needed. Event handling A view is a responder and can handle touch events and other events defined by the UIResponder class. Views can use the addGestureRecognizer: method to install gesture recognizers to handle common gestures. 因为View对象是应用与用户交互的主要途径，他们有一系列的职责。以下列出一些: 绘画和动画: View在他们的矩形区域使用UIKit，Core Graphics和OpenGL ES之类的技术绘画。 一些视图属性可以动画到新的值。 布局和子 View 管理 一个View可以包含0个或多个子View。 每个View都定义了相对父View大小改变的默认行为。 如有需要，一个View可以定义子View的大小和位置。 事件处理 View是一个响应者，可以处理 UIResponder 类定义的触摸和其他事件。 View可以使用 addGestureRecognizer 方法安装手势识别器来处理常用手势。 🏷Views can embed other views and create sophisticated visual hierarchies. This creates a parent-child relationship between the view being embedded (known as the subview) and the parent view doing the embedding (known as the superview). Normally, a subview’s visible area is not clipped to the bounds of its superview, but in iOS you can use the clipsToBounds property to alter that behavior. A parent view may contain any number of subviews but each subview has only one superview, which is responsible for positioning its subviews appropriately. View可以内嵌到其他View，创建复杂的可视层级。这会在嵌入的View(子View)和被嵌入的View(父View)间创建父子关系。正常情况下，子View的可视区域不会被父View的边界剪辑，但在iOS里你可以使用 clipsToBounds 属性来修改这个行为。一个父View可能有多个子View,但一个子View只有一个父View，它负责确定子View的位置。 🏷The geometry of a view is defined by its frame , bounds , and center properties. The frame defines the origin and dimensions of the view in the coordinate system of its superview and is commonly used during layout to adjust the size or position of the view. The center property can be used to adjust the position of the view without changing its size. The bounds defines the internal dimensions of the view as it sees them and is used almost exclusively in custom drawing code. The size portion of the frame and bounds rectangles are coupled together so that changing the size of either rectangle updates the size of both. For detailed information about how to use the UIView class, see View Programming Guide for iOS . View的几何结构是通过它的框架(frame)，边界(bounds)和中心(center)属性来定义的。frame定义了View相对父View坐标系的原点和大小，一般在View布局和调整尺寸或位置时使用。center属性可以在不改变view的大小来调整view的位置。bounds定义了view的内部尺寸，几乎只在自定义绘画代码时使用。frame的size部分和bounds矩形部分耦合在一起，所以可以使用两者中的一个或两个同时来改变view的大小。 更多关于如何使用 UIView 类，参见iOS View编程向导(View Programming Guide for iOS) NoteIn iOS 2.x, the maximum size of a UIView object is 1024 x 1024 points. In iOS 3.0 and later, views are no longer restricted to this maximum size but are still limited by the amount of memory they consume. It is in your best interests to keep view sizes as small as possible. Regardless of which version of iOS is running, you should consider tiling any content that is significantly larger than the dimensions of the screen. 注意在iOS 2.x时，UIView的最大尺寸是1024*1024点，在iOS 3.0以后，不再强制限制大小，而是受限于内存消耗。让View尽可能小，无论运行在哪个版本的iOS上，都应该考虑避免View明显大于屏幕尺寸 📌 Creating a View「创建一个View」 To create a view programmatically, you can use code like the following:以编程方式创建一个视图，您可以使用代码如下: Objective-c12CGRect viewRect = CGRectMake(10, 10, 100, 100);UIView* myView = [[UIView alloc] initWithFrame:viewRect]; swift12let viewRect = CGRect(x: 10, y: 10, width: 100, height: 100)let myView = UIView(frame: viewRect) This code creates the view and positions it at the point (10, 10) in its superview’s coordinate system (once it is added to that superview). To add a subview to another view, you use the addSubview: method. In iOS, sibling views may overlap each other without any issues, allowing complex view placement. The addSubview: method places the specified view on top of other siblings. You can specify the relative z-order of a subview by adding it using the insertSubview:aboveSubview: and insertSubview:belowSubview: methods. You can also exchange the position of already added subviews using the exchangeSubviewAtIndex:withSubviewAtIndex: method. 这段代码创建了view，并把它放在父view坐标系的(10,10)点(一旦它被加到父view)。添加一个子view到另一个view上，用addSubview:方法。在 iOS 里，同级的view可以相互覆盖，而不会有任何问题，允许复杂的view布置。addSubview放置指定的view到它的同级view的顶部。你可以使用insertSubview:aboveSubview: 和 insertSubview:belowSubview: 方法指定子view的相对z坐标。你也可以使用exchangeSubviewAtIndex:withSubviewAtIndex:方法交换已经添加的子view的位置。 🏷When creating a view, it is important to assign an appropriate value to the autoresizingMask property to ensure the view resizes correctly. View resizing primarily occurs when the orientation of your application’s interface changes but it may happen at other times as well. For example, calling the setNeedsLayout method forces your view to update its layout. 当创建一个视图，适当的属性值分配给autoresizingMask，以确保视图尺寸正确。视图调整主要发生在应用程序的接口的方向变化，但也可能发生在其他时间。例如，调用setNeedsLayout方法迫使你的视图更新它的布局。 📌 The View Drawing Cycle「绘制周期」 View drawing occurs on an as-needed basis. When a view is first shown, or when all or part of it becomes visible due to layout changes, the system asks the view to draw its contents. For views that contain custom content using UIKit or Core Graphics, the system calls the view’s drawRect: method. Your implementation of this method is responsible for drawing the view’s content into the current graphics context, which is set up by the system automatically prior to calling this method. This creates a static visual representation of your view’s content that can then be displayed on the screen. View绘画发生在需要时。当一个view第一次展示时，或者在布局变化时，它的整体或部分变得可见时，系统请求view绘出它的内容。对那些使用UIKit或Core Graphics包含自定义内容的view来说，系统会调用它的 drawRect: 方法。你对该方法的实现，负责将view的内容画进当前的图形上下文(graphics context),系统自动优先调用该方法。这里创建了view内容的静态可视展现，接着会被展示在屏幕上。 🏷When the actual content of your view changes, it is your responsibility to notify the system that your view needs to be redrawn. You do this by calling your view’s setNeedsDisplay or setNeedsDisplayInRect: method of the view. These methods let the system know that it should update the view during the next drawing cycle. Because it waits until the next drawing cycle to update the view, you can call these methods on multiple views to update them at the same time. 当view的真实内容发生改变时，你有责任通知系统你的view需要重绘。通过调用view的 setNeedsDisplay 或setNeedsDisplayInRect: 方法来通知。这些方法让系统知道它应该在下次绘画周期更新View.因为它一直等待直到下次绘画周期来更新View，你可以在多个view上调用这些方法，同时更新它们. NoteIf you are using OpenGL ES to do your drawing, you should use the GLKView class instead of subclassing UIView. For more information about how to draw using OpenGL ES, see OpenGL ES Programming Guide . 注意如果你用OpenGL ES来绘画，应该用GLKView类来代替UIView.更多信息关于如何用OpenGL ES绘画，参见 iOS OpenGL ES编程向导（see OpenGL ES Programming Guide） For detailed information about the view drawing cycle and the role your views have in this cycle, see View Programming Guide for iOS.更多关于View绘画周期和你的view的角色，参见iOS View编程向导(View Programming Guide for iOS.) 📌 Animations「动画」 Changes to several view properties can be animated—that is, changing the property creates an animation that conveys the change to the user over a short period of time. The UIView class does most of the work of performing the actual animations but you must still indicate which property changes you want to be animated. There are two different ways to initiate animations: In iOS 4 and later, use the block-based animation methods. (Recommended) Use the begin/commit animation methods. 改变多个View属性可以被动画展现，在一个短周期时间内，改变属性可以创建动画。UIView类做了很多执行动画的工作，但你仍然必须判断你需要哪些属性改变被动画。下面是两种不同的初始化动画方法： 在iOS4.0及以后的版本中，使用基于块的动画方法(推荐) 使用开始/提交(begin/commit)动画方法。 🏷The block-based animation methods (such as animateWithDuration:animations: ) greatly simplify the creation of animations. With one method call, you specify the animations to be performed and the options for the animation. However, block-based animations are available only in iOS 4 and later. If your application runs on earlier versions of iOS, you must use the beginAnimations:context: and commitAnimations class methods to mark the beginning and ending of your animations. 基于块的动画方法(像 animateWithDuration:animations: )极大地简化了动画创建。只要调用一个方法，指定动画的参数，并且执行动画。然后，基于块的动画仅在iOS4及以后版本中可用。如果你的设备运行老版本的iOS,必须使用 beginAnimations:context: 和 commitAnimations 类方法标记动画开始和结束。 The following properties of the UIView class are animatable: frame bounds center transform alpha backgroundColor 可以做成动画UIView类的属性如下: @property frame @property bounds @property center @property transform @property alpha @property backgroundColor For more information about how to configure animations, see View Programming Guide for iOS .更多关于如何配置动画，请参见视图iOS编程指南 View Programming Guide for iOS 。 📌 Threading Considerations「线程注意事项」 Manipulations to your application’s user interface must occur on the main thread. Thus, you should always call the methods of the UIView class from code running in the main thread of your application. The only time this may not be strictly necessary is when creating the view object itself but all other manipulations should occur on the main thread. 操作用户界面必须发生在主线程。因此，你必须在应用主线程调用UIView类的方法。只有在创建view对象自身时可以不用严格遵守，但其他操作必须在主线程中。 📌 Subclassing Notes「子类化(继承)说明」 The UIView class is a key subclassing point for visual content that also requires user interactions. Although there are many good reasons to subclass UIView, it is recommended that you do so only when the basic UIView class or the standard system views do not provide the capabilities that you need. Subclassing requires more work on your part to implement the view and to tune its performance. 对同样需要用户交互的可见内容来说，UIView类是一个关键的子类化点。尽管有很多好理由继承UIView，但我们只推荐在基本的UIView和系统自带的其他组件不能满足需要时继承UIView.继承UIView会在你实现的代码里消耗更多性能.(Apple写的代码比你的更好，有现成的就用现成的)。 For information about ways to avoid subclassing, see Alternatives to Subclassing .更多关于子类化信息，请参见选择子类化 Alternatives to Subclassing。 📌 Methods to Override「覆盖方法」 When subclassing UIView, there are only a handful of methods you should override and many methods that you might override depending on your needs. Because UIView is a highly configurable class, there are also many ways to implement sophisticated view behaviors without overriding custom methods, which are discussed in the Alternatives to Subclassing section. In the meantime, the following list includes the methods you might consider overriding in your UIView subclasses: Initialization: initWithFrame: - It is recommended that you implement this method. You can also implement custom initialization methods in addition to, or instead of, this method. initWithCoder: - Implement this method if you load your view from an Interface Builder nib file and your view requires custom initialization. layerClass Use this property only if you want your view to use a different Core Animation layer for its backing store. For example, if your view uses tiling to display a large scrollable area, you might want to set the property to the CATiledLayer class. Drawing and printing: drawRect: - Implement this method if your view draws custom content. If your view does not do any custom drawing, avoid overriding this method. drawRect:forViewPrintFormatter: - Implement this method only if you want to draw your view’s content differently during printing. Constraints: requiresConstraintBasedLayout Use this property if your view class requires constraints to work properly. updateConstraints - Implement this method if your view needs to create custom constraints between your subviews. alignmentRectForFrame:, frameForAlignmentRect: - Implement these methods to override how your views are aligned to other views. Layout: sizeThatFits: - Implement this method if you want your view to have a different default size than it normally would during resizing operations. For example, you might use this method to prevent your view from shrinking to the point where subviews cannot be displayed correctly. layoutSubviews - Implement this method if you need more precise control over the layout of your subviews than either the constraint or autoresizing behaviors provide. didAddSubview: , willRemoveSubview: - Implement these methods as needed to track the additions and removals of subviews. willMoveToSuperview:, didMoveToSuperview - Implement these methods as needed to track the movement of the current view in your view hierarchy. willMoveToWindow: , didMoveToWindow - Implement these methods as needed to track the movement of your view to a different window. Event Handling: touchesBegan:withEvent:, touchesMoved:withEvent:, touchesEnded:withEvent: , touchesCancelled:withEvent: - Implement these methods if you need to handle touch events directly. (For gesture-based input, use gesture recognizers.) gestureRecognizerShouldBegin: - Implement this method if your view handles touch events directly and might want to prevent attached gesture recognizers from triggering additional actions. 当子类化 UIView 时，只有少数的方法你必须覆盖，大多数方法你可以按需覆盖。因为UIView是一个高度可配的类，不用覆盖父类方法，同样有很多实现复杂的行为的途径，这些在 选择子类化 一节中介绍。你可以在你的UIView子类中考虑覆盖下面列表中的方法： 初始化 initWithFrame : 推荐覆盖。你同样可以实现自定义的初始化方法添加或代替此方法 initWithCoder : 如果你从一个Interface Builder的nib文件加载view，并且需要自定义初始化，覆盖该方法。 layerClass : 仅当你的view需要用不同的Core Animation层后备保存时才要覆盖。例如，当你的view需要用平铺方式显示一块很大的可滚动区域时，你可能想要覆盖该方法返回CATiledLayer类.(这里不是很明白) 绘画和打印 drawRect : 如果你的View画自定义的内容，就要实现该方法，否则避免覆盖该方法。 drawRect : forViewPrintFormatter:仅当你需要在打印时，打印不同内容(与显示不同)才需要实现该方法。 约束 requiresConstraintBasedLayout : – 如果你的View类需要约束才能正常工作，实现该方法 updateConstraints : 如果你的view需要在子view间创建约束，需要实现该方法 alignmentRectForFrame :, frameForAlignmentRect:– 实现这些方法覆盖你的view如何与其他view对齐 布局 sizeThatFits :: – 当你想在执行resize操作时有一个不同于默认的size，实现该方法。比如，你可以用这个方法阻止view收缩到子view不能正确显示的点 layoutSubviews : – 如果你需要更精确控制子view，而不是使用限制或autoresizing行为，就需要实现该方法。 didAddSubview :: , willRemoveSubview:跟踪子view添加或删除事件 willMoveToSuperview :, didMoveToSuperview 跟踪当前view在view层次里的运动 willMoveToWindow :,didMoveToWindow 跟踪view(即将或已经)移动到另一个Window 事件处理: touchesBegan:withEvent :, touchesMoved:withEvent:, touchesEnded:withEvent:,touchesCancelled:withEvent: 直接处理触摸事件(如果是手势，使用gesture recognizers) gestureRecognizerShouldBegin : 如果需要直接处理触摸事件，那么需要覆盖该方法，阻止手势识别器触发额外动作。 📌 Alternatives to Subclassing「替代子类化」Many view behaviors can be configured without the need for subclassing. Before you start overriding methods, consider whether modifying the following properties or behaviors would provide the behavior you need. addConstraint: - Define automatic layout behavior for the view and its subviews. autoresizingMask: - Provides automatic layout behavior when the superview’s frame changes. These behaviors can be combined with constraints. contentMode: - Provides layout behavior for the view’s content, as opposed to the frame of the view. This property also affects how the content is scaled to fit the view and whether it is cached or redrawn. hidden or alpha: - Change the transparency of the view as a whole rather than hiding or applying alpha to your view’s rendered content. backgroundColor: - Set the view’s color rather than drawing that color yourself. Subviews - Rather than draw your content using a drawRect: method, embed image and label subviews with the content you want to present. Gesture recognizers - Rather than subclass to intercept and handle touch events yourself, you can use gesture recognizers to send an Target-Action to a target object. Animations - Use the built-in animation support rather than trying to animate changes yourself. The animation support provided by Core Animation is fast and easy to use. Image-based backgrounds - For views that display relatively static content, consider using a UIImageView object with gesture recognizers instead of subclassing and drawing the image yourself. Alternatively, you can also use a generic UIView object and assign your image as the content of the view’s CALayer object. 很多view行为可以配置而不用子类化。在你开始覆盖这些方法时，考虑是否可以修改下面的属性或行为来提供你需要的功能。 addConstraint: – 为view和它的子view定义自动布局行为. autoresizingMask: – 当父view的frame改变时，提供自动布局行为。这些行为可以和约束(Constraint)合并 contentMode: -为view内容提供布局行为，与view的frame相反。这个属性同样影响内容应用view的缩放，是缓存还是重绘。 contentStretch:-定义view的部分可伸缩。这个行为通常用于实现按钮和其他复杂布局、可变尺寸、重绘代价高的view。 hidden 或 alpha: 改变view的不透明度或隐藏view backgroundColor: – 设置view的背景颜色 Subviews:不在drawRect方法里绘制你的内容，使用嵌入图片或文本子view等方式 Gesture recognizers: – 使用手势识别器替代自己手工处理touch事件 Animations:– 使用内建动画支持代替自己写动画。Core Animation提供的动画支持很快很好用 基于图片的背景 – 对那些显示相对静态内容的view来说，考虑使用UIImageView对象加上手势识别替代子类化和自己绘制图片。同样，你也可以使用一般的UIView对象，分配你的图片作为view的CALayer对象内容。 🏷Animations are another way to make visible changes to a view without requiring you to subclass and implement complex drawing code. Many properties of the UIView class are animatable, which means changes to those properties can trigger system-generated animations. Starting animations requires as little as one line of code to indicate that any changes that follow should be animated. For more information about animation support for views, see Animations. 动画是不需要子类化和实现复杂代码而让视觉改变的另一种方式。很多UIView的属性是可以动画的，意味着改变这些属性可以触发系统生成动画。启动动画只需要很少的一行代码指示那些改变需要被动画。更多view动画的信息，参考 Animations For more information about appearance and behavior configuration, see About Views in UIKit User Interface Catalog .更多关于外观和行为配置的信息，见 UIKit User Interface Catalog 目录里的 About Views 📌 Initializing a View Object「初始化View对象」 - initWithFrame: 使用指定的frame矩形，初始化并且返回新的View对象。 声明：SWIFT:1init(frame aRect: CGRect) OBJECTIVE-C: 1- (instancetype)initWithFrame:(CGRect)frame 参数aRect view的frame矩形，使用point测量。frame的原点是相对你将添加到的父view的。这个方法用frame矩形来设置中心点和边界。 返回值：一个初始化的对象，如果不能创建，返回nil. 说明：一个新的view对象必须插入到一个windows的view层级里才能使用。如果你用程序创建了一个view对象，这个方法是UIView类的指定初始器。子类可以覆盖这个方法来执行一些自定义的初始化，但必须在第一行调用super实现。如果你用Interface Builder来设计你的界面，这个方法在从nib文件创建view对象时不会被调用。nib里的对象使用initWithCoder:方法重建和初始化，它会修改view属性来匹配存储在nib文件里的属性。关于view如何从nib文件载入的详细信息，参见 Resource Programming Guide. 📌 配置View的可见外观 🏷 - backgroundColor: View的背景颜色 声明SWIFT:1@NSCopying var backgroundColor: UIColor? OBJECTIVE-C1@property(nonatomic, copy) UIColor *backgroundColor 说明:改变这个属性可以动画，默认值是nil,表现为透明。 扩展 alpha opaque 🏷 hidden：一个判断view是否隐藏的bool值 声明SWIFT:1var hidden: Bool OBJECTIVE-C1@property(nonatomic, getter=isHidden) BOOL hidden 说明:设置这个值为YES隐藏view,NO显示View,默认是NO一个隐藏的view从窗口消失并且不接收输入事件。然而，它还留在它的父view的子view列表中，并且跟往常一样参与autoresizing。隐藏一个带有子view的view,跟隐藏这些子view(包括他们的子view）有一样的效果。这个效果是含蓄的并且不会修改子view的hidden属性.如果隐藏的view是窗口的当前第一响应者，会导致下一个view成为第一响应者(得到焦点，是这个意思么？) 参考原著：https://www.pocketdigi.com/20150105/1413.html 🏷 alpha: View的不透明度 声明SWIFT:1var alpha: CGFloat OBJECTIVE-C1@property(nonatomic) CGFloat alpha 说明:这个属性的值是一个浮点值，范围从0.0到1.0,0.0代表完全透明，1.0代表完全不透明。这个值只能当前view有效，不影响内嵌的子view 改变这个属性可以动画 扩展 backgroundColor opaque 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MJExtension框架学习]]></title>
    <url>%2FSourceAnnotations%2FMJExtensionLibrary.html</url>
    <content type="text"><![CDATA[MJExtension字典转模型框架1234A fast, convenient and nonintrusive conversion between JSON and model.转换速度快、使用简单方便的字典转模型框架 Contents 作用12345678910111213141516171819201.MJExtension是一套字典和模型之间互相转换的超轻量级框架2.JSON --&gt; Model、Core Data Model3.JSONString --&gt; Model、Core Data Model4.Model、Core Data Model --&gt; JSON5.JSON Array --&gt; Model Array、Core Data Model Array6.JSONString --&gt; Model Array、Core Data Model Array7.Model Array、Core Data Model Array --&gt; JSON Array8.Coding all properties of model in one line code.只需要一行代码，就能实现模型的所有属性进行Coding（归档和解档）1.简单的字典 --&gt; 模型2.JSON字符串 --&gt; 模型3.复杂的字典 --&gt; 模型 (模型里面包含了模型)4.复杂的字典 --&gt; 模型 (模型的数组属性里面又装着模型)5.复杂的字典 --&gt; 模型（模型属性名和字典的key不一样）6.字典数组 --&gt; 模型数组7.模型 --&gt; 字典8.模型数组 --&gt; 字典数组9.字典 --&gt; CoreData模型10.归档与解档NSCoding11.过滤字典的值 安装12345使用CocoaPods `pod 'MJExtension'`手动导入1.将`MJExtension`文件夹中的所有源代码拽入项目中2.导入主头文件：`#import "MJExtension.h"` Getting Started【开始使用】 1.JSON -&gt; Model【最简单的字典转模型】核心方法:mj_objectWithKeyValues:12345678910111213141516171819202122232425262728模型类User定义typedef enum &#123; SexMale, SexFemale&#125; Sex;@interface User : NSObject@property (copy, nonatomic) NSString *name;/* 姓名 */@property (copy, nonatomic) NSString *icon;/* 头像 */@property (assign, nonatomic) unsigned int age;/* 年龄 */@property (copy, nonatomic) NSString *height;/* 身高 */@property (strong, nonatomic) NSNumber *money;/* 资产 */@property (assign, nonatomic) Sex sex;/* 性别 */@property (assign, nonatomic, getter=isGay) BOOL gay;/* 是否是同性恋 */@end// 简单的字典 NSDictionary *dict_user = @&#123; @"name" : @"Jack", @"icon" : @"lufy.png", @"age" : @20, @"height" : @"1.55", @"money" : @100.9, @"sex" : @(SexFemale),/* 枚举需要使用NSNumber包装 */ @"gay" : @YES &#125;; User *user = [User mj_objectWithKeyValues:dict_user]; NSLog(@"MJ-%@-%@-%u-%@-%@-%u-%d",user.name,user.icon,user.age,user.height,user.money,user.sex,user.gay);//打印结果//2016-07-04 11:06:59.746 PPDemos[2432:73824] MJ-Jack-lufy.png-20-1.55-100.9-1-1 2.JSONString -&gt; Model【JSON字符串转模型】核心方法:mj_objectWithKeyValues:123456// 定义一个JSON字符串 NSString *jsonStr = @"&#123;\"name\":\"Jack\", \"icon\":\"lufy.png\", \"age\":20&#125;"; User *user = [User mj_objectWithKeyValues:jsonStr]; NSLog(@"MJ---%@----%@---%u",user.name,user.icon,user.age); // 打印结果 // 2016-07-04 11:16:04.655 PPDemos[2563:78561] MJ---Jack----lufy.png---20 3.复杂的字典【模型中嵌套模型】核心方法:mj_objectWithKeyValues:123456789101112131415//复杂的字典[模型中有个数组属性，数组里面又要装着其他模型的字典]NSDictionary *dict_m8m = @&#123; @"text" : @"Agree!Nice weather!", @"user" : @&#123; @"name" : @"Jack", @"icon" : @"lufy.png" &#125;, @"retweetedStatus" : @&#123; @"text" : @"Nice weather!", @"user" : @&#123; @"name" : @"Rose", @"icon" : @"nami.png" &#125; &#125; &#125;; 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;@class User;@class Status;//Status模型@interface Status : NSObject@property (copy, nonatomic) NSString *text;@property (strong, nonatomic) User *user;/* 其他模型类型 */@property (strong, nonatomic) Status *retweetedStatus;/* 自我模型类型 */@end//// 字典转模型，模型里面含有模型 Status *status = [Status mj_objectWithKeyValues:dict_m8m]; NSString *text = status.text; NSString *name = status.user.name; NSString *icon = status.user.icon; NSLog(@"mj-----text=%@, name=%@, icon=%@", text, name, icon); NSString *text2 = status.retweetedStatus.text; NSString *name2 = status.retweetedStatus.user.name; NSString *icon2 = status.retweetedStatus.user.icon; NSLog(@"mj-----text2=%@, name2=%@, icon2=%@", text2, name2, icon2); // 打印结果 //2016-07-04 11:45:39.675 PPDemos[2781:87089] mj-----text=Agree!Nice weather!, name=Jack, icon=lufy.png //2016-07-04 11:45:39.675 PPDemos[2781:87089] mj-----text2=Nice weather!, name2=Rose, icon2=nami.png 4.【模型中有个数组属性，数组里面又要装着其他模型】核心方法:mj_objectWithKeyValues: 和mj_objectClassInArray12345678910111213141516171819@interface Ad : NSObject@property (copy, nonatomic) NSString *image;@property (copy, nonatomic) NSString *url;@end@interface StatusResult : NSObject/** 数组中存储模型Status类型数据 */@property (strong, nonatomic) NSMutableArray *statuses;/** 数组中存储模型Ad类型数据 */@property (strong, nonatomic) NSArray *ads;@property (strong, nonatomic) NSNumber *totalNumber;@end #import "StatusResult.h"#import "MJExtension.h"@implementation StatusResult/* 数组中存储模型数据，需要说明数组中存储的模型数据类型,实现该方法 */+(NSDictionary *)mj_objectClassInArray&#123; return @&#123; @"statuses" : @"Status", @"ads" : @"Ad" &#125;;&#125;@end 在VC里实现以下来解析数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//模型中有个数组属性，数组里面又要装着其他模型 NSDictionry *dict_m8a = @&#123; @"statuses" : @[ @&#123; @"text" : @"Nice weather!", @"user" : @&#123; @"name" : @"Rose", @"icon" : @"nami.png" &#125; &#125;, @&#123; @"text" : @"Go camping tomorrow!", @"user" : @&#123; @"name" : @"Jack", @"icon" : @"lufy.png" &#125; &#125; ], @"ads" : @[ @&#123; @"image" : @"ad01.png", @"url" : @"http://www.ad01.com" &#125;, @&#123; @"image" : @"ad02.png", @"url" : @"http://www.ad02.com" &#125; ], @"totalNumber" : @"2014" &#125;;【重点，核心】&gt;&gt;数组中存储模型数据，需要说明数组中存储的模型数据类型&lt;&lt; /* [StatusResult mj_setupObjectClassInArray:^NSDictionary *&#123; return @&#123; @"statuses" : @"Status", // @"statuses" : [Status class], @"ads" : @"Ad" // @"ads" : [Ad class] &#125;; &#125;]; // Equals: StatusResult.m implements +mj_objectClassInArray method.*/ // 以上方法在VC里写，如果多个地方解析该model，就要写多次，最好在model的.m文件写！ // 字典转模型，支持模型的数组属性里面又装着模型 StatusResult *result = [StatusResult mj_objectWithKeyValues:dict_m8a]; // 打印博主信息 for (Status *status in result.statuses) &#123; NSString *text = status.text; NSString *name = status.user.name; NSString *icon = status.user.icon; NSLog(@"mj---text=%@, name=%@, icon=%@", text, name, icon); &#125; // 打印广告 for (Ad *ad in result.ads) &#123; NSLog(@"mj---image=%@, url=%@", ad.image, ad.url); &#125;// 打印结果//2016-07-04 13:47:58.994 PPDemos[3353:113055] mj---text=Nice weather!, name=Rose, icon=nami.png //2016-07-04 13:47:58.995 PPDemos[3353:113055] mj---text=Go camping tomorrow!, name=Jack, icon=lufy.png //2016-07-04 13:47:58.995 PPDemos[3353:113055] mj---image=ad01.png, url=http://www.ad01.com //2016-07-04 13:47:58.995 PPDemos[3353:113055] mj---image=ad02.png, url=http://www.ad02.com 5.【模型中的属性名和字典中的key不相同(或者需要多级映射)】核心方法:mj_objectWithKeyValues: 和mj_replacedKeyFromPropertyName123456789101112131415161718192021222324252627282930@interface Bag : NSObject@property (copy, nonatomic) NSString *name;@property (assign, nonatomic) double price;@end#import &lt;Foundation/Foundation.h&gt;@class Bag;@interface Student : NSObject@property (copy, nonatomic) NSString *ID;@property (copy, nonatomic) NSString *desc;@property (copy, nonatomic) NSString *nowName;@property (copy, nonatomic) NSString *oldName;@property (copy, nonatomic) NSString *nameChangedTime;@property (strong, nonatomic) Bag *bag;@end// 多级映射，用点语法设置@implementation Student/* 设置模型属性名和字典key之间的映射关系 */+(NSDictionary *)mj_replacedKeyFromPropertyName&#123; /* 返回的字典，key为模型属性名，value为转化的字典的多级key */ return @&#123; @"ID" : @"id", @"desc" : @"desciption", @"oldName" : @"name.oldName", @"nowName" : @"name.newName", @"nameChangedTime" : @"name.info[1].nameChangedTime", @"bag" : @"other.bag" &#125;;&#125;@end 1234567891011121314151617181920212223242526272829303132333435363738394041NSDictionry *dict_nokey = @&#123; @"id" : @"20", @"desciption" : @"kids", @"name" : @&#123; @"newName" : @"lufy", @"oldName" : @"kitty", @"info" : @[ @"test-data", @&#123; @"nameChangedTime" : @"2013-08" &#125; ] &#125;, @"other" : @&#123; @"bag" : @&#123; @"name" : @"a red bag", @"price" : @100.7 &#125; &#125; &#125;;//// // How to map// [Student mj_setupReplacedKeyFromPropertyName:^NSDictionary *&#123;// return @&#123;// @"ID" : @"id",// @"desc" : @"desciption",// @"oldName" : @"name.oldName",// @"nowName" : @"name.newName",// @"nameChangedTime" : @"name.info[1].nameChangedTime",// @"bag" : @"other.bag"// &#125;;// &#125;];// // Equals: Student.m implements +mj_replacedKeyFromPropertyName method. // 字典转模型，支持多级映射 Student *stu = [Student mj_objectWithKeyValues:dict_nokey]; // 打印 NSLog(@"ID=%@, desc=%@, oldName=%@, nowName=%@, nameChangedTime=%@", stu.ID, stu.desc, stu.oldName, stu.nowName, stu.nameChangedTime); NSLog(@"bagName=%@, bagPrice=%f", stu.bag.name, stu.bag.price); //2016-07-04 14:20:28.082 PPDemos[3602:126004] ID=20, desc=kids, oldName=kitty, nowName=lufy, nameChangedTime=2013-08 //2016-07-04 14:20:28.082 PPDemos[3602:126004] bagName=a red bag, bagPrice=100.700000 6.【将一个字典数组转成模型数组】核心方法:mj_objectArrayWithKeyValuesArray:123456789101112131415161718NSArray *dictArray = @[ @&#123; @"name" : @"Jack", @"icon" : @"lufy.png" &#125;, @&#123; @"name" : @"Rose", @"icon" : @"nami.png" &#125; ]; // 字典数组转模型数组，使用的是mj_objectArrayWithKeyValuesArray:方法 NSArray *userArray = [User mj_objectArrayWithKeyValuesArray:dictArray]; //打印 for (User *user in userArray) &#123; NSLog(@"name=%@, icon=%@", user.name, user.icon); &#125; // name=Jack, icon=lufy.png // name=Rose, icon=nami.png 7.【将一个模型转成字典】核心方法:mj_keyValues:12345678910111213141516171819//创建一个模型对象User *user = [[User alloc] init];user.name = @"Jack";user.icon = @"lufy.png";Status *status = [[Status alloc] init];status.user = user;status.text = @"Nice mood!";//模型转字典，使用的是mj_keyValues属性NSDictionary *statusDict = status.mj_keyValues;NSLog(@"%@", statusDict);/*&#123;text = "Nice mood!"; user = &#123; icon = "lufy.png"; name = Jack; &#125;;&#125;*/ 8.【将一个模型数组转成字典数组】核心代码:mj_keyValuesArrayWithObjectArray1234567891011121314151617181920212223// 创建模型数组User *user1 = [[User alloc] init];user1.name = @"Jack";user1.icon = @"lufy.png";User *user2 = [[User alloc] init];user2.name = @"Rose";user2.icon = @"nami.png";NSArray *userArray = @[user1, user2];//模型数组转字典数组，使用的是mj_keyValuesArrayWithObjectArray:方法NSArray *dictArray = [User mj_keyValuesArrayWithObjectArray:userArray];NSLog(@"%@", dictArray);/*( &#123; icon = "lufy.png"; name = Jack; &#125;, &#123; icon = "nami.png"; name = Rose; &#125;)*/ 9.Core Data1234567891011121314NSDictionary *dict = @&#123; @"name" : @"Jack", @"icon" : @"lufy.png", @"age" : @20, @"height" : @1.55, @"money" : @"100.9", @"sex" : @(SexFemale), @"gay" : @"true" &#125;;//字典转为CoreData模型NSManagedObjectContext *context = nil;User *user = [User mj_objectWithKeyValues:dict context:context];[context save:nil]; 10.归档与解档NSCoding12345678910111213@interface Bag : NSObject &lt;NSCoding&gt;@property (copy, nonatomic) NSString *name;@property (assign, nonatomic) double price;@end#import "MJExtension.h"@implementation Bag//添加了下面的宏定义MJExtensionCodingImplementation/* 实现下面的方法，说明哪些属性不需要归档和解档 */+ (NSArray *)mj_ignoredCodingPropertyNames&#123; return @[@"name"];&#125;@end 123456789101112//创建模型Bag *bag = [[Bag alloc] init];bag.name = @"Red bag";bag.price = 200.8;//获取归档路径NSString *file = [NSHomeDirectory() stringByAppendingPathComponent:@"Desktop/bag.data"];//归档[NSKeyedArchiver archiveRootObject:bag toFile:file];//解档Bag *decodedBag = [NSKeyedUnarchiver unarchiveObjectWithFile:file];NSLog(@"name=%@, price=%f", decodedBag.name, decodedBag.price);// name=(null), price=200.800000 11.【统一转换属性名（比如驼峰转下划线）】12345678910111213141516171819// Dog#import "MJExtension.h"@implementation Dog+ (NSString *)mj_replacedKeyFromPropertyName121:(NSString *)propertyName&#123; // nickName -&gt; nick_name return [propertyName mj_underlineFromCamel];&#125;@end// NSDictionaryNSDictionary *dict = @&#123; @"nick_name" : @"旺财", @"sale_price" : @"10.5", @"run_speed" : @"100.9" &#125;;// NSDictionary -&gt; DogDog *dog = [Dog mj_objectWithKeyValues:dict];// printingNSLog(@"nickName=%@, scalePrice=%f runSpeed=%f", dog.nickName, dog.salePrice, dog.runSpeed); 12.【过滤字典的值（比如字符串日期处理为NSDate、字符串nil处理为@””）】123456789101112131415161718192021@interface Book: NSObject@property (copy, nonatomic) NSString *name;@property (strong, nonatomic) NSDate *publishedTime;@end#import "MJExtension.h"@implementation Book/* 转化过程中对字典的值进行过滤和进一步转化 */- (id)mj_newValueFromOldValue:(id)oldValue property:(MJProperty *)property&#123; if ([property.name isEqualToString:@"publisher"]) &#123; if (oldValue == nil) &#123; return @""; &#125; &#125; else if (property.type.typeClass == [NSDate class]) &#123; NSDateFormatter *fmt = [[NSDateFormatter alloc] init]; fmt.dateFormat = @"yyyy-MM-dd"; return [fmt dateFromString:oldValue]; &#125; return oldValue;&#125;@end 12345678NSDictionary *dict = @&#123; @"name" : @"5分钟突破iOS开发", @"publishedTime" : @"2011-09-10" &#125;;//字典转模型，过滤name为nil的情况，把NSString转为NSDateBook *book = [Book mj_objectWithKeyValues:dict];//打印NSLog(@"name=%@, publishedTime=%@", book.name, book.publishedTime); 1.模型中有个数组属性，数组里面又要装着其他模型 12345678910111213141516171819202122//1.把字典数组转换为模型数组//使用MJExtension框架进行字典转模型self.videos = [XMGVideo objectArrayWithKeyValuesArray:videoArray];//2.重命名模型属性的名称//第一种重命名属性名称的方法，有一定的代码侵入性//设置字典中的id被模型中的ID替换+(NSDictionary *)replacedKeyFromPropertyName &#123; return @&#123; @"ID":@"id" &#125;;&#125;//第二种重命名属性名称的方法，代码侵入性为零[LNVideo setupReplacedKeyFromPropertyName:^NSDictionary *&#123; return @&#123; @"ID":@"id" &#125;;&#125;];//3.MJExtension框架内部实现原理-运行时 这个框架有太多的东西值得我们去学习推敲，方方面面都透露着作者以及众多贡献者的智慧，我们使用起来也一定会受益良多。 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UI控件详解—「UIScrollView滚动视图」]]></title>
    <url>%2FiOSUI%2FUIScrollView.html</url>
    <content type="text"><![CDATA[引导 “ 本文不适合老司机… ”Copyright © PBWln Unauthorized shall not be reproduced. 本文章将介绍 iOS UI控件 详解，最常使用的三大控件之一 UIScrollView，将会分成两篇文章完整的讲述 UIScrollView 的常用属性方法使用（包括优化方面）及注意点 和 实战开发使用场景案例，文章编写周期会长一些，用到那点实用的东西，会及时补充。 本篇文章主要从【 UIScrollView 属性方法注解】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： UIScrollView概念 UIScrollView基本使用(滚动) UIScrollView属性与方法1.属性 &amp; 方法2.使用格式 &amp; 说明：3.简明注解： UIScrollView代理方法1.滑动代理方法相关2.缩放代理方法相关3.部分代理方法简明示例 UIScrollView处理触摸事件原理 常见需求示例 &amp; 原理解析1.导航栏半透明效果2.控件导航悬停3.下拉头部图片放大4.正反无限轮播（3张）重点 UIScrollView底层实现 正反无限轮播（2张） UIScrollView.h属性和方法 期待 &amp; 后续 UIScrollView概念 我还是喜欢先看官方的说明： 上图简明释义：可以展示比设备屏幕更大区域的内容，我们可以通过手指滑动来查看内容视图（content view）的每一部分内容，也可以通过手指捏合来对内容视图进行缩放操作。 UIScrollView 是一个非常重要的控件，UITableView、UICollectionView和UITextView等常用控件全部继承自UIScrollView，而UIWebView控件内部也是基于UIScrollView实现的。而UIScrollView继承自UIView，至于它可以滚动的原因我下面会有原理说明。 UIScrollView基本使用(滚动) UIScrollView的使用很简单，基本使用方式如下 3点： 12345678910// 1.创建滚动视图UIScrollView *scrollView = [[UIScrollView alloc] init];scrollView.frame = CGRectMake(0,0,375,150);[self addSubview:scrollView];// 2. 设置滚动范围（内容视图的大小）scrollView.contentSize = CGSizeMake(ImageViewCount * self.bounds.size.width, 0);// 3. 添加内容[scrollView addSubview:[UIImageView new]]; 说明：如果想让UIScrollView进行滚动,必须设置可以滚动的范围 UIScrollView属性与方法 属性 &amp; 方法：12345678910111213141516属性 &amp; 方法：#pragma mark ------------------#pragma mark - 内容视图属性方法相关/** 内容视图的原点相对于scrollView的原点的偏移量(上/左 方向偏移为正数,下/右 方向偏移为负数),默认为CGPointZero */@property(nonatomic) CGPoint contentOffset; // default CGPointZero/** 内容视图的大小,默认为CGSizeZero */@property(nonatomic) CGSize contentSize; // default CGSizeZero/** 为内容视图周围增加可滚动区域,默认为UIEdgeInsetsZero */@property(nonatomic) UIEdgeInsets contentInset; // default UIEdgeInsetsZero. add additional scroll area around content// 代理@property(nullable,nonatomic,weak) id&lt;UIScrollViewDelegate&gt; delegate; // default nil. weak reference/** 设置内容视图的原点相对于scrollView的原点的偏移量 */- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated; // animate at constant velocity to new offset 使用格式 &amp; 说明：1234567891011121314151617使用格式 &amp; 说明：// 内容滚动大小（说明：设置的大小 &gt; scrollView.bounds 才可以滚动，哪个方向不滚动可直接设置为0 如:width = 0 或是 height = 0）self.scrollView.contentSize = CGSizeMake(3 * ScreenViewW, ScreenViewH); // 内容偏移量（说明：内容视图的左上角到scrollView左上角的一个偏移量，计算时以内容视图的左上角为基准，默认（0,0）开始）scrollView.contentOffset = CGPointMake(150, 0);// 内边距（top +,left +,bottom -,right -）scrollView.contentInset = UIEdgeInsetsMake(10, 10, 10, 10);// 设置scorllView的代理，当滚动事件事件发生时，相应的代理方法被调用（说明：苹果设计的代理属性为什么是weak？注解在下面）// 可以看到前面定义属性类型为 id,可知 任何OC对象都可以作为scrollView的代理，必须（1.遵守协议 2.实现协议方法）scrollView.delegate = self;// 方法：setContentOffset: 内容偏移量// 说明：方法动画结束时调用 scrollViewDidEndScrollingAnimation:(仅当animated设置为YES时才调用)[self.scrollView setContentOffset:offset animated:YES]; 简明注解：对于 UIScrollView 最重要的属性 contentSize、 contentOffset、 contentInset，要有正确的认知。 这个图很能说明，这三个属性的区别： 解答上面问题：苹果设计的代理属性为什么是weak？ 上图注解： 原因：防止造成循环引用 说明： rootViewController 指针指向控制器对象（每个控制器都有个View 被 强引用）–&gt; UIView对象（强引用 内部 属性 subViews）–&gt; 子控件数组对象（强引用 假设scr对象在第0位）–&gt; UIScrollView对象将ViewController设置为自己的代理（delegate），所以的用 弱引用 weak。 假设没有指针指向这个控制器，而delegate(weak弱引用) 没有强指针引用，控制器就会释放。 UIScrollView代理方法 滑动代理方法相关123456789101112131415161718192021222324252627282930313233343536373839@protocol UIScrollViewDelegate&lt;NSObject&gt;@optional (可选)#pragma mark ------------------#pragma mark - 滑动代理方法相关/** 当scrollView的contentOffset发生变化时调用 */- (void)scrollViewDidScroll:(UIScrollView *)scrollView; // any offset changes// called on start of dragging (may require some time and or distance to move)/** 用户即将开始拖拽scrollView是调用(注: 该方法可能需要先滑动一段时间或距离才会被调用) */- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;// called on finger up if the user dragged. velocity is in points/millisecond. targetContentOffset may be changed to adjust where the scroll view comes to rest/** 用户即将停止拖拽时调用(注: 应用程序可以通过修改targetContentOffset参数的值来调整内容视图content view停止的位置) */- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset NS_AVAILABLE_IOS(5_0);// called on finger up if the user dragged. decelerate is true if it will continue moving afterwards/** 用户已经停止拖拽时调用(注: 如果内容视图content view在停止拖拽后但由于惯性会继续滚动，减速,则decelerate参数为YES) */- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;/** 将要开始减速时调用(仅当停止拖拽后继续移动时才会被调用) */- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView; // called on finger up as we are moving/** 已经结束减速时调用(仅当停止拖拽后继续移动时才会被调用) */- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; // called when scroll view grinds to a halt/** 当-setContentOffset:animated:/-scrollRectVisible:animated:方法动画结束时调用(仅当animated设置为YES时才调用) */- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView; // called when setContentOffset/scrollRectVisible:animated: finishes. not called if not animating/** 返回是否允许点击状态栏让scrollView滑动到顶部,如果未实现该方法,则默认为YES(仅当scrollsToTop属性为YES时才调用) */- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView; // return a yes if you want to scroll to the top. if not defined, assumes YES/** 当scrollView已经滑动到顶部时调用(仅当点击状态栏让scrollView滑动到顶部才调用) */- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView; // called when scrolling animation finished. may be called immediately if already at top 缩放代理方法相关12345678910111213#pragma mark ------------------#pragma mark - 缩放代理方法相关/** 当缩放比例更改时调用 */- (void)scrollViewDidZoom:(UIScrollView *)scrollView NS_AVAILABLE_IOS(3_2); // any zoom scale changes/** 参与缩放的子视图 */- (nullable UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView; // return a view that will be scaled. if delegate returns nil, nothing happens/** 将要开始缩放时调用 */- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view NS_AVAILABLE_IOS(3_2); // called before the scroll view begins zooming its content/** 已经结束缩放时调用 */- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view atScale:(CGFloat)scale; // scale between minimum and maximum. called after any 'bounce' animations@end 部分代理方法简明示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#pragma mark ------------------#pragma mark - UIScrollViewDelegate// 只要scrollView滚动就会调用该方法- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; //由于该方法在视图滚动中一直调用，所以不要在这里做耗时的计算 NSLog(@"视图正在滚动----");&#125;// 用户即将开始拖动时,停止定时器- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123; NSLog(@"滚动视图内容即将被拖动");&#125;// 用户即将停止拖动时调用- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123; NSLog(@"滚动视图的内容即将停止拖动"); &#125;// 用户已经停止拖动时调用 (decelerate 指定是否有减速动作 Dragging 拖)- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; if (decelerate == NO) &#123; NSLog(@"用户已经停止拖动,停止滚动"); &#125;else&#123; NSLog(@"用户已经停止拖动,但是由于惯性会减速滚动"); &#125;&#125;// 手动滚动 减速完毕会调用(停止滚动),开启定时器// 只要设置了scrollView的分页显示，当手动(使用手指)滚动结束后，该代理方法会被调用- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; NSLog(@"减速结束,内容视图停止");&#125;// 指定在scollView上哪一个视图被缩放-(UIView*)viewForZoomingInScrollView:(UIScrollView *)scrollView&#123; //NSLog(@"346"); return [scrollView.subviews objectAtIndex:0]; &#125;// 只要scrollView缩放就会调用该方法- (void)scrollViewDidZoom:(UIScrollView *)scrollView&#123; //由于该方法在视图缩放中一直调用，所以不要在这里做耗时的计算 NSLog(@"视图正在缩放----");&#125; UIScrollView处理触摸事件原理 当用户在UIScrollView的一个子视图上按下时，UIScrollView并不知道用户是想要滑动内容视图还是点击对应子视图，所以在按下的一瞬间，事件UIEvent从UIApplication传递到UIScrollView后，其会先将该事件拦截而不会立即传递给对应的子视图,同时开始一个150ms的倒计时，并监听用户接下来的行为 当倒计时结束前，如果用户的手指发生了移动，则直接滚动内容视图，不会将该事件传递给对应的子视图; 当倒计时结束时，如果用户的手指位置没有改变，则调用自身的-touchesShouldBegin:withEvent:inContentView:方法询问是否将事件传递给对应的子视图(如果返回NO，则该事件不会传递给对应的子视图,如果返回YES，则该事件会传递给对应的子视图，默认为YES)。 当事件被传递给子视图后,如果手指位置又发生了移动，则调用自身的-touchesShouldCancelInContentView:方法询问是否取消已经传递给子视图的事件。 常见需求示例 &amp; 原理解析 导航栏半透明效果原理解析: 默认情况下，在有UINavigationBar存在时，系统为了防止UIScrollView被遮挡，其contentInset和scrollIndicatorInsets属性都会被设置为UIEdgeInsetsMake(64, 0, 0, 0);在有UITabBar存在时，系统为了防止UIScrollView被遮挡，其contentInset和scrollIndicatorInsets属性都会被设置为UIEdgeInsetsMake(0, 0, 49, 0) 因此，为了使用此种半透明效果，可以直接将UIScrollView的frame设置为整个屏幕的大小。 注1: 系统只在UIScrollView是控制器视图的第0个子视图时才会自动修改contentInset和scrollIndicatorInsets属性。 注2: 如果不想让系统自动修改contentInset和scrollIndicatorInsets属性，可以设置self.automaticallyAdjustsScrollViewInsets = NO; 控件导航悬停原理解析: 通过-scrollViewDidScroll:代理方法跟踪contentOffset的的变化,当不满足悬停条件时，待悬停控件属于UIScrollView的子视图，当满足悬停条件时，待悬停控件属于UIScrollView的父视图的子视图。 12345678910111213141516171819- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; if (scrollView.contentOffset.y &gt;= 100) &#123; CGRect rect = label.frame; rect.origin.y = 0; label.frame = rect; [self.view addSubview:label]; &#125; else &#123; CGRect rect = label.frame; rect.origin.y = 100; label.frame = rect; [scrollView addSubview:label]; &#125;&#125; 下拉头部图片放大原理解析: 通过-scrollViewDidScroll:代理方法跟踪contentOffset的的变化,根据contentOffset动态设置图片的缩放比例。 12345678// 以"动态修改图片缩放比例于1倍和2倍之间"为例- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat scale = 1 - (scrollView.contentOffset.y / 100); scale = (scale &gt;= 1) ? scale : 1; scale = (scale &lt;= 2) ? scale : 2; imageView.transform = CGAffineTransformMakeScale(scale, scale);&#125; 正反无限轮播（3张）原理解析: 手动滚动：只创建三张图片： leftImageView、centerImageView、rightImageView，定义中间显示页码为 centerPage ，设置初始self.centerPage = 0;，而左右图片页码都以 centerPage 表示，通过 scrollViewDidEndDecelerating: 方法判断contentOffsest.x 和 scrollView.frame.size.width 比较，使改变 self.centerPage的值，然后对应页码滚动取数组中的图片，始终显示中间一张。 定时器滚动： 将定时器添加到 Runloop 的 NSRunLoopCommonModes下，触发方法中设置setContentOffset: animated:YES 方法动画结束时调用 scrollViewDidEndScrollingAnimation:(仅当animated设置为YES时才调用)，这个方法下 self.centerPage++;。OK了 监听图片点击当图片被点击的时候，我们往往需要执行某些操作，因此需要监听图片的点击，思路如下： 1.定义一个block属性暴露给外界void(^LNBlock)(NSInteger index)，（不会block的可以用代理，或者看这里 Block模式详解）。 2.设置centerImageView的userInteractionEnabled为YES。 3.给scrollView添加一个点击的手势 4.在手势方法里调用block，并传入图片索引 核心代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#pragma mark - 添加三张图片- (void)createContentViews&#123; // 把3张imageView对象添加到scrollView上 CGRect frame = self.bounds; self.leftImageView = [[UIImageView alloc] initWithFrame:frame]; frame.origin.x += ScreenViewW; self.centerImageView = [[UIImageView alloc] initWithFrame:frame]; frame.origin.x += ScreenViewW; self.rightImageView = [[UIImageView alloc] initWithFrame:frame]; [self.scrollView addSubview:self.leftImageView]; [self.scrollView addSubview:self.centerImageView]; [self.scrollView addSubview:self.rightImageView];&#125;#pragma mark - set方法赋值- (void)setCenterPage:(NSInteger)centerPage &#123; _centerPage = centerPage; if (_centerPage &lt; 0) &#123; // 向右滑动显示左面图片,值与0比较 _centerPage = self.imageArray.count - 1; &#125; if (_centerPage &gt; self.imageArray.count - 1) &#123; _centerPage = 0; // 向左滑动显示右面图片,值与count-1 比较 &#125; // Page: left和right用center表示 NSInteger leftPage = _centerPage - 1 &lt; 0 ? self.imageArray.count -1 : _centerPage - 1; NSInteger rightPage = _centerPage +1 &gt; self.imageArray.count - 1 ? 0 : _centerPage + 1; // 赋值 self.leftImageView.image = self.imageArray[leftPage]; self.centerImageView.image = self.imageArray[_centerPage]; self.rightImageView.image = self.imageArray[rightPage]; // 显示中间那一页（注:这里不要使用动画） [self.scrollView setContentOffset:CGPointMake(self.scrollView.frame.size.width, 0)]; // 设置pageControl的页码 self.pageControl.currentPage = _centerPage; &#125;#pragma mark - UIScrollViewDelegate// 手动滚动 减速完毕会调用(停止滚动),开启定时器// 只要设置了scrollView的分页显示，当手动(使用手指)滚动结束后，该代理方法会被调用- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123; // 判断contentOffsest.x if (scrollView.contentOffset.x &gt; scrollView.frame.size.width) &#123; // 下一张 self.centerPage++; &#125; else if (scrollView.contentOffset.x &lt; scrollView.frame.size.width)&#123; // 上一张 self.centerPage--; &#125; [self startTimer]; NSLog(@"手动减速完毕,开启定时器 当前页 %ld",self.centerPage);&#125; UIScrollView底层实现123456789101112131415NS_CLASS_AVAILABLE_IOS(2_0) @interface UIScrollView : UIView &lt;NSCoding&gt;#pragma mark ------------------#pragma mark - 内置手势识别器// Change `panGestureRecognizer.allowedTouchTypes` to limit scrolling to a particular set of touch types./** 拖动手势 */@property(nonatomic, readonly) UIPanGestureRecognizer *panGestureRecognizer NS_AVAILABLE_IOS(5_0);// `pinchGestureRecognizer` will return nil when zooming is disabled./** 捏合手势 */@property(nullable, nonatomic, readonly) UIPinchGestureRecognizer *pinchGestureRecognizer NS_AVAILABLE_IOS(5_0);// `directionalPressGestureRecognizer` is disabled by default, but can be enabled to perform scrolling in response to up / down / left / right arrow button presses directly, instead of scrolling indirectly in response to focus updates./** 定向手势识别器 */@property(nonatomic, readonly) UIGestureRecognizer *directionalPressGestureRecognizer UIKIT_AVAILABLE_TVOS_ONLY(9_0); 总结：UIScrollView 继承自UIView，内部加了手势，之所以可以滑动，是改变了bounds，若手指向上滑动，y++，内容就会向上滑动。这样我们也可以用 给UIView 添加个 Pan手势 实现滚动效果。 正反无限轮播（2张）大致原理：最底层是一个UIView，上面有一个UIScrollView以及UIPageControl，scrollView上有两个UIImageView，imageView宽高 = scrollview宽高 = view宽高; 假设轮播控件的宽度为x高度为y，我们设置scrollview的contentSize.width为3x，并让scrollview的水平偏移量为x，既显示最中间内容。 具体细节请移步这里阅读：轮播两个ImageView实现 http://www.jianshu.com/p/ef03ec7f23b2 参考：iOS控件详解之UIScrollView 正反无限轮播 效果图 附上总结写的小样 Demo，重要的部分代码中都有相应的注解和文字打印，运行程序可以很直观的表现 ！ 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UI控件详解—「UITableView表格视图」]]></title>
    <url>%2FiOSUI%2FUITableView.html</url>
    <content type="text"><![CDATA[引导 “ 本文不适合老司机… ” 本文章将介绍 iOS UI布局 详解，最常使用的三大控件之一 UITableView，将会分成两篇文章完整的讲述UITableView的常用属性方法使用（包括优化方面）及注意点 和 实战开发使用场景案例，文章编写周期会长一些，用到那点实用的东西，会及时补充。 本篇文章主要从【UITableView 属性方法注解】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： 概念1.UITableView的概念2.UITableViewCell的概念3.UITableViewController的概念 UITableView的使用步骤1.大致个人总结六步 UITableView的常用属性 UITableViewCell的常用属性 UITableView的代理方法 UITableViewController的使用 UITableViewCell的重用 UITableViewCell的优化 UITableView重要属性图解 UITableView.h 属性&amp;方法 期待后续 &amp; About me 概念 UITableView的概念 简化可释义为 &quot;表格视图&quot; 或是 &quot;列表视图&quot;， 且 支持选择和编辑的信息。在iOS开发中做列表数据类型的应用，最常用的做法就是使用UITableView控件。 UITbaleView 继承自 UIScrollView，因此支持竖直滚动，而且在 UIScrollView 做了性能优化，当然你也可以做到水平滚动，把cell 旋转一下就可以了。 UITableViewCell的概念 简化意思就是 UITableView的每一行都是一个UITableViewCell。其中类包含属性和方法用于设置和管理单元格； UITableView内部有个默认的子控件：contentView，填充整个UITableViewCell的父控件。 UITableView的子控件实质都在contentView上。 UITableViewController的概念 简化意思就是 这个类是一个自带（管理）tableView 的控制器。 在Xcode 中 cmd UITableViewController 点进去，看到 1NS_CLASS_AVAILABLE_IOS(2_0) @interface UITableViewController : UIViewController 简化意思就是UITableViewController是已经遵循了UITableViewDelegate，UITableViewDataSource代理的控制器 UITableView使用步骤 下面示例以 tableView代码自定义不等高Cell 为例： 第一步：创建 UITableView，采用懒加载方式。 12345678910111213141516- (UITableView *)tableView &#123; if (_tableView == nil) &#123; _tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0,kScreenWidth, kScreenHeight) style:UITableViewStylePlain];// Plain单组数据悬停 Grouped多组数据不悬停 _tableView.dataSource = self;// 数据源 _tableView.delegate = self;// 代理 _tableView.separatorStyle = UITableViewCellSeparatorStyleNone;// 分割线 _tableView.estimatedRowHeight = 100;// 预设高度 //[self.view addSubview:self.tableView];// 这里不要忘记添加上 //--------------------------- tableView 常用属性 ------------------------------// // &#125; return _tableView;&#125; 第二步：设置数据源和代理，遵守对应协议。 1@interface LNTableViewAttributeVC () 第三步：设置数据数组，采用懒加载方式加载数据（使用MJExtension字典数组转模型数组）。 1234567- (NSMutableArray *)dataArray&#123; if (!_dataArray) &#123; _dataArray = [LNStatus mj_objectArrayWithFilename:@"statuses.plist"]; &#125; return _dataArray;&#125; 第四步：创建自定义Cell（视图继承UITableViewCell）。 1.定义模型类对象。 2.定义子控件属性。 3.在initWithStyle:style reuseIdentifier:reuseIdentifier，添加子控件(设置约束Masonry)。 4.在 layoutSubviews 设置子控件的 frame. 5.模型类对象set方法setStatus:设置子控件的数据(赋值)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// LNStatusViewCell.h@class LNStatus;@interface LNStatusViewCell : UITableViewCell/** 模型类对象 */@property (nonatomic, strong) LNStatus *status;@end//--------------------------- &lt;#我是分割线#&gt; ------------------------------//// LNStatusViewCell.m@interface LNStatusViewCell ()/* 头像 */@property (nonatomic, weak) UIImageView *iconImageView;/* 配图 */@property (nonatomic, weak) UIImageView *pictureImageView;/* vip */@property (nonatomic, weak) UIImageView *vipImageView;/* 名称 */@property (nonatomic, weak) UILabel *nameLabel;/** 文字 */@property (nonatomic, weak) UILabel *text_Label;// 自定义控件不要与系统textLabel重名@end@implementation LNStatusViewCell/*1. 添加子控件(设置约束)(如:文字和颜色,一次性的设置) 注意点:把所有有可能显示的子控件都先添加进去 */- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier&#123; if (self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]) &#123; // 图像 // 配图 // vip // 昵称 // 正文 // 自定义分割线 UILabel *lineLabel = [[UILabel alloc] initWithFrame:CGRectZero]; lineLabel.backgroundColor = [UIColor colorWithWhite:0.5 alpha:0.5]; [self.contentView addSubview:lineLabel]; [lineLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.bottom.left.right.equalTo(self.contentView).with.offset(0); make.height.mas_equalTo(1.0f); &#125;]; &#125; return self;&#125;// 2.设置子控件的frame/* - (void)layoutSubviews&#123; [super layoutSubviews]; &#125; */// 3.set方法设置子控件的数据(赋值)- (void)setStatus:(LNStatus *)status&#123; _status = status; self.iconImageView.image = [UIImage imageNamed:status.icon]; self.nameLabel.text = status.name; self.text_Label.text = status.text; if (status.isVip) &#123;// 有无皇冠 self.vipImageView.hidden = NO; self.nameLabel.textColor = [UIColor redColor]; &#125; else &#123; self.vipImageView.hidden = YES; self.nameLabel.textColor = [UIColor blackColor]; &#125; if (status.picture) &#123;// 有无配图(有配图再赋值,无配图就不赋值) self.pictureImageView.hidden = NO; self.pictureImageView.image = [UIImage imageNamed:status.picture]; &#125; else &#123; self.pictureImageView.hidden = YES; &#125; /** 这里的下文会介绍到 */ self.iconImageView.frame = self.status.iconFrame; self.nameLabel.frame = self.status.nameFrame; self.vipImageView.frame = self.status.vipFrame; self.text_Label.frame = self.status.textFrame; self.pictureImageView.frame = self.status.pictureFrame;&#125; 第五步：创建自定义模型类（模型继承NSObject）。 1.定义模型属性。 2.提供构造方法(对象方法和类方法)。 3.定义对应模型frame属性（注解：Cell的动态行高，这里解决方案: 在heightForRowAtIndexPath:这个方法返回之前就要计算cell的高度，即把cell子控件的frame封装到模型中，cellHeight返回行高(相当于懒加载)）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@interface LNStatus : NSObject// 1.定义模型属性/* 文字 */@property (nonatomic, copy) NSString *text;/* 头像 */@property (nonatomic, copy) NSString *icon;/* 名称 */@property (nonatomic, copy) NSString *name;/** VIP 到时候访问的时候可以.vip ,也可以.isVip */@property (nonatomic, assign, getter=isVip) BOOL vip;/* 配图 */@property (nonatomic, copy) NSString *picture;/** 用MJExtension字典转模型框架,下面可以不写 */// 2.提供构造方法//+ (instancetype)statusWithDict:(NSDictionary *)dict;//--------------------------- 返回cell的高度封装 ------------------------------/////** 图像的frame */@property (nonatomic, assign) CGRect iconFrame;/** 昵称的frame */@property (nonatomic, assign) CGRect nameFrame;/** vip的frame */@property (nonatomic, assign) CGRect vipFrame;/** 正文frame */@property (nonatomic, assign) CGRect textFrame;/** 配图的frame */@property (nonatomic, assign) CGRect pictureFrame;/** 返回cell的高度 */@property (nonatomic, assign) CGFloat cellHeight;// LNStatus.m//+ (instancetype)statusWithDict:(NSDictionary *)dict &#123;// // 字典赋值模型属性//&#125;// get方法返回行高(相当于懒加载)- (CGFloat)cellHeight&#123; if (_cellHeight == 0) &#123; /** 图像 */ self.iconFrame = CGRectMake(iconX, iconY, iconWH, iconWH); /** 昵称：字符串自适应宽(昵称文字没有换行) */ self.nameFrame = CGRectMake(nameX, nameY, nameSize.width, nameSize.height); /** vip */ if (self.isVip) &#123; self.vipFrame = CGRectMake(vipX, vipY, vipW, vipH); &#125; /** 正文：字符串自适应宽高(文字有换行) */ self.textFrame = CGRectMake(textX, textY, textW, textH); /** 配图 */ if (self.picture) &#123; // 有配图 self.pictureFrame = CGRectMake(pictureX, pictureY, pictureWH, pictureWH); _cellHeight = CGRectGetMaxY(self.pictureFrame) + space; &#125; else &#123; _cellHeight = CGRectGetMaxY(self.textFrame) + space; &#125; &#125; return _cellHeight;&#125; 第六步：实现DataSource数据源（必须） 和Delegate代理（可选）协议方法创建自定义模型类（模型继承NSObject）。 123456789101112131415161718192021222324#pragma mark ------------------#pragma mark - UITableViewDataSource// TableView中 有多少组Sections// 说明：单组数据可不实现方法，默认返回1- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123; return 1;&#125;// 每组Sections 有多少行Rows- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return self.dataArray.count;&#125;// 每行 cell内容- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 1.cell注册（只要用到forIndexPath:就必须要注册） //[self.tableView registerClass:[LNStatusViewCell class] forCellReuseIdentifier:cellID]; // 2.cell复用队列(访问缓存池) LNStatusViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID forIndexPath:indexPath]; // 3.设置数据(数据数组赋值模型类) cell.status = self.dataArray[indexPath.row]; return cell;&#125; 123456789#pragma mark ------------------#pragma mark - UITableViewDelegate// 解决方案:在这个方法返回之前就要计算cell的高度，即返回cell的高度封装在模型中- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; LNStatus *status = self.dataArray[indexPath.row]; return status.cellHeight;&#125; UITableView基本使用效果图 UITableView常用属性 全局设置行row高： 12345678属性：@property (nonatomic) CGFloat rowHeight;使用格式：self.tableView.rowHeight = 70;说明：默认是44 全局设置区头(区尾)高： 1234567属性：@property (nonatomic) CGFloat sectionHeaderHeight; @property (nonatomic) CGFloat sectionFooterHeight;使用格式：self.tableView.sectionHeaderHeight = 50;self.tableView.sectionFooterHeight = 50; 设置分割线的样式、铺满和颜色： 12345678910111213141516属性：@property (nonatomic) UITableViewCellSeparatorStyle separatorStyle __TVOS_PROHIBITED;@property (nonatomic, strong, nullable) UIColor *separatorColor UI_APPEARANCE_SELECTOR __TVOS_PROHIBITED;@property (nonatomic) UIEdgeInsets separatorInset NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR;使用格式：self.tableView.separatorStyle = UITableViewCellSeparatorStyleSingleLine;self.tableView.separatorColor = [UIColor redColor];self.tableView.separatorInset = UIEdgeInsetsMake(0, 0, 0, 0);说明：设置 StyleNone 代表隐藏分割线，[UIColor clearColor]为透明色对象枚举UITableViewCellSeparatorStyle常用的枚举元素：UITableViewCellSeparatorStyleNone // 隐藏分割线UITableViewCellSeparatorStyleSingleLine // 默认样式UITableViewCellSeparatorStyleSingleLineEtched // 仅支持在grouped样式，但是和默认样式没什么区别 设置tableView表格头(尾)视图： 1234567属性：@property (nonatomic, strong, nullable) UIView *tableHeaderView; @property (nonatomic, strong, nullable) UIView *tableFooterView; 使用格式：self.tableView.tableHeaderView = [[UISwitch alloc] init];self.tableView.tableFooterView = [[UISwitch alloc] init]; 设置table背景视图和颜色： 1234567属性：@property (nonatomic, strong, nullable) UIView *backgroundView NS_AVAILABLE_IOS(3_2);@property (nonatomic, copy, nullable) UIColor *backgroundColor;使用格式：self.tableView.backgroundView = [[UIView alloc] init];self.tableView.backgroundColor = [UIColor grayColor]; 设置TableView的cell的预设高度(性能优化)： 12345678属性：@property (nonatomic) CGFloat estimatedRowHeight NS_AVAILABLE_IOS(7_0);使用格式：self.tableView.estimatedRowHeight = 100;说明：这里的高度也不是越大越好，要适时而定 隐藏多余分割线： 12使用格式：self.tableView.tableFooterView = [[UIView alloc] init]; 设置右侧索引文字和背景颜色： 1234567属性：@property (nonatomic, strong, nullable) UIColor *sectionIndexColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;@property (nonatomic, strong, nullable) UIColor *sectionIndexBackgroundColor NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR; 使用格式：self.tableView.sectionIndexColor = [UIColor grayColor];self.tableView.sectionIndexBackgroundColor = [UIColor yellowColor]; UITableViewCell的常用属性 设置cell附加样式（比如右侧的箭头）： 12345属性：@property (nonatomic) UITableViewCellAccessoryType accessoryType; 使用格式：cell.accessoryType = UITableViewCellAccessoryCheckmark; 设置cell右边的指示控件（比如右侧的开关）： 12345属性：@property (nonatomic, strong) UIView *accessoryView;使用格式：cell.accessoryView = [[UISwitch alloc] init]; 设置cell选中样式(StyleNone选中不变灰色)： 12345属性：@property (nonatomic) UITableViewCellSelectionStyle selectionStyle; 使用格式：cell.selectionStyle = UITableViewCellSelectionStyleNone; 设置cell的背景控件： 12345678910属性：@property (nonatomic, strong) UIView *backgroundView;使用格式：UIView *bg = [[UIView alloc] init];bg.backgroundColor = [UIColor redColor];cell.backgroundView = bg;说明：背景控件 和 背景颜色 同时存在时，(优先级: backgroundView &gt; backgroundColor) 设置cell的背景颜色： 123456789属性：@property(nullable, nonatomic,copy) UIColor *backgroundColor使用格式：cell.backgroundColor = [UIColor blueColor];说明：还可以设置cell的子控件背景图片cell.textLabel.backgroundColor = [UIColor greenColor]; 设置cell选中时背景View： 1234567属性：@property (nonatomic, strong) UIView *selectedBackgroundView;使用格式：UIView *seletedBg = [[UIView alloc] init];seletedBg.backgroundColor = [UIColor purpleColor];cell.selectedBackgroundView = seletedBg; UITableView的代理方法 返回每一行cell的高度： 12345678方法 和 使用格式：- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 获取indexPath// if (indexPath.row%2) &#123;// return 100;// &#125;else return 44;&#125; 当选中某一行cell的时候就会调用这个方法： 1234方法 和 使用格式：- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; NSLog(@"选中第%ld区---第%ld行 ",indexPath.section,indexPath.row);&#125; 返回每一组的区头(区尾) 标题 和 控件： 12345678910111213方法 和 使用格式：// 区头(区尾)标题- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section&#123; return @"简书-ln";&#125;// 区头(区尾)View- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section &#123; return [[UISwitch alloc] init];&#125;说明：标题 和 View 同时存在时，View 会覆盖 Title 返回每一组的头部(尾部)高度： 123456789方法 和 使用格式：- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123; // 获取indexPath NSIndexPath *indexPath = [[NSIndexPath alloc]initWithIndex:section]; if (indexPath.section == 0) &#123; return 60; &#125;else return 30;&#125; 返回右侧索引标题： 12345方法 和 使用格式：-(NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView&#123; //return [self.dataArray valueForKeyPath:@"title"]; return @[@"黄焖鸡小份",@"黄焖鸡中份",@"黄焖鸡大份",];&#125; 返回某一行缩进： 1234方法 和 使用格式：- (NSInteger)tableView:(UITableView *)tableView indentationLevelForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return 7;&#125; UITableViewController的使用 将控制器设置为UITableView的方法和步骤 第一步：创建新的类或修改原有的ViewController类，继承自UITableViewController 第二步：在Main.storyboard中删除自带的UIViewController控制器，然后往里面拖一个UITableViewController控制器 第三步：修改新拖进来的TableViewController控制器的自定义类名为第一步中继承自UITableViewController类的类名 第四步：勾选TableViewController控制器为程序启动第一个加载的控制器 注意点： tableVieController有个tableView属性，指向一个tableView。 tableView的dataSource和delegate属性指向的就是这个控制器，并且这个控制器已经遵守了UITableViewDataSource和UITableViewDelegate。 每个控制器的内部都有一个view属性，在tableVieController中，view和tableView属性指向的是同一个对象（控制器的view就是tableView）。 UITableViewCell的重用 原因： iOS设备的内存有限，如果用 UITableView显示成千上万条数据，就需要成千上万个UITableViewCell对象的话，那将会耗尽iOS设备的内存。 有可能导致显示数据错乱。 原理： 当滚动列表时，部分UITableViewCell会移出窗口，UITableView会将窗口外的UITableViewCell放入一个缓存池中，等待重用 当UITableView要求dataSource返回UITableViewCell时，dataSource会先查看这个对象池，如果池中有未使用的UITableViewCell，dataSource会用新的数据配置这个UITableViewCell，然后返回给UITableView，重新显示到窗口中，从而避免创建新的UITableViewCell对象 Cell重用的实现代码 方法一： 1.定义一个cell的重用标识 2.根据这个ID去缓存池中看有没有可循环利用的cell 3.如果缓存池中没有可循环利用的cell，自己创建 123456789101112- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 1. 定义一个重用标识 static NSString *cellID = @"cellID"; // 2. 根据这个cellID去缓存池中看有没有可循环利用的cell UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cellID"]; // 3. 如果缓存池中没有可循环利用的cell, 自己创建 if (cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"cellID"]; &#125; return cell;&#125; 方法二： 1.定义一个cell的重用标识。 2.根据这个ID去缓存池中看有没有可循环利用的cell。 3.如果缓存池中没有会看有没有，根据ID这个标识注册对应的cell类型。 4.如果有注册，会根据这个ID创建对应的类型的cell，并且会绑定这个ID标识，返回这个cell。 12345678910111213141516171819202122// 1. 定义一个重用标识static NSString *cellID = @"CellID";static NSString *testID = @"testID";- (void)viewDidLoad &#123; [super viewDidLoad]; // 3. 根据ID 这个标识 注册 对应的cell类型是UITableViewCell [self.tableView registerClass:[LNTableViewCell class] forCellReuseIdentifier:cellID]; [self.tableView registerNib:[UINib nibWithNibName:NSStringFromClass([LNTableViewXibCell class]) bundle:nil] forCellReuseIdentifier: testID];&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; // 2. 根据这个ID去缓存池中看有没有可循环利用的cell LNTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (indexPath.row%2 == 0) &#123; LNTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier: CellID]; return cell; &#125;else&#123; LNTableViewXibCell *cell = [tableView dequeueReusableCellWithIdentifier:testID]; return cell; &#125;&#125; 总结： 不同类型的Cell共存（重要点是CellID不同）。 UITableViewCell的优化 UITableView 的优化主要从三个方面入手： 1.提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法； 2.异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口； 3.滑动时按需加载，按照用户滚动的速度去选择加载哪个cell。这个在大量图片展示，网络加载的时候很管用！（SDWebImage已经实现异步加载，配合这条性能杠杠的）。 除了上面最主要的三个方面外，还有很多几乎大伙都很熟知的优化点： 1.正确使用reuseIdentifier来重用Cells。 2.尽量使所有的view opaque，包括Cell自身。 3.尽量少用或不用透明图层。 4.如果Cell内显示的内容来自web，使用异步加载，缓存请求结果。 5.减少subviews的数量。 6.在heightForRowAtIndexPath:中尽量不使用。cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果。 7.尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示。 案例（按需加载）： 原理：在快速滑动松手后滚动的cell个数超过预定的个数，只显示最后出现的cell的前三个cell，把这三个cell的indexPath存到数组中，在数据源方法里判断如果数组count&gt;0，且数组不包含当前的indexPath，那就说明此cell是在快速滑动中需要隐藏的： 123456789101112131415161718192021//按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123; NSIndexPath *ip = [_titleTableView indexPathForRowAtPoint:CGPointMake(0, targetContentOffset-&gt;y)]; NSIndexPath *cip = [[_titleTableView indexPathsForVisibleRows] firstObject]; NSInteger skipCount = 1; // 这里我为了方便演示写的1，大家可以按需求自行设定 if (labs(cip.row-ip.row)&gt;skipCount) &#123;// 此方法可以获取将要显示的组// visibleSections = [NSSet setWithArray:[[_titleTableView indexPathsForVisibleRows] valueForKey:@"section"]]; NSArray *temp = [_titleTableView indexPathsForRowsInRect:CGRectMake(0, targetContentOffset-&gt;y, _titleTableView.frame.size.width, _titleTableView.frame.size.height)]; NSMutableArray *arr = [NSMutableArray arrayWithArray:temp]; if (velocity.y&lt;0) &#123; // 上滑 NSIndexPath *indexPath = [temp lastObject]; if (indexPath.row+33) &#123; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-3 inSection:indexPath.section]]; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-2 inSection:indexPath.section]]; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-1 inSection:indexPath.section]]; &#125; &#125; [needLoadArr addObjectsFromArray:arr]; &#125;&#125; 相应的，每次开始拖动的时候去清空数组。还有种情况，如果界面上有显示空白cell的时候突然手动停止滚动呢? 123456789101112- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView &#123; [needLoadArr removeAllObjects]; // 清空数组 // 取到当前界面上能显示的indexPaths，判断是否有隐藏 NSArray *indexpaths = [_titleTableView indexPathsForVisibleRows]; UITableViewCell *firstCell = [_titleTableView cellForRowAtIndexPath:indexpaths.firstObject]; UITableViewCell *lastCell = [_titleTableView cellForRowAtIndexPath:indexpaths.lastObject]; // 在当前可见的区域中，第一个cell或者最后一个cell是隐藏状态，那么重新加载可见区域内的cell if (firstCell.isHidden == true || lastCell.isHidden == true) &#123; [_titleTableView reloadRowsAtIndexPaths:indexpaths withRowAnimation:UITableViewRowAnimationNone]; &#125;&#125;也可以把判断的代码写在scrollView停止滚动监听方法里，但是个人觉得没必要，因为这种情况必定是手动触碰去停止的，这里处理没问题 数据源方法： 12345678 if (needLoadArr.count &gt; 0) &#123; if (![needLoadArr containsObject:indexPath]) &#123;// NSLog(@"该cell是快速滑动中的cell，所以隐藏"); cell.hidden = true; return cell; &#125; &#125; cell.hidden = false; // 正常显示的cell 附上：按需加载参考 VVeboTableViewDemo： 这位前辈在tableView优化上做到了极致。 总结：tableView性能优化的方式有很多，但不是所有的我们都需要。比如不是必需要显示的界面，预先计算行高就是浪费（用户流量）。应适时而定。站在用户体验的角度开发才是好的伐码猿。 UITableView重要属性图解 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 源代码管理「SVN & Git」续更]]></title>
    <url>%2FToolsAndPlugins%2FSVNGit.html</url>
    <content type="text"><![CDATA[Write in the first 开发过程中离不开源代码的管理，目地：为了解决在软件开发过程中，由源代码引发的各种蛋疼、繁琐的问题。目前开发使用较广的 版本控制系统「Git &amp; SVN」，后续会单开一篇总结正在使用的【强大的 Git 客户端：SourceTree】。 本篇文章主要从使用者角度【Git &amp; SVN 详解使用】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： 源代码管理认知 源代码管理 SVN 详解使用 SVN 基础知识概念2.SVN 客户端实用命令3.SVN 客户端实用示例4.「SVN–&gt;branch &amp; tag」分支和标签5.SVN ST 显示的文件状态 源代码管理 Git 详解使用1.Git基础知识概念2.Git 几个核心概念3.Git 工作原理 / 流程4.Git 客户端实用命令5.「Git–&gt;branch &amp; tag &amp; remote」分支、标签和远程6.Git 客户端实用示例 SVN &amp; Git 两者比较 码农们踩过的坑整理（持续~） 源代码管理认知 下面简单几点总结，来给初学者快速对源代码管理有个认知； 为什么会出现源代码管理工具 ？ 为了解决在软件开发过程中，由源代码引发的各种蛋疼、繁琐的问题。 源代码会引发哪些问题 ？ 无法后悔：做错了一个操作后，某些情况下无法返回，没有后悔药可以吃。 版本备份：费空间、费时间。 版本混乱：因版本备份过多造成混乱，难于找回正确的想要的版本。 代码冲突：多人操作同一个文件（团队开发中的常见问题）。 权限控制：无法对源代码进行精确的权限控制。 追究责任：出现了严重的 BUG，无法定位到负责人，容易耍赖。 源代码管理工具的作用是 ？ 能追踪一个项目从诞生一直到定案的过程。 记录一个项目的所有内容变化。 方便地查阅特定版本的修订情况。 温馨提示： 如果是团队开发，使用源代码管理工具是强制性的！ 如果是单人开发，也强烈建议现在就开始使用源代码管理工具。 源代码管理 SVN 详解使用 基础知识概念 SVN是集中式控制系统，需要一个中央服务器。 Repository 代码仓库，保存代码的仓库。 Server 服务器，保存所有版本的代码仓库。 Client 客户端，只保存当前用户的代码仓库。 用户名&amp;密码 访问代码仓库需要使用自己的 “用户名和密码”，从而可以区分出不同的人对代码做的修改。 SVN 客户端实用命令 svn checkout「简写svn co」：将服务器上最新的代码仓库下载到本地（只需要做一次）。 svn update「简写svn up」：从服务器上将其他人所做的修改下载到本地 （每天上班必须要做的事情）。 svn commit「简写svn ci」：将改动的文件提交到服务器（每天下班之前至少做一次）。 svn add：向本地的版本控制库中添加新文件。 svn delete、svn remove「简写svn del、svn rm」：从本地的版本控制库中删除文件。 svn move：移动文件或者目录或文件更名 svn mkdir：创建纳入版本控制下的新目录 svn revert：撤销之前的一切修改 svn merge：将两个版本之间的差异合并到当前文件 svn info：查看文件的详细信息。 svn diff：查看不同版本的区别。 svn log：查看日志信息。 svn list：列出版本库下的文件和目录列表。 svn status「简写svn st」：查看文件状态。 svn help：获取帮助信息（比如 svn help ci）。 svn lock：加锁。 svn unlock：解锁。 SVN 客户端实用示例检出： 去到公司的第一天，将项目检出（下载）至本地。svn checkout URL[PATH]svn co URL[PATH] 注意： 这里的中括号[ ]代表可选（可以省略）。 URL：代码仓库的远程地址。 [PATH]：将代码下载到本地的哪个路径（如果省略本地的路径，就下载到命令行当前所在的路径）。 提交： 将改动过的旧文件提交至服务器。svn commit-m &quot;注释&quot;[PATH]svn ci-m &quot;注释&quot;[PATH] 注意： 一定要养成写注释的良好习惯。 “注释”：”修改了User.m文件”。 [PATH]：代表是 提交哪个文件到服务器（如果省略路径，就将命令行所在路径中所有改动过的文件提交到服务器）。 添加： 提交一个新建的文件到服务器，需要2个步骤。 添加新建的文件到本地的版本控制库中：svn add。 提交刚才的添加操作到服务器：svn commit。 将文件添加到本地的版本控制库。svn add PATH PATH：代表是 添加哪个文件到版本控制库中。 删除： 删除服务器上的某个旧文件，需要做2个步骤。 将文件从本地的版本控制库中移除：svn delete、svn remove。 提交刚才的删除操作到服务器：svn commit。 将文件从本地的版本控制库中移除。svn delete PATH PATH：代表是 将哪个文件从版本控制库中移除。 更新： 将服务器上其他同事提交的，最新代码更新到本地。svn update [PATH] PATH：代表是 更新哪个文件的内容（如果省略路径，就更新命令行所在路径的所有内容）。 回滚： 改动没有被提交。这种情况下，使用svn revert就能取消之前的修改。当为单个文件时，直接svn revert 文件就行了；当为目录时，需要加上参数-r (Recursive,递归)，否则只会将改文件这个目录的改动。 改动已经被提交。这种情况下，用svn merge命令来进行回滚。先运行svn up保证拿到最新的版本，然后svn log查看并找到要回滚的版本号，如果想要更详细的了解情况，可以使用svn diff -r HEAD:2500 [文件]（回滚到版本号2500），此处的 [ ] 可以是文件、目录或整个项目。 「SVN–&gt;branch &amp; tag」分支和标签 SVN 官方推荐在一个版本库的根目录下先建立trunk、branches、tags这三个文件夹，其中 trunk 是开发主干，存放日常开发的内容；branches 存放各分支的内容，比如为不同客户定制的不同版本；tags 存放某个版本状态的标签。branhces和tags本质没有区别，都是通过svn copy方式建立的，差异在于通常branches中的内容是需要继续修改或开发的，tags中的内容是存放不再修改的，这一般通过权限设置来解决，tags通常只给管理员开放写权限。 12345678910111213141516171.新建分支svn copy master_repository_url branch_repository_url -m "your comments"2.新建空白分支svn mkdir branch_repository_url3.删除分支svn rm branch_repository_url -m "your comments"4.新建tagsvn copy master_repository_url tag_repository_url -m "your comments"5.删除tagsvn rm tag_repository_url -m "your comments"6.查看branchessvn ls ^/branches --verbose 分支与主干的合并：1234567891011121314151617181920# 分支合到主干 cd trunksvn merge -r &lt;revision where branch was cut&gt;:&lt;revision of trunk&gt; svn://branch/path# 分支当前版本为4847，想把4825到4847间的改动merge到主干# cd trunksvn merge -r 4825:4847 svn://branch/pathsvn ci -m "merge branch changes r4835:4847 into trunk"# 主干合到分支 cd branch# 在r23创建了一个分支，trunk版本号更新到了25，想把23-25之间的改动merge到分支svn merge -r 23:25 svn://trunk/pathsvn ci -m "merge trunk changes r23:25 into my branch"# cd trunk# 查看当前Branch中已经有那些改动已经被合并到Trunk中svn mergeinfo svn://branch/path# cd trunk# 查看Branch中那些改动还未合并svn merginfo svn://branch/path --show-revs eligible merge分支B到分支A12345step1: Checkout URL A # cd branch Astep2: merge URL B to your working copy of A svn merge -r 10:HEAD http://branch-b .step3: Commit A 冲突提示123456(p) postpone 暂时推后处理，我可能要和那个和我冲突的家伙商量一番(df) diff-full 把所有的修改列出来，比比看(e) edit 直接编辑冲突的文件(mc) mine-conflict 如果你很有自信可以只用你的修改，把别人的修改干掉(tc) theirs-conflict 底气不足，还是用别人修改的吧(s) show all options 显示其他可用的命令 SVN ST 显示的文件状态 &#39; &#39; 没有修改。 A 被添加到本地代码仓库。 C 冲突。 D 被删除。 I 被忽略。 M 被修改。 R 被替换。 X 外部定义创建的版本目录。 ? 文件没有被添加到本地版本库内。 ! 文件丢失或者不完整（不是通过svn命令删除的文件）。 ~ 受控文件被其他文件阻隔。 U 服务器收到文件更新了 G 本地文件以及服务器文件都已更新,而且成功的合并了 源代码管理 Git 详解使用 基础知识概念 git是一款开源的分布式版本控制工具。 在世界上所有的分布式版本控制工具中，git是最快、最简单、最流行的。 作者是Linux之父：Linus Benedict Torvalds。 当初开发git仅仅是为了辅助Linux内核的开发（管理源代码）。 Git 几个核心概念 工作区（Working Directory）：仓库文件夹里除.git目录以外的内容。 版本库（Repository）：.git目录，用于存储记录版本信息。 暂存区（stage） 分支（master）：git自动创建的第一个分支。 HEAD指针：用于指向当前分支。 Git 工作原理 / 流程 git add：将工作区文件修改添加到暂存区。 git commit：将暂存区的所有内容提交到当前分支（提交区）。 git push：将提交区内容 推送到服务器上。 git pull：从服务器上更新文件。 Git 客户端实用命令 1.git clone：从服务器上克隆(下载)最新的代码到本地。 2.git init：初始化本地仓库(在当前目录新建代码库)，也可以 git init Desktop/GitCode(在指定位置创建代码库) ，如果使用了git clone不用使用此命令。 3.git config：配置用户名和邮箱。 12345678910git config --global user.name "GO_ln"git config --global user.email "xxx @xx.com"``` - 4.`add`：将工作区的文件提交到暂存区。```objc// 添加指定文件git add GitTest/GitTest/ViewController.m// 添加本地库所有文件git add . 5.git commit：提交信息。 123456781.git commit -m 将暂存区的内容提交到提交区// 提交所有git commit -m "日志"// 提交某一个文件git commit GitTest/GitTest/ViewController.m -m"修改VC"2.把工作区中的内容提交到暂存区并从暂存区中提交到提交区git commit -am “提交信息” 6.git status：查看当前 git 的状态。 7.git push：将提交区内容 推送到服务器上。 8.checkout：撤销某次提交的某个文件。 1git checkout 8989920311bacb3f4e3ced7f82ab75ca47c318c7 GitTest/GitTest/ViewController.m 9.revert：撤销某一次提交。 1git revert 8989920311bacb3f4e3ced7f82ab75ca47c318c7 10.checkout HEAD：放弃本地某一文件的修改。 1git checkout HEAD GitTest/GitTest/ViewController.m 11.git reset：回退到某个版本并保存未追踪的改动。(通过log来查询) 1git reset 8989920311bacb3f4e3ced7f82ab75ca47c318c7 12.git reset --hard HEAD：放弃本地全部修改。 13.git reset --keep：回退到某个版本并保存未提交的改动。 1git reset --keep 8989920311bacb3f4e3ced7f82ab75ca47c318c7 14.log：查看提交日志。 15.git show：查看每次提交的具体内容。 16.diff：查看追踪文件的差异。 1234// 查看追踪文件的差异git diff// 查看某一文件的差异git diff GitTest/GitTest/ViewController.m 17.rm：删除文件。 1git rm GitTest/GitTest/ViewController.m 18.mv：修改某一个文件的名字。 12// 注意，路径要对应，否则会自动移动git mv GitTest/GitTest/ViewController.m GitTest/GitTest/View.m 19.blame：查看文件被谁修改。 1git blame GitTest/GitTest/ViewController.m 「Git–&gt;branch &amp; tag &amp; remote」分支、标签和远程 branch：分支。 12345678910111213141516171819202122232425262728293031// 查看本地分支git branch// 查看远程分支git branch -r// 查看远程和本地分支git branch -a// 创建本地分支，但是不切换git branch branch1// 新建一个分支并切换git checkout -b branch2// 新建一个分支，指向指定commitgit branch branch3 8989920311bacb3f4e3ced7f82ab75ca47c318c7// 新建一个分支，与指定的远程分支建立追踪关系git branch --track branch4 origin/master// 切换到指定分支，并更新工作区git checkout branch4// 切换到上一个分支git checkout -// 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream branch3 origin/master// 合并指定分支到当前分支git merge branch2// 选择一个commit，合并进当前分支git cherry-pick 8989920311bacb3f4e3ced7f82ab75ca47c318c7// 删除分支git branch -d branch1// 删除远程分支git push origin --delete branch1git branch -dr branch1// 将当前分支push到指定远程分支git push origin HEAD:branch1 tag：标签。 12345678910111213141516// 列出所有taggit tag// 新建一个tag在当前commitgit tag 1// 新建一个tag在指定commitgit tag 2 8989920311bacb3f4e3ced7f82ab75ca47c318c7// 删除本地taggit tag -d 1// 查看tag信息git show 2// 提交所有taggit push --tags// 删除远程taggit push origin --delete tag 2// 新建一个分支，指向某个taggit checkout -b [branch] [tag] remote：远程。 123456789101112// 查看远程库的地址列表git remote -v// 查看这个远程库的信息git remote show origin// 从远程库更新所有的信息到本地，但是不合并git fetch origin// 从远程库更新所有的信息到本地，但是不合并并清理已删除的远程分支git fetch -p origin// 从远程库更新数据并立即合并数据git pull origin branch1// 将本地数据同步到远程库中git push origin branch1 Git 客户端实用示例 1、示例：将本地代码提交到 GitHub 上。前期准备： cd Desktop/git（桌面文件夹） git clone https://github.com/CustomPBWaters/liunDemo.git（仓库的URL） cd liunDemo(github上建的文件夹) 把要上传的Demo放到建的桌面 git 文件夹里。 ls -a 会提示下步操作。 git commit -am CoreDataDemo，这里的CoreDataDemo是我本地的Demo。 12git add CoreDataDemo 把工作区的内容提交到暂存区git commit -m CoreDataDemo 把暂存区中的内容提交到提交区 git status 查看提交状态。 这时第一次提交，会让输入GitHub用户名密码。 git push 将文件推送到服务器上。 注意：要传得Demo项目中，有的含隐藏文件.git，需要删除 rm -rf .git，再上传就可以了。 2、示例：解决冲突（手动解决）。打开冲突文件，删除&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt; branch1这三行再修改成想要的，添加，提交即可。 SVN &amp; Git 两者比较 SVN &amp; Git特点 结构(最主要的区别) SVN是集中式管理，Git是分布式管理 速度 在很多情况下，git的速度远远比SVN快 难度 SVN功能简单，指令简单，入门容易。Git功能完善，指令复杂，入门简单掌握难 其他 SVN使用分支比较笨拙，git可以轻松拥有无限个分支 SVN必须联网才能正常工作，git支持本地版本控制工作 旧版本的SVN会在每一个目录置放一个.svn，git只会在根目录拥有一个.git 补充集中式版本控制 在分布式下开发者可以本地提交。 每个开发者机器上都有一个服务器的数据库。 从稳定可靠的角度来看，分布式肯定是更好的选择。 总结 这两个版本控制一直持续到现在，两者都有其优点和缺点。 个人认为两者没有绝对的优势，能够取代另一方。 但是从功能上来讲，Git 拥有SVN大致所有的功能，还拥有更多可靠，便捷，个性化的指令方便操作。 就剩最后一句话了，没错，想要复杂的功能，就要承受学习的代价。 码农们踩过的坑整理（持续~） 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>工具&amp;插件</category>
      </categories>
      <tags>
        <tag>工具&amp;插件</tag>
        <tag>SVNGit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 常用绘图—「drawRect绘制矩形」]]></title>
    <url>%2FiOSNET%2FdrawRect.html</url>
    <content type="text"><![CDATA[Write in the first 关于绘图，其实在我当前接触的项目中用得很少，但是以后肯定会接触到。像这种不常用但比较重要的内容，我觉得要做到初步理解，然后梳理总结，到最后夯实基础、活学活用。所以写这篇文章。 iOS 系统本身提供了两大绘图的框架，即 UIKit 和 Core Graphics。UIKit：像 UIImage（绘制图像）、NSString（绘制文本）、UIBezierPath（绘制形状）、UIColor。 这些类提供了功能有限但使用方便的方法来让我们完成绘图任务。一般情况下，UIKit就是我们所需要的。 Core Graphics：CoreGraphics也称为Quartz 2D 是UIKit下的主要绘图系统，频繁的用于绘制自定义视图。Core Graphics是高度集成于UIView和其他UIKit部分的。Core Graphics数据结构和函数可以通过前缀CG来识别。 本篇文章主要从【iOS绘图 drawRect】学习总结，在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： 绘图基本概念 我是Core Graphics绘图 UIBezierPath绘图概念 我是UIKit 之 UIBezierPath绘图 期待 &amp; 后续 绘图基本概念在学习绘图之前，我们先来了解一下几个基本的概念 属性 描述 drawRect:(CGRect)rect 作用：专门用来绘图 什么时候调用：当View显示的时候调用(ViewWillAppear和ViewDidAppear之间) 参数rect：当View的bounds，Note: 在drawRect方法当中系统已经帮你创建一个跟View相关联的上下文(Layer上下文),只要获取上下文就可以了 什么操作调用：1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。2、该方法在调用sizeThatFits后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。 Context 定义：图形上下文，是一个CGContextRef类型的数据，你可以将图形上下文理解为一块画布 作用：1、保存绘图信息，绘图状态；2、决定绘制的输出目标（绘制到什么地方去？// 输出目标可以是PDF文件、Bitmap或者显示器的窗口上）3、相同的一套绘图序列，指定不同的 Graphics Context,就可将相同的图像绘制到不同的目标上 path 路径，ios绘图可以想象为你拿着一支笔去画图，画几条线或几个点从而形成一个路径，之后可以利用理解去填色或者描边 stroke、fill 描边和填充，每个路径都需要填充或者描边后才能在视图中看见，他们都各自有很多样式可以设置，常见的有颜色、粗细、渐变，连接样式等等。 了解完上面的几个概念之后，我想 我们先不着急写的，首先你的知道你想实现什么效果用到什么属性值，及对属性值意思的理解。然后再结合下面的代码 就更容易理解和吸收了 Core Graphics绘图属性 描述 UIGraphicsGetCurrentContext() 获取上下文 CGContextMoveToPoint(ctx, x, y) 设置起始点 CGContextAddLineToPoint(ctx, x, y) 添加一根线到终点 CGContextAddLines(ctx, points, count) 添加线(点之间) 参数：points点数组，count数组个数 CGContextAddEllipseInRect(ctx, CGRect rect) 画椭圆，如果长宽相等就是圆 CGContextAddRect(ctx, CGRect rect) 画矩形，长宽相等就是正方形 [image drawInRect:CGRect rect] 画图片 [@”hello world” drawInRect:CGRect rect withAttributes:NSDictionary *dict] 画文字 (属性值：NSFontAttributeName字体大小、NSForegroundColorAttributeName字体颜色) CGContextAddArc(ctx, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, int clockwise) 画圆 参数：圆心的x坐标，圆心的y坐标，圆的半径，开始弧度，结束弧度，0表示顺时针 1表示逆时针 CGContextAddQuadCurveToPoint(ctx, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y); 二次曲线函数 参数：控制点 x坐标，控制点 y坐标，终点 x坐标，终点 y坐标 Note:这里使用必须要设置起点MoveToPoin CGContextAddCurveToPoint(ctx, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y) 三次曲线函数 参数：控制点1 x y坐标，控制点2 x y坐标，终点 x坐标，终点 y坐标 Note:这里使用必须要设置起点MoveToPoin CGContextStrokePath(ctx) 渲染上下文（Stroke描边,空心） CGContextFillPath(ctx) 渲染上下文（Fill填充,实心） CGContextDrawPath(ctx, CGPathDrawingMode mode) 渲染上下文 mode：1、kCGPathFill 只有填充（非零缠绕数填充），不绘制边框 2、kCGPathEOFill 奇偶规则填充（多条路径交叉时，奇数交叉填充，偶交叉不填充）3、kCGPathStroke 只有边框 4、kCGPathFillStroke 既有边框又有填充 5、kCGPathEOFillStroke 奇偶填充并绘制边框 其他属性设置 CGContextSetStrokeColorWithColor(ctx, Color) 设置线颜色 CGContextSetFillColorWithColor(ctx, Color) 设置填充色 CGContextSetLineWidth(ctx, CGFloat width); 设置线宽度 CGContextSetLineJoin(ctx, CGLineJoin join) 设置连接样式（kCGLineJoinMiter尖的、斜接, Round圆, Bevel斜面） CGContextSetLineCap(ctx, CGLineCap cap) 设置顶角样式（kCGLineCapButt, Round, Square） CGContextSetLineDash(ctx, CGFloat phase, lengths, count) 设置虚线样式（参数：phase虚线从那开始绘制；lengths C语言的数组,举个例子: 声明一个数组 CGFloat dash[] = @{3.0, 1.0}意思就是长度为3.0 间隙长度为1.0,以此类推；count lengths数组的个数） 示例代码：自定义View的步骤新建一个类,继承UIView实现- (void)drawRect:(CGRect)rect方法 我是Core Graphics绘图 1、获取上下文2、绘制路径3、添加路径到上下文4、渲染上下文（描边或填充） 12345678910111213141516171819202122232425262728293031323334- (void)drawRect:(CGRect)rect &#123;//------------------我是Core Graphics绘图------------- // 获取ctx CGContextRef ctx = UIGraphicsGetCurrentContext(); // 设置绘图的其他属性 // 设置线颜色 CGContextSetStrokeColorWithColor(ctx, [UIColor blackColor].CGColor); // 设置线宽度 CGContextSetLineWidth(ctx, 5); // 设置线颜色 [[UIColor redColor] set]; // 设置填充色 CGContextSetFillColorWithColor(ctx, [UIColor purpleColor].CGColor); // 设置连接样式（Miter尖的、斜接, Round圆, Bevel斜面） CGContextSetLineJoin(ctx, kCGLineJoinRound); // 设置顶角样式（Butt, Round, Square） CGContextSetLineCap(ctx, kCGLineCapRound); // 设置虚线样式 CGFloat lengths[] = &#123; 20, 5 &#125;; CGContextSetLineDash(ctx, 0, lengths, 2); // 画线 [self drawLine:ctx]; // 画矩形,画椭圆，多边形 [self drawSharp:ctx]; // 画图片 [self drawPicture:ctx]; // 画文字 [self drawText:ctx]; // 画圆、画弧 [self drawCircle:ctx];&#125; PS.第一个方法写的比较详细，写了使用直接画线的方式 和 path的方式。推荐使用path的方式画线。 另外，第一个方法也写了移动笔触画线和用点集合画线。后面方法只会涉及其中一种，因为方法都比较类似 画线12345678910111213141516171819202122232425262728293031323334// 画线-(void)drawLine:(CGContextRef)ctx&#123; // 画一条简单的线 CGPoint points1[] = &#123;CGPointMake(10, 80),CGPointMake(300, 80)&#125;; CGContextAddLines(ctx,points1, 2); // 画线方法一：使用CGContextAddLineToPoint画线，需要先设置一个起始点 // 设置起始点 CGContextMoveToPoint(ctx, 10, 100); // 添加一根线到终点 CGContextAddLineToPoint(ctx, 100,120); // 再添加一根线到终点，变成折线 CGContextAddLineToPoint(ctx, 150, 100); // 画线方法二： // 构造线路径的点数组 CGPoint points2[] = &#123;CGPointMake(10, 130),CGPointMake(10, 160),CGPointMake(130, 200)&#125;; CGContextAddLines(ctx,points2, 3); // 利用路径去画一组点（推荐使用路径的方式，虽然多了几行代码，但是逻辑更清晰了） // 第一个路径 CGMutablePathRef path1 = CGPathCreateMutable(); CGPathMoveToPoint(path1, &amp;CGAffineTransformIdentity, 0, 200); //CGAffineTransformIdentity 类似于初始化一些参数 CGPathAddLineToPoint(path1, &amp;CGAffineTransformIdentity, 100, 250); CGPathAddLineToPoint(path1, &amp;CGAffineTransformIdentity, 310, 210); //路径1加入context CGContextAddPath(ctx, path1); // path同样有方法CGPathAddLines(),和CGContextAddLines() // 渲染上下文 CGContextStrokePath(ctx);&#125; 画矩形,画椭圆，多边形1234567891011121314151617181920// 画矩形,画椭圆，多边形-(void)drawSharp:(CGContextRef)ctx&#123; CGContextSetFillColorWithColor(ctx, [UIColor redColor].CGColor); // 画椭圆,如果长宽相等就是圆 CGContextAddEllipseInRect(ctx, CGRectMake(0, 250, 50, 50)); // 画矩形,长宽相等就是正方形 CGContextAddRect(ctx, CGRectMake(70, 250, 50, 50)); // 画多边形，多边形是通过path完成的 CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, &amp;CGAffineTransformIdentity, 120, 250); CGPathAddLineToPoint(path, &amp;CGAffineTransformIdentity, 200, 250); CGPathAddLineToPoint(path, &amp;CGAffineTransformIdentity, 180, 300); CGPathCloseSubpath(path); CGContextAddPath(ctx, path); // 填充 CGContextFillPath(ctx);&#125; 画图片、画文字123456789101112131415// 画图片-(void)drawPicture:(CGContextRef)context&#123; UIImage *image = [UIImage imageNamed:@&quot;阿狸头像&quot;]; [image drawInRect:CGRectMake(10, 300, 100, 100)]; //CGContextDrawImage(ctx, rect, image.CGImage);&#125;// 画文字-(void)drawText:(CGContextRef)ctx&#123; NSDictionary *dict = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:18], NSForegroundColorAttributeName:[UIColor redColor]&#125;; [@&quot;hello world&quot; drawInRect:CGRectMake(120 , 350, 500, 50) withAttributes:dict];&#125; 画圆、圆弧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 画圆、圆弧-(void)drawCircle:(CGContextRef)ctx&#123; CGContextSetStrokeColorWithColor(ctx, [UIColor purpleColor].CGColor); /** 绘制路径方法一: CGContextRef c,// 上下文 CGFloat x, // 圆心的x坐标 CGFloat y, // 圆心的y坐标 CGFloat radius, // 圆的半径 CGFloat startAngle, // 开始弧度 CGFloat endAngle, // 结束弧度 int clockwise // 0表示顺时针，1表示逆时针 */ // 圆 CGContextAddArc (ctx, 100, 100, 50, 0, M_PI* 2 , 0); CGContextFillPath(ctx); // 半圆 CGContextAddArc (ctx, 100, 200, 50, 0, M_PI, 0); CGContextStrokePath(ctx); /** 三次曲线函数 CGContextRef c, CGFloat cp1x, // 控制点1 x坐标 CGFloat cp1y, // 控制点1 y坐标 CGFloat cp2x, // 控制点2 x坐标 CGFloat cp2y, // 控制点2 y坐标 CGFloat x, // 直线的终点 x坐标 CGFloat y // 直线的终点 y坐标 */ CGContextMoveToPoint(ctx, 200, 200); CGContextAddCurveToPoint(ctx, 200, 0, 300, 200, 400, 100); CGContextStrokePath(ctx); /** 二次曲线函数 CGContextRef c, CGFloat cpx, //控制点 x坐标 CGFloat cpy, //控制点 y坐标 CGFloat x, //直线的终点 x坐标 CGFloat y //直线的终点 y坐标 */ CGContextMoveToPoint(ctx, 100, 100); CGContextAddQuadCurveToPoint(ctx, 200, 0, 300, 150); CGContextStrokePath(ctx);&#125; Core Graphics绘图效果： UIBezierPath绘图概念 同样，首先你的知道你想实现什么效果用到什么属性值，及对属性值意思的理解。然后再结合下面的代码 就更容易理解和吸收了 UIKit 之 UIBezierPath绘图属性 描述 [UIBezierPath bezierPath] 创建路径 moveToPoint:(CGPoint) 设置起点 addLineToPoint:(CGPoint) 添加一根线到终点 [[UIColor redColor] set] 设置线颜色（注意:如果使用 setStroke 和 setFill 与渲染方式要相对应） addQuadCurveToPoint:(CGPoint) controlPoint:(CGPoint) 画曲线(controlPoint:弯曲方向点) bezierPathWithRect:(CGRect) 画矩形 bezierPathWithRoundedRect:(CGRect) cornerRadius:(CGFloat) 画圆角矩形 bezierPathWithOvalInRect:(CGRect) 画圆(Width = Height)、画椭圆(Width != Height) bezierPathWithArcCenter:(CGPoint) radius:(CGFloat) startAngle:(CGFloat) endAngle:(CGFloat) clockwise:(BOOL) Center:弧所在的圆心(这里不能直接用self.center,因为它是相对于它的父控件的,采用rect 宽度0.5、高度0.5)，radius:圆的半径，startAngle:开始角度， endAngle:结束角度，clockwise:YES顺时针 NO逆时针 bezierPathWithArcCenter:(CGPoint) radius:(CGFloat) startAngle:(CGFloat) endAngle:(CGFloat) clockwise:(BOOL) [path addLineToPoint:center]; 注：1、[path closePath] 从路径终点连接一根线到路径的起点，2、[path fill] 填充之前,会自动关闭路径 UIGraphicsBeginImageContextWithOptions 开启上下文（size:上下文大小, opaque:透明度(YES透明,NO不透明), scale:图片质量，一般为0和当前设备的分辨率一样) drawAtPoint:(CGPoint) 图片绘制到上下文 addClip 设置成裁剪区域 drawAtPoint:(CGPoint) blendMode:(CGBlendMode) alpha:(CGFloat) 图片绘制到上下文 drawAtPoint:(CGPoint) withAttributes:NSDictionary *dict) 文字绘制到上下文（属性值：NSFontAttributeName字体大小、NSForegroundColorAttributeName字体颜色） UIGraphicsEndImageContext() 关闭上下文 [path stroke] / [path fill] 底层做了:1.获取上下文-&gt;2.绘制路径-&gt;3.添加路径到上下文-&gt;4.渲染上下文 PS.同样第一个方法写的比较详细，且有注释实现- (void)drawRect:(CGRect)rect方法 我是UIKit 之 UIBezierPath绘图 1、获取上下文2、绘制路径3、添加路径到上下文4、渲染上下文（描边或填充） 1234567- (void)drawRect:(CGRect)rect &#123;//------------------我是UIKit 之 UIBezierPath绘图------------- [self drawLine];// 画直线、曲线 [self drawRect];// 画矩形、画椭圆 [self drawRidan];// 画弧度、扇形 画直线123456789101112131415161718192021222324252627282930/** 画直线、曲线 */- (void)drawLine&#123; // 1.获取上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 2.绘制路径 UIBezierPath *path = [UIBezierPath bezierPath]; // 设置起点 + 添加一根线到终点 [path moveToPoint:CGPointMake(10, 150)]; [path addLineToPoint:CGPointMake(160, 80)]; // 画第二条线 [path addLineToPoint:CGPointMake(130, 150)]; // 画曲线 [path moveToPoint:CGPointMake(10, 280)]; // 画曲线(controlPoint:弯曲方向点) [path addQuadCurveToPoint:CGPointMake(180, 280) controlPoint:CGPointMake(130, 130)]; // **在这里设置其他属性与上面的一样就不在写一遍了** // 3.路径添加到上下文 // UIBezierPath:UIKit框架 ,CGPathRef:CoreGraphics框架 CGContextAddPath(ctx, path.CGPath); // 4.渲染上下文 CGContextStrokePath(ctx);// 描边(空心) //CGContextFillPath(ctx);// 填充(实心)&#125; 画矩形、椭圆12345678910111213141516171819202122232425/** 画矩形、椭圆 */- (void)drawRect&#123; CGContextRef ctx = UIGraphicsGetCurrentContext(); // 画矩形 UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(10, 300, 80, 40)]; // 画圆角矩形 UIBezierPath *path1 = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(100, 300, 80, 40) cornerRadius:10]; // 画指定角为圆角的矩形 UIBezierPath *path2 = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(200, 300, 80, 40) byRoundingCorners:UIRectCornerBottomRight cornerRadii:CGSizeMake(10, 10)]; [[UIColor redColor] set]; CGContextAddPath(ctx, path.CGPath); CGContextAddPath(ctx, path1.CGPath); CGContextAddPath(ctx, path2.CGPath); CGContextStrokePath(ctx); // 使用UIBezierPath提供的绘图方法进行绘制 // 画椭圆、圆 UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(10, 370, 180, 50)]; // 使用UIBezierPath提供的绘图方法进行绘制 [path stroke];// 底层做了:1.获取上下文-&gt;2.绘制路径-&gt;3.添加路径到上下文-&gt;4.渲染上下文&#125; 画弧度、扇形1234567891011121314151617/** 画弧度、扇形 */- (void)drawRidan&#123; CGPoint center = CGPointMake(100, 430); CGFloat radius = 100; // 画弧度 clockwise:方向(顺时针或是逆时针) UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:0 endAngle:M_PI_4*3 clockwise:YES]; // 画扇形 [path addLineToPoint:center]; //[path closePath];// 从路径终点连接一根线到路径的起点 [path fill];// fill填充之前,会自动关闭路径 //[path stroke];&#125; 画图片和文字1234567891011121314151617181920212223242526272829303132/** 根据传入的图片,生成一终带有边框的圆形图片 参数:边框宽度,边框颜色,原始图片 */+ (UIImage *)imageWithImage:(UIImage *)image Border:(CGFloat)borderW color:(UIColor *)borderColor &#123; CGSize size = CGSizeMake(image.size.width + 2*borderW, image.size.height + 2*borderW); // 1.开启一个跟图片原始大小的上下文 UIGraphicsBeginImageContextWithOptions(size, NO, 0); // 2.绘制大圆 UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, size.width, size.height)]; [borderColor set];// 边框颜色 [path fill]; // 设置圆形裁剪区域 UIBezierPath *clipPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(borderW, borderW, image.size.width, image.size.height)]; [clipPath addClip]; // 3.把图片绘制到上下文当中 [image drawAtPoint:CGPointMake(borderW, borderW)]; // 3.把文字绘制到上下文当中 NSDictionary *dict = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:18.f],NSForegroundColorAttributeName:[UIColor whiteColor]&#125;; [@&quot;我是绘制上的\n图片和文字&quot; drawAtPoint:CGPointMake(0, 0) withAttributes:dict]; // 4.从上下文当中生成一张图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); // 5.关闭上下文 UIGraphicsEndImageContext(); image = newImage; return image;&#125; 效果： 如果你想更深入学习 UIBeizerPath ，这里有一篇官方译文加原理的总结 ，👍推荐一篇 UIBezierPath译文+活用 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 数据安全—「加密解密」]]></title>
    <url>%2FiOSNET%2FDataSecurity.html</url>
    <content type="text"><![CDATA[Write in the first 在写项目中，数据的安全性至关重要，而仅仅用 POST 请求提交用户的隐私数据，还是不能完全解决安全问题。因此：我们经常会用到加密技术，比如说在登录的时候，我们会先把密码用MD5加密再传输给服务器 或者 直接对所有的参数进行加密再POST到服务器。 本篇文章主要从【iOS 数据安全相关】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录: 数据安全介绍 常用加密算法 常用加密方式 Base64编码方案 加密实现代码5.1 MD5加密算法5.2 对称加密算法AES和DES5.3 非对称加密RSA HTTPS基本使用 数据安全–加密解密效果 加密实战应用场景（持续更新） Contents【相关介绍】 1.数据安全介绍 最基础的是我们发送网络请求时，使用get和post方式发送请求。两者具体区别就不做解释了，只是引出相关安全性问题 get：将参数暴露在外，（绝对不安全–&gt;明文请求或者傻瓜式请求）。 post：将参数放到请求体body中，（相对于get比较安全–&gt;但是我们可以很容易用一些软件截获请求数据。比如说Charles（青花瓷）） Charles（大部分app的数据来源都使用该工具来抓包，并做网络测试） 注意：Charles在使用中的乱码问题，可以显示包内容，然后打开info.plist文件，找到java目录下面的VMOptions，在后面添加一项：-Dfile.encoding=UTF-8 这里提供一个青花瓷破解版下载途径，供大家学习使用，商务需求，也请支持正版。 数据安全的原则 在网络上不允许传输用户隐私数据的明文,（即:App网络传输安全，指对数据从客户端传输到Server中间过程的加密，防止网络世界当中其他节点对数据的窃听）。 在本地不允许保存用户隐私数据的明文,（即:App数据存储安全，主要指在磁盘做数据持久化的时候所做的加密）。 App代码安全,（即:包括代码混淆，加密或者app加壳）。 要想非常安全的传输数据，建议使用https。抓包不可以，但是中间人攻击则有可能。建议双向验证防止中间人攻击，可以参考下文篇章。 2.常用加密算法 常用加密算法 名称 编码方案 Base64 哈希(散列)函数 MD5（消息摘要算法） SHA1 SHA256 对称加密算法 DES AES 非对称加密算法 RSA HTTPS HTTP+SSL协议 3.常用加密方式 常用加密方式 1.通过简单 BASE64编码 防止数据明文传输 2.对普通请求、返回数据，生成MD5校验（MD5中加入动态密钥），进行数据完整性（简单防篡改，安全性较低，优点：快速）校验 3.对于重要数据，使用RSA进行数字签名，起到防篡改作 4.对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密 5.要想非常安全的传输数据，建议使用https。抓包不可以，但是中间人攻击则有可能。建议双向验证防止中间人攻击 4.Base64编码方案1.Base64简单说明 描述：Base64可以成为密码学的基石，非常重要。 特点：可以将任意的二进制数据进行Base64编码 结果：所有的数据都能被编码为并只用65个字符（A~Z a~z 0~9 + / =）就能表示的文本文件。 注意：对文件进行base64编码后文件数据的变化：编码后的数据~=编码前数据的4/3，会大1/3左右。 2.Base64编码原理和处理过程 Base64编码原理 1、将所有字符转化为ASCII码 2、将ASCII码转化为8位二进制 3、将二进制3个归成一组(不足3个在后边补0)共24位，再拆分成4组，每组6位 4、统一在6位二进制前补两个0凑足8位 5、将补0后的二进制转为十进制 6、从Base64编码表获取十进制对应的Base64编码 Base64处理过程 1、转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。 2、数据不足3byte的话，于缓冲区中剩下的bit用0补足。然后，每次取出6个bit，按照其值选择查表选择对应的字符作为编码后的输出。 3、不断进行，直到全部输入数据转换完成。 4、如果最后剩下两个输入数据，在编码结果后加1个“=”； 5、如果最后剩下一个输入数据，编码结果后加2个“=”； 6、如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。 在这里提供几张图结合上面的处理过程，好理解。 Base64实现代码简单方法直接拿走，调用12345678910111213141516171819202122// 对一个字符串进行base64编码,并且返回-(NSString *)base64EncodeString:(NSString *)string &#123; // 1.先转换为二进制数据 NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding]; // 2.对二进制数据进行base64编码,完成之后返回字符串 return [data base64EncodedStringWithOptions:0];&#125;// 对base64编码之后的字符串解码,并且返回-(NSString *)base64DecodeString:(NSString *)string &#123; // 注意:该字符串是base64编码后的字符串 // 1.转换为二进制数据(完成了解码的过程) NSData *data = [[NSData alloc]initWithBase64EncodedString:string options:0]; // 2.把二进制数据在转换为字符串 return [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];&#125;//---------------------------&lt;#我是分割线#&gt;------------------------------//NSLog(@"%@",[self base64EncodeString:@"A"]);NSLog(@"%@",[self base64DecodeString:@"QQ=="]); PS.终端执行编码和解码123如：编码：base64 123.png -o 123.txt解码：base64 123.txt -o test.png -D 4.加密实现代码哈希(散列)函数特点： 算法是公开的 对相同的数据加密，得到的结果是一样的” 对不同的数据加密，得到的结果是定长的，MD5对不同的数据进行加密，得到的结果都是 32 个字符长度的字符串 信息摘要，信息”指纹”，是用来做数据识别的！ 不能逆推反算(重要) 用途： 版权 对文件进行散列判断该文件是否是正版或原版的 文件完整性验证 对整个文件进行散列，比较散列值判断文件是否完整或被篡改 密码加密，服务器并不需要知道用户真实的密码！ 搜索：如：百度搜索–&gt;老司机 皮皮虾 苍老师或是 【苍老师 老司机 皮皮虾 】上面两种方式搜索出来的内容是一样的 如何判断：对搜索的每个关键字进行三列，得到三个相对应的结果，按位相加结果如果是一样的，那搜索的内容就是一样的！ 经典加密算法：MD5、SHA1、SHA512 MD5消息摘要算法 简单介绍: MD5：全称是Message Digest Algorithm 5，译为“消息摘要算法第5版”(经MD2、MD3和MD4发展而来) 效果：对输入信息生成唯一的128位散列值（32个字符），即 32个16进制的数字。 特点: 输入两个不同的明文不会得到相同的输出值 根据输出值，不能得到原始的明文，即其过程不可逆(只能加密, 不能解密) 应用: 现在的MD5已不再是绝对安全(如：暴力破解的网站)，对此，可以对MD5稍作改进，以增加解密的难度。 解决：加盐（Salt）：在明文的固定位置插入随机串，然后再进行MD5（先加密，后乱序：先对明文进行MD5，然后对加密得到的MD5串的字符进行乱序） 注意点: 开发中，一定要和后台开发人员约定好，MD5加密的位数是16位还是32位(大多数都是32位的)，16位的可以通过32位的转换得到。 MD5加密区分 大小写，使用时要和后台约定好。 MD5公认被破解不代表其可逆，而是一段字符串加密后的密文，可以通过强大运算计算出字符串加密后的密文对应的原始字符串，但也不是绝对的被破解。 PS.暴力破解是指通过将明文和生成的密文进行配对，生成强大的数据库，在数据库中搜索，在这里就可以破解密码。破解网址 http://www.cmd5.com 提升MD5加密安全性，解决办法 1.先明文加盐，然后再进行MD5。即明文后拼接字符串（此时拼接的字符串要 足够长+足够咸+足够复杂），再进行MD5加密。如：#define salt @&quot;1342*&amp;%&amp;shlfhs390(*^^6R%@@KFGKF&quot; 2.先加密+乱序 3.乱序|加盐，多次MD5加密等 4.使用消息认证机制HMAC：给定一个”秘钥”，对明文进行加密，并且做”两次散列”！-&gt; 得到的结果，还是 32 个字符，相对安全（KEY是服务器传给你的，不是你写死的）。 消息认证机制（HMAC）简单说明 原理 消息的发送者和接收者有一个共享密钥 发送者使用共享密钥对消息加密计算得到MAC值（消息认证码） 消息接收者使用共享密钥对消息加密计算得到MAC值 比较两个MAC值是否一致 使用 客户端需要在发送的时候把（消息）+（消息·HMAC）一起发送给服务器 服务器接收到数据后，对拿到的消息用共享的KEY进行HMAC，比较是否一致，如果一致则信任 简单示例1234567891011121314151617181920212223242526272829303132333435363738394041#pragma mark - md5加密方法- (NSString *)md5String &#123; const char *str = self.UTF8String; uint8_t buffer[CC_MD5_DIGEST_LENGTH]; CC_MD5(str, (CC_LONG)strlen(str), buffer); return [self stringFromBytes:buffer length:CC_MD5_DIGEST_LENGTH];&#125;#pragma mark - HMACMD5加密方法- (NSString *)hmacMD5StringWithKey:(NSString *)key &#123; const char *keyData = key.UTF8String; const char *strData = self.UTF8String; uint8_t buffer[CC_MD5_DIGEST_LENGTH]; CCHmac(kCCHmacAlgMD5, keyData, strlen(keyData), strData, strlen(strData), buffer); return [self stringFromBytes:buffer length:CC_MD5_DIGEST_LENGTH];&#125;/** * 返回二进制 Bytes 流的字符串表示形式 * @param bytes 二进制 Bytes 数组 * @param length 数组长度 * @return 字符串表示形式 */- (NSString *)stringFromBytes:(uint8_t *)bytes length:(int)length &#123; NSMutableString *strM = [NSMutableString string]; for (int i = 0; i &lt; length; i++) &#123; [strM appendFormat:@"%02x", bytes[i]]; &#125; return [strM copy];&#125;//---------------------------&lt;#我是分割线#&gt;------------------------------//// md5加密调用NSLog(@"%@",[@"520it" md5String]);// (明文+加盐)MD5加密调用NSLog(@"%@",[[@"520it" stringByAppendingString:salt] md5String]);// hmacMD5加密调用（先加密+乱序）NSLog(@"%@",[@"520it" hmacMD5StringWithKey:@"xiaomage"]); 对称加密算法AES和DES 对称加密的特点 加密/解密使用相同的密钥 加密和解密的过程是可逆的 经典算法 DES 数据加密标准 AES 高级加密标准 提示： 加密过程是先加密，再base64编码 解密过程是先base64解码，再解密 简单示例123456789101112131415161718192021222324/** * 加密字符串并返回base64编码字符串 * * @param string 要加密的字符串 * @param keyString 加密密钥 * @param iv 初始化向量(8个字节) * * @return 返回加密后的base64编码字符串 */- (NSString *)encryptString:(NSString *)string keyString:(NSString *)keyString iv:(NSData *)iv;/** * 解密字符串 * * @param string 加密并base64编码后的字符串 * @param keyString 解密密钥 * @param iv 初始化向量(8个字节) * * @return 返回解密后的字符串 */- (NSString *)decryptString:(NSString *)string keyString:(NSString *)keyString iv:(NSData *)iv;// 调用EncryptionTools *encrypt = [EncryptionTools sharedEncryptionTools];NSLog(@"%@",[encrypt encryptString:@"LN123" keyString:@"LN" iv:nil]);NSLog(@"%@",[encrypt decryptString:@"OPcTMDB5paivqtYo9Fj+hQ==" keyString:@"LN" iv:nil]); 非对称加密RSA 非对称加密的特点 使用 公钥 加密，使用 私钥 解密 使用 私钥 加密，使用 公钥 解密（私钥签名，公钥验签） 公钥是公开的，私钥保密 加密处理安全，但是性能极差 经典算法–&gt;RSA 简单示例12345678910111213// 公钥加密时调用类方法：+ (NSString *)encryptString:(NSString *)str publicKey:(NSString *)pubKey;+ (NSData *)encryptData:(NSData *)data publicKey:(NSString *)pubKey;// 私钥解密时调用类方法+ (NSString *)decryptString:(NSString *)str privateKey:(NSString *)privKey;+ (NSData *)decryptData:(NSData *)data privateKey:(NSString *)privacy;/** 调用 */NSString *str = [RSAUtil encryptString: @"LN" publicKey:RSA_Public_key];NSLog(@"RSA公钥加密数据--&gt;\n%@",str);NSString *str1 = [RSAUtil decryptString:str privateKey:RSA_Privite_key];NSLog(@"RSA私钥解密数据--&gt;%@",str1); MAC上生成公钥、私钥的方法，及使用12345678910# MAC上生成公钥、私钥的方法@code1.打开终端，切换到自己想输出的文件夹下2.输入指令:openssl（openssl是生成各种秘钥的工具，mac已经嵌入)3.输入指令:genrsa -out rsa_private_key.pem 1024 (生成私钥，java端使用的)4.输入指令:rsa -in rsa_private_key.pem -out rsa_public_key.pem -pubout (生成公钥)5.输入指令:pkcs8 -topk8 -in rsa_private_key.pem -out pkcs8_rsa_private_key.pem -nocrypt(私钥转格式，在ios端使用私钥解密时用这个私钥)注意:在MAC上生成三个.pem格式的文件，一个公钥，两个私钥，都可以在终端通过指令vim xxx.pem 打开，里面是字符串，第三步生成的私钥是java端用来解密数据的，第五步转换格式的私钥iOS端可以用来调试公钥、私钥解密（因为私钥不留在客户端）iOS端公钥加密私钥解密、java端公钥加密私钥解密，java端私钥加密公钥解密都容易做到，iOS不能私钥加密公钥解密，只能用于验签@endcode HTTPS基本使用 https简单说明 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。 在HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。 HTTPS：URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。 注意 HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的保护。 HTTPS的信任继承基于预先安装在浏览器中的证书颁发机构（如VeriSign、Microsoft等）（意即“我信任证书颁发机构告诉我应该信任的”）。 因此，一个到某网站的HTTPS连接可被信任，如果服务器搭建自己的https 也就是说采用自认证的方式来建立https信道，这样一般在客户端是不被信任的。 所以我们一般在浏览器访问一些https站点的时候会有一个提示，问你是否继续。 HTTPS和HTTP区别 https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 实现代码 方案一：如果是自己使用NSURLSession来封装网络请求123456789101112131415161718192021222324252627282930313233// 1.创建sessionNSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];// 2.创建TaskNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"https://kyfw.12306.cn/otn"]] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; // 3.解析数据 NSLog(@"%@---%@",[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding],error);&#125;];// 4.执行task[dataTask resume];#pragma mark - 遵守&lt;NSURLSessionDataDelegate&gt;// 如果发送的请求是https的,那么才会调用该方法-(void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler &#123; /** 判断服务器传给我们的信任的类型，只有是【服务器信任的时候，才安装证书】 NSURLSessionAuthChallengeDisposition 如何处理证书 NSURLAuthenticationMethodServerTrust 服务器信任 */ if(![challenge.protectionSpace.authenticationMethod isEqualToString:@"NSURLAuthenticationMethodServerTrust"]) &#123; return; &#125; NSLog(@"%@",challenge.protectionSpace); /* NSURLCredential 授权信息 NSURLSessionAuthChallengeUseCredential = 0, 使用该证书 安装该证书 NSURLSessionAuthChallengePerformDefaultHandling = 1, 默认采用的方式,该证书被忽略 NSURLSessionAuthChallengeCancelAuthenticationChallenge = 2, 取消请求,证书忽略 NSURLSessionAuthChallengeRejectProtectionSpace = 3, 拒绝 */ NSURLCredential *credential = [[NSURLCredential alloc]initWithTrust:challenge.protectionSpace.serverTrust]; completionHandler(NSURLSessionAuthChallengeUseCredential,credential); // 注意：并不是所有的https的请求都需要安装证书(授权)的，请求一些大型的网站有的是强制安装的，如：苹果官网https://www.apple.com&#125; 方案二：如果使用AFN网络请求123456789101112131415161718AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];// 更改解析方式（请求网页源码应使用原始解析）manager.responseSerializer = [AFHTTPResponseSerializer serializer];// 设置对证书的处理方式// 允许自签名证书，必须的manager.securityPolicy.allowInvalidCertificates = YES;// 是否验证域名的CN字段（不是必须的，但是如果写YES，则必须导入证书）manager.securityPolicy.validatesDomainName = NO;[manager GET:@"https://kyfw.12306.cn/otn" parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSLog(@"success---%@",[[NSString alloc]initWithData:responseObject encoding:NSUTF8StringEncoding]);&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; NSLog(@"error---%@",error);&#125;]; 补充ATS（全称:App Transport Security） iOS9中新增App Transport Security（简称ATS）特性, 让原来请求时候用到的HTTP，全部都转向TLS1.2协议进行传输。 这意味着所有的HTTP协议都强制使用了HTTPS协议进行传输。 如果我们在iOS9下直接进行HTTP请求是会报错。系统会告诉我们不能直接使用HTTP进行请求，需要在Info.plist中控制ATS的配置。 “NSAppTransportSecurity”是ATS配置的根节点，配置了节点表示告诉系统要走自定义的ATS设置。 “NSAllowsAritraryLoads”节点控制是否禁用ATS特性，设置YES就是禁用ATS功能; 采用解决方法，修改配置信息。 【学习本文之外可以参考】网络安全——数据的加密与签名,RSA介绍关于Https安全性问题、双向验证防止中间人攻击问题 附上一张图： 附上总结写的小样 Demo，重要的部分代码中都有相应的注解和文字打印，运行程序可以很直观的表现 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>数据安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIWebViewApple译文]]></title>
    <url>%2FAppleTranslation%2FUIWebViewApple.html</url>
    <content type="text"><![CDATA[Write in the first 随着HTML5的迅速发展与日趋成熟，越来越多的移动开发者选择使用HTML5来进行混合开发，不仅节约成本而且效果绚丽，只有一个感觉 D！(此时默默下决心我要学会☺)。 那么作为内置浏览器的WebView被重视起来，不管是iOS还是Android，都要是使用 WebView 控件来加载HTML5页面，甚至有些程序打开后只有一个WebView 控件，其他的页面都是被它加载出来网页。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 正题在这里首先附上官方原文地址 UIWebView Class Relationships Inherits From UIView 继承自: UIView Conforms To 遵守:CVarArg、Equatable、Hashable、Equa NSCoding table、UIAccessibilityIdentification、UIScrollViewDelegate Framework iOS 2.0+ ClassUIWebView You can use the UIWebView class to embed web content in your app. To do so, create a UIWebView object, attach it to a window, and send it a request to load web content. You can also use this class to move back and forward in the history of webpages, and you can even set some web content properties programmatically. 你可以使用 UIWebView 类来将网页（web content）嵌入到你的 app 中。为此，首先创建一个 UIWebView 对象，将它添加到一个 窗体（window） 上， 然后给它发送一个请求去加载网页（web content）。你还可以用这个类在网页浏览记录中后退前进（move back and forward），甚至可以设置一些网页属性（web content properties）。 Overview NoteIn apps that run in iOS 8 and later, use the WKWebView class instead of using UIWebView. Additionally, consider setting the WKPreferences property javaScriptEnabled to false if you render files that are not supposed to run JavaScript. 注意：在只支持iOS 8及以后的系统的 app 中，建议使用WKWebView，而不是 UIWebView 。值得注意的一点是，如果你要渲染的文件不支持运行 JavaScript 的话，不妨将 WKPreferences的javaScriptEnabled 属性设为 NO。 ImportantAn iOS app linked on or after iOS 10.0 must include in its Info.plist file the usage description keys for the types of data it needs to access or it will crash. To access a user’s photo data specifically, it must include NSPhotoLibraryUsageDescription and NSCameraUsageDescription. 重要：iOS应用程序链接或之后的iOS 10.0必须包括在其信息。plist文件使用描述键类型的数据需要访问或它会崩溃。访问用户的照片数据具体地说,它必须包括NSPhotoLibraryUsageDescription和NSCameraUsageDescription。 Use the loadHTMLString(_:baseURL:) method to begin loading local HTML files or the loadRequest(_:) method to begin loading web content. Use the stopLoading() method to stop loading, and the isLoading property to find out if a web view is in the process of loading. 我们可以使用 loadHTMLString:baseURL: 方法来加载本地 HTML 文件或者用 loadRequest: 方法来加载网页（web content）。我们还可以通过调用stopLoading 方法来停止加载，以及通过获取属性 loading 的值来判断一个 web view 是否还处于正在加载的过程中。 If you allow the user to move back and forward through the webpage history, then you can use the goBack() and goForward() methods as actions for buttons. Use the canGoBack and canGoForward properties to disable the buttons when the user can’t move in a direction. 如果你想让用户在浏览网页时可以前进后退，你可以通过 button 的 action 对goBack 和goForward 方法的调用来控制。当用户不能在某一个方向“移动”时，需要使用 canGoBack 和 canGoForward 属性来禁用按钮的前进后退操作。 By default, a web view automatically converts telephone numbers that appear in web content to Phone links. When a Phone link is tapped, the Phone app launches and dials the number. To turn off this default behavior, set the dataDetectorTypes property with a UIDataDetectorTypes bitfield that does not contain the phoneNumber flag. 默认情况下，一个 web view 会自动将网页中的电话号码转成一个号码链接（Phone links）。当用户在点击那个链接（Phone links）时，系统会自动启动 Phone app 并拨打那个电话号码。你可以将属性 dataDetectorTypes 的值设置为一个 UIDataDetectorTypes 位字段来关闭这个电话号码识别行为，因为UIDataDetectorTypes不包括 TypePhoneNumber 这个标志位。 You can also use the scalesPageToFit property to programmatically set the scale of web content the first time it is displayed in a web view. Thereafter, the user can change the scale using gestures. 你可以通过设置 scalesPageToFit 属性来设置网页（web content）第一次展示在一个 web view 中的页面比例。但仅仅这个属性只在首次展示时有效，首次展示之后用户仍然可以通过手势改变页面比例。 Set the delegate property to an object conforming to the UIWebViewDelegate protocol if you want to track the loading of web content. 如果你想追踪网页内容（web content）的加载，你需要将 web view 的 delegate 属性赋给一个遵守 UIWebViewDelegate 协议的对象。 ImportantYou should not embed UIWebView or UITableView objects in UIScrollView objects. If you do so, unexpected behavior can result because touch events for the two objects can be mixed up and wrongly handled. 重要：不要将 UIWebView 或 UITableView 对象嵌入到 UIScrollView 对象中。如果你这么做了，将会导致一些意想不到的结果，因为那两个嵌套的 view 的 touch 事件会被混淆并且会被错误地处理。 You can easily debug the HTML, CSS, and JavaScript contained inside a UIWebView with Web Inspector. Read Debugging Web Content on iOS to learn how to configure Web Inspector for iOS. Read the rest of Safari Web Content Guide to learn how to create web content that is optimized for Safari on iPhone and iPad. For information about basic view behaviors, see View Programming Guide for iOS. 借助 Web Inspector，可以很方便地调试一个 UIWebView 中的HTML，CSS 和 JavaScript。你可以通过阅读 Debugging Web Content on iOS 来学习如何配置 Web Inspector for iOS。你还可以通过阅读 Safari Web Content Guide 的其余部分，来学习如何创建一个为 iPhone 和 iPad 上的 Safari 而优化的网页（web content）。 如果你想了解一些关于基本的 view 的知识，不妨看一下View Programming Guide for iOS 。 Supported File Formats支持的文件格式 In addition to HTML content, UIWebView objects can be used to display other content types, such as Keynote, PDF, and Pages documents. For the best rendering of plain and rich text in your app, however, you should use UITextView instead. 除了 HTML 内容之外，UIWebView 对象还可以被用来展示其他格式的内容，比如，Keynote，PDF，Pages文件等。为了能够保证文本（plain and rich text）渲染的最佳效果，建议使用 UITextView。 State Preservation状态保存 In iOS 6 and later, if you assign a value to this view’s restorationIdentifier property, it attempts to preserve its URL history, the scaling and scrolling positions for each page, and information about which page is currently being viewed. During restoration, the view restores these values so that the web content appears just as it did before. For more information about how state preservation and restoration works, see App Programming Guide for iOS. 在iOS 6及以后版本的系统中，如果你给 web view 的 restorationIdentifier 属性赋一个值，它将会为每一页保存它的 URL 历史，缩放比例和滚动位置，以及当前正在查看的网页信息。在恢复（ restoration）过程中，那个 view 会复原（ restore）这些值，因此那个网页（web content）看起来就像它之前的样子一样。如果你想了解更多关于状态保存和恢复是如何运作的信息，不妨读一读 App Programming Guide for iOS。 For more information about appearance and behavior configuration, see Web Views. 更多关于外观和行为配置的信息，请看 Web Views。 Subclassing Notes关于继承 The UIWebView class should not be subclassed. UIWebView 不应该被继承。 SymbolsSetting the Delegate设置代理 var delegate: UIWebViewDelegate?The receiver’s delegate. 1@property(nonatomic, assign) id&lt; UIWebViewDelegate &gt; delegate The delegate is sent messages when content is loading. See UIWebViewDelegate for the optional methods this delegate may implement. ImportantBefore releasing an instance of UIWebView for which you have set a delegate, you must first set its delegate property to nil. This can be done, for example, in your dealloc method. 重要：在释放一个你已经为其设过 delegate 的 UIWebView 实例之前，你首先一定要将该 UIWebView 对象的 delegate 属性设为 nil。比如说，你可以在你的 dealloc 方法中这样做。 Loading Content加载内容1234567func load(Data, mimeType: String, textEncodingName: String, baseURL: URL)Sets the main page contents, MIME type, content encoding, and base URL.- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)encodingName baseURL:(NSURL *)baseURL; 12345func loadHTMLString(String, baseURL: URL?)Sets the main page content and base URL.- (void)loadHTMLString:(NSString *)string baseURL:(NSURL *)baseURL; 1234func loadRequest(URLRequest)Connects to a given URL by initiating an asynchronous client request.- (void)loadRequest:(NSURLRequest *)request; 1234var request: URLRequest?The URL request identifying the location of the content to load.@property(nonatomic, readonly, strong) NSURLRequest *request; 1234var isLoading: BoolA Boolean value indicating whether the receiver is done loading content.@property(nonatomic, readonly, getter=isLoading) BOOL loading; 1234func stopLoading()Stops the loading of any web content managed by the receiver.- (void)stopLoading; 1234func reload()Reloads the current page.- (void)reload; Moving Back and Forward后退前进1234var canGoBack: BoolA Boolean value indicating whether the receiver can move backward.@property(nonatomic, readonly, getter=canGoBack) BOOL canGoBack; 1234var canGoForward: BoolA Boolean value indicating whether the receiver can move forward.@property(nonatomic, readonly, getter=canGoForward) BOOL canGoForward; 1234func goBack()Loads the previous location in the back-forward list.- (void)goBack; 1234func goForward()Loads the next location in the back-forward list.- (void)goForward; Setting Web Content Properties内容相关属性的设置 1234var allowsLinkPreview: BoolA Boolean value that determines whether pressing on a link displays a preview of the destination for the link.@property(nonatomic) BOOL allowsLinkPreview; 1234var scalesPageToFit: BoolA Boolean value determining whether the webpage scales to fit the view and the user can change the scale.@property(nonatomic) BOOL scalesPageToFit; 1234var scrollView: UIScrollViewThe scroll view associated with the web view.@property(nonatomic, readonly, strong) UIScrollView *scrollView; 1234var suppressesIncrementalRendering: BoolA Boolean value indicating whether the web view suppresses content rendering until it is fully loaded into memory.@property(nonatomic) BOOL suppressesIncrementalRendering; 1234var keyboardDisplayRequiresUserAction: BoolA Boolean value indicating whether web content can programmatically display the keyboard.@property(nonatomic) BOOL keyboardDisplayRequiresUserAction; 1234var dataDetectorTypes: UIDataDetectorTypesThe types of data converted to clickable URLs in the web view’s content.@property(nonatomic) UIDataDetectorTypes dataDetectorTypes; Running JavaScript1234func stringByEvaluatingJavaScript(from: String)Returns the result of running a JavaScript script. Although this method is not deprecated, best practice is to use the evaluateJavaScript(_:completionHandler:) method of the WKWebView class instead.- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; Managing Media Playback多媒体播放1234var allowsInlineMediaPlayback: BoolA Boolean value that determines whether HTML5 videos play inline or use the native full-screen controller.@property(nonatomic) BOOL allowsInlineMediaPlayback; 1234var mediaPlaybackRequiresUserAction: BoolA Boolean value that determines whether HTML5 videos can play automatically or require the user to start playing them.@property(nonatomic) BOOL mediaPlaybackRequiresUserAction; 1234var mediaPlaybackAllowsAirPlay: BoolA Boolean value that determines whether Air Play is allowed from this view.@property(nonatomic) BOOL mediaPlaybackAllowsAirPlay; 1234var allowsPictureInPictureMediaPlayback: BoolA Boolean value that determines whether Picture in Picture playback is allowed from this view.@property(nonatomic) BOOL allowsPictureInPictureMediaPlayback; Managing Pages页面设置1234var gapBetweenPages: CGFloatThe size of the gap, in points, between pages.@property(nonatomic) CGFloat gapBetweenPages; 1234var pageCount: IntThe number of pages produced by the layout of the web view.@property(nonatomic, readonly) NSUInteger pageCount; 1234var pageLength: CGFloatThe size of each page, in points, in the direction that the pages flow.@property(nonatomic) CGFloat pageLength; 1234var paginationBreakingMode: UIWebPaginationBreakingModeThe manner in which column- or page-breaking occurs.@property(nonatomic) UIWebPaginationBreakingMode paginationBreakingMode; 1234var paginationMode: UIWebPaginationModeThe layout of content in the web view.@property(nonatomic) UIWebPaginationMode paginationMode; 最后附上 UIWebView.h作为一枚成长中的菜鸟，分享和开源精神，还是值得具备的。如果…我是说如果，可以关注下 GitHub123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//// UIWebView.h// UIKit//// Copyright (c) 2007-2015 Apple Inc. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIView.h&gt;#import &lt;UIKit/UIKitDefines.h&gt;#import &lt;UIKit/UIDataDetectors.h&gt;#import &lt;UIKit/UIScrollView.h&gt;NS_ASSUME_NONNULL_BEGINtypedef NS_ENUM(NSInteger, UIWebViewNavigationType) &#123;UIWebViewNavigationTypeLinkClicked,UIWebViewNavigationTypeFormSubmitted,UIWebViewNavigationTypeBackForward,UIWebViewNavigationTypeReload,UIWebViewNavigationTypeFormResubmitted,UIWebViewNavigationTypeOther&#125; __TVOS_PROHIBITED;typedef NS_ENUM(NSInteger, UIWebPaginationMode) &#123;UIWebPaginationModeUnpaginated,UIWebPaginationModeLeftToRight,UIWebPaginationModeTopToBottom,UIWebPaginationModeBottomToTop,UIWebPaginationModeRightToLeft&#125; __TVOS_PROHIBITED;typedef NS_ENUM(NSInteger, UIWebPaginationBreakingMode) &#123;UIWebPaginationBreakingModePage,UIWebPaginationBreakingModeColumn&#125; __TVOS_PROHIBITED;@class UIWebViewInternal;@protocol UIWebViewDelegate;NS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UIWebView : UIView &lt;NSCoding, UIScrollViewDelegate&gt;@property (nullable, nonatomic, assign) id &lt;UIWebViewDelegate&gt; delegate;@property (nonatomic, readonly, strong) UIScrollView *scrollView NS_AVAILABLE_IOS(5_0);- (void)loadRequest:(NSURLRequest *)request;- (void)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;@property (nullable, nonatomic, readonly, strong) NSURLRequest *request;// 重新加载（刷新）- (void)reload;// 停止加载- (void)stopLoading;// 回退- (void)goBack; // 前进- (void)goForward;// 是否能回退@property (nonatomic, readonly, getter=canGoBack) BOOL canGoBack;// 是否能前进@property (nonatomic, readonly, getter=canGoForward) BOOL canGoForward; // 是否正在加载中@property (nonatomic, readonly, getter=isLoading) BOOL loading;// 在OC中调用JavaScript代码- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;// 是否伸缩内容至适应屏幕当前尺寸@property (nonatomic) BOOL scalesPageToFit;@property (nonatomic) BOOL detectsPhoneNumbers NS_DEPRECATED_IOS(2_0, 3_0); // 需要进行检测的数据类型@property (nonatomic) UIDataDetectorTypes dataDetectorTypes NS_AVAILABLE_IOS(3_0);@property (nonatomic) BOOL allowsInlineMediaPlayback NS_AVAILABLE_IOS(4_0); // iPhone Safari defaults to NO. iPad Safari defaults to YES@property (nonatomic) BOOL mediaPlaybackRequiresUserAction NS_AVAILABLE_IOS(4_0); // iPhone and iPad Safari both default to YES@property (nonatomic) BOOL mediaPlaybackAllowsAirPlay NS_AVAILABLE_IOS(5_0); // iPhone and iPad Safari both default to YES@property (nonatomic) BOOL suppressesIncrementalRendering NS_AVAILABLE_IOS(6_0); // iPhone and iPad Safari both default to NO@property (nonatomic) BOOL keyboardDisplayRequiresUserAction NS_AVAILABLE_IOS(6_0); // default is YES@property (nonatomic) UIWebPaginationMode paginationMode NS_AVAILABLE_IOS(7_0);@property (nonatomic) UIWebPaginationBreakingMode paginationBreakingMode NS_AVAILABLE_IOS(7_0);@property (nonatomic) CGFloat pageLength NS_AVAILABLE_IOS(7_0);@property (nonatomic) CGFloat gapBetweenPages NS_AVAILABLE_IOS(7_0);@property (nonatomic, readonly) NSUInteger pageCount NS_AVAILABLE_IOS(7_0);@property (nonatomic) BOOL allowsPictureInPictureMediaPlayback NS_AVAILABLE_IOS(9_0);@property (nonatomic) BOOL allowsLinkPreview NS_AVAILABLE_IOS(9_0); // default is NO@end__TVOS_PROHIBITED @protocol UIWebViewDelegate &lt;NSObject&gt;@optional// UIWebView在发送请求之前，都会调用这个方法，如果返回NO，代表停止加载请求，返回YES，代表允许加载请求- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType; // 开始发送请求（加载数据）时调用这个方法- (void)webViewDidStartLoad:(UIWebView *)webView; // 请求完毕（加载数据完毕）时调用这个方法- (void)webViewDidFinishLoad:(UIWebView *)webView; // 请求错误时调用这个方法- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error;@endNS_ASSUME_NONNULL_END 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 封装思维—业务逻辑类]]></title>
    <url>%2FEncapsulationThinking%2Fbusiness.html</url>
    <content type="text"></content>
      <categories>
        <category>封装</category>
      </categories>
      <tags>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIBezierPath译文]]></title>
    <url>%2FAppleTranslation%2FUIBezierPathApple.html</url>
    <content type="text"><![CDATA[引导 记得刚接触 iOS 的时候, 第一次看到绘图和动画做出来的效果时，只有一个感觉酷！高大上！(默默下决心我要学会☺).在写出这些牛X效果的前提 贝塞尔曲线这个东西我觉得要做到初步理解，然后梳理总结，到最后夯实基础、活学活用。 正题在这里首先附上官方原文地址 UIBezierPath Class &amp; UIBezierPath.h 属性和方法 Relationships Inherits From NSObject 继承自: NSObject Conforms To NSCoding, NSCopying 遵守: NSCoding，NSObject Framework: UIKit in iOS 3_2 iOS 3.2+ ClassUIBezierPath The UIBezierPath class lets you define a path consisting of straight and curved line segments and render that path in your custom views.You use this class initially to specify just the geometry for your path. Paths can define simple shapes such as rectangles, ovals, and arcs or they can define complex polygons that incorporate a mixture of straight and curved line segments.After defining the shape, you can use additional methods of this class to render the path in the current drawing context. UIBezierPath 类允许你在自定义的 View 中绘制和渲染由直线和曲线组成的路径. 你可以在初始化的时候, 直接为你的 UIBezierPath 指定一个几何路径. 路径可以是简单的几何图形例如: 矩形、椭圆、弧线之类的, 也可以是相对比较复杂的由直线和曲线组成的多边形. 当你定义完图形以后, 你可以使用这个类的其他的方法将你的路径直接绘制在当前的绘图上下文中. Overview A UIBezierPath object combines the geometry of a path with attributes that describe the path during rendering. You set the geometry and attributes separately and can change them independent of one another. Once you have the object configured the way you want it, you can tell it to draw itself in the current context. Because the creation, configuration, and rendering process are all distinct steps, Bezier path objects can be reused easily in your code. You can even use the same object to render the same shape multiple times, perhaps changing the rendering options between successive drawing calls. UIBezierPath 是由几何路径 和 属性描述组成的, 属性是用来在渲染阶段描绘几何路径的, 比如线宽之类的东西. 路径和属性是完全独立的, 他们并不互相依赖, 你可以分开分开去设置他们. 一旦你以自己喜欢的方式配置了 UIBezierPath 对象, 你就可以调用方法通知UIBezierPath 在当前的绘图上下文中绘制图形了. 因为创建、 配置、 渲染路径等操作, 都是完全不同的步骤, 所以你可以在你的代码中非常容易的对UIBezierPath 对象进行复用. 你甚至可以使用同一个 UIBezierPath 对象去渲染同一个图形很多次, 你也可以再多次渲染的间隔中, 修改属性来渲染出不同样式的路径. You set the geometry of a path by manipulating the path’s current point. When you create a new empty path object, the current point is undefined and must be set explicitly. To move the current point without drawing a segment, you use the moveToPoint:method. All other methods result in the addition of either a line or curve segments to the path. The methods for adding new segments always assume you are starting at the current point and ending at some new point that you specify. After adding the segment, the end point of the new segment automatically becomes the current point. 你可以通过控制路径的当前的(起始)点来设置一条路径的形状，当你创建了一个空的UIBezierPath 对象时, 起始点currentPoint 这个属性是未定义的, 你需要手动的去设置.currentPoint. 如果你希望在不绘制任何线条的情况下移动currentPoint, 你可以使用 moveToPoint:方法. 其他的方法都会导致在你的路径中添加额外的直线或曲线. 所有构造路径相关的方法, 都会以当前路径的currentPoint 为起点, 以你指定的endPoint为终点进行绘制. 当完成绘制之后, 会自动将新增的这条线的终点设置为UIBezierPath 对象的currentPoint. A single Bezier path object can contain any number of open or closed subpaths, where each subpath represents a connected series of path segments. Calling the closePath method closes a subpath by adding a straight line segment from the current point to the first point in the subpath. Calling the moveToPoint: method ends the current subpath (without closing it) and sets the starting point of the next subpath. The subpaths of a Bezier path object share the same drawing attributes and must be manipulated as a group. To draw subpaths with different attributes, you must put each subpath in its own UIBezierPath object. 一个单一的贝塞尔路径对象能够包含任意数量的开放和闭合的子路径,在这些路径的线段中，每一个线段都是串联的. 调用closePath方法将会闭合路径, 它将会从currentPoint 到 子路经的 firstPoint起点绘制一条直线. 调用moveToPoint:方法将会结束当前的子路径, 但是并不会自动闭合当前的自路径, 并且会将currentPoint 移动到指定的点, 也就是下一条绘制路径的起始点.UIBezierPath中所有的自路径都会共享同样的绘图属性. 如果你希望绘制一些子路径, 但是不适用相同的绘图属性, 那么你就只能创建很多的UIBezierPath 对象来承载每一条路径. After configuring the geometry and attributes of a Bezier path, you draw the path in the current graphics context using the stroke and fill methods. The stroke method traces the outline of the path using the current stroke color and the attributes of the Bezier path object. Similarly, the fill method fills in the area enclosed by the path using the current fill color. (You set the stroke and fill color using the UIColor class.) 当你为UIBezierPath 对象配置完几何路径和绘图属性之后, 你就可以使用stroke描边(空心) 和 fill填充(实心) 方法在当前的绘图上下文中进行绘制了. stroke方法将会使用当前的strokeColor 和 绘图属性来描绘曲线的轮廓. 同样的, fill 方法将会使用fillColor 来填充路径所围成的图形(使用UIColor 类方法来设置strokeColor 和 fillColor). In addition to using a Bezier path object to draw shapes, you can also use it to define a new clipping region. The addClip method intersects the shape represented by the path object with the current clipping region of the graphics context. During subsequent drawing, only content that lies within the new intersection region is actually rendered to the graphics context. 除了可以用贝塞尔路径对象去绘制图形,你还可以利用它去定义个新的裁剪区域.addClip方法通过当前图形上下文裁剪的区域的路径对象来表示两个图形的相交. 在随后的绘制过程中,只有处在新的交集区域内的内容实际上是被图形上下文绘制的 然后我们就直接从UIBezierPath.h 入手吧 UIBezierPath.h 创建 UIBezierPath 创建并且返回一个新的 UIBezierPath 对象 12// Objective-C+ (instancetype)bezierPath; 通过一个矩形, 创建并且返回一个新的 UIBezierPath 对象 123456789/** * 画矩形 * 该方法将会创建一个闭合路径, 起始点是 rect 参数的的 origin, 并且按照顺时针方向添加直线, 最终形成矩形 * @param rect: 矩形路径的 Frame */// Swiftconvenience init(rect rect: CGRect)// Objective-C+ (instancetype)bezierPathWithRect:(CGRect)rect; 通过一个指定的矩形中的椭圆形, 创建并且返回一个新的 UIBezierPath 对象 123456789/** * 画圆（width = height）、画椭圆（width != height） * 该方法将会创建一个闭合路径, 该方法会通过顺时针的绘制贝塞尔曲线, 绘制出一个近似椭圆的形状. 如果 rect 参数指定了一个矩形, 那么该 UIBezierPath 对象将会描述一个圆形. * @param rect: 矩形路径的 Frame */// Swiftconvenience init(ovalInRect rect: CGRect)// Objective-C+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect; 根据一个圆角矩形, 创建并且返回一个新的 UIBezierPath 对象 1234567891011/** * 画圆角矩形 * 该方法将会创建一个闭合路径, 该方法会顺时针方向连续绘制直线和曲线. 当 rect 为正方形时且 cornerRadius 等于边长一半时, 则该方法会描述一个圆形路径. * @param rect: 矩形路径的 Frame * @param cornerRadius: 矩形的圆角半径 */// Swiftconvenience init(roundedRect rect: CGRect, cornerRadius cornerRadius: CGFloat)// Objective-C + (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius; // rounds all corners with the same horizontal and vertical radius 根据一个圆角矩形, 创建并且返回一个新的 UIBezierPath 对象 12345678910111213/** * 画指定角为圆角的矩形 * 该方法将会创建一个闭合路径, 该方法会顺时针方向连续绘制直线和曲线. * @param rect: 矩形路径的 Frame * @param corners: UIRectCorner 枚举类型, 指定矩形的哪个角变为圆角 * @param cornerRadii: 矩形的圆角半径 */// Swiftconvenience init(roundedRect rect: CGRect, byRoundingCorners corners: UIRectCorner, cornerRadii cornerRadii: CGSize)// Objective-C + (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii; 通过一个圆弧, 创建并且返回一个新的 UIBezierPath 对象 1234567891011121314151617/** * 画圆弧 * 该方法会创建出一个开放路径, 创建出来的圆弧是圆的一部分. 在默认的坐标系统中, 开始角度 和 结束角度 都是基于单位圆的(看下面这张图). 调用这个方法之后, currentPoint 将会设置为圆弧的结束点. * @param center: 弧所在的圆心（这里不能直接用self.center,因为它是相对于它的父控件的,采用rect 宽度*0.5、高度*0.5） * @param radius: 圆的半径 * @param startAngle: 开始角度 * @param endAngle: 结束角度 * @param clockwise: 是否顺时针绘制（YES顺时针 NO逆时针） */// Swiftconvenience init(arcCenter center: CGPoint, radius radius: CGFloat, startAngle startAngle: CGFloat, endAngle endAngle: CGFloat, clockwise clockwise: Bool)// Objective-C + (instancetype)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise; 通过一个 CGPath, 创建并且返回一个新的 UIBezierPath 对象 1234// Swiftconvenience init(CGPath CGPath: CGPath)// Objective-C+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath; 创建并返回一个新的BezierPath, 这个 BezierPath 的方向是原 BezierPath 的反方向 123456789 // Modified paths/** * 通过该方法反转一条路径, 并不会修改该路径的样子. 它仅仅是修改了绘制的方向 * @return: 返回一个新的 UIBezierPath 对象, 形状和原来路径的形状一样,但是绘制的方向相反. */// Swiftfunc bezierPathByReversingPath() -&gt; UIBezierPath// Objective-C - (UIBezierPath *)bezierPathByReversingPath NS_AVAILABLE_IOS(6_0); 构造路径 将 UIBezierPath 对象的 currentPoint 移动到指定的点 12345678910 // Path construction/** * 设置起点 * 如果当前有正在绘制的子路径, 该方法则会隐式的结束当前路径, 并将 currentPoint 设置为指定点. * @param point: 当前坐标系统中的某一点 */// Swiftfunc moveToPoint(_ point: CGPoint)// Objective-C - (void)moveToPoint:(CGPoint)point; 在当前子路径中追加一条直线 12345678910111213/** * 添加一根线到终点 * 该方法将会从 currentPoint 到 指定点 链接一条直线. * @param point: 绘制直线的终点坐标, 当前坐标系统中的某一点 * Note: 在追加完这条直线后, 该方法将会更新 currentPoint 为 指定点 调用该方法之前, 你必须先设置 currentPoint. 如果当前绘制路径 为空, 并且未设置 currentPoint, 那么调用该方法将不会产生任何 效果. */// Swiftfunc addLineToPoint(_ point: CGPoint)// Objective-C - (void)addLineToPoint:(CGPoint)point; 在当前子路径中追加一条圆弧 1234567891011/** * 画指定一条圆弧 * 该方法将会从 currentPoint 添加一条指定的圆弧. * 该方法的介绍和 bezierPathWithArcCenter构造方法中的一样. 请前往上文查看 * @param center: 圆心 * @param radius: 半径 * @param startAngle: 开始角度 * @param endAngle: 结束角度 * @param clockwise: 是否顺时针绘制 */ - (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise NS_AVAILABLE_IOS(4_0); 在当前 子路经中追加一条 二次贝塞尔曲线 1234567891011121314151617/** * 画二次贝塞尔曲线（由一个控制点来控制） * 该方法将会从 currentPoint 到 指定的 endPoint 追加一条二次贝塞尔曲线. * currentPoint、endPoint、controlPoint 三者的关系最终定义了二次贝塞尔曲线的形状. * 二次贝塞尔曲线的弯曲由一个控制点来控制. 如下图所示 Note: 调用该方法前, 你必须先设置 currentPoint, 如果路径为空, 并且尚未设置 currentPoint, 调用该方法则不会产生任何效果. 当添加完贝塞尔曲线后, 该方法将会自动更新 currentPoint 为 指定的结束点 * @param endPoint: 终点 * @param controlPoint: 弯曲方向点1 */// Swiftfunc addQuadCurveToPoint(_ endPoint: CGPoint, controlPoint controlPoint: CGPoint)// Objective-C - (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint; 在当前 子路经中追加一条 三次贝塞尔曲线 12345678910111213141516171819/** * 画三次贝塞尔曲线（由两个控制点来控制） * 该方法将会从 currentPoint 到 指定的 endPoint 追加一条三次贝塞尔曲线. * 三次贝塞尔曲线的弯曲由两个控制点来控制. 如下图所示 * Note: 调用该方法前, 你必须先设置 currentPoint, 如果路径为空, 并且尚未设置 currentPoint, 调用该方法则不会产生任何效果. 当添加完贝塞尔曲线后, 该方法将会自动更新 currentPoint 为 指定的结束点 * @param endPoint: 终点 * @param controlPoint1: 弯曲方向点1 * @param controlPoint2: 弯曲方向点2 */// Swiftfunc addCurveToPoint(_ endPoint: CGPoint, controlPoint1 controlPoint1: CGPoint, controlPoint2 controlPoint2: CGPoint)// Objective-C - (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2; 关闭当前子路经 12345678910/** * 闭合路径 * 该方法将会从 currentPoint 到子路经的起点 绘制一条直线, * 以此来关闭当前的自路径. 紧接着该方法将会更新 currentPoint * 为 刚添加的这条直线的终点, 也就是当前子路经的起点. */// Swiftfunc closePath()// Objective-C- (void)closePath; 移除 UIBezierPath 对象中的所有点, 效果也就等同于移除所有子路经 1234// Swiftfunc removeAllPoints()// Objective-C- (void)removeAllPoints; 将指定 UIBezierPath 中的内容添加到当前 UIBezierPath 对象中 123456789/** * 追加路径 * 该方法将会在当前 UIBezierPath 对象的路径中追加 * 指定的 UIBezierPath 对象中的内容. */// Swiftfunc appendPath(_ bezierPath: UIBezierPath)// Objective-C- (void)appendPath:(UIBezierPath *)bezierPath; UIBezierPath 中的 CGPath 对象 1234567891011/** * 获取这个属性, 你将会获得一个不可变的 CGPathRef 对象, * 他可以传入 CoreGraphics 提供的函数中 * 你可以是用 CoreGraphics 框架提供的方法创建一个路径, * 并给这个属性赋值, 当时设置了一个新的路径后, * 这个将会对你给出的路径对象进行 Copy 操作 */// Swiftvar CGPath: CGPath// Objective-C@property(nonatomic) CGPathRef CGPath; 绘图路径中的当前点 12345678/** * 该属性的值, 将会是下一条绘制的直线或曲线的起始点. * 如果当前路径为空, 那么该属性的值将会是 CGPointZero */// Swiftvar currentPoint: CGPoint &#123; get &#125;// Objective-C@property(nonatomic, readonly) CGPoint currentPoint; 绘图属性 线宽 1234567/** * 线宽属性定义了 `UIBezierPath` 对象中绘制的曲线规格. 默认为: 1.0 */// Swiftvar lineWidth: CGFloat// Objective-C@property(nonatomic) CGFloat lineWidth; 曲线终点样式 1234567891011121314/** * 该属性应用于曲线的终点和起点. 该属性在一个闭合子路经中是无效果的. 默认为: kCGLineCapButt */// Swiftvar lineCapStyle: CGLineCap// Objective-C@property(nonatomic) CGLineCap lineCapStyle;/* Line cap styles. */typedef CF_ENUM(int32_t, CGLineCap) &#123; kCGLineCapButt,// kCGLineCapRound,// 圆弧 kCGLineCapSquare //&#125;; 曲线连接点样式 1234567891011121314/** * 默认为: kCGLineJoinMiter. */// Swiftvar lineJoinStyle: CGLineJoin// Objective-C@property(nonatomic) CGLineJoin lineJoinStyle;/* Line join styles. */typedef CF_ENUM(int32_t, CGLineJoin) &#123; kCGLineJoinMiter,// 尖的 kCGLineJoinRound,// 圆弧 kCGLineJoinBevel // 斜面&#125;; 内角和外角距离 12345678910111213/** * 斜接点长度 * 两条线交汇处内角和外角之间的最大距离, 只有当连接点样式为 kCGLineJoinMiter * 时才会生效，最大限制为10 * 我们都知道, 两条直线相交时, 夹角越小, 斜接长度就越大. * 该属性就是用来控制最大斜接长度的. * 当我们设置了该属性, 如果斜接长度超过我们设置的范围, * 则连接处将会以 kCGLineJoinBevel 连接类型进行显示. */// Swiftvar miterLimit: CGFloat// Objective-C@property(nonatomic) CGFloat miterLimit; 渲染精度 12345678910111213/** * 该属性用来确定渲染曲线路径的精确度. * 该属性的值用来测量真实曲线的点和渲染曲线的点的最大允许距离. * 值越小, 渲染精度越高, 会产生相对更平滑的曲线, 但是需要花费更 * 多的计算时间. 值越大导致则会降低渲染精度, 这会使得渲染的更迅速. flatness 的默认值为 0.6. * Note: 大多数情况下, 我们都不需要修改这个属性的值. 然而当我们 希望以最小的消耗去绘制一个临时的曲线时, 我们也许会临时增 大这个值, 来获得更快的渲染速度. */// Swiftvar flatness: CGFloat// Objective-C@property(nonatomic) CGFloat flatness; 是否使用基偶填充规则 12345678/** * 设置为 YES, 则路径将会使用 基偶规则 (even-odd) 进行填充. * 设置为 NO, 则路径将会使用 非零规则 (non-zero) 规则进行填充. */// Swiftvar usesEvenOddFillRule: Bool// Objective-C@property(nonatomic) BOOL usesEvenOddFillRule; 虚线 1234567891011121314151617181920212223/** * @param pattern: 该属性是一个 C 语言的数组, 其中每一个元素都是 CGFloat 数组中的元素代表着线段每一部分的长度, 第一个元素代表线段的第一条线, 第二个元素代表线段中的第一个间隙. 这个数组中的值是轮流的. 来解释一下 什么叫轮流的. * 举个例子: 声明一个数组 CGFloat dash[] = @&#123;3.0, 1.0&#125;; 这意味着绘制的虚线的第一部分长度为3.0, 第一个间隙长度为1.0, 虚线的 第二部分长度为3.0, 第二个间隙长度为1.0. 以此类推. * @param count: 这个参数是 pattern 数组的个数 * @param phase: 这个参数代表着, 虚线从哪里开始绘制. * 举个例子: 这是 phase 为 6. pattern[] = @&#123;5, 2, 3, 2&#125;; 那么虚线将会 第一个间隙的中间部分开始绘制, 如果不是很明白就请继续往下看, 下文实战部分会对虚线进行讲解. */// Swiftfunc setLineDash(_ pattern: UnsafePointer&lt;CGFloat&gt;,count count: Int,phase phase: CGFloat)// Objective-C- (void)setLineDash:(const CGFloat *)pattern count:(NSInteger)count phase:(CGFloat)phase; 重新获取虚线的模式 123456789101112131415/** * 该方法可以重新获取之前设置过的虚线样式. * Note: pattern 这个参数的容量必须大于该方法返回数组的容量. 如果无法确定数组的容量, 那么可以调用两次该方法, 第一次 调用该方法的时候, 传入 count 参数, 然后在用 count 参数 来申请 pattern 数组的内存空间. 然后再第二次正常的调用该方法 */// Swiftfunc getLineDash(_ pattern: UnsafeMutablePointer&lt;CGFloat&gt;,count count: UnsafeMutablePointer&lt;Int&gt;,phase phase: UnsafeMutablePointer&lt;CGFloat&gt;)// Objective-C- (void)getLineDash:(CGFloat *)pattern count:(NSInteger *)count phase:(CGFloat *)phase; 绘制路径 填充路径 1234567891011/** * 填充（实心） * 该方法当前的填充颜色 和 绘图属性对路径的封闭区域进行填充. * 如果当前路径是一条开放路径, 该方法将会隐式的将路径进行关闭后进行填充 * 该方法在进行填充操作之前, 会自动保存当前绘图的状态, 所以我们不需要 * 自己手动的去保存绘图状态了. */// Swiftfunc fill()// Objective-C- (void)fill; 混合模式进行填充 12345678910111213141516/** * 该方法当前的填充颜色 和 绘图属性 (外加指定的混合模式 和 透明度) * 对路径的封闭区域进行填充. 如果当前路径是一条开放路径, 该方法将 * 会隐式的将路径进行关闭后进行填充 * 该方法在进行填充操作之前, 会自动保存当前绘图的状态, 所以我们不需要 * 自己手动的去保存绘图状态了. * * @param blendMode: 混合模式决定了如何和已经存在的被渲染过的内容进行合成 * @param alpha: 填充路径时的透明度 */// Swiftfunc fillWithBlendMode(_ blendMode: CGBlendMode,alpha alpha: CGFloat)// Objective-C- (void)fillWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha; 描边路径 1234// Swiftfunc stroke()// Objective-C- (void)stroke; 混合模式进行填充 123456789/** * @param blendMode: 混合模式决定了如何和已经存在的被渲染过的内容进行合成 * @param alpha: 填充路径时的透明度 */// Swiftfunc strokeWithBlendMode(_ blendMode: CGBlendMode,alpha alpha: CGFloat)// Objective-C- (void)strokeWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha; 剪切路径 剪切路径 123456789101112131415/** * 该方法将会修改当前绘图上下文的可视区域. * 当调用这个方法之后, 会导致接下来所有的渲染操作, 只会在剪切下来的区域内进行, 区域外的内容将不会被渲染. * 如果你希望执行接下来的绘图时, 删除剪切区域, 那么你必须在调用该方法前, 先使用CGContextSaveGState 方法保存当前的绘图状态, 当你不再需要这个剪切区域的时候, 你只需要使用 CGContextRestoreGState 方法， 来恢复之前保存的绘图状态就可以了. * @param blendMode: 混合模式决定了如何和已经存在的被渲染过的内容进行合成 * @param alpha: 填充路径时的透明度 */// Swiftfunc addClip()// Objective-C- (void)addClip; Hit Detection 是否包含某个点 123456789101112131415/** * 该方法返回一个布尔值, 当曲线的覆盖区域包含 * 指定的点(内部点)， 则返回 YES, 否则返回 NO. * Note: 如果当前的路径是一个开放的路径, 那么 就算指定点在路径覆盖范围内, 该方法仍然会 返回 NO, 所以如果你想判断一个点是否在一个 开放路径的范围内时, 你需要先Copy一份路径, 并调用 -(void)closePath; 将路径封闭, 然后 再调用此方法来判断指定点是否是内部点. * @param point: 指定点. */// Swiftfunc containsPoint(_ point: CGPoint) -&gt; Bool// Objective-C- (BOOL) containsPoint:(CGPoint)point; 路径是否为空 123456789/** * 检测当前路径是否绘制过直线或曲线. * Note: 记住, 就算你仅仅调用了 moveToPoint 方法 那么当前路径也被看做不为空. */// Swiftvar empty: Bool &#123; get &#125;// Objective-C@property (readonly, getter=isEmpty) BOOL empty; 路径覆盖的矩形区域 123456789/** * 该属性描述的是一个能够完全包含路径中所有点 * 的一个最小的矩形区域. 该区域包含二次贝塞尔 * 曲线和三次贝塞尔曲线的控制点. */// Swiftvar bounds: CGRect &#123; get &#125;// Objective-C@property (nonatomic, readonly) CGRect bounds; Apply Transform 12345678/** * 该方法将会直接对路径中的所有点进行指定的放射 * 变换操作. */// Swiftfunc applyTransform(_ transform: CGAffineTransform)// Objective-C- (void)applyTransform:(CGAffineTransform)transform; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Swiftstruct UIRectCorner : OptionSetType &#123;init(rawValue rawValue: UInt)static var TopLeft: UIRectCorner &#123; get &#125;static var TopRight: UIRectCorner &#123; get &#125;static var BottomLeft: UIRectCorner &#123; get &#125;static var BottomRight: UIRectCorner &#123; get &#125;static var AllCorners: UIRectCorner &#123; get &#125;&#125;// Objective-Cenum &#123;UIRectCornerTopLeft = 1 &lt;&lt; 0,UIRectCornerTopRight = 1 &lt;&lt; 1,UIRectCornerBottomLeft = 1 &lt;&lt; 2,UIRectCornerBottomRight = 1 &lt;&lt; 3,UIRectCornerAllCorners = ~0&#125;;typedef NSUInteger UIRectCorner;常数(Constants):UIRectCornerTopLeftThe top-left corner of the rectangle.矩形的左上角.Available in iOS 3.2 and later.UIRectCornerTopRightThe top-right corner of the rectangle.矩形的右上角.Available in iOS 3.2 and later.UIRectCornerBottomLeftThe bottom-left corner of the rectangle.矩形的左下角.Available in iOS 3.2 and later.UIRectCornerBottomRightThe bottom-right corner of the rectangle.矩形的右下角.Available in iOS 3.2 and later.UIRectCornerAllCornersAll corners of the rectangle.矩形的所有的角.Available in iOS 3.2 and later.指定的常数反映了一个没有被 仿射变换修改和已经在默认坐标系上绘制的矩形的所有角.(原点在左上角和 ??扩散的值(positive values)向下延伸到右边).导入声明(Import Statement)// Swiftimport UIKit// Objective-C@import UIKit; 实战示例UIBezierPath.h 文件大家完全的过了一遍了, 其实看上去还是蛮简单过的昂.. 接下来就到了激动人心的实战环节了. 我们来简单的写几句代码, 看看效果吧.1、bezierPathByReversingPath:路径反转12345678910111213141516171819202122232425- (void) drawRect:(CGRect)rect &#123; // 1. 随便画一个路径出来. UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint: CGPointMake(10, 10)]; [path addLineToPoint: CGPointMake(80, 40)]; [path addLineToPoint: CGPointMake( 40, 80)]; [path addLineToPoint: CGPointMake(40, 40)]; path.lineWidth = 3; // 2. 为这条路径制作一个反转路径 UIBezierPath *reversingPath = [path bezierPathByReversingPath]; reversingPath.lineWidth = 3; // 3. 为了避免两条路径混淆在一起, 我们为第一条路径做一个位移 CGAffineTransform transform = CGAffineTransformMakeTranslation(200, 0); [path applyTransform: transform]; // 4. 设置颜色, 并绘制路径 [[UIColor redColor] set]; [path stroke]; [[UIColor greenColor] set]; [reversingPath stroke];&#125; 效果： 2、setLineDash: 虚线1234567891011121314151617181920212223242526272829303132333435363738- (void) typeDashLine &#123; // 1. 先创建三条路径, 有对比更有助于理解 UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint: CGPointMake(80, 40)]; [path addLineToPoint: CGPointMake(self.frame.size.width - 40, 40)]; path.lineWidth = 2; UIBezierPath *path1 = [UIBezierPath bezierPath]; [path1 moveToPoint: CGPointMake(80, 80)]; [path1 addLineToPoint: CGPointMake(self.frame.size.width - 40, 80)]; path1.lineWidth = 2; UIBezierPath *path2 = [UIBezierPath bezierPath]; [path2 moveToPoint: CGPointMake(80, 120)]; [path2 addLineToPoint: CGPointMake(self.frame.size.width - 40, 120)]; path2.lineWidth = 2; // 2. 这部分是配置三条路径虚线的规格, 重点主要是这部分. CGFloat dashLineConfig[] = &#123;8.0, 4.0&#125;; [path setLineDash: dashLineConfig count: 2 phase: 0]; CGFloat dashLineConfig1[] = &#123;8.0, 4.0, 16.0, 8.0&#125;; [path1 setLineDash: dashLineConfig1 count: 4 phase: 0]; CGFloat dashLineConfig2[] = &#123;8.0, 4.0, 16.0, 8.0&#125;; [path2 setLineDash: dashLineConfig2 count: 4 phase: 12]; // 3. 绘制 [[UIColor orangeColor] set]; [path stroke]; [path1 stroke]; [path2 stroke];&#125; 效果： 要想做出多牛逼酷炫的动画效果，就必须承受同等学习的代价 ！ 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UI控件详解—「UICollectionView综合视图」]]></title>
    <url>%2FiOSUI%2FUICollectionView.html</url>
    <content type="text"><![CDATA[Write in the first【写在最前】 UITableView 熟悉吧， UICollectionView 必须熟悉吧。在WWDC2012中的Introducing Collection Views，苹果首次介绍了UICollectionView，类似UITableView的用法使人很容易接受，但强大的自定义布局，又使其相较于UITableView有了选择它的更多理由，UITableView中的表格只支持单排列表，没有办法支持网格列表模式，CollectionView有着灵活的布局特性，这一点充分说明我们在学会UITableView的基础上，再去学习推敲CollectionView的必要性。 本篇文章主要从【UICollectionView 系统文件注解】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 目录： UICollectionView概念 UICollectionView基本组成 UICollectionView层次结构1.UICollectionView 继承于 UIScrollView2.UICollectionViewDataSource数据源3.UICollectionViewDelegate代理4.UICollectionViewLayout自定义布局对象5.UICollectionViewFlowLayout布局对象(默认)6.UICollectionViewCell样式7.UICollectionViewLayoutAttributes布局属性 UICollectionView与UITableView比较 UICollectionView使用说明 UICollectionView基本使用 自定义FlowLayout：水平滚动相册 UICollectionView效果图 自定义FlowLayout：瀑布流 UICollectionView.h 属性&amp;方法 UICollectionView概念 本着好好学习，了解权威的目的，我们还是主动看官网的说明。 上图释义：管理有序的数据项集合和使用自定制的布局。 通俗点就是：UICollectionView 是一种新的数据展示方式，简单来说可以把他理解成多列的UITableView，可以做九宫格布局的一种view； UICollectionView基本组成 注解：如上图：你看到的就是一个最简单的UICollectionView，它包含：Cells、Supplementary Views、Decoration Views。 Cells：用于展示内容的主体，cell的尺寸和内容可以各不相同。 Supplementary Views：追加视图，类似于UITableView每个Seciton的Header View 或者Footer View，用来标记Section的View。 Decoration Views：装饰视图，完全跟数据没有关系的视图，负责给cell 或者supplementary Views添加辅助视图用的，灵活性较强。 不管多么复杂的UIcollectionView都是由着三个部件组成的。 UICollectionView层次结构 注解： 1、UICollectionView 继承于 UIScrollView1NS_CLASS_AVAILABLE_IOS(6_0) @interface UICollectionView : UIScrollView 2、UICollectionViewDataSource：主要管理视图数据源方面，告诉view要显示些什么东西以及如何显示它们。 @required（必须） 123456789@protocol UICollectionViewDataSource &lt;NSObject&gt;@required/* （必须）设置容器视图各个组Section中有【多少item】 */- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section;// The cell that is returned must be retrieved from a call to -dequeueReusableCellWithReuseIdentifier:forIndexPath:/* （必须）设置每个区中【item的内容】，类似于UITableViewCell的设置 */- (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath; @optional（可选） 123456789101112131415@optional（可选）/* （可选）设置容器视图有多少组Section，系统默认返回值为1 */- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView;// The view that is returned must be retrieved from a call to -dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:// 补充视图，这里可以充当区的头和尾，我们自己不实现的话，系统默认返回值为nil/* （可选）返回顶部视图和底部视图，通过kind参数分辨是设置顶部还是底部（补充视图） */- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath;/** （可选）询问是否指定的单元格项目是否可以移动到集合视图中的另一个位置，默认返回值为NO */- (BOOL)collectionView:(UICollectionView *)collectionView canMoveItemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(9_0);/** （可选）将指定的单元格项目从一个位置移动到集合视图中的另一个位置 */- (void)collectionView:(UICollectionView *)collectionView moveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath NS_AVAILABLE_IOS(9_0); 3、UICollectionViewDelegate：主要管理于用户交互方面，提供一些样式的小细节。 @optional（可选） 123456789101112131415161718192021222324252627@protocol UICollectionViewDelegate &lt;UIScrollViewDelegate&gt;@optional// Methods for notification of selection/deselection and highlight/unhighlight events.// The sequence of calls leading to selection from a user touch is:// (when the touch begins)// 1. -collectionView:shouldHighlightItemAtIndexPath:// 2. -collectionView:didHighlightItemAtIndexPath://// (when the touch lifts)// 3. -collectionView:shouldSelectItemAtIndexPath: or -collectionView:shouldDeselectItemAtIndexPath:// 4. -collectionView:didSelectItemAtIndexPath: or -collectionView:didDeselectItemAtIndexPath:// 5. -collectionView:didUnhighlightItemAtIndexPath:/** 下面是和高亮有关的方法： */// cell点击时是否高亮，点击cell时的样式和点击后cell的样式- (BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath;// 手指按下高亮- (void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath;// 手指松开取消高亮- (void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath;/** 当前item是否可以点击 */- (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath;/** 当前item是否取消点击 */- (BOOL)collectionView:(UICollectionView *)collectionView shouldDeselectItemAtIndexPath:(NSIndexPath *)indexPath; // called when the user taps on an already-selected item in multi-select mode 事件的处理顺序如下： 1、手指按下：shouldHighlightItemAtIndexPath (如果返回YES则向下执行，否则执行到这里为止)。 2、didHighlightItemAtIndexPath (高亮)。 3、手指松开：didUnhighlightItemAtIndexPath (取消高亮)。 4、shouldSelectItemAtIndexPath (如果返回YES则向下执行，否则执行到这里为止)。 5、didSelectItemAtIndexPath (执行选择事件)。 选中 和 取消选中 item时 ,会触发的方法 1234/* 选中item时 ,会触发的方法 */- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath;/* 取消选中item时 ,会触发的方法 */- (void)collectionView:(UICollectionView *)collectionView didDeselectItemAtIndexPath:(NSIndexPath *)indexPath; 补充视图（头部或尾部视图），显示 和 移除 12345678910111213/** 这两个方法分别是指定indexPath的cell将要显示出的时候调用, 和指定indexPath的头部或尾部视图view将要显示出来的时候调用 */- (void)collectionView:(UICollectionView *)collectionView willDisplayCell:(UICollectionViewCell *)cell forItemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0);- (void)collectionView:(UICollectionView *)collectionView willDisplaySupplementaryView:(UICollectionReusableView *)view forElementKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0);/** 这两个方法分别是指定indexPath的cell将要从collectionView中移除的的时候调用, 和指定indexPath的头部或尾部视图view将要collectionView中移除的时候调用 */- (void)collectionView:(UICollectionView *)collectionView didEndDisplayingCell:(UICollectionViewCell *)cell forItemAtIndexPath:(NSIndexPath *)indexPath;- (void)collectionView:(UICollectionView *)collectionView didEndDisplayingSupplementaryView:(UICollectionReusableView *)view forElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath; 长按某item，弹出copy（复制）和paste（粘贴）的菜单相关。 12345678910// These methods provide support for copy/paste actions on cells.// All three should be implemented if any are./** 这些方法为是 复制/粘贴操作相关 *//** 是否弹出菜单，需要返回YES */- (BOOL)collectionView:(UICollectionView *)collectionView shouldShowMenuForItemAtIndexPath:(NSIndexPath *)indexPath;/** 是否可以弹出事件，使copy和paste有效 */- (BOOL)collectionView:(UICollectionView *)collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender;/** 对事件进行相应操作 */- (void)collectionView:(UICollectionView *)collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender; 注册类型相关 1234567/** 注册要使用的cell对应的类型 */- (void)registerClass:(nullable Class)cellClass forCellWithReuseIdentifier:(NSString *)identifier;- (void)registerNib:(nullable UINib *)nib forCellWithReuseIdentifier:(NSString *)identifier;/** 注册要使用的补充视图(HeaderView 和 FooterView)对应的类型 */- (void)registerClass:(nullable Class)viewClass forSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier;- (void)registerNib:(nullable UINib *)nib forSupplementaryViewOfKind:(NSString *)kind withReuseIdentifier:(NSString *)identifier; 复用队列 123/** 复用队列 */- (__kindof UICollectionViewCell *)dequeueReusableCellWithReuseIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;- (__kindof UICollectionReusableView *)dequeueReusableSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath; 动态修改当前的Item 和 Section 1234567891011121314151617181920212223// These methods allow dynamic modification of the current set of items in the collection view/** 这些方法允许动态修改当前的Item 和 Section */// 插入Section- (void)insertSections:(NSIndexSet *)sections;// 删除Section- (void)deleteSections:(NSIndexSet *)sections;// 刷新Section- (void)reloadSections:(NSIndexSet *)sections;// 移动Section- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;// 插入Item- (void)insertItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;// 删除Item- (void)deleteItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;// 刷新Item- (void)reloadItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;// 移动Item- (void)moveItemAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath;/** 同样可以进行批量操作 */- (void)performBatchUpdates:(void (^ __nullable)(void))updates completion:(void (^ __nullable)(BOOL finished))completion; // allows multiple insert/delete/reload/move calls to be animated simultaneously. Nestable. 其它属性 和 方法相关 1234567891011121314/** 预加载 */@property (nonatomic, getter=isPrefetchingEnabled) BOOL prefetchingEnabled NS_AVAILABLE_IOS(10_0);/** 允许选择 */@property (nonatomic) BOOL allowsSelection; // default is YES/** 允许多个选择 */@property (nonatomic) BOOL allowsMultipleSelection; // default is NO/** 全局刷新 */- (void)reloadData; // discard the dataSource and delegate data and requery as necessary/** 布局动画 */- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated; // transition from one layout to another- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0); 4、UICollectionViewLayout：自定义布局，它负责了将各个cell、Supplementary View和Decoration Views进行组织。UICollectionViewLayout 是UICollectionView特有的，是UICollectionView的精髓所在，它负责将每个cell、supplementary view、decoration view进行组合，为它们设置各自的属性，包括：位置、大小、透明度、层级关系、形状等。UICollectionViewLayout决定了，UICollectionView是如何显示在界面上，从UICollectionView初始化必须要一个UICollectionViewLayout也可以看得出来，Layout对于UICollectionView的最要性。 自定义布局：只要了解5个方法（重写它方法，扩展功能） 12345678910111213141516171819202122232425/** 什么时候调用:collectionView第一次布局,collectionView刷新的时候也会调用 作用:计算cell的布局，条件:ell的位置是固定不变的. */- (void)prepareLayout;/** 作用:指定一段区域给你这段区域cell的尺寸(可以一次性返回所有cell尺寸,也可以每隔一个距离返回cell) 系统传递过来一个区域rect，我们需要返回在该区域中的item的位置信息 返回的是一个数组，数组中包含UICollectionViewLayoutAttributes 对象 */- (nullable NSArray&lt;__kindof UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect; // return an array layout attributes instances for all the views in the given rect// 在滚动的时候是否允许刷新(Invalidate)布局- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds; // return YES to cause the collection view to requery the layout for geometry information/** 什么时候调用:用户手指一松开就会调用 作用:确定最终偏移量 */- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity; // return a point at which to rest after scrolling - for layouts that want snap-to-point scrolling behavior- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset NS_AVAILABLE_IOS(7_0); // a layout can return the content offset to be applied during transition or update animations/** 由于UICollectionVeiw继承自UIScrollView，所以需要重写该函数，告诉contentSize大小 */- (CGSize)collectionViewContentSize; 5、UICollectionViewFlowLayout：主要管理布局信息方面，Apple为我们提供了一个最简单可能也是最常用的默认layout对象，UICollectionViewFlowLayout。Flow Layout简单说是一个直线对齐的layout。 我们来了解UICollectionViewFlowLayout它内部常用的属性： 12345678910111213141516171819202122232425262728NS_CLASS_AVAILABLE_IOS(6_0) @interface UICollectionViewFlowLayout : UICollectionViewLayout@property (nonatomic) CGFloat minimumLineSpacing; // 设置行之间的最小间距(竖直)@property (nonatomic) CGFloat minimumInteritemSpacing; // 设置2个item之间(列)的最小间隙(水平)，@property (nonatomic) CGSize itemSize; // 设置item的大小/** 预设item大小 */@property (nonatomic) CGSize estimatedItemSize NS_AVAILABLE_IOS(8_0); // defaults to CGSizeZero - setting a non-zero size enables cells that self-size via -preferredLayoutAttributesFittingAttributes:/** 设置滚动方向，默认是竖直滚动 V */@property (nonatomic) UICollectionViewScrollDirection scrollDirection; // default is UICollectionViewScrollDirectionVerticaltypedef NS_ENUM(NSInteger, UICollectionViewScrollDirection) &#123; UICollectionViewScrollDirectionVertical, // 默认是竖直滚动 UICollectionViewScrollDirectionHorizontal // 水平滚动&#125;;// 设置滚动方向，/** 1.如果是垂直滚动，高度起作用，宽度忽略 / 2.如果是水平滚动，宽度期作用，高度忽略 */@property (nonatomic) CGSize headerReferenceSize; // 分组的头部视图的size大小@property (nonatomic) CGSize footerReferenceSize; // 分组的尾部视图的size大小@property (nonatomic) UIEdgeInsets sectionInset; // 设置区的内边距// Set these properties to YES to get headers that pin to the top of the screen and footers that pin to the bottom while scrolling (similar to UITableView).// 头部视图悬停设为YES@property (nonatomic) BOOL sectionHeadersPinToVisibleBounds NS_AVAILABLE_IOS(9_0);// 尾部视图悬停设为YES@property (nonatomic) BOOL sectionFootersPinToVisibleBounds NS_AVAILABLE_IOS(9_0);@end 上面对FlowLayout的属性设置，当然代理方法中也有一一对应，UICollectionViewDelegateFlowLayout 常用方法： 1234567891011121314151617181920212223242526@protocol UICollectionViewDelegateFlowLayout &lt;UICollectionViewDelegate&gt;@optional/** 下面的代理方法是针对indexPath对应的item进行个性化设置 如果使用的是UICollectionViewFlowLayout布局，这些代理方法自动调用 *//** 设置指定indexPath的单元格的大小(itemSize) */- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath;/** 设置分组中的每一个单元格的上下左右的空白距离(内边距) */- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout insetForSectionAtIndex:(NSInteger)section;/** 设置分组中的单元格的行间距(竖直) */- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section;/** 设置每行中的item的(列)间距(水平) */- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section;/** 分组的头部视图的size大小，含义也是有滚动方向决定的 */- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section;/** 分组的尾部视图的size大小，含义也是有滚动方向决定的 */- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section;@end UIEdgeInsets sectionInset 内边距 6、UICollectionViewCell：相对于UItableViewCell而言，UIcollectionViewCell没有那么多样式。UIcollectionViewCell不存在所谓的style，也没有titleLabel和内置的imageView属性，UIcollectionViewCell的结构上相对比较简单。 cell：本身作为的View，这里应该就是UICollectionReusableView backgroundView ：用作cell背景的视图，设置背景图片等。 selectedBackgroundView ：cell被选中的背景视图 contentView ：内容视图，自定义的cell时应该将内容放在这个View上 补充：UIcollectionView有一个小细节：被选中的cell的自动变化，所有的cell中的子View，也包括contentView中的子View，当cell被选中是，会自动去查找view是否有被选中状态下的改变，如果在contentView中有一个imageView的selected和normal状态下的图片是不同的，那么选中cell这张图片也会从normal变成selected，不需要添加代码。 7、UICollectionViewLayoutAttributes 布局属性：在了解这个类之前，我们得先疏通一下，UIcollectionView的布局方式，首先我们之前一直提，UIcollectionView的初始化必须有一个UICollectionViewLayout，也就是我们说的，必须要有一个布局格式样式， 那么一个UIcollectionView有那么多的cell、supplementary View、decoration View，UIcollectionViewLayout是如何进行布局显示的呢？ 原来从UIcollectionViewLayout开始加载内容的时候，便默默的做了很多事：首先是去调用 prepareLayout 准备布局，然后根据当前屏幕所处位置的合适rect，得到每一个视图的UICollectionViewLayoutAttributes属性，然后在把视图按UICollectionViewLayoutAttributes中的属性描述设置视图具体的center、size等等，期间也会去调用其他方法去确定一些间距。所以UICollectionViewLayoutAttributes是每个视图决定性的布局的属性。 12345678910111213141516NS_CLASS_AVAILABLE_IOS(6_0) @interface UICollectionViewLayoutAttributes : NSObject &lt;NSCopying, UIDynamicItem&gt;@property (nonatomic) CGRect frame; // 布局视图的frame简单明了@property (nonatomic) CGPoint center; // 视图中心点@property (nonatomic) CGSize size; // 视图尺寸@property (nonatomic) CATransform3D transform3D; // 这个属性可以用来做酷炫的3D动画@property (nonatomic) CGRect bounds NS_AVAILABLE_IOS(7_0);@property (nonatomic) CGAffineTransform transform NS_AVAILABLE_IOS(7_0); // 转场属性@property (nonatomic) CGFloat alpha; // 透明度@property (nonatomic) NSInteger zIndex; // default is 0 // 层级，数字越大，层级越高（最上面）@property (nonatomic, getter=isHidden) BOOL hidden; // As an optimization, UICollectionView might not create a view for items whose hidden attribute is YES@property (nonatomic, strong) NSIndexPath *indexPath; // 如果是cell有对应的indexPath// 视图标记，是cell还是supplementary View或者decoration View@property (nonatomic, readonly) UICollectionElementCategory representedElementCategory;@property (nonatomic, readonly, nullable) NSString *representedElementKind; // nil when representedElementCategory is UICollectionElementCategoryCell UICollectionView与UITableView比较 相同点： 都需要遵守DataSource和 Delegate，实现协议方法。 待补充 不同点： 与UITableView的最大不同，布局交给了指定的UICollectionViewLayout布局对象。 UICollectionView 的cell 使用必须先注册，使用出列的方式。 UICollectionView：Supplementary 补充视图需要先注册（这里可以充当区的头和尾）。 待补充 UICollectionView 使用说明 说明：代码不重要，重要的是思维 创建UICollectionView必须要有布局参数flowLayout;(采用懒加载)UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc] init]; cell必须通过注册;registerClass: forCellWithReuseIdentifier: 自定义Cell，原因：系统cell没有任何子控件;(添加子控件image，label)。@interface LNPhotoViewCell : UICollectionViewCell FlowLayout自定义（调整cell尺寸，利用布局就做效果），原因：系统cell中每个item尺寸都一样;(继承flowLayout 或 Layout)。@interface LNFlowLayout : UICollectionViewFlowLayout 自定义布局: 只要了解5个方法（重写它方法，扩展功能） 1234567891011121314151617// 什么时候调用:collectionView第一次布局,collectionView刷新的时候也会调用// 作用:计算cell的布局，条件:ell的位置是固定不变的.- (void)prepareLayout;// 作用:指定一段区域给你这段区域cell的尺寸(可以一次性返回所有cell尺寸,也可以每隔一个距离返回cell)- (nullable NSArray&lt;__kindof UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect;// 在滚动的时候是否允许刷新(Invalidate)布局- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds;// 什么时候调用:用户手指一松开就会调用// 作用:确定最终偏移量- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity; // return a point at which to rest after scrolling - for layouts that want snap-to-point scrolling behavior// 由于UICollectionVeiw继承自UIScrollView，所以需要重写该函数，告诉contentSize大小- (CGSize)collectionViewContentSize; UICollectionView基本使用 初始化12345678910111213141516171819202122232425262728293031- (UICollectionView *)collectionView &#123; if (_collectionView == nil) &#123; UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc] init]; //sectionInset 设置区的内边距 layout.sectionInset = UIEdgeInsetsMake(20, 20, 20, 20); //设置2个item之间的最小间隙， layout.minimumInteritemSpacing = 10; //设置行之间的最小间距 layout.minimumLineSpacing = 10; //设置滚动方向，默认是垂直滚动 //layout.scrollDirection = UICollectionViewScrollDirectionHorizontal; //如果是垂直滚动，高度起作用，宽度忽略 //如果是水平滚动，宽度期作用，高度忽略 layout.headerReferenceSize = CGSizeMake(50, 50); //设置footerView的大小 layout.footerReferenceSize = CGSizeMake(50, 50); _collectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:layout]; _collectionView.backgroundColor = [UIColor whiteColor]; // 设置代理，遵守协议&lt;UICollectionViewDataSource,UICollectionViewDelegate&gt; _collectionView.dataSource = self; _collectionView.delegate = self; &#125; return _collectionView;&#125; 注册UICollectionView使用的cell类型12345678// 注册要使用的cell对应的类型[self.collectionView registerClass:[LNNumberCollectionViewCell class] forCellWithReuseIdentifier:cellID];// 注册要使用的HeaverView对应的类型[_collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"HeadViewId"];// 注册要使用的FooterView对应的类型[_collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"footViewId"]; 实现协议UICollectionViewDataSource12345678910111213141516171819202122#pragma mark ------------------#pragma mark - UICollectionViewDataSource// 多少区- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView &#123; return 3;&#125;// 多少item- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section &#123; return 20;&#125;// item内容- (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath &#123; LNNumberCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:cellID forIndexPath:indexPath]; cell.label.text = [NSString stringWithFormat:@"%ld",indexPath.item]; cell.photoImageView.image = [UIImage imageNamed:[NSString stringWithFormat:@"%ld",indexPath.item + 1]]; //cell.backgroundColor = [UIColor grayColor]; return cell;&#125; 12345678910111213141516171819//和UITableView不同：补充视图需要先注册//Supplementary 补充视图，这里可以充当区的头和尾- (UICollectionReusableView*)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath&#123; if([kind isEqual:UICollectionElementKindSectionHeader]) &#123; //指明是头 UICollectionReusableView *headView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"HeadViewId" forIndexPath:indexPath]; headView.backgroundColor = [UIColor redColor]; return headView; &#125; if ([kind isEqual:UICollectionElementKindSectionFooter]) &#123; UICollectionReusableView *footView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"footViewId" forIndexPath:indexPath]; footView.backgroundColor = [UIColor blueColor]; return footView; &#125; return nil;&#125; 实现代理UICollectionViewDelegate123456789101112131415161718// 点击item时触发- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath&#123; NSLog(@"(第%ld-区,第%ld-item)",indexPath.section,indexPath.item); [collectionView cellForItemAtIndexPath:indexPath].backgroundColor = [UIColor redColor]; &#125;// 当前item是否可以点击- (BOOL) collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(nonnull NSIndexPath *)indexPath&#123; if (indexPath.row % 2) &#123; return YES; &#125; return NO;&#125; 1234567891011121314151617//cell点击时是否高亮，点击cell时的样式和点击后cell的样式- (BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath&#123; return YES;&#125;- (void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell *cell = [collectionView cellForItemAtIndexPath:indexPath]; cell.backgroundColor = [UIColor redColor];&#125;- (void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell *cell = [collectionView cellForItemAtIndexPath:indexPath]; cell.backgroundColor = [UIColor grayColor];&#125; 123456789101112131415161718192021222324252627282930313233// 长按某item，弹出copy和paste的菜单 (这些方法为是 复制/粘贴操作相关)- (BOOL)collectionView:(UICollectionView *)collectionView shouldShowMenuForItemAtIndexPath:(NSIndexPath *)indexPath&#123; return YES;&#125;// 使copy和paste有效- (BOOL)collectionView:(UICollectionView *)collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender&#123; if ([NSStringFromSelector(action) isEqualToString:@"copy:"] || [NSStringFromSelector(action) isEqualToString:@"paste:"]) &#123; return YES; &#125; return NO;&#125;//- (void)collectionView:(UICollectionView *)collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender&#123; if([NSStringFromSelector(action) isEqualToString:@"copy:"]) &#123;// NSLog(@"-------------执行拷贝-------------"); [_collectionView performBatchUpdates:^&#123; [_section0Array removeObjectAtIndex:indexPath.row]; [_collectionView deleteItemsAtIndexPaths:@[indexPath]]; &#125; completion:nil]; &#125; else if([NSStringFromSelector(action) isEqualToString:@"paste:"]) &#123; NSLog(@"-------------执行粘贴-------------"); &#125;&#125; 布局对象UICollectionViewDelegateFlowLayout123456789101112131415161718192021222324252627282930#pragma mark ------------------#pragma mark - UICollectionViewDelegateFlowLayout//下面的代理方法是针对indexPath对应的item进行个性化设置//如果使用的是UICollectionViewFlowLayout布局，这些代理方法自动调用- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123; // indexPath.item 指定第几个cell// NSInteger item = indexPath.item;// if (item % 3 == 1) &#123;// return CGSizeMake(100, 150);// &#125;// return CGSizeMake(100, 200); return CGSizeMake(100, 150);&#125;/** 设置分组中的每一个单元格的上下左右的空白距离(内边距) */- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout insetForSectionAtIndex:(NSInteger)section;/** 设置分组中的单元格的行间距(竖直) */- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section;/** 设置每行中的item的(列)间距(水平) */- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section;/** 分组的头部视图的size大小，含义也是有滚动方向决定的 */- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section;/** 分组的尾部视图的size大小，含义也是有滚动方向决定的 */- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section; 自定义FlowLayout：水平滚动相册 核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 作用:指定一段区域给你这段区域cell的尺寸(可以一次性返回所有cell尺寸,也可以每隔一个距离返回cell)// 缩放- (nullable NSArray&lt;__kindof UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect &#123; // 设置cell尺寸 =&gt; UICollectionViewLayoutAttributes // 越靠近中心点,距离越小,缩放越大 // 求cell与中心点距离 // 1.获取当前显示cell的布局 NSArray *attrs = [super layoutAttributesForElementsInRect:self.collectionView.bounds]; for (UICollectionViewLayoutAttributes *attr in attrs) &#123; // 2.计算中心点距离 CGFloat delta = fabs((attr.center.x - self.collectionView.contentOffset.x) - self.collectionView.bounds.size.width * 0.5); // 3.计算比例 CGFloat scale = 1 - delta / (self.collectionView.bounds.size.width * 0.5) * 0.25; // 4.缩放 attr.transform = CGAffineTransformMakeScale(scale, scale); &#125; return attrs;&#125;// 什么时候调用:// 作用:确定最终偏移量// 定位:距离中心点越近，这个cell最终展示到中心点- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity &#123; // 最终偏移量 CGPoint targetP = [super targetContentOffsetForProposedContentOffset:proposedContentOffset withScrollingVelocity:velocity]; CGFloat collectionW = self.collectionView.bounds.size.width; // 1.获取最终显示的区域 CGRect targetRect = CGRectMake(targetP.x, 0, collectionW, MAXFLOAT); // 2.获取最终显示的cell NSArray *attrs = [super layoutAttributesForElementsInRect:targetRect]; // 3.获取最小间距 CGFloat minDelta = MAXFLOAT; for (UICollectionViewLayoutAttributes *attr in attrs) &#123; // 获取距离中心点的距离，注意：应该用最终的x CGFloat delta = (attr.center.x - targetP.x) - self.collectionView.bounds.size.width * 0.5; if (fabs(delta) &lt; fabs(minDelta)) &#123; minDelta = delta; &#125; &#125; // 移动间距 targetP.x += minDelta; if (targetP.x &lt; 0) &#123; targetP.x = 0; &#125; // 获取collectionView偏移量// NSLog(@"%@ %@",NSStringFromCGPoint(targetP),NSStringFromCGPoint(self.collectionView.contentOffset)); return targetP;&#125; 附图： 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS NSURLSessionApple译文]]></title>
    <url>%2FAppleTranslation%2FNSURLSessionApple.html</url>
    <content type="text"><![CDATA[Write in the first【写在最前】 由于 X X (自动脑补) 的苹果在 iOS9 之后已经废弃了 NSURLConnection，所以在现在的实际开发中，除了大家常见的 AFN 框架，一般使用的是 iOS7 之后推出的 NSURLSession，作为一名 iOS 开发者，如果你只知道 AFN 框架来进行网络请求，那就 X x 了。 在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 正题在这里首先附上官方原文地址 URLSession Class Relationships Inherits From NSObject 继承自: NSObject Conforms To CVarArg，Equatable，Hashable Framework iOS 7.0+ Class URLSession The NSURLSession class and related classes provide an API for downloading content. This API provides a rich set of delegate methods for supporting authentication and gives your app the ability to perform background downloads when your app is not running or, in iOS, while your app is suspended. NSURLSession 类及其相关类为下载内容提供了接口。这个 API 提供了一系列丰富的代理方法来支持授权，而且让你的 APP 在后台被挂起时也能继续下载。 Overview The URLSession class natively supports the data, file, ftp, http, and https URL schemes, with transparent support for proxy servers and SOCKS gateways, as configured in the user’s system preferences. URLSession supports the HTTP/1.1, SPDY, and HTTP/2 protocols. HTTP/2 support is described by RFC 7540, and requires a server supporting either ALPN or NPN for protocol negotiation. You can also add support for your own custom networking protocols and URL schemes (for your app’s private use) using URLProtocol. 通过代理服务器的和 SOCKS 网关为用户配置好系统设置，NSURLSession类完全支持 data, file, ftp, http, https类型的超链接。你也可以添加一些支持你自己定制的网络协议或超链接（专门为你自己的 APP 所用） ImportantThe NSURLSession API involves many different classes working together in a fairly complex way that may not be obvious if you read the reference documentation by itself. Before using this API, you should read URL Session Programming Guide to gain a conceptual understanding of how these classes interact with one another. 重要：NSURLSession 的 API 有很多你在看文档时可能感觉并不重要，但实际上却以很复杂的方式来共同发挥作用的类。用这个 API 之前，你应该看一下 URL Session Programming Guide 来了解这些类之间相互调用的一些概念。 With the NSURLSession API, your app creates one or more sessions, each of which coordinates a group of related data transfer tasks. For example, if you are writing a web browser, your app might create one session per tab or window, or one session for interactive use and another session for background downloads. Within each session, your app adds a series of tasks, each of which represents a request for a specific URL (following HTTP redirects if necessary). 通过 NSURLSession 的 API，你的 APP可以创建一个或者多个事务，其中的每一个事务都用来协助一组相关的数据来传输任务。比如，如果你在写一个浏览器，你的 APP 可能在每一栏或是每一个窗口都创建了一个事务，可能一个用来进行交互，一个用来后台下载。在每一个事务中，你的 APP 都添加了一些了的任务，其中的每一个任务就代表一个请求或是一个特定的 URL（必要时进行HTTP重定向） The tasks within a given URL session share a common session configuration object, which defines connection behavior, such as the maximum number of simultaneous connections to make to a single host, whether to allow connections over a cellular network, and so on. The behavior of a session is determined in part by which method you call when creating its configuration object: The singleton shared session (which has no configuration object) is for basic requests. It is not as customizable as sessions that you create, but it serves as a good starting point if you have very limited requirements. You access this session by calling the shared class method. See that method’s discussion for more information about its limitations. Default sessions behave much like the shared session (unless you customize them further), but let you obtain data incrementally using a delegate. You can create a default session configuration by calling the default method on the URLSessionConfiguration class. Ephemeral sessions are similar to default sessions, but do not write caches, cookies, or credentials to disk. You can create an ephemeral session configuration by calling the ephemeral method on the URLSessionConfiguration class. Background sessions let you perform uploads and downloads of content in the background while your app is not running. You can create a background session configuration by calling the backgroundSessionConfiguration(_:) method on the URLSessionConfiguration class. 给定 URL事务的这些任务共享一个事务配置 session，这个对象定义好了连接行为，比如通往同一个主机的相似连接的最大连接数，不管是通过蜂窝移动网络还是别的方式来允许连接。session 的行为一部分是由创建这个配置对象时你调用的方法来决定： 单例 shared session （没有配置对象）用于普通请求。它像你自己创建的session一样可定制，但是如果你的请求有限的话它是一个很好的起点，通过调用 sharedSession 来获取这个 session。看这个方法的文档来得到它的一些限制信息。 Default sessions 的行为和 shared session 差不多（除非你自己进行了深度定制），但你必须要通过代理方法得到增量数据。调用 NSURLSessionConfiguration 中的 defaultSessionConfiguration 方法来创建 Default session。 Ephemeral sessions和Default sessions 很相似，但是不写入 caches,cookies, 或credentials。调用 NSURLSessionConfiguration 中的 ephemeral Session Configuration 方法来创建 ephemeral session。 Background sessions 可以在你的 APP 在后台被挂起时进行上传或下载。调用 NSURLSessionConfiguration 中的 backgroundSessionConfiguration: 方法来创建 background session。 The session configuration object also contains a reference to URL cache and cookie storage objects that may be used when making requests and handling the responses, depending on the configuration and request type. session 配置对象还包含了对 URL cache 和 cookie 存储对象发起请求并处理相应的引用，具体取决于配置和请求类型。 The tasks in a session also share a common delegate that lets you provide and obtain information when various events occur—when authentication fails, when data arrives from the server, when data is ready to be cached, and so on. For all background downloads and uploads, you must provide a delegate that conforms to the URLSessionDownloadDelegateObjective-C protocol. Otherwise, if you don’t need any of the features provided by a delegate, you can use this API without providing a delegate by passing nil when you create a session. 当多种类型的事件发生时（比如授权失败时，数据传输到服务器时，数据准备好缓存时等等）session 中的任务也会共享一个通用的代理来让你提供和获取相关信息。对于所有的后台下载和上传，你必须提供一个遵从 NSURLSessionDownloadDelegate的 OC 协议。否则，如果你不需要任何由代理提供的特性，在你创建 session 时就给 delegate 传 nil 来调用这个 API。 ImportantThe session object keeps a strong reference to the delegate until your app exits or explicitly invalidates the session. If you do not invalidate the session, your app leaks memory until it exits. 重要：session 对你的 delegate 始终保持强引用，除非你的 app 退出或者 session已明确失效。如果你没有使 session 失效，你的 app 将会内存溢出，直到它终止。 Within a session, you create tasks that optionally upload data to a server, then retrieve data from the server either as a file on disk or as one or more NSData objects in memory. The NSURLSession API provides three types of tasks: Data tasks send and receive data using NSData objects. Data tasks are intended for short, often interactive requests to a server. Upload tasks are similar to data tasks, but they also send data (often in the form of a file), and support background uploads while the app is not running. Download tasks retrieve data in the form of a file, and support background downloads and uploads while the app is not running. 在 session 中，你创建了可上传数据到服务器的任务，然后通过磁盘上的文件，或是内存中的一个或多个 NSData 对象来获取数据。 NSURLSession 的 API 提供了三种类型的任务： data tasks 通过 NSData 对象来发送和接受数据。 data tasks 用于与服务器进行简短频繁的请求。 Upload tasks 和 data tasks 类似，但是他们也可以发送数据（一般是通过文件的形式），也支持 app 后台上传。 Download tasks 通过文件的形式来获取数据，并且支持 app 后台上传和下载。 Like most networking APIs, the NSURLSession API is highly asynchronous. It returns data to your app in one of two ways, depending on the methods you call: To a completion handler block that is called when a transfer finishes successfully or with an error. By calling methods on the session’s delegate as data is received and when the transfer is complete. 和大多数网络接口一样，NSURLSession是高度异步的。它通过两种方式中的其中一种来返回数据给 app，取决于你调用的方法： 当传输成功或是发生错误时调用 completion handler block； 当收到数据或是传输完成时调用 session 的代理方法。 In addition to delivering this information to delegates, the NSURLSession API provides status and progress properties that you can query if you need to make programmatic decisions based on the current state of the task (with the caveat that its state can change at any time). URL sessions also support canceling, restarting or resuming, and suspending tasks, and provide the ability to resume suspended, canceled, or failed downloads where they left off. 除了通过代理来传递数据，如果你需要通过当前任务的状态（给出一些状态警示）做一些程序上的决定， NSURLSession的 API 统一提供了状态和进度的属性，方便查询。 URL sessions 同样支持取消，重启，恢复，挂起任务，而且可以在他们停止的地方恢复挂起、取消、失败了的下载。 URL Session Class Hierarchy层级结构The NSURLSession API consists of the following classes (nested to show subclass relationships):NSURLSession API 由下面的类组成（下面的缩进显示的是子类的关系） URLSession—A session object. （一个 session 对象） URLSessionConfiguration—A configuration object used when initializing the session.（用来初始化 session 的配置对象） URLSessionTask—The base class for tasks within a session.（在 session 中表示任务的基类） URLSessionDataTask—A task for retrieving the contents of a URL as an NSData object.（用来获取 NSData 对象的 URL 的任务） URLSessionUploadTask—A task for uploading a file, then retrieving the contents of a URL as an NSData object.（用来上传文件，并接收 NSData 对象的 URL 的任务） URLSessionDownloadTask—A task for retrieving the contents of a URL as a temporary file on disk（以磁盘临时文件的形式获取 URL 的内容的任务） URLSessionStreamTask—A task for establishing a TCP/IP connection（用来建立 TCP/IP连接的任务） In addition, the NSURLSession API provides four protocols that define delegate methods your app can implement to provide more fine-grained control over session and task behavior. 除此之外，NSURLSession 还提供了4个代理， 订了代理方法，你的 app 可以实现这些代理方法，提供对 session 和 task 更加细化的控制。 URLSessionDelegate—Defines delegate methods to handle session-level events（可处理 session level 事件的代理） URLSessionTaskDelegate—Defines delegate methods to handle task-level events common to all task types（可处理和其他所有 task 类型相通的 task level 的方法的代理） URLSessionDataDelegate—Defines delegate methods to handle task-level events specific to data and upload tasks（可处理与数据和上传任务相关的 task level 的方法的代理） URLSessionDownloadDelegate—Defines delegate methods to handle task-level events specific to download tasks（处理与下载任务相关的 task level 的方法的代理） URLSessionStreamDelegate—Defines delegate methods to handle task-level events specific to stream tasks（处理与数据流相关的 task level 的方法的代理） Finally, the NSURLSession API uses a number of classes that are also commonly used with other APIs such as NSURLConnection and NSURLDownload. Some of these shared classes include: 最终，NSURLSession 的 API 使用了很多类，这些类也同样使用了其他的 API，比如 NSURLConnection 和 NSURLDownload。共同使用的类包括： NSURL—An object that contains a URL.（包含了 URL 的对象） NSURLRequest—Encapsulates metadata related to a URL request, including the URL, request method, and so on.（封装与 URL 请求，包括 URL、 请求方法等等相关的元数据） NSURLResponse—Encapsulates metadata related to a server’s response to a request, such as the content MIME type and length. (封装服务器相应的请求，如与 Content 的 MIME 类型和长度相关的元数据) NSHTTPURLResponse—Adds additional metadata specific to HTTP requests, such as response headers.（给 HTTP请求添加特定的附加元数据，比如 response headers） NSCachedURLResponse—Encapsulates an URLResponse object, along with the actual body data of the server’s response, for caching purposes.（用来缓存服务器响应的 body data 封装的一个NSURLResponse对象） Authentication and TLS Customization身份验证和 TLS 定制 When a server requests authentication or provides credentials during TLS negotiation, the URL session calls methods on its delegate, allowing you to handle the authentication or certificate validation in a custom manner. The method it calls depends on whether you are handling a task-specific challenge or a session-wide challenge. Table 1 shows the difference between the two. 当服务器要求身份验证或在 TLS 协商期间提供凭证时，URL Session 通过调用代理方法，让你可以自定义处理身份验证或证书验证。调用的代理方法取决于你是在处理 task 相关还是 session范围内的挑战。Table 1 给出了两者之间的区别。 Table 1Session-level and connection-level challenges Session-wide challenges Task-specific challenges NSURLAuthenticationMethodNTLM NSURLAuthenticationMethodDefault NSURLAuthenticationMethodNegotiate NSURLAuthenticationMethodHTTPBasic NSURLAuthenticationMethodClientCertificate NSURLAuthenticationMethodHTTPDigest NSURLAuthenticationMethodServerTrust - 对于 task 相关的挑战， session 会调用代理的URLSession:task:didReceiveChallenge:completionHandler: 方法。 对于 session 相关的授权挑战，session 会调用代理的URLSession:didReceiveChallenge:completionHandler: 方法，如果它不存在，则调用代理的URLSession:task:didReceiveChallenge:completionHandler: 方法。 If you do not implement these methods, when a request requires client authentication, the URL session attempts to authenticate as follows: Using the authentication information provided as part of the requested URL, if available By looking up Internet passwords and certificates in the user’s keychain (in macOS) or the app’s keychain (in iOS) 当请求需要客户端授权时，如果你没有实现这些方法，URL Session 会通过下面的方式来尝试授权： 如果 URL中含有授权信息的话，通过请求的 URL 中的授权信息。 在用户的钥匙串（ 在 OS X 中）或是 app 的钥匙串（在 iOS 中）寻找网络密码或是证书。 Then, if credentials are not available, or if the server rejects the credentials, the connection continues without authenticating. For HTTP and HTTPS requests, the connection attempt fails with an appropriate HTTP status code, and may provide alternative content (such as the public version of a private site). For other URL types (such as FTP),the connection fails with a connection failure. 如果验证不可用，或是服务器拒绝了验证，那这个连接将会在没有授权的情况下继续。对于 HTTP 和 HTTPs 请求来说，连接会通过一个对应的 HTTP 状态码反应尝试失败， 也可能会提供可选择的内容（比如私有网站的公开版本）。对于其他类型的 URL（比如 FTP），将会直接连接失败。 NoteKerberos authentication is handled transparently. The delegate methods described here do not apply to Kerberos authentication. 注意：erberos 身份验证的处理是公开透明的。这里描述的委托方法不适用于 Kerberos 身份验证。 App Transport Security (ATS)App 传输安全 (ATS) Starting in iOS 9.0 and OS X v10.11, a new security feature called App Transport Security (ATS) is enabled by default for all HTTP connections made with NSURLSession. ATS requires that HTTP connections use HTTPS (RFC 2818). For more information, see NSAppTransportSecurity in the Information Property List Key Reference. 从 iOS9.0 和 OS X v10.11 开始，一种称为App 传输安全（ATS）的安全特性在所有用作 HTTP 连接的 NSURLSession 中是默认启用的。ATS 要求 HTTP 连接使用 HTTPS（RFC 2818）。 想了解更多信息，请看Information Property List Key Reference 中的 NSAppTransportSecurity Using an URL Session使用 URL Session使用 NSURLSession 类发起一个请求: 创建一个 session 配置。若是用作后台的 session，这个配置必须包括一个 唯一标识（unique identifier）。 存储这个标识， 当你的 app 崩溃或是被终止或是被挂起时用它来重连 session。 创建一个 session， 指定它的配置对象，或是代理。 在每个代表一个资源请求的 session 中创建 task 对象。这些 task 对象应该是NSURLSessionTask—NSURLSessionDataTask,NSURLSessionUploadTask, or NSURLSessionDownloadTask 的子类，具体用哪个取决于你想要做什么。 每个task 开始时都处于挂起状态。你的 App 调用恢复任务后，它会开始下载其对应的资源。 在你开始一个 task 之后，session 会调用其代理方法，如下： 如果和服务器初始化握手需要一个连接 level 的挑战（比如SSL 的客户端证书），NSURLSession 会调用 URLSession:task:didReceiveChallenge:completionHandler: 或是 URLSession:didReceiveChallenge:completionHandler: 代理方法，如前面的 身份验证和 TLS 定制 所述。了解更多为 NSURLSession 写一个授权代理方法的信息，请阅读 read URL Session Programming Guide. 如果这个 task 的数据是由流提供的，NSURLSession 对象将会调用代理的 URLSession:task:needNewBodyStream: 代理方法来获取一个 提供新请求的 body data 的 NSInputStream 对象。 在初始化上传到服务器（如果可用的话）的 body 内容期间，代理会阶段性接收 URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend: 的回调来报告上传进度； 服务器发送一个响应； 如果响应表明需要授权，session 会调用代理方法URLSession:didReceiveChallenge:completionHandler: ，回到步骤2； 如果响应是一个 HTTP 重定向响应， NSURLSession 对象会调用代理方法URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler: 代理方法会用提供的 NSRULRequest 对象（遵循重定向），或是新的 NSURLRequest 对象（如果需要重定向到一个不同的 URL 的话），或是 nil（将有效的响应作为重定向响应的 body，并将它作为结果返回） 来调用所提供的 completion handler 。 如果你决定追踪重定向，返回步骤2； 如果代理没有实现这个方法，这个重定向将会被重定向的最大数字跟进。 对于一个通过调用downloadTaskWithResumeData:或 downloadTaskWithResumeData:completionHandler: 方法创建的（重复）下载任务来说，NSURLSession 会对一个新的任务对象调用URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes: 代理方法。 对于数据任务，NSURLSession 会调用URLSession:dataTask:didReceiveResponse:completionHandler: 代理方法，来决定是否要将 数据任务转换成下载任务，然后调用完成回调来继续接收或下载数据。 如果你的 app 选择将数据任务转换成下载任务，NSURLSession 会将这个新的下载任务作为一个参数来调用 urlSession:dataTask:didBecomeDownloadTask: 代理方法。调用完之后，代理不会从数据任务接收到进一步回调，而是从下载任务那里来接收回调； 在服务器传输过程中，代理会周期性地接收到一个 task-level 的回调方法来报告传输的进度。 对于数据任务，session 会在接收过程中通过真正的数据块来调用URLSession:dataTask:didReceiveData: 代理方法。对于下载任务来说，session 会通过已经成功写入磁盘的 bytes 来调用urlSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite: 代理方法。如果用户告诉 app 来暂停下载，通过cancelByProducingResumeData: 然后，如果用户要求 app 继续下载任务，将返回的恢复数据给downloadTaskWithResumeData:或 downloadTaskWithResumeData:completionHandler: 方法来创建一个新的下载任务，来继续下载。（返回步骤1） 对于数据任务，NSURLSession 对象可能会调用URLSession:dataTask:willCacheResponse:completionHandler: 方法。你的 app 应该来决定是否允许缓存。如果你没有是现在合格方法，默认会使用 session 的配置对象中的缓存方案。 如果响应是由多个部分组成的编码，session 会在didiRecieveReponse代理被多次调用之后再次调用 didRecieveData 代理方法。如果出现这样的情况，回调步骤8（处理 didRecieveResponse回调） 如果下载任务成功完成， NSURLSession 对象会通过一个临时文件的地址来调用任务的 urlSessionDownloadTask:didFinishDownloadingToURL: 方法。你的 app 必须从这个文件中读取返回的数据，或是在这个代理方法 结束之前将它移到一个永久保存的地址。 任务完成时， NSURLSession 对象会通过一个错误对象或是 nil （如果任务成功完成）来调用 urlSession:task:didCompleteWithError:如果这个下载任务是可被重新唤起的，这个 NSError 对象的 userInfo 字典中会包含 key 为NSURLSessionDownloadTaskResumeData的值。你要将这个值传给downloadTaskWithResumeData:或是 downloadTaskWithResumeData:completionHandler: 来创建一个新的下载任务以继续这个已经存在的下载任务。如果这个下载任务不能被重新唤起，你的 app 需要创建一个新的下载任务来从头开始下载。不管是哪种情况，如果传输因任何服务器错误以外的原因而失败，返回到步骤3（创建或唤起任务对象）。 注意：NSURLSession 不会通过 error 参数返回任何的服务器错误。通过 error 参数返回的错误只会是服务器端错误，比如不能解决 hostname，不能连接到 host。error codes 信息可在 URL Loading System Error Codes 中查询。服务器端错误会通过 NSHTTPURLResponse 对象中的HTTP 状态码来返回，了解更多信息，请阅读 NSHTTPURLREsponse和 NSURLResponse的文档。 14 . 如果你不需要用到 session 了，可以通过调用 invalidateAndCancel（用来取消未完成的任务）或是 finishTasksAndInvalidate(在这个对象失效前完成未完成的任务)。如果你不使这个session失效，它会在你的app终止时自动消失（除非它是一个含有正在进行的任务的后台 session） session 失效后，当所有未完成的任务被取消或是完成时，session会调用 urlSession:didBecomeInvalidWithError: 方法。当代理方法返回时，session 会处置对代理的强引用。 如果你的app 取消了一个正在进行的下载任务， 当出现错误时，NSURLSession 对象会调用代理的 URLSession:task:didCompleteWithError: 方法。 Background Transfer Considerations后台处理注意事项因为重启app（或是等待用户重新唤起时）代价是相当高的，在后台session中有些特性是不可用的。如下： session 必须提供一个传递事件的代理，因为在传输进行中app可能会退出或是重启，完成事件的回调 Block 是不支持的、（为了上传和下载），这些代理在传输过程中表现是相同的； 只有 HTTP 和 HTTPS 协议是被支持的。其他内置的网络协议和用户网络协议都不被支持； 只有上传和下载是被支持的（没有 data 任务）；重定向一直被允许；全系统同时进行的后台传输的数量是被限制的； 如果后台任务未能满足指定系统吞吐量限制，可能会被取消。也就是说，如果一个长期运行的任务在一段时间内没有发送或者接受足够的数据，它可能会被取消，以后再被唤起。所以，如果可能的话，让一个传输可被重新唤起是很重要的。 如果后台传输初始化时app是在后台，那这个任务将被当做可裁剪的。换言之，它将被当做 配置对象的 discretionary 属性为 true 的session中的一个任务。 如果这些限制和你 app 的需求有冲突，你可以在 non-background session 中将远程资源下载到一个文件中。这样，当你的用户让你的 iOS app 进入后台或是退出你的 OS X app 时，可以通过调用 cacelByProducingResumeData: 方法来暂停任何进行中的下载任务。当用户重新让 app 进入前台时恢复下载。如果你的 app 在你获取到任何恢复的数据之前终止了，就不能再恢复下载了。 注意：后台 session 是为了优化传输少量很大的资源，在必要时可以进行续传。如果可以，你可能想要调查优化服务器端行为的方法 ，来实现这样的用法，比如： 在终结点发起发送或接收 zip 或 tar格式的压缩文件的请求，而不是分开调用多次； 在终结点发起发送或接收在服务器和客户端之间的增量差异的请求； 在终结点发起一个可返回上传ID的请求，这个ID可用来追踪和恢复传输到服务器的数据； 添加一个中间的web 服务器代理请求到规范的web服务器，以方便任何上述优化。 NSCopying Behaviorsession 和 task 对象都遵从 NSCopying 协议，如下： 当你的app 拷贝一个session 或是 task 对象时，你会得到一个同样的对象； 当你的app拷贝一个配置对象时，你会得到一个你可以独立地修改的拷贝对象。 Thread Safety线程安全URL Session API 自身完全是线程安全的。你可以在任何一个线程上下文中随意创建 session 和 task，而且，当你的代理方法调用提供的 完成回调时，它的工作已自动被安排在正确的代理队列中。 警告：你的 URLSessionDidFinishEventsForBackgroundURLSession: 代理方法可能会在第二线程中被调用。但是，在iOS中，你完成那个方法时需要在application:handleEventsForBackgroundURLSession:CompletionHandler: app 代理方法中调用completion handler。而且你必须在主线程中调用那个 completion handler。 NSURLSession 有太多的东西值得我们去学习推敲，方方面面都透露着学习的必要性，学习总结，一劳永逸，对我们日后开发一定会受益良多。作为一枚成长中的菜鸟，分享和开源精神，还是值得具备的。 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo文章简单加密访问]]></title>
    <url>%2FHexoBlog%2FHexoArticleEncryption.html</url>
    <content type="text"><![CDATA[Welcome]]></content>
      <categories>
        <category>HexoBlog</category>
      </categories>
      <tags>
        <tag>HexoBlog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo(Pages)—优化博客「续更」]]></title>
    <url>%2FHexoBlog%2FHexoPagesOptimize.html</url>
    <content type="text"><![CDATA[给自己一个记录 知识 和 时间 的空间。 拥有一个这样的独立而自由的空间是一件非常有趣的事情。 本篇整理来自网络文章，是自己搭建优化遇到使用或摘录博文常用好用的小功能点，再次整理一下，方便首次搭建少走些坑，我会及时加上出处 Content progress 文字居中（写博客时）在你博客文章中需要居中处加上下面这段代码即可，中间的文字改成你所需要的文字。123&lt;blockquote class="blockquote-center"&gt;不忘初心，这里可以写多行文字&lt;/blockquote&gt; 为博客加上GitHub丝带如果是Next主题（其他主题也差不多），添加GitHub丝带：在themes\next\layout\_layout.swig中加入相关代码，记得修改自己的链接。 相关代码你可以在GitHub官方网站 GitHub Ribbons 上进行选择。 加入作者版权信息我们可以为博客文章加入作者版权信息。例如本文地址：http://www......./ 转载请注明出处，谢谢！等等。对Next主题而言，先找到/themes/next/layout/_macro/post.swig，再找到其中的微信订阅部分，如下所示： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后直接在其上面添加如下代码段： 123456789&lt;div align="center"&gt; &#123;% if not is_index %&#125; &lt;div class="copyright"&gt; &lt;p&gt;&lt;span&gt; &lt;b&gt;本文地址：&lt;/b&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;&lt;br /&gt;&lt;b&gt;转载请注明出处，谢谢！&lt;/b&gt; &lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 当然，在上面这段代码，你可以进行一些个性化编写，可以展示你自己个性化的版权信息。 为博客加入动态背景首先找到\themes\next\layout\_layout.swig，在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）。 默认灰色线条 1&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 浅蓝色线条 1&lt;script type="text/javascript" src="/js/src/particle.js" count="50" zindex="-2" opacity="1" color="0,104,183"&gt;&lt;/script&gt; 然后在themes\source\js\src\下新建文件particle.js写上以下代码:1!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e("script"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,"zIndex",-1),o:n(i,"opacity",.5),c:n(i,"color","0,0,0"),n:n(i,"count",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle="rgba("+m.c+","+(t+.2)+")",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement("canvas"),m=t(),d="c_n"+m.l,l=u.getContext("2d"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText="position:fixed;top:0;left:0;z-index:"+m.z+";opacity:"+m.o,e("body")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 为博客加入鼠标点击显示红心鼠标点击小红心在\themes\next\source\js\src文件目录下添加love.js文件。内容为：1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 找到\themes\next\layout\_layout.swing文件，在文件的后面，&lt;/body&gt;之前 添加以下代码：12&lt;!-- 小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 给博客添加LICENSE在主题配置文件中添加下面这段代码（添加之前好好看看你的主题配置文件是否已经包含这段代码，已经包含就不用再加一遍了，因为重复会报错），这个LICENSE显示在侧边栏。12345# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: by-nc-sa#creative_commons: 添加Local Search功能安装 hexo插件在你的站点文件夹中，用shell等运行下面这行代码：1$ npm install hexo-generator-searchdb --save 编辑站点配置文件添加以下字段：12345search: path: search.xml field: post format: html limit: 10000 启用本地搜索编辑主题配置文件启用本地搜索123# Local searchlocal_search: enable: true 修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示：1$font-size-base = 16px 修改网页配色取色可以用QQ，打开QQ按Ctrl+Alt+A开始截图，将鼠标移到文字上，按住Ctrl键即可看到该颜色的16进制代码。也可以用chrome浏览器的develop tool取色，选取喜欢的颜色。 修改\themes\next\source\css\ _variables\base.styl文件，找到文件开头的colors for use across theme，加入自定义颜色，在$orange = #fc6423下加入下面这段代码：123// 下面是我自定义的颜色$my-link-blue = #0593d3 //链接颜色$my-link-hover-blue = #0477ab //鼠标悬停后颜色 修改超链接颜色打开\themes\next\source\css\ _variables\base.styl文件，像下面这样改掉这几行：12345/ Global link color.$link-color = $my-link-blue$link-hover-color = $my-link-hover-blue$link-decoration-color = $gray-lighter$link-decoration-hover-color = $my-link-hover-blue 修改小型代码块颜色我修改&lt;code&gt;样式是因为我开启了highlight，highlight在渲染&lt;pre&gt;&lt;code&gt;标签的同时也渲染了&lt;code&gt;标签，而且优先级高，所以才会出现方法一中这种不开启!important，样式就不起作用的问题。在方法一使用了!important使得此处对&lt;code&gt;的样式优先级最高，所以设置成功。 方法一打开\themes\next\source\css\ _variables\base.styl文件，修改如下：在下面这段代码：123456// Code &amp; Code Blocks// --------------------------------------------------$code-font-family = $font-family-monospace$code-font-size = 14px$code-font-size = unit(hexo-config('font.codes.size'), px) if hexo-config('font.codes.size') is a 'unit'$code-border-radius = 4px 下方加入下面这段代码:1234code &#123; color:#dd0055 !important; background:#eee !important;&#125; 方法二你也可以不用方法一（建议使用方法一，因为第二种可能会失效，被其他的样式定义覆盖），而是在source/css/_variables/custom.styl文件中设定$code-foreground和$code-background的值，也是用的优先级。123$code-foreground = #fc6423$code-background = #fc6423#此处颜色只是例子，你自己设置。 修改其他颜色修改：themes\next\source\css\_variables\.base.styl文件：123grey-dim = #666 &gt;&gt;&gt; $grey-dim = #353535$black-light = #555 &gt;&gt;&gt; $black-light = #353535$blue-bright = #87daff &gt;&gt;&gt; $blue-bright = #45c5ff 加入统计和提高索引量添加sitemap插件 谷歌与百度的站点地图，前者适用于其他搜索引擎，用来手动提交以增加收录。 sitemap 安装在你的站点文件夹中，用shell等分次运行下面这两行代码：12npm install hexo-generator-sitemap@1 --savenpm install hexo-generator-baidu-sitemap@0.1.1 --save 设置站点配置文件在站点配置文件中添加代码：12345# hexo sitemap网站地图sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml。其中sitemap.xml适合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。 其次，在站点根目录下新建一个robots.txt文件，其中添加下面的一段代码（具体网站改为你自己的网址）： 123456789101112# hexo robots.txtUser-agent: *Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://dingxuewen.github.io/sitemap.xmlSitemap: https://dingxuewen.github.io/sitemap.xml 给非友情链添加标签经过chinaz站长工具友情链接检测，发现有不必要的PR值输出，对于非友情链接的PR值输出，我们可以加上nofollow便签避免不必要的PR输出。方法是给链接加上rel=&quot;external nofollow&quot;属性。例如： 找到\themes\next\layout\_partials\footer.swig文件，将下面代码：1&#123;&#123; __('footer.powered', '&lt;a class="theme-link" href="http://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125; 改成：1&#123;&#123; __('footer.powered', '&lt;a class="theme-link" href="http://hexo.io" rel="external nofollow"&gt;Hexo&lt;/a&gt;') &#125;&#125; 将下面代码：1&lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next"&gt; 改成：1&lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow"&gt; 加入Baidu站长统计先准备一些代码。站长统计，注册并获取统计代码：12345 | &lt;script type="text/javascript"&gt; var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://"); document.write(xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' type='text/javascript'%3E%3C/script%3E"));&lt;/script&gt; 修改底栏:找到\themes\next\layout\_partials\footer.swig文件,加入上面这段代码，出于保护隐私的考虑，我编辑掉了部分关键代码，直接复制上面的无法使用。注意把上面的xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx换成你自己的站长统计代码。 在页脚加入地图在页脚加入百度地图和谷歌地图链接： 找到\themes\next\layout\_partials\footer.swig文件，百度和Google网站地图，上面已经安装了，这是插入到底栏的代码：12 | &lt;span&gt;&lt;a href="/sitemap.xml"&gt;Google网站地图&lt;/a&gt;&lt;/span&gt; | &lt;span&gt;&lt;a href="/baidusitemap.xml"&gt;百度网站地图 添加Baidu自动推送百度自动推送代码，在页面被访问时，页面URL将立即被推送给百度，可以增加百度收录：找到\themes\next\layout\_partials\footer.swig或\themes\next\layout\_macro\post.swig文件，（Next主题已经有了\themes\next\layout\_scripts\baidu-push.swig）添加下面的代码。1234567891011121314&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https')&#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else&#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt; 不蒜子统计找到\themes\next\layout\_partials\footer.swig文件，加入下面不蒜子统计代码：12345 | 本页点击 &lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt; 次 | 本站总点击 &lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt; 次 | 您是第 &lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt; 位访客&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 在标题下添加【阅读量】等现在要添加的阅读量统计也依赖下面这段代码。12&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 打开/themes/next/layout/_macro/post.swig，找到标签&lt;div class=&quot;post-meta&quot;&gt;&lt;/div&gt;，在该标签内部合适的位置（如time和categories之间或categories后面）添加：123&#123;% if not is_index %&#125; &lt;span id="busuanzi_container_page_pv"&gt; | 阅读量 &lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt; 次&lt;/span&gt;&#123;% endif %&#125; 将阅读量改为热度（更个性）还可以继续修改，看到好多人的博客不是阅读次数（阅读量），而是热度 188 ℃，那么可以继续这样修改，首先在Next主题的/themes/next/languages/zh-Hans文件中查找”阅读次数“这几个字，可以看到，在post中的visitors被定义为“阅读次数”，把这里的“阅读次数”改为“热度”。 那么怎么在页面中显示呢。打开Next主题文件夹中layout/_macro/post.swig，在这个文件里加上摄氏度的标志，在&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;下面增加一行&lt;span&gt;℃&lt;/span&gt;即可。 修改标题下分类等的样式在Next主题中，我用的是LeanCloud数据统计，默认样式是在统计数据前有个小眼睛，我感觉不好看，想把它去掉，那么打开/themes/next/layout/_macro/post.swig，找到标签&lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;，去掉下面这段代码即可：123&lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-eye"&gt;&lt;/i&gt;&lt;/span&gt; SEO优化更改首页标题格式为「关键词-网站名称-网站描述」。打开\themes\next\layout\index.swig文件，找到这行代码：1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 把它改成：123&#123;% block title %&#125; &#123;&#123; theme.keywords &#125;&#125; - &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125;&#123;% endblock %&#125; 博客部署的message设置在\hexo\node_modules\hexo-deployer-git\lib\deployer.js文件末尾找到这一句：1Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;. 改得个性化一点：1勤奋的博主又更新啦: &#123;&#123; now(\'YYYY-MM-DD HH:mm:ss\') &#125;&#125;. 为项目主页添加README在 Github 上的博客仓库主页空荡荡的，没有README。如果把README.md放入source文件夹，hexo g生成时会被解析成html文件，放到public文件夹，生成时又会自动删除。 解决方法很简单，在站点配置文件中，搜索skip_render:，在其冒号后加一个空格然后加上README.md即可。 优化主题 sidebar 头像就是为主题 sidebar 头像添加圆形化旋转的效果。修改 /themes/next/source/css/_common/components/sidebar/sidebar-author.styl 文件，我的整个 sidebar-author.styl文件的代码如下，你可以直接复制这段代码去替换你这个文件中的所有代码。有一个注意事项，就是你要保证你的头像，也就是 avatar.jpg 这个图片是正方形，不是的话你要将其修改成正方形，这样才能通过样式将其展现为很好看的正圆，否则会是一个椭圆形。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 小红心优化为博客加入鼠标点击显示小红心，但是如果我们只想在博客的某个页面添加这个功能呢？那么就可以在 \themes\next\source\js\src 文件目录下添加 love.js 文件。内容为：1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 之后呢，不在\themes\next\layout\_layout.swing 文件中添加代码，而是在你想要显示红心的页面的 Markdown 文件中加入下面这段代码,例如我就在我的留言板页面的 Markdown 文件中加入了下面这段代码。12&lt;!-- 小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 文章内文本样式Markdown 毕竟是为了方便写作，在样式上过于单调。我们可以自己来给文章加一些样式。NexT 作者提供了一个供用户自己定义样式的文件：\themes\next\source\css\_custom\custom.stly。可以按照自己的需要写。下参考： 设置动态title在 \themes\next\source\js\src 目录下新建 dytitle.js 。添加以下内容： 1234567891011121314151617&lt;!--崩溃欺骗--&gt;var OriginTitile = document.title; var titleTime; document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="icon"]').attr('href', "/img/TEP.ico"); document.title = ' 页面崩溃啦 ~ | cwyaml！'; clearTimeout(titleTime); &#125; else &#123; $('[rel="icon"]').attr('href', "/favicon.ico"); document.title = ' 噫又好了~ ' + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125; &#125;); 更改 \themes\next\layout\_layout.swig 。在 &lt;/body 之前添加：12&lt;!--卖萌--&gt;&lt;script type="text/javascript" src="/js/src/dytitle.js"&gt;&lt;/script&gt; 添加听音乐代码设置在 \themes\next\layout\_macro目录下新建 high.swig 文件，添加以下内容：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;a title="收藏到书签，偶尔High一下^_^" rel="alternate" class="mw-harlem_shake_slow wobble shake" href='javascript:( /* * Copyright (C) 2015 Rocko (rocko.xyz) &lt;rocko.zxp@gmail.com&gt; * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ function go() &#123; var songs = [ "http://m2.music.126.net/3uHnH7uQAeFwUfuvEB9lrg==/3265549619475054.mp3", "http://m2.music.126.net/NnHwR2HV-1OoKZ6R5LVy4Q==/18502581673300023.mp3", "http://m2.music.126.net/qv3RI4K7ABKJ0TyAdb3taw==/3250156397064860.mp3", "......" ]; function S() &#123; var e = document.getElementById("audio_element_id"); if(e != null)&#123; var index = parseInt(e.getAttribute("curSongIndex")); if(index &gt; songs.length - 2) &#123; index = 0; &#125; else &#123; index++; &#125; e.setAttribute("curSongIndex", index); &#125; e.src = i; e.play() &#125; function initAudioEle() &#123; var e = document.getElementById("audio_element_id"); if(e === null)&#123; e = document.createElement("audio"); e.setAttribute("curSongIndex", 0); e.id = "audio_element_id"; e.loop = false; e.bgcolor = 0; e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.addEventListener("ended", function() &#123; go(); &#125;, true); &#125; &#125; initAudioEle(); var curSongIndex = parseInt(document.getElementById("audio_element_id").getAttribute("curSongIndex")); var i = songs[curSongIndex]; S(); &#125;)()'&gt; &lt;i class="fa fa-music"&gt;&lt;/i&gt; 听音乐&lt;/a&gt; 在侧边栏引用该文件：修改 \themes\next\layout\_macro\sidebar.swig ，添加以下代码：1&#123;% include 'high.swig' %&#125; 样式修改：使 听音乐 和 RSS 并排展示。修改 \themes\next\source\css\_schemes\Pisces\_sidebar.styl文件：1display: inline-block; 添加自己喜欢的音乐：修改其中的歌曲链接即可.123456var songs = [ "http://m2.music.126.net/3uHnH7uQAeFwUfuvEB9lrg==/3265549619475054.mp3", "http://m2.music.126.net/NnHwR2HV-1OoKZ6R5LVy4Q==/18502581673300023.mp3", "http://m2.music.126.net/qv3RI4K7ABKJ0TyAdb3taw==/3250156397064860.mp3", "......" ]; 首页听音乐摇晃：需要加载 css 样式。在 themes\next\layout\_layout.swig文件的 &lt;/body&gt;标签前 添加以下代码：12&lt;!-- 听音乐摇晃 --&gt;&lt;link href="http://s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css" rel="stylesheet" type="text/css"&gt; 注意：有时候使用 Firefox 、Chrome时会提示非法插件并禁止使用，遇到这种情况我们把样式代码引入到 \themes\next\source\css\_custom\custom.stly文件即可解决。 音乐链接获取 先获取歌曲id，直接打开 网易云音乐网页版 http://music.163.com 搜索自己喜欢的音乐，点击外链生成器获取歌曲的 ID 。举个例子：（id显而易见吧） 1http://music.163.com/#/song?id=443205403 将下面网址中的两处id替换成的歌曲 id ，你将会获得一大串代码：外链就隐藏其中（如下图，自己找）。 http://music.163.com/api/song/detail/?id=425137664&amp;ids=[425137664]&amp;csrf_token= 将上一步中获取到的网址放到地址栏中，若能正常播放音乐说明获取到的网址是正确的。然后你就可以把这些歌曲添加到自己的网页中了！用这种方法有些歌曲并不能获得，不过时效很长（只要网易云能听）。 博文压缩目前知道的有两个插件可以压缩博文，hexo-all-minifier 插件和 gulp 插件。hexo-all-minifier 虽然使用比较简单，而且也可以压缩图片，但是对文章缩进（输入法全拼模式下按 Tab）不支持，所以暂时使用 gulp 压缩手段。 hexo-all-minifier 使用方法安装 hexo-all-minifier，在站点的根目录下执行以下命令：1$ npm install hexo-all-minifier --save hexo g 编译的时候就会自动压缩 HTML、JS、图片。详情参考插件介绍 hexo-all-minifier glup 使用方法hexo 依赖 gulp 插件安装，在站点的根目录下执行以下命令：12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在 package.json 同级目录下，新建 gulpfile.js 并填入以下内容：123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']); 生成博文是执行 hexo g &amp;&amp;amp; gulp 就会根据 gulpfile.js 中的配置，对 public目录中的静态资源文件进行压缩。 博文置顶修改 hero-generator-index 插件 替换文件：node_modules/hexo-generator-index/lib/generator.js 内的代码为：12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 设置文章置顶在文章 Front-matter 中添加 top 值，数值越大文章越靠前，如：1234567---title: 图集categories: [图片]tags: [picture]date: 2015-04-02 14:36:04top: 10--- embed.js本地化embed.js 是多说使用的远程脚本，你可以访问 http://static.duoshuo.com/embed.js 这个网址。右键另存为 \theme\next\source\js\src\这个文件夹。 然后打开 \themes\next\layout\_scripts\third-party\comments\duoshuo.swig 这个文件，在文件里搜索 //static.duoshuo.com/embed.js ，把它改成 /js/src/embed.js。搞定啦！ Hexo更改默认Google字体库因为一些国内的客观原因，google字体库 的访问速度一直很慢，所以生成页面后，访问系统总是会耗费一大部分的时间在加载google字体库上，而且经常加载不成功。 解决的办法是可以用国内的CDN库来替代主题中的google字体库，更改方法如下：shell中运行如下命令：1grep -ir fonts.google themes/ 找到对应的google字体库地方，用国内的CDN字体库替换，如360字体库：360前端公共库CDN。 首页分割线在 \themes\next\source\css\_custom\custom.styl 文件中添加以下代码，可以修改博客首页中每篇文章的分割线长度，我设置为了100%长度。1234567891011//index页面中每篇文章相隔的那条线.posts-expand &#123; .post-eof &#123; display: block; margin: $post-eof-margin-top auto $post-eof-margin-bottom; width: 100%; height: 3px; background: $grey-light; text-align: center; &#125;&#125; 字体、颜色等设置在\themes\next\source\css\_variables\custom.styl 文件中添加以下代码。具体功能我已经做了注释。12345678910111213141516// 标题，修改成你期望的字体族$font-family-headings = Georgia, sans// 修改成你期望的字体族$font-family-base = "Microsoft YaHei", Verdana, sans-serif// 代码字体$code-font-family = "Input Mono", "PT Mono", Consolas, Monaco, Menlo, monospace// 正文字体的大小$font-size-base = 16px// 代码字体的大小$code-font-size = 14px// 代码块颜色$code-foreground = #dd0055// Background color for &lt;body&gt;$body-bg-color = #e7e5dc //theme mist use #fdfdfd// text-color$text-color = #353535 语言配置_config.yml中的language要配置为选定的主题cilia文件夹下的language目录下的文件，如：1234language: zh-Hanslanguage: enlanguage: zh-hklanguage: zh-tw 这里修改 zh-Hans为标准的zh-cn,并添加一些汉化内容语言配置用法:1234# 不带参数的__('xxxx')# 带参数的_p('xxx',xx) 不蒜子统计显示添加站点统计配置为不蒜子统计，并且可开关1busuanzi: true 配置自己的分享国内的jiathis将themes/yilia/_partial/share_jia.ejs中的内容替换为：12345678910&lt;div class="jiathis_style"&gt; &lt;span class="jiathis_txt"&gt;&lt;%= __('post.share') %&gt;: &lt;/span&gt; &lt;a class="jiathis_button_weixin"&gt;微信&lt;/a&gt; &lt;a class="jiathis_button_cqq"&gt;QQ好友&lt;/a&gt; &lt;a class="jiathis_button_qzone"&gt;QQ空间&lt;/a&gt; &lt;a class="jiathis_button_tsina"&gt;新浪微博&lt;/a&gt; &lt;a href="http://www.jiathis.com/share?uid=2080230" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"&gt;更多&lt;/a&gt; &lt;a class="jiathis_counter_style"&gt;&lt;/a&gt;&lt;/div&gt;&lt;script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=2080230" charset="utf-8"&gt;&lt;/script&gt; 其中uid为自己在jiathis注册的uid 国外的add this将themes/yilia/_partial/share_jia.ejs中的内容替换为：123&lt;!-- Go to www.addthis.com/dashboard to customize your tools --&gt;&lt;div class="addthis_sharing_toolbox"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="http://s7.addthis.com/js/300/addthis_widget.js#pubid=ra-568f54bcfd6a7b04" async="async"&gt;&lt;/script&gt; Rss添加Rss，需要先安装rss生成模块：1npm install hexo-generator-feed --save 然后在themes/yilia/_config.yml开启rss1rss: /atom.xml 站点配置文件123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 添加站点地图插件1npm install hexo-generator-sitmap --save 会在每次hexo generator后自动生成到网站根目录 设置网站logo通过网站favicon在线制作 制作favicon图片，logo最好设置32*32。next主题：将图片放在next主题source/images目录下12# 在next主题配置文件中添加：favicon: /uploads/images/favicon.png Hexo文章简单加密访问找到themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件。按道理是添加在任何地方都行，但是推荐加在所有的&lt;meta&gt;标签之后。12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 1234567891011---title: Hexo文章简单加密访问date: 2016-12-02 tags: hexocategories: 博客keywords: - Hexo - 加密description: 文章访问密码：passwordpassword: password--- Hexo high一下是直接把这段代码当成一个菜单项加在博客主题配置的_config.yml文件中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;li&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125;&#125;)() '&gt;High一下&lt;/a&gt; &lt;/li&gt; 12345678910menu: high: javascript:void(0)menu_icons: high: play// 第一个 high 的javascript:void(0)是指a标签的跳转链接，其实这里的功能就是为了让它不跳转的，另外还有一个功能，可以把空链接的a标签悬浮变成手型的鼠标。第二个 high对应的play是展示的图标，NexT主题使用的是fontawesome图标，这里的play就是其对应的图标，想自己 diy 一下就去fontawesome上找个自己喜欢的。这样的方法简单粗暴有效，并且还有一个好处，可以直接把这个链接保存成浏览器的书签，这样就能在任何网页都能够调用这个 High一下 的方法。 high 一下自定义页面歌曲首先是在需要自定义曲子的文章中加上： 1&lt;div id="musicUrl" url="***"&gt;&lt;div&gt; 然后最终版high.js代码是这样：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165document.getElementsByClassName('menu-item-high')[0].addEventListener('click', (function()&#123; var play = false; var musicUrl = document.getElementById('musicUrl'); if(musicUrl)&#123; musicUrl = musicUrl.getAttribute('url'); &#125;else&#123; musicUrl = null; &#125; return function()&#123; if(play)&#123; console.log('Enjoying'); return; &#125; play = true; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height: e.offsetHeight, width: e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h(); paly = false; &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = musicUrl || "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "/vendors/high/high.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125; &#125;;&#125;)(), false); 修改文章链接HEXO 默认的文章链接形式为domain/year/month/day/postname，默认就是一个四级url，并且可能造成url过长，对搜索引擎是十分不友好的，我们可以改成domain/postname的形式。编辑站点_config.yml文件，修改其中的permalink字段改为permalink: :title.html即可。 夜间模式 Hexo-Next-Mist主题头部顶栏背景图片图片存放位置：选择一张心仪的图片，命名为 background.jpg，放到 source 文件夹下的 image 文件夹内。12Hexo\source\image // 图片大小我选择的是“50厘米*5厘米”，太小的话无法覆盖整个背景 背景图片设置：找到如下位置：1234567hexo\themes\next\source\css\_schemes\Mist\_header.styl打开 _header.styl，将第一行 background: 后的内容改为如下形式：方式一：本地图片.header &#123; background: url('Hexo\source\image/background.jpg'); &#125;方式一：网络图片.header &#123; background: url('http://upload-images.jianshu.io/upload_images/2230763-265f0df7e75d706a.gif?imageMogr2/auto-orient/strip'); &#125; 保存，重新生成网页即可。 打赏字体不闪动 修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下： 123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 博客文章链接无中文乱码 未完待续 ！ 未完待续 ！ 未完待续 ！ 参考原著：摘录1、【Levi.Blog】 http://www.dingxuewen.com2、【lancelot_lewis】 https://lancelot_lewis.coding.me3、【http://www.jianshu.com/p/f054333ac9e6】 4、【】]]></content>
      <categories>
        <category>HexoBlog</category>
      </categories>
      <tags>
        <tag>HexoBlog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo(Pages)—博客搭建同步GitHub&Coding]]></title>
    <url>%2FHexoBlog%2FHexoPagesSetup.html</url>
    <content type="text"><![CDATA[给自己一个记录 知识 和 时间 的空间。 引导 给自己一个记录知识和时间的空间 –&gt; 对你有新思想 或是 习惯 ！，拥有一个这样的独立而自由的空间是一件非常有趣的事情。 每个优秀的程序员（、📱）在成长过程都有许多个人的体会与感悟，这些感悟让他走的更远，而通常个人博客就是这样一个记录个人成长的地方。Ta，给了你分享成长的机会； 目录： 个人博客搭建方案 创建 GitHub 仓库 本地环境的准备工作 配置本地和Github的ssh传输连接 配置本地和Coding的ssh传输连接 Hexo的上线部署 Next 主题安装 Next 主题博客的站点配置 Next 主题博客的主题配置 创建分类界面 创建标签界面 写博客与发布 多终端编辑hexo博客(多台电脑) Hexo常用命令笔记 域名配置 Hexo博客搭建被坑蛋疼的报错解决集合 优化博客设置「持续更新」 个人博客搭建方案 笔者选择的是GitHubPages + Hexo + Next，一种简单高效的实现方式，当然还有其他的实现方式，如：WordPress、GitHubPages + Jekyll 等。 跟着我做，很简单几分钟你即可拥有自己的个人博客（Hello World 版）。试试吧！ 1.创建 GitHub 仓库 首先你需要拥有一个GitHub账号，注册或者登录 GitHub 创建仓库： 填写仓库名称：注意点： Respository name 中一定要输入：你的用户名.github.io。（用户名即仓库名下面会用到）其他地方不用修改，然后直接点 Create repository“按钮完成创建即可。 2. 本地环境的准备工作 主要以Mac操作进行讲解； Git安装 Git已帮大家下载好了，只需去百度云下载一份安装即可，也可去Git官网下载； 安装：直接双击 dmg 文件安装即可。 Nodejs安装 两种方式：其一去百度云下载一份直接安装；其二去Nodejs官网下载。 说明：Nodejs也可使用Nodejs版本管理器nvm安装，考虑其安装过程中存在的问题较多，操作流程也多，笔者不推荐大家使用这种方式安装。 Hexo 安装Hexo 是搭建的主角，先打开 Hexo 官网。 打开终端，输入Hexo的安装命令： 1npm install hexo-cli -g 若此命令安装不成功时，出现错误解决方法：可输入下面的命令和开机密码继续完成安装： 1sudo npm install --unsafe-perm --verbose -g hero 本地博客仓库 在你本地创建个你希望存储博客文件夹，打开终端，定位到存储博客的目录下，如下所示： 执行Hexo命令，初始化本地博客仓库： hexo init 你的用户名.github.io // 尽量和在上面创建的Github仓库使用同一个名称（我在这就坑了一次，建议使用同一个名称） 博客效果预览 上述步骤完成后，基本的博客框架就已经搭建完了，Hexo安装完成后默认使用 landscape 主题； 在终端定位到 cd xxx.github.io 文件夹下，并在终端输入下面的命令就能启动服务预览功能；1hexo s --debug # 启动服务预览 在浏览器上输入网址：http://localhost:4000/，就能预览到landscape 主题下的博客效果，具体如图： 接着来. . . 3. 配置本地和Github的ssh传输连接 首先我们需要检查你电脑上现有的ssh key： 1234cd ~/. ssh 检查本机的ssh密钥如果提示：No such file or directory 说明你是第一次使用git。 生成新的SSH Key：打开终端输入 ssh-keygen -t rsa -b 4096 -C &quot;你注册Github时的邮箱&quot; ，回车之后系统显示 Enter file in which to save the key(/xxx/.ssh/id_rsa): 我们记住（）中的地址是保存私钥保存地址及文件，之后继续一路回车到结束。 注意：输入密码的时候没有*字样的，你直接输入就可以了。最后看到这样的界面，就成功设置ssh key了： 然后 sudo cat /Users/your_user_directory/id_rsa.pub ，(提示把中间的 Users/your_user_directory/id_rsa替换成你上一步生成的地址) ，回车后把终端上显示的一大段就是 SSH Key 结果复制下来。 登陆github，在下拉菜单中点击Settings，在左侧栏中点击SSH and GPG keys，再点击右侧的New SSH key按键。此时我们可以看到下图情况，Title给这个key起个别名，在Key中，粘贴进去我们之前一步从终端保存下来的那一大段密钥。之后点击下方Add SSH key 现在我们测试一下本地和github的ssh配置是否正确，打开终端输入 ssh -T git@github.com，输入密码后，如果你看到了一句提示信息: Hi (你的注册用户名)! You&#39;ve successfully authenticated, but GitHub does not provide shell access.那么说明已经配置好了github远程仓库与本地。 4.配置本地和Coding的ssh传输连接 登录 Coding 官网，注册账号登录，点击添加项目，【项目名称填写：自己设计的名称.coding.me。(ps:这就是我们Github上个人博客的二级域名，需要把它记录下来，后面需要用)，选择*私有或者公开，点击底部的创建项目。 然后 sudo cat /Users/your_user_directory/id_rsa.pub ，(提示把中间的 Users/your_user_directory/id_rsa替换成你上一步生成的地址) ，回车后把终端上显示的一大段就是 SSH Key 结果复制下来。 点击右上角用户头像，点击左边栏的账户–&gt;SSH 公钥，把上步的 SSH Key 粘上。（提示可以看到ssh key最后的邮箱，此时GitHub和Coding是同一个注册邮箱），点击永久有效，点击添加项目。 补充：多个SSH私钥配置经验 设置多个私钥如果你的Coding 和 Github的注册邮箱不能满足一样，或者说他们有各自的ssh私钥。我们通过配置ssh连接时候，更换不同私钥文件名称来分别存储。 （ps:如果你Github已经本地生成了私钥，这块可以不做，但是coding部分的私钥文件名要区分你之前的私钥文件名）终端输入$ ssh-keygen -t rsa -b 4096 -C “你注册Github时的邮箱”，终端显示Enter file in which to save the key(/xxx/.ssh/id_rsa):id_rsa_github这里代表着，你的github远程仓库绑定的是这个邮箱，私钥名称为*id_rsa_github之后继续连续回车到结束。 建立Coding的ssh私钥终端输入$ ssh-keygen -t rsa -b 4096 -C “你注册Coding时的邮箱”，终端显示Enter file in which to save the key(/xxx/.ssh/id_rsa):id_rsa_coding这里代表着，你的coding远程仓库绑定的是这个邮箱，私钥名称为id_rsa_coding之后继续连续回车到结束 在本地保存ssh私钥文件所在的目录新建一个config配置文档，以我的为例终端输入$ vim ~/.ssh/config，里面填写如下内容，其中IdentityFile是你自己存放ssh私钥的文件名和文件路径，切记。 1Host github.com HostName github.com User git IdentityFile /home/redredleaf/.ssh/id_rsa_githubHost coding.net HostName coding.net User git IdentityFile /home/redredleaf/.ssh/id_rsa_coding 上面两步操作完后，我们的私钥文件所在目录的结构是： 注意权限如果你在$ ssh-keygen -t rsa -b 4096 -C “你注册Github时的邮箱”，这步的时候用了sudo，或者在root用户下执行的，那么你后续的ssh连接和hexo本地提交到远程仓库的命令都必须都是在root权限下执行，否则会出现Permission denied (publickey)的情况。 5.Hexo的上线部署 登陆coding后，点击左侧栏的项目–&gt;点击建立的项目–&gt;点击左侧栏的代码 ，之后页面中就能找到ssh的连接了 登陆github后，点击右上角自己的头像–&gt;点击Your profile–&gt;点击你的博客远程仓库，页面中就能找到ssh的连接了 打开【站点配置文件 _config.yml】 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: coding: 你的coding远程仓库ssh连接地址 github: 你的github远程仓库ssh连接地址 branch: master 记得 cmd+s，保存 然后执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d，再然后输入 你的博客项目名称.github.io，当成功看到Hexo的hello world的页面，这代表你的Github与Coding配置Hexo站点成功啦啦。 6. Next 主题安装 Next主题是 iissnan 所创作的一个Hexo主题，以简洁为主； 安装：在终端定位到xxx.github.io目录下，执行下面的命令后，稍等片刻，主题就下载到对应的位置；12cd xxx.github.iogit clone https://github.com/iissnan/hexo-theme-next themes/next 7.Next 主题博客的站点配置 首先，复制一份打开本地博客目录下的 _config.yml 文件，做为备份，以防改错 站点配置文件：打开之前的xxx.github.io文件夹，找到 _config.yml 即为站点配置文件，选中该文件-&gt;右击-&gt;打开方式-&gt;文本编辑（也可以选择Sublime打开），打开后就可以修改基本的博客配置了；（注意一下：在配置文件里‘#’就是注释符，相当于C语言中的‘//’） 注意：该配置文件中的键值之间一定要加空格。 关于 Hexo 配置的详细信息请前往 Hexo的官方文档(简体中文)。 站点配置文件详细配置示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site title: xxx # 博客的名字，也称站点名称subtitle: xxx # 副标题description: xxx # 对站点的描述，搜索引擎会抓取，可以自定义author: xxx # 作者名字language: zh-Hans # 语言 简体中文timezone: # 用默认的即可# URL # 这项暂时不需要配置，绑定域名后，要创建 sitemap.xml 时再配置该项## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory # 目录，不要修改source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing # 文章布局、写作格式的定义，不修改new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format # 日期 / 时间 格式，不要修改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: MMM D YYYYtime_format: H:mm:ss# Pagination # 每页显示文章数，可以自定义## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions # 配置站点所用主题和插件，这里将默认主题注释，修改为 next## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next#theme: landscape# Deployment# 本地博客部署到 github 上要配置这里## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git #git提交 repo: https://github.com/CustomPBWaters/CustomPBWaters.github.io.git # 已创建的Github仓库 prompt：配置好站点配置文件，就可以预览一下博客的效果了，步骤如下：在终端定位到 xxx.github.io 文件夹下，并在终端输入下面的命令就能启动服务预览功能；1hexo s --debug # 启动服务预览 启动成功可以看到提示，按照提示用浏览器打开提示网址，即可看到你的本地博客了，里面有一篇 Hello World 看完效果之后继续学习下面的内容… 8.博客的 Next 主题配置 主题配置文件在：xxx.github.io/themes/next/_config.yml 目录下，老规矩，先备份一份 以防改错，当然，最权威的是看 官方 的说明文档，我在这里提供一个示例，供大家参考； 温馨提示：你可以在/next/_config.yml，复制下面的键，回车找到对应的值修改，—&gt;方便 快捷；没修改完一个之后你都可以预览👀一下效果的hexo s –debug 关于主题需配置的选项略多，故采取分条讲解的形式，具体如下： 1.设置头像 123# 头像 注意：在站点下的 :/next/source/images，avatar: /images/avatar.jpg # 修改头像 2. 设置关键字 12# Set default keywords (Use a comma to separate)keywords: “iOS, 程序员” # 修改关键字 3. 设置博客的开始时间 12# Specify the date when the site was setup#since: 2016 # 设置博客的开始时间 4. 菜单栏的设置 1234567891011121314# ------------------------------------------------ ---------------# Menu Settings# 菜单栏的设置# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: home: / # 在菜单上显示首页 archives: /archives # 在菜单显示全部(归档) categories: /categories # 在菜单上显示分类 tags: /tags # 在菜单上显示标签 #search: /search # 搜索 about: /about # 在菜单上显示关于 #sitemap: /sitemap.xml #commonweal: /404.html 5. 菜单栏的图标设置：可从 Font Awesome （简体中文）网站查询图标对应的名称填入到对应的菜单项即可 1234567891011121314# 菜单栏的图标设置,规则为：菜单（左）：图标名（右）menu_icons: enable: true home: home # 首页 archives: archive # 全部(归档) categories: th # 分类 tags: tags # 标签 #search: search # 搜索 about: user # 关于 # schedule: calendar # 时间表 # sitemap: sitemap # 网站地图 # commonweal: heartbeat # 公益 # KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome # 键映射到菜单项键 6. 设置博客的外观 1234# Schemes#scheme: Muse #默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白scheme: Mist #Muse 的紧凑版本，整洁有序的单栏外观#scheme: Pisces #双栏 Scheme 7. 设置社交链接（设置了Github、微博） 123456789# Social Links# Key is the link label showing to end users.# Value is the target link (E.g. GitHub: https://github.com/iissnan)# 设置社交链接（如:Github、微博）,这里下面一定要空两格social: # LinkLabel: Link GitHub: https://github.com/CustomPBWaters Weibo: http://weibo.com/JacklinIOS/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo # JianShu: 12345678910# Social Links Icons# 设置社交链接对应的图标social_icons: enable: true # Icon Mappings. # KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome GitHub: github Twitter: twitter Weibo: weibo #JianShu: heartbeat 1234567# Blogrolls # 设置友情链接links_title: Links#links_layout: block#links_layout: inlinelinks: #Title: http://example.com/ 白开水简书: http://www.jianshu.com/users/fd745d76c816/latest_articles 8. 设置侧栏的方向（设置成左侧） 12345# 设置侧栏的方向（设置成左侧）sidebar: # Sidebar Position, available value: left | right position: left #position: right 9. 设置博客中代码高亮显示 123456# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-theme# 代码高亮主题highlight_theme: normal 10. 设置微信支付宝赞赏功能 1234567# 打赏配置# 打赏说明文本reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！# 微信收款二维码wechatpay: /uploads/money/wechat-reward-image.jpg# 支付宝收款二维码alipay: /uploads/money/alipay-reward-image.jpg 9. 设置微信公众号订阅 12345# 设置微信公众号订阅#wechat_subscriber: enabled: true qcode: /uploads/money/alipay-reward-image.jpg description: 欢迎您扫一扫上面的微信公众号，订阅我的博客！ 10. 添加网页计数器-不蒜子 123456789101112131415161718# 添加网页计数器-不蒜子# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count:# count values only if the other configs are false enable: true# custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; # 本站总访问数 site_uv_footer: 人# custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; # 本站总访问量 site_pv_footer: 次# custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; # 本文阅读量 page_pv_footer: 次 11. 设置是否显示阅读全文1234# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true # 设置是否显示阅读全文，文章较多的话，有必要设置为 true length: 200 13. 设置网站logo通过网站favicon在线制作 制作favicon图片，logo最好设置32*32。next主题：将图片放在next主题source/images目录下12# 在next主题配置文件中添加：favicon: /uploads/images/favicon.png 13. 站点头像改成圆形在themes/next/source/css/_common/components/sidebar/sidebar-author.styl 中.site-author-image定义中增加12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 14. 加入站点内容搜索功能本站点使用的是Local Search。加入站点内容搜索功能步骤如下：需要：安装hexo-generator-searchdb1npm install hexo-generator-searchdb --save 在站点 XXX.github.io/_config.yml 中添加search字段，如下：123456# 站点内容搜索功能search: path: search.xml field: post format: html limit: 10000 15. next主题添加背景图片1.找到一个背景图片放到 hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; Bgimage（存放背景图片的文件） 的路径下； 123456/themes/next/source/css/_custom/custom.styl// Custom styles.#body &#123;# background:url(http://upload-images.jianshu.io/upload_images/2230763-265f0df7e75d706a.gif?imageMogr2/auto-orient/strip);# background-attachment: fixed;#&#125; 16. 底部logo栏更改找到 /themes/next/layout/_partials/ 下面的 footer.swig文件，打开会发现，如下图的语句： 第一个框，是下面的“日期 ❤️ XXX” 第二个框，是图当中 “由Hexo驱动” 的Hexo链接 第三个框，是“主题-Next.XX” 9.创建分类界面 先看下效果： 打开终端，定位到xxx.github.io目录下； 执行下面的命令，新建一个名为categories的页面； 1hexo new page categories 创建完成后，在对应的目录下找到index.md文件，进行如下的修改： 123456 ---title: categories # 分类名字（可为空）date: 2016-06-15 08:17:00type: "categories" # 将页面的类型设置为 categories,主题将自动为这个页面显示所有分类comments: false # 如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，设置为 false --- 10.创建标签界面 先看效果： 打开终端，定位到xxx.github.io目录下； 执行下面的命令，新建一个名为tags的页面； 1hexo new page tags 创建完成后，在对应的目录下找到index.md文件，进行如下的修改： 123456 ---title: tags # 标签名字（可为空）date: 2016-08-20 22:17:49type: "tags" # 将页面的类型设置为 tags,主题将自动为这个页面显示为标签云comments: false # 如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，设置为 false --- 注意点 格式：再次强调，设置项的键值之间一定要有空格 关于第三方服务的 ”duoshuo_info“在配置该项的时候，user_id 键对应的值不要修改，也就是保持为 0，具体原因我不清楚； 分类和标签云页面首先，要使用” hexo new page “命令生成这两个页面，否则报404。其次，这两个页面是主题自动维护的，只要我们的文章按照规矩来就行了； 11.写博客与发布 经过上述步骤，本地博客和主题设置已经完成，那么接下来就是写博客了; 温馨提示：你的博客文件需要存放到 xxx.github.io/source/_posts 文件夹中，在该文件夹下面你可以按照你的博客分类建立一系列的文件夹来管理博客原文件； 操作步骤1. 用 Markdown 写文章不管你用什么编辑 Markdown 文件，最后生成的 md 文件放到 xxx.github.io/source/_posts 文件夹或其子文件夹中即可，如：12345678910---title: 个人博客搭建详解（Windows和Mac通用版） # 这是标题date: 2016-05-20 11:26:00 # 这个时间就是本篇文章创建时间 ^_^. 可以自定的。categories: # 这里写的分类会自动汇集到 categories 页面上，分类可以多级- 博客搭建 # 一级分类- Next主题配置 # 二级分类 tags: # 这里写的标签会自动汇集到 tags 页面上- 博客搭建 # 可配置多个标签，注意格式- Next主题配置--- 温馨提示 分类和标签是自动维护的，关键是的文章要按照规定的格式写，如上格式，可以参考. Next 主题会自动生成目录，这也省了不少事; 2. 在本地运行测试在终端上定位到xxx.github.io目录下，输入命令：1hexo s --debug 3. 在浏览器查看效果在浏览器输入http://localhost:4000/ 即可看到博客的效果 4. 安装自动部署发布工具1sudo npm install hexo-deployer-git --save 5. 发布到 GitHubPages当在本地确认博客效果后，就可以将md文件生成静态网页上传至GithubPages，在终端定位到xxx.github.io目录下，执行下面的命令即可：123456hexo clean # 清除缓存 网页正常情况下可以忽略此条命令hexo g # 生成静态网页hexo d # 开始部署也可以一次性执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 温馨提示如果是第一次部署，终端会提示要求输入用户名和密码。等命令执行完之后，过几分钟打开 http://xxx.github.io 即可看到你的个人博客了。以后要发布新文章，执行上述命令即可; 12.多终端编辑hexo博客 摘录原地址：http://www.jianshu.com/p/4f9fc8aafe15 之前就想到了一个问题，如果我想要在公司写博客怎么办，或者说如果我换电脑了怎么办，因为在github中的我们github.io项目是只有编译后的文件的，没有源文件的，也就是说，如果我们的电脑坏了，打不开了，我们的博客就不能进行更新了，所以我们要把我们的源文件也上传到github上，这道题的解题思路（哈哈，突然想到这个词了）是，将我们的源文件上传至username.github.io的Hexo分支，并且设置为默认分支（分支需要自己创建），然后对我们的源文件进行版本管理，这样我们就可以在另一台电脑上pull我们的源码，然后编译完之后push上去。 更为优雅的方式是使用travis-ci，然后用webhook自动部署。你只需要写markdown，push到github就行了。根本不用关心deploy，只要维护你的markdown就行。详情请参考：http://blog.bigruan.com/2015-03-09-Continuous-Integration-Your-Hexo-Blog-With-TravisCI/ 创建Hexo分支创建两个分支：master 与 Hexo,并将Hexo设置为默认分支（这个Hexo分支就是存放我们源文件的分支，我们只需要更新Hexo分支上的内容据就好，master上的分支hexo编译的时候会更新的） 删除文件夹内原有的.git缓存文件夹并编辑.gitignore文件因为有些主题是从git上clone过来的，所以我们要先删除.git缓存文件，否则会和blog仓库冲突（.git默认是隐藏文件夹，需要先开启显示隐藏文件夹。.git文件夹被删除后整个文件对应的git仓库状态也会被清空).gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容： 1234/.deploy_git/public /_config.yml.deploy_git是hexo默认的.git配置文件夹，不需要同步 public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去 初始化仓库然后我们再初始化仓库，重新对我们的代码进行版本控制 123git initgit remote add origin &lt;server&gt;&lt;server&gt;是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端 将博客源文件上传至Hexo分支依次执行 123git add .git commit -m "..."git push origin hexo 提交网站相关的文件； 对B电脑进行的操作假设B电脑现在没有我们的源文件1234git initgit remote add origin &lt;server&gt; #将本地文件和云端仓库映射起来。git fetch --allgit reset --hard origin/master 13.Hexo常用命令笔记 hexo安装升级 123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 常用简写 12345hexo n "我的博客" == hexo new "我的博客" #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 启动本地服务 1234hexo server #Hexo #会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP 监视文件变动 123hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动hexo clean #清除缓存 网页正常情况下可以忽略此条命令 部署 12345#两个命令的作用是相同的hexo generate --deployhexo deploy --generatehexo deploy -ghexo server -g 草稿 1234# 新建草稿hexo new draft &lt;title&gt;# 发布草稿为posthexo publish draft &lt;title&gt; 模版 12345678hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo new [layout] &lt;title&gt;hexo new photo "My Gallery"hexo new "Hello World" --lang tw 写作时间 1234567变量 描述:title 标题:year 建立的年份（4 位数）:month 建立的月份（2 位数）:i_month 建立的月份（去掉开头的零）:day 建立的日期（2 位数）:i_day 建立的日期（去掉开头的零） 14.域名配置 注册购买我们先到阿里云官网注册一个帐号(官网地址)之后打开 域名购买地址，根据个人喜好选后缀为什么的顶级域名。如：.me .cn .com DNS域名解析再登陆回我们的阿里云到首页，点击右上角的控制台，继续点击左侧栏域名与网站(万网)–&gt;域名. 这里我们看到刚刚购买的域名了，点击域名那行尾部的解析，之后我们就跳转配置解析页面。我们继续点击红色添加解析按键，若有认证信息请自己通过]]></content>
      <categories>
        <category>HexoBlog</category>
      </categories>
      <tags>
        <tag>HexoBlog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac&Xcode「实用快捷键」续更]]></title>
    <url>%2FMacUseEfficiency%2FMac%26XcodeShortcuts.html</url>
    <content type="text"><![CDATA[毅力能滴水穿石，重复能熟能生巧。 温馨提示：要使用键盘快捷键，请按住一个或多个修饰键，同时按快捷键的最后一个键。例如：要使用快捷键 Command + C（拷贝），请按住 Command 键并按 C 键，然后同时松开这两个键。Mac 菜单和键盘通常使用某些按键的符号，其中包括以下修饰键： Command ⌘ Shift ⇧ Option ⌥ Control ⌃ Caps Lock ⇪ Fn 如果你使用的是 Windows PC 专用键盘，请用 Alt 键代替 Option 键，用 Windows 标志键代替 Command 键。有些 Mac 键盘在顶行中设有特殊按键，快捷键中也会用到它们；这些按键上有音量图标、显示屏亮度图标和其他功能图标。按下图标键可执行相应功能，将其与 Fn 键组合可用作 F1、F2、F3 或其他标准功能键。 (有福利在最后哦~) 常用快捷键12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152快捷键 | 描述Command + Q | 退出应用程序。Command + W | 关闭最前面的窗口。要关闭该应用程序的所有窗口，请按 Command-Option-W。Command + i | 显示文件夹简介（选中文件夹）Command + O | 打开所选项，或打开一个对话框以选择要打开的文件。Command + P | 打印当前文稿。Command + A | 全选各项。Command + S | 保存当前文稿。Command + F | 查找：打开“查找”窗口，或在文稿中查找项目。Command + G | 再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Command + Shift + G。Command + H | 隐藏最前面的应用程序的窗口。要查看最前面的应用程序但隐藏所有其他应用程序，请按 Command + Option + H。Command + L | 当前程序是浏览器时，可以直接定位到地址栏Command + Z | 撤销前一个命令。随后你可以按 Command + Shift + Z 来重做，从而反向执行撤销命令。在某些应用程序中，你可以撤销和重做多个命令。Command + X | 剪切：删除所选项并将其拷贝到剪贴板。Command + C | 将所选项拷贝到剪贴板。这同样适用于 Finder 中的文件。Command + V | 将剪贴板的内容粘贴到当前文稿或应用程序中。这同样适用于 Finder 中的文件。Command + N | 新建：打开一个新文稿或窗口。Command + M | 将最前面的窗口最小化至 Dock。要最小化最前面的应用程序的所有窗口，请按 Command + Option + M。Option + Command + Esc | 强制退出：选择要强制退出的应用程序。或者，按住 Command + Shift + Option + Esc 3 秒钟来仅强制最前面的应用程序退出。Command + 波浪号(~) | 切换窗口：切换到最前端应用中下一个最近使用的窗口。Command + Tab | 切换应用程序：在打开的应用程序中切换到下一个最近使用的应用程序。Shift + Command + 3 | 屏幕快照：截桌面屏。Shift + Command + 4 | 屏幕快照：自由截屏Command + 空格键 | Spotlight：显示或隐藏 Spotlight 搜索栏。要从 Finder 窗口执行 Spotlight 搜索，请按 Command + Option + 空格键。如果你使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示 Spotlight。空格键 | 快速查看：使用快速查看预览所选项。Command + 逗号 (,) | 偏好设置：打开最前面的应用程序的偏好设置。Command + Delete | 把选中的资源移到废纸篓Shift + Command + Delete | 清倒废纸篓(有确认)Shift + Option + Command + Delete | 直接清倒废纸篓选中文件 + enter | 修改文件名Command + [ | 左缩进Command + ] | 右缩进Ctrl + ↑ | 进入屏幕选择界面 Ctrl + ↓ | 进入选定的屏幕Ctrl + ←／→ | 切换屏幕Command + option + control + Eject | 关机Command + option + Eject | 睡眠Command + control + Eject | 重启Command + shift + control + Q | 注销 启动组合键在启动期间按住某些键可以使用一些 Mac 功能。 请在 Mac 开机并听到启动声后立即按住这些键。请一直按住，直至所述行为出现。以下组合适用于基于 Intel 的 Mac 电脑。 123456789101112131415161718在启动期间按住 | 描述Shift ⇧ | 以安全模式启动。Option ⌥ | 启动进入启动管理器。C | 从可引导的 CD、DVD 或 USB 闪存驱动器（如 OS X 安装介质）启动。D | 启动进入 Apple Hardware Test 或 Apple Diagnostics，具体取决于您正在使用的 Mac。Option-D | 通过互联网启动进入 Apple Hardware Test 或 Apple Diagnostics。N | 从兼容的 NetBoot 服务器启动。Option-N | 使用默认的启动映像从 NetBoot 服务器启动。T | 以目标磁盘模式启动。X | 从 OS X 启动宗卷启动，否则 Mac 将从非 OS X 启动宗卷启动。Command + V | 以详细模式启动。Command + S | 以单用户模式启动。Command (⌘) + R | 从 OS X 恢复功能启动。Command + Option + R | 通过互联网从 OS X 恢复功能启动。Command + Option + P + R | 重置 NVRAM。当再次听到启动声后，请松开这些键。推出键 (⏏)、F12、鼠标键或触控板按钮 | 推出可移动介质，如光盘。 Finder 快捷键1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768快捷键 | 描述Command + D | 复制所选文件。Command + E | 推出所选磁盘或宗卷。Command + F | 在 Finder 窗口中开始 Spotlight 搜索。Command + I | 显示所选文件的“显示简介”窗口。Shift + Command + C | 打开“电脑”窗口。Shift + Command + D | 打开“桌面”文件夹。Shift + Command + F | 打开“我的所有文件”窗口。Shift + Command + G | 打开“前往文件夹”窗口。Shift + Command + H | 打开当前 macOS 用户帐户的个人文件夹。Shift + Command + I | 打开 iCloud Drive。Shift + Command + K | 打开“网络”窗口。Option + Command + L | 打开“下载”文件夹。Shift + Command + O | 打开“文稿”文件夹。Shift + Command + R | 打开“AirDrop”窗口。Shift + Command + T | 将所选的 Finder 项目添加到 Dock（OS X Mountain Lion 或较早版本）Control + Shift + Command + T | 将所选的 Finder 项目添加到 Dock（OS X Mavericks 或更高版本）Shift + Command + U | 打开“实用工具”文件夹。Option + Command + D | 显示或隐藏 Dock。即使您未打开 Finder，此快捷键通常也有效。Control + Command + T | 将所选项添加到边栏（OS X Mavericks 或更高版本）。Option + Command + P | 隐藏或显示 Finder 窗口中的路径栏。Option + Command + S | 隐藏或显示 Finder 窗口中的边栏。Command–斜线 (/) | 隐藏或显示 Finder 窗口中的状态栏。Command + J | 调出“显示”选项。Command + K | 打开“连接服务器”窗口。Command + L | 为所选项制作替身。Command + N | 打开一个新的 Finder 窗口。Shift + Command + N | 新建文件夹。Option + Command + N | 新建智能文件夹。Command + R | 显示所选替身的原始文件。Command + T | 在当前 Finder 窗口中打开单个标签时显示或隐藏标签栏。Shift + Command + T | 显示或隐藏 Finder 标签。Option + Command + T | 在当前 Finder 窗口中打开单个标签时显示或隐藏工具栏。Option + Command + V | 移动：将剪贴板中的文件从其原始位置移动到当前位置。Option + Command + Y | 显示所选文件的快速查看幻灯片显示。Command + Y | 使用“快速查看”预览所选文件。Command + 1 | 以图标方式显示 Finder 窗口中的项目。Command + 2 | 以列表方式显示 Finder 窗口中的项目。Command + 3 | 以分栏方式显示 Finder 窗口中的项目。 Command + 4 | 以 Cover Flow 方式显示 Finder 窗口中的项目。Command + 左中括号 ([) | 前往上一文件夹。Command + 右中括号 (]) | 前往下一文件夹。Command + 上箭头 | 打开包含当前文件夹的文件夹。Command + Control + 上箭头 | 在新窗口中打开包含当前文件夹的文件夹。Command + 下箭头 | 打开所选项。Command + Mission Control | 显示桌面。即使您未打开 Finder，此快捷键也有效。Command + 调高亮度 | 开启或关闭目标显示器模式。Command + 调低亮度 | 当 Mac 连接到多个显示器时打开或关闭显示器镜像功能。右箭头 | 打开所选文件夹。此快捷键仅在列表视图中有效。左箭头 | 关闭所选文件夹。此快捷键仅在列表视图中有效。Option + 连按 | 在单独窗口中打开文件夹，并关闭当前窗口。Command + 连按 | 在单独标签或窗口中打开文件夹。Command + Delete | 将所选项移到废纸篓。Shift + Command + Delete| 清倒废纸篓。Option + Shift + Command + Delete| 清倒废纸篓（不显示确认对话框）。Command + Y | 使用“快速查看”预览文件。Option + 调高亮度 | 打开“显示器”偏好设置。此快捷键可与任一亮度键搭配使用。Option + Mission Control | 打开“Mission Control”偏好设置。Option + 调高音量 | 打开“声音”偏好设置。此快捷键可与任一音量键搭配使用。拖移时按 Command 键| 将拖移的项目移到其他宗卷或位置。拖移项目时指针会随之变化。拖移时按 Option 键 | 拷贝拖移的项目。拖移项目时指针会随之变化。拖移时按下 Option + Command | 为拖移的项目制作替身。拖移项目时指针会随之变化。Option + 点按伸缩三角形| 打开所选文件夹内的所有文件夹。此快捷键仅在列表视图中有效。Command + 点按窗口标题 | 查看包含当前文件夹的文件夹。 文档快捷键12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970快捷键 | 描述Command + B | 以粗体显示所选文本，或者打开或关闭粗体显示功能。 Command + I | 以斜体显示所选文本，或者打开或关闭斜体显示功能。Command + U | 对所选文本加下划线，或者打开或关闭加下划线功能。Command + T | 显示或隐藏“字体”窗口.Command + D | 从“打开”对话框或“存储”对话框中选择“桌面”文件夹。Control + Command + D | 显示或隐藏所选字词的定义。Shift + Command + 冒号 (:) | 显示“拼写和语法”窗口。Command + 分号 (;) | 查找文稿中拼写错误的字词。Option + Delete | 删除插入点左边的字词。Control + H | 删除插入点左边的字符。也可以使用 Delete 键。Control + D | 删除插入点右边的字符。也可以使用 Fn-Delete。Fn + Delete | 在没有向前删除 键的键盘上向前删除。也可以使用 Control-D。Control + K | 删除插入点与行或段落末尾处之间的文本。Command + Delete | 在包含“删除”或“不存储”按钮的对话框中选择“删除”或“不存储”。Fn + 上箭头 | 向上翻页：向上滚动一页。 Fn + 下箭头 | 向下翻页：向下滚动一页。Fn + 左箭头 | 开头：滚动到文稿开头。Fn + 右箭头 | 结尾：滚动到文稿末尾。Command + 上箭头 | 将插入点移至文稿开头。Command + 下箭头 | 将插入点移至文稿末尾。Command + 左箭头 | 将插入点移至当前行的行首。Command + 右箭头 | 将插入点移至当前行的行尾。Option + 左箭头 | 将插入点移至上一字词的词首。Option + 右箭头 | 将插入点移至下一字词的词尾。Shift + Command + 上箭头 | 选中插入点与文稿开头之间的文本。Shift + Command + 下箭头 | 选中插入点与文稿末尾之间的文本。Shift + Command + 左箭头 | 选中插入点与当前行行首之间的文本。Shift + Command + 右箭头 | 选中插入点与当前行行尾之间的文本。Shift + 上箭头 | 将文本选择范围扩展到上一行相同水平位置的最近字符处。Shift + 下箭头 | 将文本选择范围扩展到下一行相同水平位置的最近字符处。Shift + 左箭头 | 将文本选择范围向左扩展一个字符。Shift + 右箭头 | 将文本选择范围向右扩展一个字符。Option + Shift + 上箭头 | 将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。Option + Shift + 下箭头 | 将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。Option + Shift + 左箭头 | 将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。Option + Shift + 右箭头 | 将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。Control + A | 移至行或段落的开头。Control + E | 移至行或段落的末尾。Control + F | 向前移动一个字符。Control + B | 向后移动一个字符。Control + L | 将光标或所选内容置于可见区域中央。Control + P | 上移一行。Control + N | 下移一行。Control + O | 在插入点后插入一行。Control-T | 将插入点后面的字符与插入点前面的字符交换。Command + 左花括号 (&#123;) | 左对齐。Command + 右花括号 (&#125;) | 右对齐。Shift + Command + 竖线 | 居中对齐。Option + Command + F | 前往搜索栏。 Option + Command + T | 显示或隐藏应用中的工具栏。Option + Command + C | 拷贝样式：将所选项的格式设置拷贝到剪贴板。Option + Command + V | 粘贴样式：将拷贝的样式应用到所选项。Option + Shift + Command + V | 粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。Option + Command + I | 显示或隐藏检查器窗口。Shift + Command + P | 页面设置：显示用于选择文稿设置的窗口。Shift + Command + S | 显示“存储为”对话框或复制当前文稿。Shift + Command + 减号 (-) | 缩小所选项。Shift + Command + 加号 (+)| 放大所选项。Command–等号 (=) 可执行相同的功能。Shift + Command + 问号 (?)| 打开“帮助”菜单。 截图操作123456截图快捷键 | 含义command + shift + 3 | 全屏截图，保存截图到桌面文件command + shift + 4 | 鼠标选定区域截图，保存截图到桌面文件command + shift + control + 3 | 全屏截图，保存到剪贴板command + shift + control + 4 | 鼠标选定区域截图，保存到剪贴板command + shift( + control) + 4 | 然后按下空格键，鼠标变成小相机，选择某一窗口后点击鼠标左键对单个窗口截图。不必担心其它窗口的遮挡。 睡眠、注销和关机快捷键12345678910快捷键 | 描述电源按钮 | 轻点可打开 Mac 或将 Mac 从睡眠状态唤醒。当 Mac 处于唤醒状态时，按住此按钮 1.5 秒钟会显示一个对话框，询问您是要重新启动、睡眠还是关机。如果您不想等待 1.5 秒钟，请按下 Control + 电源按钮或 Control + 介质推出键 。按住此按钮 5 秒钟会强制 Mac 关机。Control + Command–电源按钮 | 强制 Mac 重新启动。Control + Shift + （电源按钮或介质推出键 ） | 将显示器置于睡眠状态。Control + Command + 介质推出键 | 退出所有应用程序，然后重新启动 Mac。如果任何打开的文稿有未存储的更改，系统将询问您是否要存储这些更改。Control + Option + Command + （电源按钮或介质推出键 ）| 退出所有应用程序，然后关闭 Mac。如果任何打开的文稿有未存储的更改，系统将询问您是否要存储这些更改。Shift + Command + Q | 注销您的 macOS 用户帐户。系统将提示您确认。Option + Shift + Command + Q | 立即注销您的 macOS 用户帐户，且系统不提示您确认。 在浏览器中123456789101112131415Control + Tab | 转向下一个标签页 Command + L | 光标直接跳至地址栏 Control + Tab | 转向下一个标签页 Control + Shift + Tab | 转向上一个标签页 Command + 加号或等号 | 放大页面 Command + 减号 | 缩小页面Command + R | 刷新页面Command + + | 大屏幕的时候很实用，放大页面，基本也是全局型的。 0是恢复默认大小Command + W | 关闭当前标签。不要和退出按错了。Command + Q | 退出当前软件，其他软件也都可以用。Command + D | 收藏当前页面空格 | 屏幕下滚一页Safari的恢复刚关闭标签就是熟悉的 Command + Z。`Chrome` 是和打开差不多的，Command + Shift + T。Chrome这个功能更强大，就是可以按顺序恢复，但是Safari只能恢复最近的一个。 Xcode 快捷键Cmd + Shirt + N | 新建工程Cmd + N | 新建Cmd + R | 运行Cmd + . | 停止运行Cmd + B | 编译Cmd + Shirt + B | 编译，静态内存分析，可以检查程序结构上是否存在内存泄露Cmd + Q | 退出应用程序 Cmd + 0 | 左侧导航窗口开启和关闭Cmd + (1 - 7) | 左侧导航窗口的选择（项目，符号，搜索，问题，调试，断点，日志） Cmd + option + 0 | 右侧工具窗口开启和关闭Cmd + option + (1 - 6) | 右侧工具窗口的选择 Cmd + option + 回车 | 打开控制器对应的文件（Storyboard）Cmd + 回车 | 关闭控制器对应的文件,只显示主窗口 Cmd ＋ ↑／↓ ／←／→ | 光标移动到文字的最上／下／左／右Cmd + ctrl + ←/→ | 按浏览的先后顺序切换文件Cmd + ctrl + ↑／↓ | .h 和 .m 切换 Cmd + 鼠标左键(出现小手) | 进入查看一些类/方法option + 鼠标左键(出现问号) | 查看官方文档 Cmd + / | 选中后，加注释//Cmd + / | 选中后，取消注释 Cmd + shift + 箭头 | 快速选中 / 快速点击鼠标三下Cmd + delete | 删除光标之前的内容 Cmd + [ | 缩退Cmd + ] | 缩进Cmd + option + [ | 向上移动Cmd + option + ] | 向下缩进 Cmd + F | 搜索Cmd + shift + f | 全局搜索Cmd + ctrl + e | 全局修改Cmd + L | 点位搜索当前行 control + 6 | 弹出当前文件方法列表esc | 方法自动补全Control + i | 格式化代码(规范) Ctrl + 脱线 | 添加属性或方法option + 拖动 | 复制选中的控件Cmd + option + = | 更新选中控件的约束 模拟器快捷键Cmd + Shift + H | 按一次，取消晃动 / 按一次，回到首页Cmd + ←/→ | 旋转Cmd + k | 弹出键盘  Mac 键盘快捷键整理了那么多快捷键，一时半会根本记不住，怎么办？除了有意识的经常使用、练习外，还有一款神奇软件 CheatSheet 在任何应用程序下面长按Command ⌘ 键，即可以查看这款软件的快捷键操作。 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
</search>
