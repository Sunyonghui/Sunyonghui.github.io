<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[老司机带你学习千份技术简历的秘籍【更方便的阅读视角】]]></title>
    <url>%2FPerceptionWork%2FTechnicalResume.html</url>
    <content type="text"><![CDATA[先玩个小游戏，如果你在写简历时也遇到了相同的情况，请打勾： [ ] 1. 不知道招聘企业最看重什么，学历、技术、还是项目？ [ ] 2. 习惯把工作年限写长，比如2016年毕业要写2年工作经验。 [ ] 3. Java、Python、C/C++等技能，不管熟不熟，都要写“精通”。 [ ] 4. 项目经历、工作经历几笔带过或啰啰嗦嗦。 [ ] 5. 觉得技术简历和普通简历没什么区别，照着模板写就好了。 [ ] 6. 每次面试官最后说“你有什么要问的吗”，都觉得特别尴尬。 勾0-1条，请点左上方的叉号，关掉这个页面。 勾2-3条，你之前的简历可能是在自嗨，需要一点解药。 勾4-6条，重度患者，请仔细消化下面的内容。 其实，上面的几种情况，大部分人写简历和求职时都会遇到。 有的人不了解面试官的需求，想把简历写得面面俱到，写完却是毫无重点，且不自知，最终简历石沉大海； 有的人想在简历中呈现更好的自己，不管这个“自己”是不是真实的：把工作年限加长、把技能全写成精通。这种自嗨只能换来面试时的尴尬； 有的人技术强，肯努力，却怀才不遇，找不到一条更有效的渠道，让更多大公司了解到自己，就错过了很多上升机会。其实这也是可以改善的。 这篇文章，就教你如何躲过这些简历中常见的“坑”。写一份让面试官喜欢、又真实的技术简历。 如果你是在校生，你更该好好看看这篇文章。它将让你毕业时已经拥有一份最好的技术简历。 （本文内容整理自「 百楼俱乐部技术分享第一期——如何准备技术简历 」，分享人是实验楼CEO石头山。 「 百楼俱乐部 」顾名思义，是实验楼100楼以上的用户组成的群体，除了定期的技术分享外，还有其他福利，欢迎大家爬楼加入。） 简介分享人：石头山 （实验楼CEO，曾任职于VMware、Intel等知名外企，有9年研发和管理经验，筛选过数千份简历，面试过数百名技术人员，深知简历和面试的“套路”，将带你从面试官的角度，了解什么样的简历才是受人欢迎的。） 01 “ 本文不适合老司机… ”今天的话题时如何准备技术简历。我个人因为在技术公司，包括一些外企有过很多经验，所以在这里和大家分享一些想法和经验。 对于这个话题，我们面向的读者是面向互联网行业或软件行业求职的人，而且主要是应届生和毕业三年以内的求职者。因为对于经验丰富的求职者，他们的招聘方式可能会差异非常大。比方说，他对简历的重视程度会越来越低，更多依靠的是行业内的知名度，和公司内部高级工程师的引荐。 因为我个人缺少大型国企、传统行业的经验，所以说这个话题难免不全面，请大家见谅。 02 “ 基本信息那么简单吗？”首先是基本信息，大家肯定都会写到。包括： 姓名 年龄 工作年限 学历 城市 联系方式：手机 + 邮箱 这里还有几项需要注意的： 首先在基本信息里面，我们会看到，有很多同学会故意地把自己的工作年限写得很长。比如16年毕业，自己会选择性地写成两年甚至三年的工作经验。我要讲的是，这是完全没有必要。 因为首先，这会让招聘者很疑惑，你前面的这些工作经验是哪里来的？当然大部分可能是把实习经验算成工作经验了，但实际上到面试阶段还是会把这部分抛除掉的。 所以我们希望的原则是尽可能地实事求是，不要虚报。不要把自己的毕业年限故意提前，来增加自己的工作年限。哪怕这会帮你过简历自动筛选的过程，到人工筛选或面试时，仍有很大的可能会被筛掉。 另外，对于一些转行的朋友，如果你原来不是做计算机这一行的，并且和计算机行业相差非常多，比方说汽车维修，那就简单的一句话概过就可以了。只是为了让你的招聘方知道，你毕业以后前几年并不是在从事计算机行业，然后把自己在计算机行行业内的工作经验、工作年限写清楚就可以了。 联系方式的话，手机号自然不必多说，邮箱尽可能地用一些常用的邮箱。如果你有自己的个人网站，也可以选择用自己个人网站的邮箱。但是呢，邮箱的名称尽可能要简短好认，比如1和L混合在一起的那种邮箱地址，看起来是非常痛苦的。 03 “ 工作、实习经历，相当重要 ”简历的第二部分，就是工作和实习经历。 公司名称 职位 时间 详细工作 这部分相当重要。无论是应届毕业生，还是工作过几年的、有经验的，其实招聘方最看重的就是这一部分的内容。 在这一部分中，至少你要证明你在先前的实习或者工作中，有非常多收获，有对你个人的成长非常有帮助的经历。这样的经历是最有价值的。 另外工作经验要尽可能地避免断档。如果有断档的话，在你面试的时候肯定会问到，你需要有一个比较合理的解释。比方说你中间是出国读书了，或者哪种情况，然后有一两年的断档，这个是没什么问题的。 第二点需要注意的就是，一个公司只需要写一栏。在这一栏下，你可以列出一、二、三、四的这种条目，详细介绍在这个公司中，你所从事的事情以及学到的技术。但是要避免一个公司写很多栏，哪怕你在这公司里的职务有些变化，你可以只写一个最重要职务，或者一个最高级的职务。 对于工作的描述，需要详细地介绍自己曾经开发的产品，以及开发这个产品中间用到的一些技术，负责的任务，并且要标明是否带过团队、带团队的规模是多少个人、这个项目的是否自己独立完成、或者两个人协作完成中你所处的角色，这个是非常细节的地方，但是一定要写得清楚一些。不需要太啰嗦，但是每一点一定要点到位。 最后一点就是刚才也提到的，把每一项以一个简短的条目一二三四标出来。这样能让对方非常清晰地看到，你所收获到的一些关键点，能够抓住他们的眼球。 在描述项目中的时候，尽可能多的使用一些关键字，一些技术的关键字。比方说，这个项目中我用到了Mongo DB、Laravel，或是前后端常用的一些框架，然后把它写到这个项目描述中。 而对于应届生来说的话，如果没有工作经验，实习经验就非常非常宝贵了。因为目前绝大部分的公司，其实都相对功利，希望自己招聘来的应届生能够直接上手，尽可能地快速融入自己的团队，形成战斗力。真正说希望拿过来培养一到两年的公司，应该是规模非常大的企业，属于比较少见的一种情况。 04 “ 什么样的项目经历让人信服？ ”第三部分通常是项目经历，分为： 项目名称 项目描述 承担的职责 用到的技术 实现的效果 项目经历，一般会把自己先前的工作或者实习，以及在学校实验室跟老师做的项目，做一些提取。选取其中最好的项目，最能够代表自己真实水平的。像一些课程的大作业，其实是完全没有必要贴上去的。当然，如果这个大作业的代码量非常大，并且有一定的知名度的话也可以。 一些情况下，项目经验和工作经验是可以合并到一起的。比如你工作经历非常丰富，每一份工作的项目也非常明确，那完全可以将这两项内容合在一起。然后对于应届生，如果工作经历和实习经历都没有，项目经历一定要写得非常精选。 在项目的描述中，我们最看重的就有三点。 这个项目跟应聘的职位之间的关联性。 这个项目在整个技术圈内的知名度。 最后就是这个项目是否有一些数据，可以证明你做到了，并且让你有所收获。 回到刚才的项目经验，其实我们是需要证据的，而最好的证据就是你GitHub的代码链接，或者是你这个项目的一个线上版本——有可能是一个网站，有可能是你展示的一个demo。只要有这样的效果，对于审核简历的人来说，他一眼就能看出来这个项目的技术水平，是能增加很多分的加分项。 选择熟悉的项目，一定要选择熟悉的项目。应该自己写的项目如果进入了面试，很有可能面试官的问题都来自于你写的项目内容中，所以不要写那些自己模棱两可，或者说仅仅是一个旁观者身份的那种项目。只是看过的，或者没办法深入进去的，被问到也很尴尬。 项目经历还需要数据支撑。举个例子，比如你为实验楼开发了一个实验操作的模块，这个模块可以支持1000人同时做实验，并且已经稳定在线上运行了几年，这个实验操作模块能达到几百万次实验的检测。这其实是非常好的，有价值的项目经验。 其实不只是应届生，我们鼓励所有的人在简历里面，尽可能的在项目经验部分列出自己曾经参与过的开源项目。比方说你参与过一些非常知名的、像VIEW一类的开源项目，提交过代码、提交过PR，这其实是非常好的增分项。 如果，应届生没有这方面的项目的话，也可以写一些实验楼的大项目。但是呢，如果是单纯的实验楼的教学项目，其实我们更希望你能够做一些扩展，就是在实验楼项目基础之上，额外做了一些扩展功能。这也可以帮你在向面试官介绍项目的时候，更好地展示自己的能力。 最后一点需要注意的是，你的项目描述一定要以非常标准的技术语言来写。甚至说一些技术的关键字，该大写的地方一定要大写，该小写地方一定要小写。这其实非常体现一个人专业化的水平。 05 “ 精通Java、Python、C、PHP = 呵呵 ”第四部分通常是技能列表。 注意事项： 实事求是 根据目标职位适当调整 数字证明：30000行代码、3个项目-Python 项目证据：爬取知乎10万用户-Python 我们在介绍完自己的项目经历之后，通常会写一个技能的列表。而这个技能列表，通常会根据你所应聘的职位做一些修正。你如果应聘Python后端工程师，那你尽可能地把自己Python相关的技能放在最前面。这些关键点，就能够抓住潜在面试官的眼球。 首先需要注意的仍然是实事求是，尽可能地不要写精通这两个字，可以写熟悉或了解。 技能列表也可以增加一些数字辅助的证据。比方说在Python后写上：我曾经有3万行代码的经验；曾经做过三个项目，三个项目在前面的项目经验里也可以做一些验证。此外还有其他的一些证据，比方说我曾经用Python爬取知乎10万个用户，这其实都是非常好的、能体现你技能水平的一些工作。 06 “ 教育经历中需要规避的 ”教育经历这部分，好像就没有什么太多可说的。基本上专科、本科、硕士这些自己写清楚，学校、专业、时间也写清楚就可以了。 务必实事求是，没有必要在这方面弄虚造假。尽管很多的公司可能会看学校，看学历，但在我的理解，他们只是在选择一种更快的筛选方式。而这一点，在实验楼我们并不会特别看重。我们对学历，或者说学校，其实并不是特别在乎。我们更看重的是你先前的一些工作经验或者自己的项目经验，和其他的一些证明自己实力和能力的东西。 在教育经历这里，大家尽量不要特别强调自学成才。因为哪怕你没有上大学，没有上大专，高中毕业，但是自己对计算机非常感兴趣，又非常努力，是可以拿项目来证明的。但是不要在这里强调自学成才，因为自学成才的概率是非常非常低的，完全靠自己拼搏，出来一个能力非常强的个人，是非常难的，很多公司对这种小概率是非常惧怕的，基本上就会选择筛过。 最后一点就是，尽可能不要写培训班的经验。因为目前大部分的线下培训，都是比较粗糙的，能够获得的技能的提升也是非常有限的。 07 “ 不要轻视额外信息 ”第六点基本上简历的最后一部分，会介绍很多其他的额外信息，比方说个人的网站或者是GitHub的链接。这里就有很多需要注意的地方。 首先你自己的个人网站或技术博客，如果内容不够丰富的话，只有一两篇日志这种的，其实是完全没有必要放出来的。 第二点需要强调的就是，GitHub是非常非常重要的。至少我们实验楼在招聘的时候，会首先看GitHub上面的一些记录，比方说原创的代码项目，甚至说代码的一些规范，包括提交的一些记录。如果你的GitHub仓库里是空的，并且，大部分都是fork别人的代码，那就不要放了，可以避免很多时间上的浪费。 如果你有其他原创的项目代码的下载链接，其实也是可以放在这里的。但是，如果需要招聘方花很多时间去查看的话，通常都不会有人看。 在列出任何一个额外信息的时候，把它的亮点附在后面。比方说你自己的技术博客，你可以写上有150篇的技术博文，当月的访问量达到了100万。这样子是通过数字来吸引别人对你技术博客的关注。 在技术简历里，非技术相关的信息，比方说参加过的志愿活动、社团活动啊、一律不要放，除非是技术社团。但是技术社团除非很知名，一般情况下也价值不大。 最后就是，不要写自己的个人描述。技术简历比较单纯一些，我们只看重你的技术水平，你的项目经验。其他的你个人的一些爱好，比如喜欢什么运动，这真的不是特别重要。 最后一点就是，如果职位没有要求你写期望的薪资，就不要写，可以到现场去谈。有可能你写了就会错过一些面试的机会。 08 “ 私人干货——技术社交！”最后介绍一些简历之外的东西，我个人称之为就是「 技术社交 」。其实是为你打造一个不需要简历，就获得一些应聘机会的方式。需要通过下面这些渠道，增加你自己在技术社区里的知名度。 当知名度有了的话，很多公司会主动地去联系你。我知道的就有很多大公司的HR，会泡在GitHub上，然后去爬当地star排名非常靠前的用户，再主动地发邮件联系他们，邀请他们来公司进行面试。 而这部分的内容，就需要时间和个人精力的投入。比方说大学里，你可以选择从大二开始维护自己的GitHub仓库，在上面可以多创建一下项目，然后把自己原创的一些代码，包括参与的开源项目中提交的PR都可以发布上去。 你还可以用GitHub去搭建一个自己的技术博客，把大二大三大四几年以来的技术的积累和收获都放在上面，到你真正毕业去找工作的时候，其实你基本上不需要一个简历了。GitHub上面几百次的提交就是对你最好的一个证明。 还有就是像Stack Overflow这一类的技术社区。我个人建议是，在你有一些非常深入的技术了解之后，可以尝试着去回答一些小白的提问，这样子对个人的名声和技术也是有一个提高。 其他的内容无外乎就是你翻译过的一些技术文档，国外的非常著名的技术文档。其实在GitHub上，就可以加入很多的翻译组。还有你为一些在线教育网站贡献的内容，比方说想实验楼，你在实验楼投稿了一些课程，或是在一些在线教育的视频网站上，发布了一些自己录制的视频，这其实都是非常好的证明。 09 “ 常见问题！”第三部分的内容，就是我能想到的一些常见的问题。 首先需要注意的是，简历一定要短。把你最重要的内容精简到一页纸里面；把你最重要的关键字，精简到最突出的位置上。 千万不要增加大段的内容，大段的文字是简历的一个大忌。也不要夹杂太多个人感受、个人经历的文字，真的没人看。Hr或者工程师在收到很多简历的时候，他们的时间是非常有限的。如果你不能在很短的时间内抓住他们的眼球，那其实是浪费了一个很好的机会。 第二点是关于信息的顺序。首先应届生的话要突出学校，就把自己的教育信息和个人信息合在一起就可以了。非应届的话，最重要的是你的工作经验——你先前的工作、工作的时间长短、工作的核心内容是否与你应聘的职位相关、以及工作中的一些数据证据。个人信息下面就可以直接放一些工作经历。 在投递简历的时候要根据应聘的职位进行一些调整。比如调整一些想要顺序、技术技能的顺序、以及先前工作经验中重点关键词的描述，尽可能往应聘需求上靠。 简历的格式尽可能的用pdf，这样通用性会更好一些。然后是不要放照片，除非是长得非常漂亮，或者职位有要求的，基本上，我见过的职位是没有要求放照片的。 最后就是如果投递外企的话，尽可能一页英文简历，一页中文简历，因为面试你的很可能是外国工程师。 另外，如果选择一个公司，可以适当地对这个公司的产品，包括用到的技术进行一些调研，也可以准备一份简短的对该公司产品的技术分析，放在简历里面。当然基本上用不到，更多的可能在面试环节里会用到。 这就是我今天给大家分享的一些内容，因为比较精简，可能很多地方并不是特别全面，大家想问的问题，或者想讨论的话题都可以提出来。 10 “ 用户提问” 01 提问：学完基础后，怎么找一个好项目来做？ 回答：学完基础之后，可以先来实验楼做一些小的项目。如果你想有拿得出去、可以证明的项目，最好是去GitHub上找一些开源的项目，看一下人家提的ISSUE，然后找一些自己可以修的，再尝试着去提一些PR，哪怕被拒掉了。我觉得经过这几次交流之后，基本会有被接受的。这是一个非常好的锻炼自己的机会。 02 提问：一般公司最看重应届生的哪方面？实习经验还是其他东西？ 回答：就拿我们公司来说，对应届生更多地看重的是实习的项目经验，以及学习能力，包括他真正解决问题的能力。并不是特别重要的是你现在技术方面的东西。因为过来以后，都是需要在团队里面进行很长时间的磨合，磨合的过程中也会有高级工程师会带一些，做一些经验的分享。 03 提问：您强调 GitHub 中原创性的重要性，但个人又想兼容较大的提交量，这样的话需要怎么平衡？比如在实验楼做完实验，自动会把实验代码git下，其实更多的是一种个人的记录和托管，但这不是与原创性有所矛盾啦？ 回答：GitHub的提交和原创性其实并不矛盾啊。比方说你有什么思路，就在GitHub上创建这个项目，尝试着从最小的版本开始，慢慢地做一些迭代，持续上半年的时间，你的项目从代码量到知名度都会起来的啊。当然这就是一个坚持的过程。另外，如果要一个知名度比较高的，其实可以找一个大型项目里面的ISSUE，相当于你帮别人解决一些已知的问题。或者用他的框架去提出一些问题，然后提出自己的修复方案，提交一个PR，在讨论或者说在代码提交中，都会收到很多国内外工程师的反馈，这也是非常重要的。 04 提问：感觉面试完了，面试官说：我的问题问完了，你有什么要问的吗？这是最尴尬的时候。 回答：其实这个时候面试官也很尴尬……他可能自己也没有什么话要说了，只不过想找一个方式来结束本次面试。其实这个时候你就可以礼貌性质地问一些公司产品或者研发技术的一些问题。如果正好面试官属于这个产品线，或者对这个技术非常感兴趣的话，可以再深入地跟他探讨一下，但是呢，不要冒昧的提出一些自己并不是特别懂的建议。 原文链接 http://www.jianshu.com/p/0b676530e506 此文由 简书-白开水ln 博客整理,【更方便的阅读视角】]]></content>
      <categories>
        <category>职场</category>
      </categories>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 干货文章（助你66+,续更~~）iOS Swift]]></title>
    <url>%2FAppleTranslation%2FCoderln.html</url>
    <content type="text"><![CDATA[对你有新思想 或是 习惯 ！ 今日更新🍗、今日更新🍗、今日更新🍗 简[完整]：http://www.jianshu.com/p/711729623b03 阅读源码 || 系统文件，不仅能使我们了解作者的功能实现方式，方便我们运用其功能，快速的fix使用中遇到的bug，更重要的是在阅读优秀源码时体会作者的设计思想和架构设计，具体的技术很快就会过时，优秀的设计思想却会历久弥新，给我们今后编码以很大的借鉴和启迪。向优秀的开源者致敬 ！ 向优秀的分享者致敬 ！Two of my idea @白开水ln 。 【@码员真爱 : 真的不点进去阅读一下 ❓】【译文 &amp; 源码】 【工具类】 Content progress非官方 &amp; 非大牛 &amp; 非符合 ——&gt; 只是一帮有思想的伐码猿 ——&gt; 不准确 &amp; 新思想 &amp; 槽槽点 ——&gt; (参考)欢迎你的槽点 || 补充 ！【招募】 不管谁的博客上面写的文章(也包括自己)，阅读的你要敢于去验证，停止无意义的 ⏹copy paste。 工具插件安装+问题解决+活用 iOS 源代码管理「SVN &amp; Git」续更。 iOS 管理库工具CocoaPods「安装+问题解决+活用」续更。 Markdown—写作便捷高效。 Mac&amp;Xcode「实用快捷键」续更。 蛋疼一刻：开发神注释大全 iOS 伐码猿真爱—「偷懒 || 效率 工具类」 iOS 伐码猿自检—「Masonry约束」 感悟职场 学习整理 时间&amp;知识 管理。 老司机带你学习千份技术简历的秘籍【更方便的阅读视角】。 开源技术嘉年华「夜聊」社区，邀你加入 Hexo·博客搭建 学习整理 Hexo(Pages)—博客搭建同步GitHub&amp;Coding GitHubPages + Hexo—详解博客搭建。 Hexo文章简单加密访问 码员熟知 runtime-runloop iOS模式详解—「runtime面试、工作」看我就 🐒 了 ^_^. iOS 模式详解—「Runloop面试、工作」看我就 🐒 了 ^_^. iOS模块详解（部分示例，更多文章请订阅博客Rss获取） iOS 模式详解—「KVC编码 &amp; KVO监听」 iOS 模块详解—「多线程面试、工作」看我就 🐒 了 ^_^. iOS 网络请求—「NSURLSession会话」 iOS 数据安全—「加密解密」 //————————— 【Apple官方译文 学习整理】 ——————————// // 【从 NSURLConnection 到 NSURLSession】✔️【官方文档】 https://www.objc.io/issues/5-ios7/from-nsurlconnection-to-nsurlsession/【博客译文】https://githubidea.github.io/AppleTranslation/ConnectionToSession.html 【NSURLSession译文】✔️【官方文档】https://developer.apple.com/reference/foundation/urlsession#//apple_ref/occ/clm/NSURLSession/sharedSession【博客译文】https://githubidea.github.io/AppleTranslation/NSURLSessionApple.html 【UIWebView译文】✔️【官方文档】https://developer.apple.com/reference/uikit/uiwebview【博客译文】https://githubidea.github.io/AppleTranslation/UIWebViewApple.html 【UIBezierPath译文】✔️【官方文档】https://developer.apple.com/reference/uikit/uibezierpath?language=objc【博客译文】https://githubidea.github.io/AppleTranslation/UIBezierPathApple.html 【UIView API 官方文档译文】✔️【官方文档】https://developer.apple.com/reference/uikit/uiview?language=objc【博客译文】https://githubidea.github.io/AppleTranslation/UIViewApple.html 【iOS RunLoop 编程手册 （译）】✔️【官方文档】https://developer.apple.com/reference/foundation/runloop【博客译文】http://www.jianshu.com/p/4c38d16a29f1 【Podfile语法参考（译）】✔️【官方文档】https://guides.cocoapods.org/syntax/podfile.html【博客译文】http://www.jianshu.com/p/8af475c4f717 【iOS自动布局框架-Masonry详解】✔️【官方文档】【博客译文】http://www.jianshu.com/p/ea74b230c70d 【OC_runtime运行时官方文档翻译】✔️【官方文档】https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048【博客译文】http://blog.csdn.net/liangliang103377/article/details/39007683 【苹果文档翻译 iOS10 NSAppTransportSecurity】✔️【官方文档】https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW34【博客译文】http://www.jianshu.com/p/1ec3fa1ec00f 【iOS 9设计规范 中文版 完整版】✔️【官方文档】【博客译文】http://www.jianshu.com/p/fbdd713eb2ce 【iOS 10设计规范笔记与整理】✔️【官方文档】【博客译文】http://www.pmcaff.com/article/index/514586365192320?from=label&amp;pmc_param[label_name]=发现 【Stack Overflow 2017 开发者调查报告】✔️【官方文档】https://insights.stackoverflow.com/survey/2017#technology-most-loved-dreaded-and-wanted-languages【博客译文】https://www.oschina.net/news/83164/stack-overflow-developer-survey-results-2017 【Swift 4 JSON 解析指南】✔️【官方文档】【博客译文】http://bignerdcoding.com/archives/37.html //————————— 【三方框架 学习整理】 ——————————// // 【AFNetworking（v3.0+）框架结构】✔️【三方框架】https://github.com/AFNetworking/AFNetworking【博客注解】https://githubidea.github.io/SourceAnnotations/AFNLibraryStructure.html 【AFNetworking（v3.0+）内部逻辑处理过程】✔️【三方框架】https://github.com/AFNetworking/AFNetworking【博客注解】https://githubidea.github.io/SourceAnnotations/AFNLibraryProcessingLogic.html 【SDWebImage框架&amp;源码学习总结】✔️【三方框架】https://github.com/rs/SDWebImage【博客注解】https://githubidea.github.io/SourceAnnotations/SDLibrary.html【博客注解】https://githubidea.github.io/SourceAnnotations/SDSourceCode1.html 【MJExtension框架学习总结】✔️【三方框架】https://github.com/CoderMJLee/MJExtension【博客注解】https://githubidea.github.io/SourceAnnotations/MJExtensionLibrary.html 【VVeboTableView源码解析】✔️【三方框架】https://github.com/johnil/VVeboTableViewDemo【博客注解】http://www.jianshu.com/p/78027a3a2c41 【MJRefresh解析与详细使用指导】✔️【三方框架】https://github.com/CoderMJLee/MJRefresh【博客注解】http://www.jianshu.com/p/4ea427bab0af【博客注解】http://www.jianshu.com/p/437095c88717 【iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Connect篇)】✔️【三方框架】【博客注解】http://www.jianshu.com/p/0a11b2d0f4ae 【Masonry 源码解析】✔️【三方框架】https://github.com/SnapKit/Masonry【博客注解】http://www.jianshu.com/p/3fce11e370b1 【基于AFNetworking3.1的二次封装和拓展】✔️【三方框架】【博客注解】http://www.jianshu.com/p/d0751b9a8d65【博客注解】http://www.jianshu.com/p/cca7656ac41e //————————— 【Objective C-SourceAnnotation】 ——————————// // 【AFNetworking-3.1.0】✔️ 网络请求; 库原地址: 向优秀的开源者致敬 ! https://github.com/AFNetworking/AFNetworking【源码注解】待注解持续 +【工具类】待工具类持续 + 【SDWebImage-3.7.5】✔️ 图片下载; 库原地址: 向优秀的开源者致敬 ! https://github.com/rs/SDWebImage【源码注解】待注解持续 +【工具类】待工具类持续 + 【MBProgressHUD-】✔️ 进度提示; 库原地址: 向优秀的开源者致敬 ! https://github.com/rs/SDWebImage【源码注解】待注解持续 +【工具类】待工具类持续 + 【MJRefresh-3.1.12】✔️ 刷新; 库原地址: 向优秀的开源者致敬 ! https://github.com/CoderMJLee/MJRefresh【源码注解】待注解持续 +【工具类】待工具类持续 + 【MJExtension-3.0.13】✔️ 字典转模型; 库原地址: 向优秀的开源者致敬 ! https://github.com/CoderMJLee/MJExtension【源码注解】待注解持续 +【工具类】待工具类持续 + 【SVProgressHUD-2.1.2】✔️ 进度提示; 库原地址: 向优秀的开源者致敬 ! https://github.com/SVProgressHUD/SVProgressHUD【源码注解】待注解持续 +【工具类】待工具类持续 + //————————— 【Swift-SourceAnnotation】 ——————————//// 【SwiftyJSON-3.1.4】✔️ Swift界JSON解析之王; 库原地址: 向优秀的开源者致敬 ! https://github.com/SwiftyJSON/SwiftyJSON【源码注解】待 +【工具类】待 + 【DZNEmptyDataSet-1.8.1】✔️ 避免空白UITableView; 库原地址: 向优秀的开源者致敬 ! https://github.com/dzenbot/DZNEmptyDataSet【源码注解】待 +【工具类】待 + //————————— 【学习资源 学习整理】 ——————————// // “摘录于”: https://github.com/zhouhuanqiang/LearningIOS 地址 简介 objc中国 为中国 Objective-C 社区带来最佳实践和先进技术 NSHipster中文版 NSHipster 关注被忽略的 Objective-C、Swift 和 Cocoa 特性。每周更新。 iOS Dev Weekly 如果你是老手精通英文，那么这个周刊是非常值得推荐订阅的，该周刊提供行业新闻、最新开发动态、开发工具、代码分享、UI设计、设计师招聘等丰富的资源。 Shinobicontrols The latest technical blog posts iOS Developer Tips Code, tips and tricks for iOS developers Raywenderlich 国外iOS视频教程网站 trip-to-iOS 6000多个star的iOS学习资料整理 SwiftGuide 这份指南汇集了Swift语言主流学习资源，接近1W的star TimLiu-iOS 4000多个star，iOS、mac开源项目及库 skill-map IT技术领域（云计算，大数据，运维，安全，开发语言，智能硬件等）及互联网产品、运营等领域学习技能图谱 全球移动技术大会2016 全球移动技术大会2016PPT下载合集 atswift-2016-resources 2016中国Swift开发者大会源文件，包括keynote, pdf 和源工程文件 全球移动技术大会2017 全球移动技术大会2017PPT下载合集 //————————— 【开源项目源码 学习整理】 ——————————//// 地址 简介 iOS-Source-Code-Analyze 收集了优秀的iOS开源框架源代码解析文章，强烈推荐 Yep 社交IM软件YEP，star5000+ TeamTalk 蘑菇街开源IM，star4500+ MessageDisplayKit 类似微信的IMapp，可发送图片，音频，视频，文字，位置信息等，star3800+ 仿网易新闻 star3000+ 高仿城觅 star1800+ YoCelsius 天气预报的应用，动画和交互非常丰富，star2300+ Coding-iOS Coding iOS 客户端源代码, star2600+ v2ex v2ex.com客户端，star1700+ 高仿微信 star2000+ 高仿美团 star1500+ 高仿喵播APP 视频直播项目，star2000+ 高仿Bilibili客户端 star2000+ 高仿最美应用 swift, star800+ 一个 《一个》 iOS 客户端, star600+ CocoaChina+ 开源的第三方CocoaChina移动端, star600+ 高仿百度糯米 star500+ Four 一个上线的任务记录app，star300+ PHPHub客户端 star1100+ 高仿美团1 star500+ 高仿美团2 star400+ 高仿城觅 star1800+ SegmentFault客户端 star1200+ 网易新闻 star3000+ //————————— 【优秀Blog 学习整理】 ——————————// // “同步于”: https://github.com/tangqiaoboy/iOSBlogCN 博客地址 RSS地址 Plain boiled water 无耻的写上 http://www.jianshu.com/u/fd745d76c816 OneV’s Den http://onevcat.com/atom.xml 一只魔法师的工坊 http://blog.ibireme.com/feed/ 破船之家 http://beyondvincent.com/atom.xml NSHipster http://nshipster.cn/feed.xml Limboy 无网不剩 http://feeds.feedburner.com/lzyy 唐巧的技术博客 http://blog.devtang.com/atom.xml Ted’s Homepage http://wufawei.com/feed sunnyxx的技术博客 http://blog.sunnyxx.com/atom.xml Kevin Blog http://zhowkev.in/rss 阿毛的蛋疼地 http://www.xiangwangfeng.com/atom.xml 亚庆的 Blog http://billwang1990.github.io/atom.xml Nonomori http://nonomori.farbox.com/feed Wonderffee’s Blog http://wonderffee.github.io/atom.xml I’m TualatriX http://imtx.me/feed/latest/ Cocoabit http://blog.cocoabit.com/rss/ 不会开机的男孩 http://studentdeng.github.io/atom.xml Nico http://blog.inico.me/atom.xml 阿峰的技术窝窝 http://hufeng825.github.io/atom.xml answer_huang http://answerhuang.duapp.com/index.php/feed/ webfrogs http://blog.nswebfrog.com/feed/ 代码手工艺人 http://joeyio.com/atom.xml Lancy’s Blog http://gracelancy.com/atom.xml I’m Allen http://www.imallen.com/atom.xml Travis’ Blog http://imi.im/feed 王中周的技术博客 http://wangzz.github.io/atom.xml 克伟的博客 http://feed.cnblogs.com/blog/u/23857/rss 摇滚诗人 http://feed.cnblogs.com/blog/u/35410/rss Luke’s Homepage http://geeklu.com/feed/ 萧宸宇 http://iiiyu.com/atom.xml Yuan博客 http://www.heyuan110.com/?feed=rss2 KooFrank’s Blog http://koofrank.com/rss hello it works http://helloitworks.com/feed 码农人生 http://msching.github.io/atom.xml 玉令天下的Blog http://yulingtianxia.com/atom.xml 不掏蜂窝的熊 http://www.hotobear.com/?feed=rss2 猫·仁波切 https://andelf.github.io/atom.xml 煲仔饭 http://ivoryxiong.org/feed.xml 里脊串的开发随笔 http://adad184.com/atom.xml Why’s blog - 汪海的实验室 http://blog.callmewhy.com/atom.xml 土土哥的技术Blog http://tutuge.me/atom.xml 庞海礁的个人空间 http://www.olinone.com/?feed=rss2 Casa Taloyum http://casatwy.com/feeds/all.atom.xml Kenshin Cui’s Blog http://www.cnblogs.com/kenshincui/rss 技术哥的博客 http://suenblog.duapp.com/rss/ 老谭笔记 http://www.tanhao.me/atom.xml coderyi http://www.coderyi.com/feed 雷纯锋的技术博客 http://blog.leichunfeng.com/atom.xml 向晨宇的技术博客 http://iosxxx.com/atom.xml Reading 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。 未完 待续 每周末(争取) 更新 About me【🔍CodeFamily_伐码累 - 白开水ln】]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>伐码累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFNetworking3.1—封装优化]]></title>
    <url>%2FSourceAnnotations%2FAFNLibraryEncapsulation.html</url>
    <content type="text"><![CDATA[AFN 封装优化 正在总结，过两天补充上 ~，可以先参考：http://www.jianshu.com/p/cca7656ac41e 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFNetworking3.1—基本使用]]></title>
    <url>%2FSourceAnnotations%2FAFNLibraryUse.html</url>
    <content type="text"><![CDATA[Write in the first AFNetWorking 基本是iOS开发中使用网络通信框架的标配，这个框架本身比较庞大，也很复杂，但是使用起来非常非常简单。 本篇文章主要从【AFN 框架基本使用】学习，要想做出多牛逼酷炫的效果，就必须承受同等学习的代价 ~在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量@jianshu - 白开水ln。 目录： AFN GET | POST 请求 AFN 文件下载 | 上传 AFN 序列化处理 AFN 检测网络状态 AFN 使用技巧 AFN 数据安全 AFN 离线断点下载 后续【AFN 框架 | 源码 学习总结】 Getting Started【开始使用】 Examples 【AFN GET | POST 请求】下面就直接来代码了【代码具有详细注释】。 AFN 发送 get 和 post 请求方法，只需把 GET 修改为 POST 即可，1234567891011121314151617181920212223242526272829// 1.创建会话管理者AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];// 字典(发送给服务器的数据~参数)NSDictionary *paramDict = @&#123; @"username":@"520it", @"pwd":@"520it", @"type":@"JSON" &#125;;// 2.发送GET请求/** GET: NSString类型的请求路径，AFN内部会自动将该路径包装为一个url并创建请求对象 parameters: 请求参数，以字典的方式传递，AFN内部会判断当前是POST请求还是GET请求， 以选择直接拼接还是转换为NSData放到请求体中传递. progress: 进度回调,此处为nil success: 请求成功之后回调Block task: 请求任务、 responseObject: 响应体信息（内部已编码处理JSON-&gt;OC对象） failure: 失败回调（error:错误信息） task.response: 响应头 */[manager GET:@"http://120.25.226.186:32812/login?username=520it&amp;pwd=520it&amp;type=JSON" parameters:paramDict progress:^(NSProgress * _Nonnull downloadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSLog(@"%@\n%@",task.response,responseObject);&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; NSLog(@"%@",error);&#125;]; 总结：这里使用方法其实非常简单和我们之前的使用没有太大的区别，只是这里 AFN 把请求路径给拆分了，把参数单独拿出来，并且用一个字典的方式装载。相信这里大家应该都可以明白为什么作者 把参数单独给拿出来，这样更有利于代码的封装，我们使用起来更加的方便。 注意：这里关于 AFN（GET | POST 请求）内部业务逻辑是如何处理的，和之前使用 NSURLSession 大致是一样的，如果你需要了解 可以在看一下 学习总结(二) Examples 【AFN 文件下载 | 上传】 AFN 实现文件下载步骤： 创建会话管理者 创建下载路径和请求对象 创建下载任务 执行下载 123456789101112131415161718192021222324252627282930313233343536373839// 1.创建会话管理者AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];// 2.创建下载路径和请求对象NSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/resources/videos/minion_01.mp4"];NSURLRequest *request = [NSURLRequest requestWithURL:url];// 3.创建下载任务/** Request: 请求对象 progress: 进度回调（监听下载进度） completedUnitCount: 已经下载的数据大小 totalUnitCount: 文件数据的总大小 destination: 回调,该block需要返回值（NSURL类型）,告诉系统应该把文件剪切到什么地方 targetPath: 文件的临时保存路径 response: 响应头信息 completionHandler: 请求完成后回调 response：响应头信息 filePath：文件的保存路径，即destination回调的返回值 error：错误信息 */NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:^(NSProgress * _Nonnull downloadProgress) &#123; // 监听下载进度（3.0版本之后的做法） NSLog(@"%f",1.0 *downloadProgress.completedUnitCount / downloadProgress.totalUnitCount); &#125; destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123; // 指定下载路径 // targetPath临时路径,fullPath存储路径 NSString *fullPath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:response.suggestedFilename]; NSLog(@"%@\n%@",targetPath,fullPath); return [NSURL fileURLWithPath:fullPath];&#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) &#123; NSLog(@"%@\n%@",filePath,error);&#125;];// 4.执行下载[downloadTask resume]; 注意：如何监听下载进度，AFN 3.0之后的版本监听下载进度是上面的做法。而AFN 在2.6.3 之前并没有提供 progress 回调给我们，此时要想监听下载进度需要使用KVO，给它添加一位观察者监听内部 progress值的改变。1234567891011121314151617181920212223AFHTTPSessionManager *manage = [AFHTTPSessionManager manager]; NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://120.25.226.186:32812/resources/videos/minion_01.mp4"]]; // 创建下载进度，并监听 NSProgress *progress = nil; NSURLSessionDownloadTask *downloadTask = [manage downloadTaskWithRequest:request progress:&amp;progress destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123; // 指定下载路径 NSString *fullPath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:response.suggestedFilename]; NSLog(@"%@\n%@",targetPath,fullPath); return [NSURL fileURLWithPath:fullPath]; &#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nonnull filePath, NSError * _Nonnull error) &#123; NSLog(@"文件下载完毕---%@",filePath); &#125;]; // 使用KVO监听下载进度 [progress addObserver:self forKeyPath:@"completedUnitCount" options:NSKeyValueObservingOptionNew context:nil]; // 启动任务 [downloadTask resume]; 12345678910111213// 获取并计算当前文件的下载进度-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(NSProgress *)progress change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123; NSLog(@&quot;%zd--%zd&quot;,progress.completedUnitCount,progress.totalUnitCount); NSLog(@&quot;%f&quot;,1.0 * progress.completedUnitCount/progress.totalUnitCount)&#125;- (void)dealloc&#123; // 移除(监听) [self.person removeObserver:self forKeyPath:@&quot;completedUnitCount&quot;];&#125; AFN 文件上传1234567891011121314151617181920212223242526272829// 1.创建会话管理者AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];// 2.发送post请求上传文件/* POST: 请求路径（NSString类型） parameters: 非文件参数，以字典的方式传递 constructingBodyWithBlock: 处理要上传的文件数据(在该回调中拼接文件参数) progress: 进度回调 uploadProgress.completedUnitCount:已经上传的数据大小 uploadProgress.totalUnitCount：数据的总大小 success: 成功回调 task：上传Task responseObject:服务器返回的响应体信息（已经以JSON的方式转换为OC对象） failure: 失败回调 */[manager POST:@"http://120.25.226.186:32812/upload" parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123; // 使用formData来拼接数据 [formData appendPartWithFileURL:[NSURL fileURLWithPath:@"/Users/sunhui/Desktop/LNnet2.16/LNnet/Assets.xcassets/LN.imageset/LN.png"] name:@"file" error:nil]; &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123; NSLog(@"%f",1.0 * uploadProgress.completedUnitCount / uploadProgress.totalUnitCount); &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSLog(@"上传成功---%@",responseObject); &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; NSLog(@"上传失败---%@",error);&#125;]; 总结：这里使用 formData 来拼接数据，共有三种方法如下1234567891011121314151617// 文件上传拼接数据的第一种方式（FileData）/* FileData: 二进制数据 要上传的文件参数 name: 服务器规定的 @"file" fileName: 该文件上传到服务器以什么名称保存 */UIImage *image = [UIImage imageNamed:@"LNl.png"];NSData *imageData = UIImagePNGRepresentation(image);[formData appendPartWithFileData:data name:@"file" fileName:@"xxoo.png" mimeType:@"application/octet-stream"];// 文件上传拼接数据的第二种方式（FileURL）[formData appendPartWithFileURL:fileUrl name:@"file" fileName:@"xx.png" mimeType:@"application/octet-stream" error:nil];// 文件上传拼接数据的第三种方式（FileURL）[formData appendPartWithFileURL:fileUrl name:@"file" error:nil]; Examples 【AFN 序列化处理】 1、AFN 它内部默认把服务器响应的数据当做 JSON来进行解析，所以如果服务器返回给我的不是JSON数据那么请求报错，这个时候需要设置 AFN 对响应信息的解析方式。AFN提供了三种解析响应信息的方式，分别是： AFHTTPResponseSerializer（默认二进制响应数据，解析方案） AFJSONResponseSerializer（返回JSON类型，JSON解析方案.默认） AFXMLParserResponseSerializer（返回XML类型，XML解析） 2、还有一种情况就是服务器返回给我们的数据格式不太一致（查看：开发者工具Content-Type:text/xml），那么这种情况也有可能请求不成功。解决方法: 直接在源代码中修改，添加相应的Content-Type 拿到这个属性，添加到它的集合中。 返回JSON、XML、二进制、text/xml 相关代码12345678910111213141516171819202122232425262728293031323334353637383940414243// 1.创建请求管理者AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];/* 知识点1：设置AFN采用什么样的方式来解析服务器返回的数据*/// 注意：如果返回的是XML，那么告诉AFN，响应的时候使用XML的方式解析manager.responseSerializer = [AFXMLParserResponseSerializer serializer];// 注意：如果返回的就是二进制数据，那么采用默认二进制的方式来解析数据//manager.responseSerializer = [AFHTTPResponseSerializer serializer];// 注意：如果返回的是JSON，采用JSON的方式来解析数据//manager.responseSerializer = [AFJSONResponseSerializer serializer];/*知识点2 告诉AFN，再序列化服务器返回的数据的时候，支持此种类型 */manager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@"text/html"]; // 2.把所有的请求参数通过字典的方式来装载， // GET方法内部会自动把所有的键值对取出以&amp;符号拼接并最后用？符号连接在请求路径后面 NSDictionary *dict = @&#123; @"username":@"223", @"pwd":@"ewr", @"type":@"XML" &#125;; // 3.发送GET请求[manager GET:@"http://120.25.226.186:32812/login" parameters:nil progress:^(NSProgress * _Nonnull downloadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; // 4.请求成功的回调block NSLog(@"请求成功-\n%@",[responseObject class]); // 解析 NSXMLParser *parser = (NSXMLParser *)responseObject; parser.delegate = self;// 遵守&lt;NSXMLParserDelegate&gt; [parser parse];// 开始解析 &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; // 5.请求失败的回调，可以打印error的值查看错误信息 NSLog(@"请求失败-%@",error); &#125;]; 123456#pragma mark - NSXMLParserDelegate- (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary&lt;NSString *,NSString *&gt; *)attributeDict &#123; if ([elementName isEqualToString:@"videos"]) &#123; return; &#125; NSLog(@"开始解析某个元素%@--%@",elementName,attributeDict);&#125; Examples 【AFN 检测网络状态】 使用 AFN 框架 来检测网络状态的改变12345678910111213141516171819202122232425262728293031// 1.创建检测网络状态管理者AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager manager];// 2.检测网络状态改变/** AFNetworkReachabilityStatusUnknown = -1, 未知 AFNetworkReachabilityStatusNotReachable = 0, 无网络 AFNetworkReachabilityStatusReachableViaWWAN = 1, 蜂窝网络 AFNetworkReachabilityStatusReachableViaWiFi = 2, WIFI */[manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123; switch (status) &#123; case AFNetworkReachabilityStatusReachableViaWWAN: NSLog(@"蜂窝网络"); break; case AFNetworkReachabilityStatusReachableViaWiFi: NSLog(@"WIFI"); break; case AFNetworkReachabilityStatusNotReachable: NSLog(@"没有网络"); break; case AFNetworkReachabilityStatusUnknown: NSLog(@"未知"); break; default: break; &#125;&#125;];// 3.开始检测[manager startMonitoring]; Encapsulation【AFN 使用技巧】 AFN 使用技巧 在开发的时候可以创建一个工具类，继承自我们的 AFN 中的请求管理者，再控制器中真正发请求的代码使用自己封装的工具类。 这样做的优点是以后如果修改了底层依赖的框架，那么我们修改这个工具类就可以了，而不用再一个一个的去修改。 该工具类一般提供一个单例方法，在该方法中会设置一个基本的请求路径。 该方法通常还会提供对 GET或POST 请求的封装。 在外面的时候通过该工具类来发送请求 单例方法示例：12345678910+ (instancetype)shareNetworkTools &#123; static LNNetworkTools *instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 注意: BaseURL中一定要以/结尾 NSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/"]; instance = [[self alloc] initWithBaseURL:url]; &#125;); return instance;&#125; 提示：这里针对AFN 二次封装，我会单开一文学习总结，如果你感兴趣，可否关注 ~ Security【AFN 数据安全】 在写项目中，数据的安全性至关重要，而仅仅用 POST 请求提交用户的隐私数据，还是不能完全解决安全问题。 要想非常安全的传输数据，建议使用https。抓包不可以，但是中间人攻击则有可能。建议双向验证防止中间人攻击。可先参考 iOS数据安全—加密解密「学习总结」这部分也正在学习，如果你有比较好的解决方式，可否分享一下，学习学习。 Download【AFN 离线断点下载】 AFN 3.0 是基于 NSURLSession 的。所以实现原理和NSURLSession 差不多。可参考 NSURLSession 详解使用 实现断点下载的方法。 这里使用了 NSURLSessionDataTask，以便实现「离线断点下载」。在这里仅供参考（不必拿走直接用）。看下代码实现： 1、定义下载文件需要用到的类，这里不需要实现代理1234567891011121314//-----------------------AFN 断点下载 属性定义--------------------/////** 文件的总长度 */@property (nonatomic, assign) NSInteger fileLength;/** 当前下载长度 */@property (nonatomic, assign) NSInteger currentLength;/** 文件句柄对象 */@property (nonatomic, strong) NSFileHandle *fileHandle;/** 下载任务 */@property (nonatomic, strong) NSURLSessionDataTask *dataTask;/* 会话管理者 */@property (nonatomic, strong) AFURLSessionManager *manager;/** 获得文件全路径 */@property (nonatomic, strong) NSString *fullPath; 2、添加全局 AFURLSessionManager、NSURLSessionDataTask 懒加载代码。这里我把实现 代码 都放这里了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// manager 懒加载- (AFURLSessionManager *)manager &#123; if (!_manager) &#123; // 创建会话管理者 // Configuration:配置信息（用默认的 defaultSessionConfiguration） _manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; &#125; return _manager;&#125;// downloadTask 懒加载- (NSURLSessionDataTask *)dataTask &#123; if (!_dataTask) &#123; // 1.创建下载URL NSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/resources/videos/minion_01.mp4"]; // 2.创建request请求 NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; // 3.设置请求头信息,Range告诉服务器请求那一部分数据 NSString *range = [NSString stringWithFormat:@"bytes=%zd-", self.currentLength]; [request setValue:range forHTTPHeaderField:@"Range"]; // 4.创建Task __weak typeof(self) weakSelf = self; _dataTask = [self.manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:^(NSProgress * _Nonnull downloadProgress) &#123; &#125; completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@"File downloaded to: %@",weakSelf.fullPath); // 清空长度 weakSelf.currentLength = 0; weakSelf.fileLength = 0; // 关闭文件句柄（创建句柄,要记得在完成方法里 关闭句柄置空） [weakSelf.fileHandle closeFile]; weakSelf.fileHandle = nil; &#125;]; // 1.接收到服务器的响应 它默认会取消该请求 [self.manager setDataTaskDidReceiveResponseBlock:^NSURLSessionResponseDisposition(NSURLSession * _Nonnull session, NSURLSessionDataTask * _Nonnull dataTask, NSURLResponse * _Nonnull response) &#123; //NSLog(@"line = %d, %@--&gt;NSURLSessionResponseDisposition",__LINE__,[NSThread currentThread]); // 获得下载文件的总长度：本次请求下载的文件长度 + 当前已经下载的文件长度 weakSelf.fileLength = response.expectedContentLength + self.currentLength; // 创建一个空的文件到沙盒中 NSFileManager *manager = [NSFileManager defaultManager]; if (![manager fileExistsAtPath:weakSelf.fullPath]) &#123; // 如果没有下载文件的话，就创建一个文件。如果有下载文件的话，则不用重新创建(不然会覆盖掉之前的文件) [manager createFileAtPath:weakSelf.fullPath contents:nil attributes:nil]; &#125; // 创建文件句柄 weakSelf.fileHandle = [NSFileHandle fileHandleForWritingAtPath:weakSelf.fullPath]; // 允许处理服务器的响应，才会继续接收服务器返回的数据 return NSURLSessionResponseAllow; &#125;]; // 2.接收到服务器返回的数据（调用多次） [self.manager setDataTaskDidReceiveDataBlock:^(NSURLSession * _Nonnull session, NSURLSessionDataTask * _Nonnull dataTask, NSData * _Nonnull data) &#123; //NSLog(@"line = %d, %@--&gt;setDataTaskDidReceiveDataBlock",__LINE__,[NSThread currentThread]); // 指定数据的写入位置 -- 文件内容的最后面 [weakSelf.fileHandle seekToEndOfFile]; // 向沙盒写入数据 [weakSelf.fileHandle writeData:data]; // 计算文件的下载进度 weakSelf.currentLength += data.length; NSLog(@"下载进度2--&gt;%f",1.0 * self.currentLength / self.fileLength); // 获取主线程，不然无法正确显示进度。 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; // 下载进度 if (weakSelf.fileLength == 0) &#123; weakSelf.progressView.progress = 0.0; weakSelf.progressLabel.text = [NSString stringWithFormat:@"当前下载进度:00.00%%"]; &#125; else &#123; weakSelf.progressView.progress = 1.0 * weakSelf.currentLength / weakSelf.fileLength; weakSelf.progressLabel.text = [NSString stringWithFormat:@"当前下载进度:%.2f%%",100.0 * weakSelf.currentLength / weakSelf.fileLength]; &#125; &#125;]; &#125;]; &#125; return _dataTask;&#125; 3、懒加载（方法的独立与抽取）123456789101112131415161718192021222324// 获得文件全路径-(NSString *)fullPath &#123; if (!_fullPath) &#123; // 拼接文件后的本地名称 FileName @"123.mp4" 或者 [url lastPathComponent] 获取URL最后一个字节命名 _fullPath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:FileName]; &#125; return _fullPath;&#125;// 获得指定文件路径对应文件的数据大小-(NSInteger)getFileSize &#123; NSDictionary *fileInfoDict = [[NSFileManager defaultManager]attributesOfItemAtPath:self.fullPath error:nil]; //NSLog(@"%@",fileInfoDict); NSInteger currentSize = [fileInfoDict[@"NSFileSize"] integerValue]; return currentSize;&#125;注释：AFN 实现文件1.开始下载、暂停下载、取消下载、恢复下载2.支持后台下载3.在处理下载任务的时候可以直接把数据下载到磁盘4.下载的时候 是子线程异步处理，效率更高 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFNetworking3.1—内部逻辑处理过程]]></title>
    <url>%2FSourceAnnotations%2FAFNLibraryProcessingLogic.html</url>
    <content type="text"><![CDATA[Write in the first AFNetWorking 基本是iOS开发中使用网络通信框架的标配，这个框架本身比较庞大，也很复杂，但是使用起来非常非常简单。 本篇文章主要从【AFN 内部逻辑处理过程】以Get请求为例，学习总结，在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： AFN GET内部逻辑处理 AFN POST内部逻辑处理 总结 后续【AFN 框架 | 源码 学习总结】 Business logic【AFN GET 内部逻辑处理】 这是 AFNetworking 发起一个 Get 请求的流程图，大概可以分为这几个步骤，下面会逐个解读这个流程。 1. AFHTTPSessionManager 发起GET请求 这个方法是 AFN 的 Get请求 的起点，其他 Get 请求的方法也都是直接或者间接调用这个方法来发起 Get 请求。这个方法的代码量很少也很直观，就是调用其他方法生成 NSURLSessionDataTask对象的实例，然后调用 NSURLSessionDataTask 的 resume 方法发起请求。 2. 创建 NSURLSessionDataTask 这个方法是创建 NSURLSessionDataTask 对象实例并返回这个实例。首先创建一个 NSMutableURLRequest 对象的实例，然后配置。之后是使用 NSMutableURLRequest 对象的实例创建NSURLSessionDataTask 对象实例，然后配置，可以选择性地传入各类Block回调，用于监听网络请求的进度比如上传进度，下载进度，请求成功，请求失败。 3. 配置 NSMutableURLRequest对象 在这个方法中先使用了 url 创建了一个 NSMutableURLRequest 对象的实例,并且设置了 HTTPMethod 为 Get 方法（如果是Post方法，那么这里就是设置Post方法）然后使用KVC的方法设置了 NSMutableURLRequest 的一些属性。 12345678910111213141516// 设置 NSMutableURLRequest 的属性static NSArray * AFHTTPRequestSerializerObservedKeyPaths() &#123; static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //allowsCellularAccess 允许使用数据流量 //cachePolicy 缓存策略 //HTTPShouldHandleCookies 处理Cookie //HTTPShouldUsePipelining 批量请求 //networkServiceType 网络状态 //timeoutInterval 超时 _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))]; &#125;); return _AFHTTPRequestSerializerObservedKeyPaths;&#125; 先设置 HTTP header，之后格式化请求参数，设置参数的编码类型。这个是这个方法的基本操作流程。对于Get操作来说，参数是直接拼接在请求地址后面。 4. 配置 NSURLSessionDataTask对象 之后配置 NSMutableURLRequest 对象就需要配置 NSURLSessionDataTask 对象了。主要分为2个步骤，第一个步骤是创建 NSURLSessionDataTask 对象实例，第二个步骤是给NSURLSessionDataTask 对象实例设置 Delegate。用于实时了解网络请求的过程。 AFN 的代理统一使用 AFURLSessionManagerTaskDelegate 对象来管理，使用 AFURLSessionManagerTaskDelegate 对象来接管NSURLSessionTask 网络请求过程中的回调，然后再传入 AFN 内部进行管理。 12@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt; 如代码所示 AFURLSessionManagerTaskDelegate 接管了NSURLSessionTaskDelegate，NSURLSessionDataDelegate，NSURLSessionDownloadDelegate 的各种回调，然后做内部处理。这也是第三方网络请求框架的重点，让网络请求更加易用，好用。 1234567891011121314// 通过 task 的标识符管理代理- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task&#123; NSParameterAssert(task); NSParameterAssert(delegate); [self.lock lock]; // 将task和代理类绑定，task的taskIdentifier作为字典的key,delegate作为字典的value self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; // 给该task添加两个KVO事件（Resume 和 Suspend） [self addNotificationObserverForTask:task]; [self.lock unlock];&#125; 通过NSURLSessionTask的taskIdentifier标识符对delegate进行管理，只要是用于识别该NSURLSessionTask的代理。 设置各类回调 Block,给 NSURLSessionTask 使用 KVO 进行各种过程进度监听。 123456#pragma mark -// 给task添加暂停和恢复的通知- (void)addNotificationObserverForTask:(NSURLSessionTask *)task &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];&#125; 监听 NSURLSessionTask 被挂起 和 恢复的通知。 5. 网络请求开始12345678910111213141516171819202122232425262728// 发送GET请求/** GET: 请求路径(不包含参数),url parameters: 字典(发送给服务器的数据~参数) progress: 进度回调 success: 成功回调（task:请求任务、responseObject:响应体信息JSON-&gt;OC对象） failure: 失败回调（error:错误信息） task.response: 响应头 */- (NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(id)parameters progress:(void (^)(NSProgress * _Nonnull))downloadProgress success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure&#123; NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"GET" URLString:URLString parameters:parameters uploadProgress:nil downloadProgress:downloadProgress success:success failure:failure]; [dataTask resume]; return dataTask;&#125; 当 NSURLSessionTask 创建和配置完毕之后，它并不会主动执行，而是需要我们主动调用 resume 方法，NSURLSessionTask 才会开始执行。 6. 网络请求回调 AFN 里面有关 NSURLSessionDelegate 的回调方法非常的多，这里我们只说和 NSURLSessionTask 相关的部分方法和 KVO 处理来进行说明，其他的大家可以参考源码细看。 对于我们的 Get请求 来说，我们最关注的莫过于关注请求过程进度，收到响应数据和请求完成这2个回调。 KVO监听的属性值发生变化：123456789101112131415161718192021222324252627282930313233343536// KVO监听的属性值发生变化- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123; if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) &#123; if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) &#123; NSLog(@"countOfBytesReceived"); // 这个是在Get请求下，网络响应过程中已经收到的数据量 // 已经收到 self.downloadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) &#123; NSLog(@"countOfBytesExpectedToReceive"); // 这个是在Get请求下，网络响应过程中期待收到的数据量 // 期待收到 self.downloadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) &#123; NSLog(@"countOfBytesSent"); // 已经发送 self.uploadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) &#123; NSLog(@"countOfBytesExpectedToSend"); // 期待发送 self.uploadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; &#125; &#125; else if ([object isEqual:self.downloadProgress]) &#123; // 下载进度变化 if (self.downloadProgressBlock) &#123; self.downloadProgressBlock(object); &#125; &#125; else if ([object isEqual:self.uploadProgress]) &#123; // 上传进度变化 if (self.uploadProgressBlock) &#123; self.uploadProgressBlock(object); &#125; &#125;&#125; 收到请求响应：1234567891011121314151617181920// 收到请求响应- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123; NSLog(@"收到请求响应"); // 允许处理服务器的响应，才会继续接收服务器返回的数据 NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow; // 是否有收到请求响应的回调Block if (self.dataTaskDidReceiveResponse) &#123; // 若有调用该Block disposition = self.dataTaskDidReceiveResponse(session, dataTask, response); &#125; // 是否有请求响应完成的回调Block if (completionHandler) &#123; // 若有调用该Block completionHandler(disposition); &#125;&#125; 请求完成：123456789101112131415161718192021// 请求完成- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; NSLog(@"请求完成"); // 取出该NSURLSessionTask的代理对象 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) &#123; // 若是该代理对象存在，那么将对应数据转给该代理对象处理 [delegate URLSession:session task:task didCompleteWithError:error]; // NSURLSessionTask任务完成之后，移除该NSURLSessionTask的代理对象 [self removeDelegateForTask:task]; &#125; // 是否有请求完成的回调Block if (self.taskDidComplete) &#123; // 若有调用改Block self.taskDidComplete(session, task, error); &#125;&#125; 因为在配置 NSURLSessionDataTask 对象的时候我们有给 NSURLSessionTask 做了一系列配置，那么当 NSURLSessionDataTask 任务完成之后，我们需要将该 NSURLSessionDataTask 的一系列配置全部清理掉。 这个是我们的配置过程：12345678910111213// 通过task的标识符管理代理- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task&#123; NSParameterAssert(task); NSParameterAssert(delegate); [self.lock lock]; self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; [delegate setupProgressForTask:task]; [self addNotificationObserverForTask:task]; [self.lock unlock];&#125; 那么对应的清理过程是这样的，就是设置过程中做了什么，在清理过程中就需要去掉什么。1234567891011// 给task移除delegate- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123; NSParameterAssert(task); AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; [self.lock lock]; [delegate cleanUpProgressForTask:task]; [self removeNotificationObserverForTask:task]; [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)]; [self.lock unlock];&#125; Business logic【AFN POST内部逻辑处理】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#pragma mark - AFURLRequestSerialization// 设置Header和请求参数- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(request); NSMutableURLRequest *mutableRequest = [request mutableCopy]; [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123; // 判断header的field是否存在,如果不存在则设置，存在则跳过 if (![request valueForHTTPHeaderField:field]) &#123; // 设置 header [mutableRequest setValue:value forHTTPHeaderField:field]; &#125; &#125;]; NSString *query = nil; if (parameters) &#123; // 用传进来的自定义block格式化请求参数 if (self.queryStringSerialization) &#123; NSError *serializationError; query = self.queryStringSerialization(request, parameters, &amp;serializationError); if (serializationError) &#123; if (error) &#123; *error = serializationError; &#125; return nil; &#125; &#125; else &#123; switch (self.queryStringSerializationStyle) &#123; case AFHTTPRequestQueryStringDefaultStyle: // 默认的格式化方式 query = AFQueryStringFromParameters(parameters); break; &#125; &#125; &#125; // 判断是否是GET/HEAD/DELETE方法， 对于GET/HEAD/DELETE方法，把参数加到URL后面 if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123; // 判断是否有参数 if (query &amp;&amp; query.length &gt; 0) &#123; // 拼接请求参数 NSLog(@"query--&gt;%@",query); mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @"&amp;%@" : @"?%@", query]]; &#125; &#125; else &#123; // #2864: an empty string is a valid x-www-form-urlencoded payload if (!query) &#123; query = @""; &#125; // 参数带在body上，大多是POST PUT if (![mutableRequest valueForHTTPHeaderField:@"Content-Type"]) &#123; // 设置Content-Type HTTP头，告诉服务端body的参数编码类型 [mutableRequest setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"]; &#125; [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]]; &#125; return mutableRequest;&#125; 如果是 Post 请求，那么请求参数是没有拼接在 URL 上面，而是放在 body 上，这是 Post 和 Get 请求的最大区别了，其他过程和Get 请求并没有太多区别。 总结AFN发起Get请求主要分为以下步骤： 1.创建NSURLSessionDataTask 2.配置NSURLSessionDataTask 3.设置NSURLSessionDataTask的Delegate 4.调用NSURLSessionDataTask的resume方法开始请求 5.在Delegate的方法里面处理网络请求的各个过程 6.清理NSURLSessionDataTask的配置 其实也就是使用 NSURLSessionDataTask 的步骤，AFN在这几个步骤加了一些封装，让我们的使用更简单。 转载原著：http://www.jianshu.com/p/c36159094e24 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间和知识管理经验]]></title>
    <url>%2FPerceptionWork%2FTimeManagement.html</url>
    <content type="text"><![CDATA[转自 weekly 维护作者:About Time and Knowledge Management 关于时间管理和知识管理这两个话题，我见过最好的一个总结是： 此生理想、近期计划、今日功课 这是马英九的父亲马鹤凌为马英九制定的人生规划解决之道，是从我的师傅 nwind 的一场培训 工程师的个人发展规划 中学到的。总结的很完美，但实践起来坑很多。分享一些我的实践经验，以及 Weekly 是怎么整理的。 此生理想很多关于时间管理和知识管理的书最后都会指向这点：你的理想是什么，你想成为什么样的人，你想要的生活是什么样的。因为只有搞清楚这点，时间和知识管理才是最高效的。拥有理想看起来很美好，然而现实是：大多数人当下并没有真正想清楚自己的理想是什么，有可能是在年龄很大时才找到属于自己理想。有时候，我们貌似有了一个理想或梦想，但行动往往会出卖我们，暴露出真相并非如此。 所以，我的实践变成了：不刻意去追寻理想，活在当下。做好这几件事： 专注于：解决问题+知识积累，这两件事可以保证知识和技能始总是提升的。不管最终理想是什么，知识和技能最后都会发挥作用。在解决问题的过程中，也会展现个人价值。 不要给自己设限，认定自己不能做什么，勇于尝试各种可能，逐步排除掉什么不是自己想要的。 近期计划请注意：是“近期”而非“远期”，是“计划”而非“规划”。这一点，在理想的驱使下，很容易错误地被实践成长远规划。按我的经验：1 年内的计划比较容易可控，超过 1 年的变数太多，只能当做远景来确定方向。 我的实践是：踏歌而行，踩着节拍往前走。保持节奏可以让我们的工作和学习有序前行，避免迷失方向。我通常这样做： 按 年 -&gt; 月 -&gt; 周 这样的自然节奏进行，在上一个时间周期结束时确定下一个周期的事，比如：春节期间想好下一年的，每月初想好下月的事情，每周写周报或周末空闲时时想好下周要做的事，周末闲暇时间 &amp; 每天在路上想好每件事大致怎么做。所以在工作时，我往往只需执行。 不迷恋于各种日程及时间管理工具，用心记，当一周事情特别多时，用纸+笔 今日功课关于这点，我想分享一个我总结出的词汇“可持续性编程”。为什么编程还需要可持续性，因为：一个人的工作生涯会在20 年以上，这是一场长跑。而且，从职业生涯的角度去看问题，会发现一些有意思的东西： 很多当下的问题根本只是浪花一朵，比如：晋升、绩效、涨薪… 很多看似不可能的东西变得可能，比如：掌握 N 种编程语言、研究清楚浏览器内核、学会一种乐器… 从编程生涯的角度来看，今日功课其实是每日功课，要跑好这场长跑，我觉得这几点很重要： 给自己一个安静的环境，同时省出学习时间 关掉聊天工具、消息提醒，QQ 我已经变成每 1 周甚至 1月去开一次了，在攻坚时我会不开邮件客户端、旺旺、钉钉 少刷微博、微信、新闻，甚至不看，需要时定期去扫即可，不用担心会漏掉什么，重要的东西总会通过各种渠道传递到你这里的 减少不必要的会议，每个技术交流都是一份非常好的学习机会，可以选择不去，但去了后就全心参与，不看手机、不开电脑，专心获取或输出有效信息 健康的体魄，没有好身体，怎么写 20 年代码 工作必须有底线，也不能让自己长期处于高压工作下。我的习惯是：周末尽量不做实体性工作（除非计划有变）；平时不能牺牲吃饭+睡觉时间去赶进度。 适度运动，找到属于自己的一种方式。我会坚持每周去爬山一次，呼吸新鲜空气+思考问题 持续学习的精神，这点 阮一峰老师 是我们的榜样。要保持持续学习，我觉得这两点非常重要： 兼容并蓄：不要给技术贴标签，以学习的心态去看待每个技术，了解它们思考和解决问题的方式、实现原理、应用场景，不断丰富自己对编程的认知和解决问题的思路。 格物致知：计算机科学是非常庞大的一门科学，足以支撑我们研究一辈子。前端所接触的，只是技术的冰山一角，还有很多东西需要我们去探索。格物致知能让我们掌握日常使用的技术背后的原理，从而提升掌控复杂的能力。 Weekly 是如何整理的很多人会问我这个问题，其实，做这件事的初心很简单：记录自己平时看到的优质资料以备用，完善个人知识库。但由于常常有会把一些特别好的东西分享到群里，就有人建议我可以定期整理这类东西，发给大家。于是 Weekly 就开始了，坚持了好多年。 做这件事，我使用的工具是： RSS ：Feedly + gReader，离线、在线都能看，上网约等于看 rss 资源汇集地：hn-daily、JavaScript Weekly 等各种 weekly、技术组织官网、Medium、JavaScriptKicks OneNote：记录感兴趣的文章和资源，比 evernote 快，稳定性、复制 html 的效率和效果、搜索等都更好用 微博：订阅一些喜欢分享资源的人或者组织，其实微博仍然是非常好的一个传播渠道 微信：订阅公众号 方式： 定期看，而非实时关注，一般我会在周三晚上、周六集中扫一遍，筛选出有价值的和感兴趣的，周日汇总并完成整理 零散时间会看 rss 筛选信息，在周末或者晚上空闲时看自己感兴趣的文章 信源： 雪球效应：以资源汇集点为起点，逐步收集优质资源来自的 bolg 、技术站点 整理自己感兴趣的知识，逐步形成个人知识库总结 时间管理和知识管理可以围绕这 12 字去探索自己的模式：此生理想、近期计划、今日功课。我的习惯和建议是： 活在当下：专注于解决问题+知识积累；不给自己设限，去尝试未来的各种可能； 踏歌而行，踩着节拍往前走：以 年 -&gt; 月 -&gt; 周 的维度制定计划；用心而非工具管理计划； 可持续编程：安静的环境；健康的体魄；持续学习的精神； 知识管理：从信息汇聚源除非逐步形成自己的知识库；利用零散时间+定期扫的模式收集资源，在业余时间集中阅读 附： 另外补充，知识不仅是用来收集的，更是要内化成自己的，因此两个步骤必不可少，凝练和删除。 凝练，可以是在某收集材料上加入自己的一段总结，也可以是由一个自建架构下做的一个链接，又或是你的若干个收藏集。 删除，也非常重要，因为收集的过程中很多只是信息，不是知识，随着时间积累，这些东西越来越多。 我会用到一个“方法”，每天可以查看历史或上月、上年今日建立的记录，不仅可以温习当时的写作和笔记心路，还能顺手把一些不重要的过时的垃圾清除掉或是再总结。 知识变成自己的，才叫知识；而你 copy 下来的，只是信息；不正确的认知自己，（此处省去6个字）也救不了你；—- 成长。 谨记自己，阅读的你，可选择性忽略。]]></content>
      <categories>
        <category>职场</category>
      </categories>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C 关键字详解1「面试、工作」看我就 🐒 了 ^_^.]]></title>
    <url>%2FiOSUI%2FOCkeyword.html</url>
    <content type="text"><![CDATA[在写项目 或 阅读别人的代码（一些优秀的源码）中，总能发现一些常见的关键字，随着编程经验的积累大部分还是知道是什么意思的。 相信很多开发者跟我当初一样，只是基本的常用关键字定义属性会使用，但在关键字概念上及具体的用法「应用场景、优化选择」上却依然有些模糊。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 为此，本着好好学习，一劳永逸的目地，决定按模块一点一点剖析详解它「工作掌握、面试熟悉」。 本篇文章主要从【OC 常用关键字详解】学习总结。 本篇文章较长一些，强烈建议先 ❤️ 收藏，在进行阅读 ！持续更新。 也欢迎你留言补充 且 可以借楼 ^_^. ，我会及时补充，以方便你我的学习。 目录： 关键字 const／static／extern 的「释义和用法」1、const2、static3、extern4、static与const联合使用5、extern与const联合使用6、const与宏的区别？「面试题」 期待 &amp; 后续 关键字 const／static／extern 的「释义和用法」1、const const 简介：之前常用的字符串常量。 const 作用： const 仅仅用来修饰右边的变量（基本数据变量p，指针变量*p） 被const 修饰的(全局)变量是只读的，不能修改。 const 基本使用： 12345678910111213141516171819202122232425262728293031323334353637383940- (void)viewDidLoad &#123; [super viewDidLoad]; // 定义变量 int a = 1; // 允许修改值 a = 20; // const两种用法 // const:修饰基本变量p // 这两种写法是一样的，const只修饰右边的基本变量b const int b = 20; // b:只读变量 int const b = 20; // b:只读变量 // 不允许修改值,错误 b = 1; // const:修饰指针变量*p，带*的变量，就是指针变量. // 定义一个指向int类型的指针变量，指向a的地址 int *p = &amp;a; int c = 10; // 允许修改p指向的地址， p = &amp;c; // 允许修改p访问内存空间的值 *p = 20;//--------------------------- 面试题 ------------------------------// // const修饰指针变量访问的内存空间，修饰的是右边*p1， // 两种方式一样 const int *p1; // *p1:只读 p1:变量 int const *p1; // *p1:只读 p1:变量 // const修饰指针变量p1 int * const p1; // *p1:变量 p1:只读 // 第一个const修饰*p1 第二个const修饰 p1 // 两种方式一样 const int * const p1; // *p1：只读 p1：只读 int const * const p1; // *p1：只读 p1：只读&#125;注意: 判断p 和 *p是只读还是变量，关键是看const在谁前面。 const 开发中应用场景 12345678910111213141516171819@implementation ViewController// 定义只读全局常量 =&gt; 代替宏NSString * const str = @"123";// 当一个方法的参数，只读.- (void)test:(NSString * const)name&#123;&#125;// 指针只读,不能通过指针修改值- (void)test1:(int const *)a&#123;&#125;// 基本数据类型只读- (void)test2:(int const)a&#123;&#125;@end 2、static static 简介：可释义为“静态”的意思。 static 作用： 修饰局部变量： 被static修饰局部变量，延长生命周期，跟整个应用程序有关。 被static修饰局部变量，只会分配一次内存。 被static修饰局部变量什么分配内存?【程序一运行就会给static修饰变量分配内存】。 修饰全局变量： 被static修饰全局变量，会作修改用域（防止重复声明全局变量），只能在当前文件下使用。即当前文件内部才能访问该全局变量。 static 基本使用： 保证局部变量永远只初始化一次，在程序的运行过程中永远只有一份内存， 生命周期类似全局变量了，但是作用域不变。这句话怎么理解呢？还是以代码例子来讲解吧。 12345678910111213141516171819202122232425// 被`static`修饰局部变量-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; //声明一个局部变量i int i = 0; // 方式一 static int i = 0; // 方式二 i ++; NSLog(@"i=%d",i);&#125;打印输出:方法一2016-10-26 14:58:48.290 test[2760:170260] i=12016-10-26 14:58:49.044 test[2760:170260] i=12016-10-26 14:58:49.200 test[2760:170260] i=1方式二2016-10-26 15:07:34.276 test[2817:175155] i=12016-10-26 15:07:35.347 test[2817:175155] i=22016-10-26 15:07:35.761 test[2817:175155] i=3注解方式一：因为每次点击进入这个方法就会重新初始化一个全新的变量i = 0，加加了一次后值变为1，然后打印出结果为1，出了这个方法后局部变量i就被释放回收。方式二：它不是每次进去都被初始化赋值为0了么，怎么能累加呢。这就是关键字static修饰的局部变量的作用，让局部变量永远只初始化一次，一份内存，生命周期已经跟全局变量类似了，只是作用域不变。 iOS 中在一个文件声明的全局变量，工程的其他文件也是能访问的，但是我又不想让其他文件访问，这时就可以用static修饰它了，比较典型的是使用GCD一次性函数创建的单例，全局变量基本上都会用static修饰。 12345678910111213// 被`static`修饰全局变量@implementation LoginTool// static修饰全局变量，让外界文件无法访问static LoginTool *_sharedManager = nil;+ (LoginTool *)sharedManager &#123; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _sharedManager = [[self alloc] init]; &#125;); return _sharedManager;&#125; 3、extern extern 简介：可释义为“外部”的意思。 extern 作用：只是用来声明外部全局变量，注意 extern 只能声明，不能用于定义。 extern 工作原理：先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。 extern 基本使用 1234567在 ViewController.m 文件中 定义个全局的常量int i = 15;在 AppDelegate.m 文件中声明extern int i;NSLog(@"%d",i); // 打印输出 15 4、static与const联合使用 static与const作用:声明一个只读的静态变量 需求：1、变量为只读，防止修改 2、只在当前文件下使用（非全局），可以使用static与const组合。 1234567// iOS中staic和const常用使用场景，是用来代替宏，把一个经常使用的字符串常量，定义成静态全局只读变量.// 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。static修饰后表示只能本文件访问。static NSString * const key = @"name";// 如果 const修饰 *key1,表示*key1只读，key1还是能改变。static NSString const *key1 = @"name"; 5、extern与const联合使用 开发中使用场景：在 多个文件中 经常使用的同一个字符串常量，可以使用extern与const组合。 原因： 使用extern与const组合：在每个文件都需要定义一份静态全局变量（报重复定义错误）。 使用extern与const组合:只需要定义一份全局变量，多个文件共享。 全局常量正规写法：全局变量不能定义在自己类中，开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。 在开发中，我们通常会单独抽一个类来管理一些全局的变量或常量，下面来看看高逼格的一种做法：123456789101112131415161718// GlobeConst.m#import "GlobeConst.h"// 定义整个项目中全局变量//--------------------------- 首页 ------------------------------////NSString * const home_name = @"name";//--------------------------- 发现 ------------------------------////NSString * const discover_name = @"name";//--------------------------- 圈子 ------------------------------////NSString * const circle_name = @"name";//--------------------------- 我的 ------------------------------//// 1234567891011121314151617181920212223242526// GlobeConst.h#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;// 在开发中，我们通常会单独抽一个类来管理一些全局的变量或常量，下面来看看【高逼格】的一种做法：#ifdef __cplusplus#define LNKIT_EXTERN extern "C" __attribute__((visibility ("default")))#else#define LNKIT_EXTERN extern __attribute__((visibility ("default")))#endif// 声明整个项目中全局变量（把声明放到.h中）//--------------------------- 首页 ------------------------------////extern NSString * const home_name;//--------------------------- 发现 ------------------------------//// 系统UIKIT_EXTERN NSString * const discover_name;//--------------------------- 圈子 ------------------------------//// 高逼格LNKIT_EXTERN NSString * const circle_name;//--------------------------- 我的 ------------------------------//// 总结：这样，只要导入头文件，就可以全局的使用定义的变量或常量。 6、const与宏的区别？「面试题」从四点回答： 编译时刻：宏是预编译（编译之前处理）；const 是编译阶段。 编译检查：宏不做检查，不会报编译错误，只是替换；const 会编译检查，会报编译错误。 宏的好处：宏能定义一些函数 或 方法。 const 不能。 宏的坏处：使用大量宏，容易造成编译时间久，每次都需要重新替换。 注意：很多Blog都说大量使用宏，会消耗大量内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存。 提示：苹果不推荐我们抽成宏，推荐我们使用const常量，Swift已干掉了。 代码示例： 1234567891011121314// 常见的常量：抽成宏#define LNAccount @"account"#define LNUserDefault [NSUserDefaults standardUserDefaults]// 字符串常量static NSString * const account = @"account";- (void)viewDidLoad &#123; [super viewDidLoad]; // 偏好设置存储 // 使用宏 [LNUserDefault setValue:@"123" forKey:LNAccount]; // 使用const常量 [[NSUserDefaults standardUserDefaults] setValue:@"123" forKey:account];&#125; 未完———-。待续未完———-。待续未完———-。待续 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFNetworking3.1—框架结构]]></title>
    <url>%2FSourceAnnotations%2FAFNLibraryStructure.html</url>
    <content type="text"><![CDATA[Write in the first AFNetWorking 基本是iOS开发中使用网络通信框架的标配，这个框架本身比较庞大，也很复杂，但是使用起来非常非常简单。极大地提高了开发效率，让我们更加专注于业务逻辑的实现。像这种经常使用用又比较重要的内容，我觉得要做到 知其然亦知其所以然，然后梳理总结常用方法，到最后夯实基础、活学活用。 本篇文章主要从【AFN 框架结构】学习总结，在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： AFN 需求 | 版本区别 AFN 内部体系结构 AFN 工程目录 AFN 后续【框架 | 源码 学习总结】 期待 &amp; About me 首先来看一下，官方介绍 AFNetworking，如下： AFNetworking is a delightful networking library for iOS and Mac OS X. It’s built on top of the Foundation URL Loading System, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use. Perhaps the most important feature of all, however, is the amazing community of developers who use and contribute to AFNetworking every day. AFNetworking powers some of the most popular and critically-acclaimed apps on the iPhone, iPad, and Mac. Choose AFNetworking for your next project, or migrate over your existing projects—you’ll be happy you did! 翻译过来简单点说就是 AFNetworking 是一个适用于 iOS 和 Mac OS X 两个平台的网络库，它是基于 Foundation URL Loading System 上进行了一套封装，并且提供了丰富且优美的API接口给使用者使用。 Requirements【需求 | 版本区别】 1.x 版本，内部底层是基于 NSURLConnection 的，是对 NSURLConnection 一次封装。 在13年，苹果推出 NSURLSession 也就是会话管理者，后来 2.x AFN框架又对 NSURLSession 进行一次封装，其实在 2.0-2.6.3 AFN内部是使用两套系统，一套是基于 NSURLConnection 的，一套是基于 NSURLSession的。 版本升级到3.0之后，AFN 就不在支持 NSURLConnection 了，把有关 URLConnection 的代码已全部移除。 Architecture【AFN 内部体系结构】 NSURLSession【管理者】 AFURLSessionManager AFHTTPSessionManager（封装了常用的 HTTP 方法） GET POST UIKit + AFNetworking 分类 NSProgress：利用KVO Serialization【序列化】 AFURLRequestSerialization【请求序列化】 AFHTTPRequestSerializer（请求的数据格式，默认二进制） AFJSONRequestSerializer AFPropertyListRequestSerializer AFURLResponseSerialization【响应者序列化】 AFHTTPResponseSerializer（默认二进制响应数据，解析方案） AFJSONResponseSerializer（返回JSON类型，JSON解析方案.默认） AFXMLParserResponseSerializer（返回XML类型，XML解析方案） Additional Functionality【额外的功能】 AFSecurityPolicy【安全策略相关】 HTTPS（HTTP+SSL加密协议） AFNetworkReachabilityManager【网络状态监听管理者】 UIKit【类库扩展与工具类】 UIKit+AFNetworking NSURLConnection（iOS9.0废弃） AFURLConnectionOperation AFHTTPRequestOperation AFHTTPRequestOperationManager（封装了常用的 HTTP 方法） 属性 baseURL：AFN建议开发者针对 AFHTTPRequestOperationManager 自定义个一个单例子类，设置 baseURL, 所有的网络访问，都只使用相对路径即可 requestSerializer：请求数据格式/默认是二进制的 HTTP responseSerializer：响应的数据格式/默认是 JSON 格式 operationQueue：操作队列 reachabilityManager：网络状态检测管理者 方法 manager :方便创建管理器的类方法 HTTPRequestOperationWithRequest :在访问服务器时，如果 要告诉服务器一些附加信息，都需要在 Request 中设置 GET POST Directory【AFN 工程目录】 目前版本是 3.1.0，我通过 CocoaPods 导入的 AFNetworking，导入后目录如下 使用 CocoaPods 导入后可以看到目录很清晰主要是在五个文件夹下， 除去 Support Files，可以看到AF分为如下5个功能模块： NSURLSession（网络通信模块） ReachAbility（网络状态监听模块） Security（网络通信安全策略模块） Serialization（网络通信信息序列化/反序列化模块） UIKit（UIKit库的扩展） 其核心当然是网络通信模块，其余的四个模块，均是为了配合网络通信或对已有 UIKit 的一个扩展及工具包。这五个模块所对应的类的结构关系图如下所示： 可以看到，AFN 的核心是 AFURLSessionManager 类，AFHTTPSessionManager 继承于 AFURLSessionManager， 针对HTTP协议传输做了特化。而 AFURLResponseSerialization，AFSecurityPolicy，AFNetworkReachabilityManager则被AFURLSessionManager所用。其次，还可以看到一个单独的UIKit 包提供了对 iOS UIKit 类库的扩展与工具类。 建议：可以学习下AFN对 UIKit 做了一些分类，对自己能力提升是非常有帮助的。 当下载好，手动导入的时候，显示两个文件夹，如下 很明显第一个文件夹里边是跟网络请求相关的，第二个是跟UI相关的。 补充1、可参考 AFNetworking 提供的 Example 学习 AFNetworking 源码阅读系列【Example】 2、「HTTPS 相关」 AFNetworking之于https认证 HTTPS为什么安全 &amp;分析 HTTPS 连接建立全过程 知识 | HTTPS到底是啥？ 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[努力做自己]]></title>
    <url>%2FPerceptionWork%2Fyourself.html</url>
    <content type="text"><![CDATA[质朴无华净无尘，空明澄澈磊落身。入壶莫问来时路，清肺滋腑润君心。《七律》—— 白开水 纸上得来终觉浅，绝知此事要躬行。《冬夜读书示子聿》—— 陆游 期待喜欢你可拿走，我无需加水印；懂得分享，乐在其中。我只是个【爱喝白开水】的人。]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 模式详解—「NSNotification通知」]]></title>
    <url>%2FiOSUI%2FNSNotification.html</url>
    <content type="text"><![CDATA[Write in the first【写在最前】 Notification(通知) 是 iOS 系统下重要的消息传递机制之一，通知封装了诸如窗口获得焦点、网络连接关闭等事件信息，通知的内容可按照我们实际的需求来定制。在实际开发中或多或少都会接触到，NSNotificationCenter 与 其它对象之间通信方式类似，但也存在不同，我们需要根据具体应用场景选择（或优先选择）恰当的通信方式。 本篇文章主要从【NSNotification和NSNotificationCenter 使用和注意点】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： NSNotification1.NSNotification 概念2.NSNotification.h 系统文件 NSNotificationCenter1.NSNotificationCenter 概念2.NSNotificationCenter 系统文件 NSNotificationCenter 的使用流程1.注册观察者（添加监听）2.发送通知3.移除观察者（移除监听） NSNotificationQueue1.NSNotificationQueue 概念2.NSNotificationQueue.h 系统文件3.NSNotificatinonCenter 实现原理 NSNotificatinonCenter 实战使用1.基本使用2.通知在多线程中使用3.通知在多线程中注意点 NSNotification Demo效果图 期待 &amp; 后续 &amp; About me NSNotification 本着好好学习，了解权威的目的，我们还是主动看官网的说明。 NSNotification 概念上图简单点释义就是NSNotification是方便NSNotificationCenter 广播到其他对象时的封装对象，简单讲即通知中心对通知调度表中的对象广播时发送NSNotification对象。NSNotification对象(称为通知)包含名称、object 和一个可选字典三个属性，名称是用来标识通知的标记（一般为常量字符串），object是任意想要携带的对象（通常为发送者自己 或为nil），字典用来存储发送通知时附带的信息（可为nil）。NSNotification 对象是不可变的对象。 NSNotification.h 系统文件看完官网，接下来当然是看系统文件了。你说是吧！ 12345678910/**************** Notifications ****************/@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;@property (readonly, copy) NSNotificationName name;// 通知的标识名称(一般为常量字符串)@property (nullable, readonly, retain) id object;// 任意想要携带的对象(通常为发送者自己,可为nil)，@property (nullable, readonly, copy) NSDictionary *userInfo;// 关于通知的附加信息(可为nil)- (instancetype)initWithName:(NSNotificationName)name object:(nullable id)object userInfo:(nullable NSDictionary *)userInfo NS_AVAILABLE(10_6, 4_0) NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER; 接下来看下三个初始化方法 12345+ (instancetype)notificationWithName:(NSNotificationName)aName object:(nullable id)anObject;// 有附加信息+ (instancetype)notificationWithName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;- (instancetype)init /*NS_UNAVAILABLE*/; /* do not invoke; not a valid initializer for this class */ NSNotificationCenter 我们还是主动看官网的说明。 NSNotificationCenter 概念上图简单点释义就是NSNotificationCenter对象(通知中心) 是 Foundation 框架的一个子系统，提供了在程序中广播消息的机制。通过［NSNotificationCenter defaultCenter］获取引用总的通知中心，可以在不同类之间通信的时候使用。 在通知中心注册观察者，发送者使用通知中心广播时，以NSNotification的name和object来确定需要发送给哪个观察者。为保证观察者能接收到通知，所以应先向通知中心注册观察者，接着再发送通知这样才能在通知中心调度表中查找到相应观察者进行通知。 NSNotificationCenter 系统文件看完官网，接下来当然是看系统文件了。你说是吧！ 123456789101112/**************** Notification Center ****************/@interface NSNotificationCenter : NSObject &#123; @package void *_impl; void *_callback; void *_pad[11];&#125;#if FOUNDATION_SWIFT_SDK_EPOCH_AT_LEAST(8)// 获取通知中心@property (class, readonly, strong) NSNotificationCenter *defaultCenter; 总结：获取NSNotificationCenter的方法只有一种，即[NSNotificationCenter defaultCenter]，并且NSNotificationCenter是一个单例模式，一旦创建，这个通知中心的对象会一直存在于一个应用的生命周期。 通知中心的使用流程获取通知中心对象后，我们就可以使用它来处理通知相关的操作了，包括注册观察者、发送通知 和 移除观察者。 1、注册观察者（添加监听）你可以使用以下两种方式注册观察者 123456789101112131415161718192021222324252627//--------------------------- 注册观察者方式一 ------------------------------///** Observer: 观察者 selector: 只要一监听到通知,就会调用观察者这个方法 Name: 通知名称也是通知的唯一标示，编译器就是通过这个找到通知的。 object: 谁发出的通知,表示会对哪个发送者对象发出的事件作出响应，nil 时表示接受所有发送者的事件。 */- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject;//--------------------------- 注册观察者方式二 ------------------------------///** Name: 通知名称 object: 谁发出的通知 queue: 决定block在哪个线程执行,nil:在发布通知的线程中执行 [NSOperationQueue mainQueue]: 一般都是使用主队列 usingBlock: 只要监听到通知,就会执行这个block 注意: 一定要记得移除 */- (id &lt;NSObject&gt;)addObserverForName:(nullable NSNotificationName)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block NS_AVAILABLE(10_6, 4_0);// The return value is retained by the system, and should be held onto by the caller in// order to remove the observer with removeObserver: later, to stop observation. 总结： 第一种方式是比较常用的添加Oberver的方式，接到通知时执行Selector方法，观察者接收到通知后执行任务的代码在发送通知的线程中执行（下面示例代码验证）。 第二种方式是提供了一个以block方式实现的添加观察者的方法。大家第一次看到这个方法时是否会有这样的疑问：观察者呢？参数中并没有指定具体的观察者，那谁是观察者呢？需要移除吗？ 实际上，与前一个方法不同的是，前者使用一个现存的对象作为观察者，而这个方法会创建一个匿名的对象作为观察者(即方法返回的id&lt;NSObject&gt;对象)，这个匿名对象会在指定的队列(queue)上去执行我们的block。 第二种注册方式注意点： 1、参数queue 决定block在哪个线程执行，即我们指定了操作队列。如果queue为nil，则消息是默认在post线程中同步处理，即 观察者接收到通知后执行任务的代码在发送通知的线程中执行（下面示例代码验证）。 2、block块会被通知中心拷贝一份(执行copy操作)，以在堆中维护一个block对象，直到观察者被从通知中心中移除。所以，应该特别注意在block中使用外部对象，避免出现对象的循环引用。 3、如果一个给定的通知触发了多个观察者的block操作，则这些操作会在各自的Operation Queue中被并发执行。所以我们 不能去假设操作的执行会按照添加观察者的顺序来执行。 4、该方法会返回一个表示观察者的对象，记得在不用时移除这个对象。 第2点示例，由于使用的是block，所以需要注意的就是避免引起循环引用的问题： 123456789101112131415161718192021222324252627282930313233343536373839404142@interface Observer : NSObject@property (nonatomic, assign) NSInteger i;@property (nonatomic, weak) id&lt;NSObject&gt; observer;@end @implementation Observer- (instancetype)init &#123; self = [super init]; if (self) &#123; NSLog(@"Init Observer"); // 添加观察者 _observer = [[NSNotificationCenter defaultCenter] addObserverForName:TEST_NOTIFICATION object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *note) &#123; NSLog(@"handle notification"); // 使用self self.i = 10; &#125;]; &#125; return self;&#125;@end #pragma mark - ViewController@implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; [self createObserver]; // 发送消息 [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];&#125;- (void)createObserver &#123; Observer *observer = [[Observer alloc] init];&#125;@end//--------------------------- &lt;#我是分割线#&gt; ------------------------------//// 打印输出Init Observerhandle notification 我们可以看到createObserver中创建的observer并没有被释放。所以，使用addObserverForName:object:queue:usingBlock:一定要注意这个问题。 2、发送通知发送通知可使用以下方法123- (void)postNotification:(NSNotification *)notification;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo; 总结： 三种方式都是发送NSNotification对象给通知中心注册的所有观察者。 发送通知通过name和object来确定来标识观察者，name和object两个参数的规则相同即当通知设置name为kChangeNotifition时，那么只会发送给符合name为kChangeNotifition的观察者，同理object指发送给某个特定对象通知，如果只设置了name，那么只有对应名称的通知会触发。如果同时设置name和object参数时就必须同时符合这两个条件的观察者才能接收到通知。 3、移除观察者（移除监听）在对象被释放前需要移除掉观察者，避免已经被释放的对象还接收到通知导致崩溃。移除观察者有两种方式： 12- (void)removeObserver:(id)observer;- (void)removeObserver:(id)observer name:(nullable NSNotificationName)aName object:(nullable id)anObject; 总结： 传入相应的需要移除的observer 或者使用第二种方式三个参数来移除指定某个观察者。 如果使用基于-[NSNotificationCenter addObserverForName:object:queue:usingBlock:]方法在获取方法返回的观察者进行释放。基于这个方法我们还可以让观察者接到通知后只执行一次： 1234__block __weak id&lt;NSObject&gt; observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"note" object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) &#123; NSLog(@"%@",[NSThread currentThread]);&#125;]; 通知的发送与处理是同步的，在某个地方post一个消息时，会等到所有观察者对象执行完处理操作后，才回到post的地方，继续执行后面的代码。 123456789101112131415161718192021222324- (void)viewDidLoad &#123; [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(reciveNote1) name:@"note" object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(reciveNote2) name:@"note" object:nil]; [[NSNotificationCenter defaultCenter] postNotificationName:@"note" object:nil]; NSLog(@"continue");&#125;- (void)reciveNote1 &#123; NSLog(@"接收到通知--reciveNote1"); &#125;- (void)reciveNote2 &#123; NSLog(@"接收到通知--reciveNote2"); &#125;//--------------------------- &lt;#我是分割线#&gt; ------------------------------////打印输出2016-03-28 15:33:48.423 03-通知补充[8711:298506] 接收到通知--reciveNote12016-03-28 15:33:48.423 03-通知补充[8711:298506] 接收到通知--reciveNote22016-03-28 15:33:48.423 03-通知补充[8711:298506] continue NSNotificationQueue 我们还是主动看官网的说明。 NSNotificationQueue 概念上图简单点释义就是NSNotificationQueue 通知队列，更像是通知中心的缓冲区，用来管理多个通知的调用。通知队列通常以先进先出（FIFO）顺序管理通知。当一个通知上升到队列的前面时，队列就将它发送给通知中心(NSNotificationCenter)，通知中心随后将它派发给所有注册为观察者的对象。。 NSNotificationQueue.h 系统文件看完官网，接下来当然是看系统文件了。你说是吧！ 创建通知队列方法 12// 创建通知队列方法- (instancetype)initWithNotificationCenter:(NSNotificationCenter *)notificationCenter NS_DESIGNATED_INITIALIZER; 往队列加入通知方法(异步) 123// 往队列加入通知方法- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle;- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle coalesceMask:(NSNotificationCoalescing)coalesceMask forModes:(nullable NSArray&lt;NSRunLoopMode&gt; *)modes; 移除队列中的通知方法 12// 移除队列中的通知方法- (void)dequeueNotificationsMatching:(NSNotification *)notification coalesceMask:(NSUInteger)coalesceMask; 发送方式 12345678910// NSPostingStyle包括三种类型typedef NS_ENUM(NSUInteger, NSPostingStyle) &#123; NSPostWhenIdle = 1, NSPostASAP = 2, NSPostNow = 3&#125;;注解：NSPostWhenIdle：空闲发送通知 当运行循环处于等待或空闲状态时，发送通知，对于不重要的通知可以使用。NSPostASAP：尽快发送通知 当前运行循环迭代完成时，通知将会被发送，有点类似没有延迟的定时器。NSPostNow ：同步发送通知 如果不使用合并通知 和postNotification:一样是同步通知。 合并通知 通过合并我们可以用来保证相同的通知只被发送一次。 forModes:(nullable NSArray&lt;NSRunLoopMode&gt; *)modes可以使用不同的NSRunLoopMode配合来发送通知，可以看出实际上NSNotificationQueue与RunLoop的机制以及运行循环有关系，通过NSNotificationQueue队列来发送的通知和关联的RunLoop运行机制来进行的。 12345678910// NSNotificationCoalescing也包括三种类型typedef NS_OPTIONS(NSUInteger, NSNotificationCoalescing) &#123; NSNotificationNoCoalescing = 0, NSNotificationCoalescingOnName = 1, NSNotificationCoalescingOnSender = 2&#125;;注解：NSNotificationNoCoalescing：不合并通知。NSNotificationCoalescingOnName：合并相同名称的通知。NSNotificationCoalescingOnSender：合并相同通知和同一对象的通知。 NSNotificatinonCenter 实现原理 NSNotificatinonCenter是使用观察者模式来实现的用于跨层传递消息，用来降低耦合度。 NSNotificatinonCenter用来管理通知，将观察者注册到NSNotificatinonCenter的通知调度表中，然后发送通知时利用标识符name和object识别出调度表中的观察者，然后调用相应的观察者的方法，即传递消息（在Objective-C中对象调用方法，就是传递消息，消息有name或者selector，可以接受参数，而且可能有返回值），如果是基于block创建的通知就调用NSNotification的block。 NSNotificatinonCenter 实战使用 基本使用第一种注册观察者的方式： 1234567891011121314151617181920212223- (void)viewDidLoad &#123; [super viewDidLoad]; // 1.注册观察者（添加监听） [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(reciveNote1) name:@"note" object:nil]; // 2.发送通知 [[NSNotificationCenter defaultCenter] postNotificationName:@"note" object:nil];&#125;// 一个对象即将销毁就会调用- (void)dealloc &#123; // 3.移除通知 [[NSNotificationCenter defaultCenter] removeObserver:self];&#125;// 观察者接收到通知后执行任务的代码- (void)reciveNote1 &#123; NSLog(@"接收到通知--reciveNote1"); &#125;打印输出：2016-03-28 16:57:45.320 03-通知补充[10343:376649] 接收到通知--reciveNote1 第二种注册观察者的方式： 123456789@property (nonatomic, weak) id observe;// 1.注册观察者（添加监听）_observe = [[NSNotificationCenter defaultCenter] addObserverForName:@"note" object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) &#123; NSLog(@"我是block方式注册观察者");&#125;]; // 2.发送通知[[NSNotificationCenter defaultCenter] postNotificationName:@"note" object:nil]; 总结：这个方法的优点在于添加观察者的操作与回调处理操作的代码更加紧凑，不需要拼命滚动鼠标就能直接找到处理代码，简单直观。个人比较喜欢。 通知在多线程中使用注册观察者两种方式，在多线程中的使用和注意点，以下 会分别说明。 第一种注册观察者方式，以下代码我们将验证这个结论：接收通知代码 由 发出通知线程决定，即观察者接收到通知后执行任务的代码在发送通知的线程中执行 123456789101112131415161718// 1.注册观察者（添加监听）[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(reciveNote1) name:@"note" object:nil];// 2.发送通知（主线程）[[NSNotificationCenter defaultCenter] postNotificationName:@"note" object:nil];// 发送通知（异步线程）dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:@"note" object:nil];&#125;);//--------------------------- &lt;#我是分割线#&gt; ------------------------------////// 接收到通知执行代码- (void)reciveNote1 &#123; NSLog(@"%@",[NSThread currentThread]); NSLog(@"接收到通知--reciveNote1"); &#125; 1234567发送通知（异步线程）打印输出：2016-03-28 17:21:36.122 03-通知补充[10818:402396] &lt;NSThread: 0x600000267cc0&gt;&#123;number = 3, name = (null)&#125;2016-03-28 17:21:36.122 03-通知补充[10818:402396] 接收到通知--reciveNote1发送通知（主线程）打印输出：2016-03-28 17:23:42.705 03-通知补充[10868:404679] &lt;NSThread: 0x60800007a6c0&gt;&#123;number = 1, name = main&#125;2016-03-28 17:23:42.705 03-通知补充[10868:404679] 接收到通知--reciveNote1 第二种注册观察者方式，以下代码我们将验证这个结论：接收通知代码 由 发出通知线程决定，即观察者接收到通知后执行任务的代码在发送通知的线程中执行（指定操作队列除外） 1234567891011121314151617// 指定操作队列 [NSOperationQueue mainQueue] // _observe = [[NSNotificationCenter defaultCenter] addObserverForName:@"note" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123;// 1.注册观察者（添加监听）_observe = [[NSNotificationCenter defaultCenter] addObserverForName:@"note" object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) &#123; // 只要监听到通知 就会调用 NSLog(@"%@",[NSThread currentThread]); NSLog(@"我是block方式注册观察者");&#125;];// 2.发送通知（主线程）[[NSNotificationCenter defaultCenter] postNotificationName:@"note" object:nil];// 发送通知（异步线程）dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:@"note" object:nil];&#125;); 1234567891011发送通知（主线程）打印输出：2016-03-28 18:17:08.587 03-通知补充[11305:421194] &lt;NSThread: 0x608000072940&gt;&#123;number = 1, name = main&#125;2016-03-28 18:17:08.587 03-通知补充[11305:421194] 我是block方式注册观察者发送通知（异步线程）打印输出：2016-03-28 18:24:56.248 03-通知补充[11503:431482] &lt;NSThread: 0x60000007ec40&gt;&#123;number = 3, name = (null)&#125;2016-03-28 18:24:56.248 03-通知补充[11503:431482] 我是block方式注册观察者注册观察者,指定操作队列（不管发送通知在那个线程都按指定操作队列执行）2016-03-28 18:27:04.567 03-通知补充[11555:433722] &lt;NSThread: 0x600000073e40&gt;&#123;number = 1, name = main&#125;2016-03-28 18:27:04.567 03-通知补充[11555:433722] 我是block方式注册观察者 通知在多线程中注意点开发中使用场景，第一种方式，一般在接收通知执行代码中，做一下处理： 123456789- (void)reciveNote1&#123; // 更新UI dispatch_sync(dispatch_get_main_queue(), ^&#123; // 更新UI NSLog(@"%@",[NSThread currentThread]); &#125;);&#125; 第二种方式，一般在接收通知执行代码中，做一下处理： 1234567// 一般不要写nil ,更新UI指定主队列_observe = [[NSNotificationCenter defaultCenter] addObserverForName:@"note" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123; // 更新UI NSLog(@"%@",[NSThread currentThread]);&#125;]; 总结 在我们的应用程序中，两个对象之间如何通信。根据具体应用场景优先选择哪一种通信方式。对象之间的通信方式主要有以下几种： 直接方法调用 Target-Action事件 Delegate代理 block回调 KVO监听 NSNotification通知 优先选择哪一种通信方式： 通信对象是一对一的还是一对多的对象之间的耦合度. 建议： 1.在需要的地方使用通知，要求: 必须得保证通知的名称在监听和发出时是一致的。 2.注册的观察者在不使用时一定要记得移除，即添加和移除要配对出现。 3.尽可能迟地去注册一个观察者，并尽可能早将其移除，这样可以改善程序的性能。因为，每post一个通知，都会是遍历通知中心的分发表，确保通知发给每一个观察者。 4.记住通知的发送和处理是在同一个线程中。 5.使用-addObserverForName:object:queue:usingBlock:务必处理好内存问题，避免出现循环引用。 6.NSNotificationCenter是线程安全的，但并不意味着在多线程环境中不需要关注线程安全问题。不恰当的使用仍然会引发线程问题。 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 模式详解—「KVC编码 & KVO监听」]]></title>
    <url>%2FiOSUI%2FKVCKVO.html</url>
    <content type="text"><![CDATA[Write in the first【写在最前】 开发过程中，最常见的就是程序的流程取决于你所使用的各种变量和属性的值，根据变量和属性的值确定后面运行的代码。学好「获取类中属性的变化」这一模块是开发重要部分之一，目地：为了解决在开发过程中，由需求改变引发的各种蛋疼、繁琐的问题。 本篇文章主要从【KVC &amp; KVO 使用场景相关】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： 引导 KVC 概论 KVC 常用方法 KVC 对多种数据类型的支持 KVC 实现原理 KVC 基本使用1.KVC 简单赋值 &amp; 取值2.KVC 访问私有成员变量3.KVC 字典转模型 KVO 概论 KVO 使用步骤 KVO 实现原理 KVO 手动发送通知机制 引导 我们有多种方式获取对象的改变。例如，使用委托、通知获取值的改变。如果需要观察多个属性的变化，使用委托或通知会产生大量代码，一个更好用来观察属性变化的方法是使用 键值监听（Key Value Observing，简称KVO），Apple 在自己的软件中大量使用 KVO。使用 KVO 跟踪单个属性或集合（如数组）的变化非常高效，键值观察建立在 键值编码（Key Value Coding，简称KVC） 基础上，也就是任何你想使用 KVO 监听的属性必须符合键值编码。KVO 只需要在观察者方法中添加代码，不需要修改被观察文件内代码，这一点和委托、通知不同。 KVC 和 KVO 提供了一个强大高效的方式来编写代码，学习 KVO 前必须先掌握 KVC，所以 我们按实用开发技巧一点点剖析它。 KVC 概论 KVC（全称 key-value-coding）即键值编码。KVC 的操作方法由NSKeyValueCoding 非正式协议提供，而NSObject(NSKeyValueCoding)就实现了这个协议，也就是说ObjC中几乎所有的对象都支持 KVC 操作，它是一种不通过存取方法（Setter、Getter），而通过属性名称字符串（key）间接访问类属性(实例变量)的机制。 KVC 常用方法 KVC 常用的方法如下： 赋值 123456- (void)setValue:(nullable id)value forKey:(NSString *)key;- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;// 注解:setValue:(属性值) forKey:(属性名),（用于简单属性）。setValue:(属性值) forKeyPath:(属性名),（用于复合属性，进行内部的点语法，层层访问内部的属性; 例如student.name，Student学生模型类中的name属性。 获取值 123456- (id)valueForKey:(NSString *)key;- (nullable id)valueForKeyPath:(NSString *)keyPath;// 注解:valueForKey:属性名valueForKeyPath:属性名(用于复合属性） KVC 对多种数据类型的支持 首先要说的是对于基本数据类型的属性，KVC 的这几个方法会自动装箱和拆箱。其次，KVC 也支持数组和字典等集合数据。这里了解不多，不做过多总结，有兴趣可参考：KVC/KVO原理详解及编程指南 简单示例：KVC 自动类型转换如：模型类定义的属性是 float money123456@property (nonatomic, assign) float money;// KVC 赋值[person setValue:@"18" forKeyPath:@"money"];[person setValue:[NSNumber numberWithInteger:18] forKeyPath:@"money"];打印输出会自动转换成 float 类型 18.00; KVC 实现原理 1、[item setValue:@&quot;白开水ln简书&quot; forKey:@&quot;name&quot;]; 1.首先去模型中查找有没有 setName，若有，直接调用赋值 [self setName:@&quot;白开水ln简书&quot;]。 2.若无，去模型中查找有没有 name 属性，若有，直接访问属性赋值 name = value。 3.若无，再去模型中查找有没有 _name 成员变量，若有，直接访问属性赋值 _name = value。 4.找不到，就会直接报找不到的错误（valueForUndefinedKey:）。 2、[item setValuesForKeysWithDictionary:dict]; 1.遍历字典中所有 key。 2.去模型中查找有没有对应的属性。 1234[dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull value, BOOL * _Nonnull stop) &#123; // 2.去模型中查找有没有对应属性 KVC [item setValue:value forKey:key];&#125;]; KVC 基本使用 KVC 简单赋值 &amp; 取值123456LNPerson *person = [[LNPerson alloc] init]; person.dog = [[LNDog alloc] init]; [person.dog setValue:@"阿黄" forKey:@"name"];[person setValue:@"旺财" forKeyPath:@"dog.name"];NSLog(@"%@", person.dog.name); 区别：forKey: 和 forKeyPath:1、forKeyPath 包含了所有 forKey 的功能2、forKeyPath 进行内部的点语法,层层访问内部的属性3、注意：key 值一定要在属性中找到，开发中最好使用forKeyPath。 KVC 取值12345[person valueForKeyPath:@"name"]// 取出数组中所有模型的某个属性值NSArray *allPersons = @[person1, person2, person3];NSArray *allPersonName = [allPersons valueForKeyPath:@"name"]; KVC 访问私有成员变量1234567@implementation LNPerson&#123; int _age; &#125;LNPerson *person = [[LNPerson alloc] init];[person setValue:@"88" forKeyPath:@"age"]; 注意：上面的 keyPath 写age 或 _age都可以，KVC 会自动去查找。 KVC 字典转模型简单示例：12345678910111213141516171819202122NSDictionary *dict = @&#123; @"name" :@"lurry", @"money" : @189.88, //@"development" : @"iOS"--&gt;问题1模型的属性和字典不能一一对应 /* @"dog" : @&#123; @"name" : @"wangcai", @"price" : @8 &#125;, */ //--&gt;问题2模型中嵌套模型 &#125;;LNPerson *person = [[LNPerson alloc] init];[person setValuesForKeysWithDictionary:dict];// 等同于下面的代码// setValuesForKeysWithDictionary: 原理:// 1.遍历字典中所有key,去模型中查找有没有对应的属性[dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull value, BOOL * _Nonnull stop) &#123; // 2.去模型中查找有没有对应属性 KVC [item setValue:value forKey:key]; &#125;];NSLog(@"%@", person); 开发中不建议使用 setValuesForKeysWithDictionary:（把字典中所有值给模型的属性赋值） 问题1：如果服务器多返回几个数据 Key，在模型中系统找不到就会报错。 1reason: '[&lt;LNPerson 0x100304730&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key nam. 解决：重写系统方法 setValue:forUndefinedKey:，就不会有报错信息了。补充：什么时候重写系统方法?1、想给系统方法添加额外功能 2、不想要系统方法实现 问题2：如果模型中带有模型型，setValuesForKeysWithDictionary 不能用。解决：思路，拿到每一个模型属性，去字典中取出对应的值，给模型赋值（提醒：从字典中取值,不一定要全部取出来）。建议使用：MJExtension 字典转模型 和 Runtime（根据模型中属性，去字典中取出对应的 value 给模型属性赋值） 模型转成字典 1NSDictionary *dict = [person dictionaryWithValuesForKeys:@[@"name", @"money"]]; KVO 概论 KVO（Key-Value-Obersver）即键值监听，利用一个key来找到某个属性并监听其属性值得改变，当该属性发生变化时，会自动的通知观察者，这比通知中心需要post通知来说，简单了许多。其实这也是一种典型的观察者模式。 KVO 使用步骤 给目标对象的属性添加观察者 在回调方法中监听属性的变化 移除观察者 具体代码如下：1234567891011121314151617181920212223242526272829303132- (void)viewDidLoad &#123; [super viewDidLoad]; self.person = [[LNPerson alloc] init]; person.name = @"zs"; /* - Observer 观察者 - KeyPath 要监听的属性 - options 选项(可选属性值，示例：旧值和新值) */ // 1.添加观察者 [self.person addObserver:self forKeyPath:@"name" options: NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:nil]; person.name = @"ls";// 这里重新赋值 person.name = @"ww";&#125;- (void)dealloc&#123; // 2.移除观察者 [self.person removeObserver:self forKeyPath:@"name"];&#125;/** * 当监听的属性值发生改变 * @param keyPath 要监听的属性 * @param object 要监听的属性所属的对象 * @param change 改变的内容 * @param context 上下文 */#pragma mark - KVO// 3.监听属性的变化- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(LNPerson *)person change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123; NSLog(@"%@------%@------%@", keyPath, change);&#125; KVO 实现原理 当一个类的属性被观察的时候，系统会通过runtime动态的创建一个该类的派生类，并且会在这个类中重写基类被观察的属性的setter方法，而且系统将这个类的isa指针指向了派生类，从而实现了给监听的属性赋值时调用的是派生类的setter方法。重写的setter方法会在调用原setter方法前后，通知观察对象值得改变。此外，派生类还重写了 dealloc 方法来释放资源。 可以看到重写的 setter 方法，给属性赋值的前后分别调用了两个方法。12- (void)willChangeValueForKey:(NSString *)key;- (void)didChangeValueForKey:(NSString *)key; 而- (void)didChangeValueForKey:(NSString *)key;会调用1- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSString*, id&gt; *)change context:(nullable void *)context; KVO 手动发送通知机制 默认情况下，KVO 观察到属性变化系统会自动发送通知，但在某些情况下，你可能需要控制何时发送通知。例如：在某些情况下不需要发送通知，或将多个改变合并为一个通知发送。其实我们也可以手动，显式的调用上面两个方法，以使其具有通知机制。举个示例：1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; self.person = [[LNPerson alloc] init]; person.name = @"zs"; // 1.添加观察者 [self.person addObserver:self forKeyPath:@"name" options: NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:nil]; [self willChangeValueForKey:@"name"]; person.name = @"this is a test"; // 直接修改成员变量的值，手动的调用上下两个方法，使其就有通知机制 [self didChangeValueForKey:@"name"];&#125;- (void)dealloc&#123; // 2.移除观察者 [self.person removeObserver:self forKeyPath:@"name"];&#125;#pragma mark - KVO// 3.监听属性的变化- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(LNPerson *)person change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123; if(object == self &amp;&amp; [keyPath isEqualToString:@"name"]) &#123; NSLog(@"%@------%@------%@", keyPath, change); &#125; else &#123; [super observeValueForKeyPath:keyPath ofObject: person change:change context:context]; &#125;&#125; 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown—写作便捷高效]]></title>
    <url>%2FToolsAndPlugins%2FMarkdown.html</url>
    <content type="text"><![CDATA[Markdown 认知Markdown Markdown 是什么? Markdown 是一种用来写作的「轻量级标记语言」，创始人为约翰·格鲁伯（John Gruber）。它允许人们「使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档 」—— 维基百科 如果你看不懂以上维基百科对 Markdown 的定义，就当这段掐了没播。约翰·格鲁伯自己对Markdown的描述的重点也在于 「easy-to-read，easy-to-write」。 那么到底 easy 在哪里呢 虽然称作 「标记语言」，但简单理解 Markdown 就是在文本前增加符号来表示文本格式。它用简洁的「标记」语法代替排版，而不像一般我们用的处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专注于内容的编写， 不仅支持文字排版，还支持 插入图片(包括gif)、 链接 等。而这些操作只用键盘就可以通通搞定了。目前也被越来越多的写作爱好者广泛使用，支持 Markdown 语法的编辑器有很多，包括很多网站（如简书）都支持 Markdown 语法的录入。Markdown 从写作到完成，内容「易读易写」，导出格式「随心所欲」，你可以导出 HTML 格式的文件用来网站发布，也可以导出 PDF 格式打印浏览。对求职者来说，Markdown 写出的简历更能得到 HR 的好感。 无图无真相： 使用 Markdown 的优点 1. 编辑，不用操心排版 你只需要把注意力放在内容上。笔者在用 Markdown 之前，打开word 先想想，标题用啥字体呢，几号字呢？不知不觉我的意志力就被消耗了。实际上所谓排版，不就是作者的思路以及内容的层级和结构么，在学会使用 Markdown 之后，几个简单的符号就把这些事儿搞定，样式还特别工整精美。2. 修改，不用担心排版 想想那些你汗洒的 word 文档吧，如果童鞋你从外部粘贴了一段带格式的文字，粘贴后发现整个人都不好了：格式被改的乱七八糟，还要重新调整。如果用 Markdown 编写 ，想改哪里改哪里，根本不用担心格式，改完发布收工，多轻松！3. 导出，不用费心格式 可以导出为 PDF、 HTML 以及.md 本身的格式文件，不管在什么设备上，看起来都是一个工整的样子。 一句话来说，Markdown 是用最简单的方式，零排版成本，写出布局工整、阅读舒适的笔记。减少干扰，降低成本，提高效率，不仅自己阅读爽，分享给朋友也有面儿不是~ P.S : Markdown 中文版语法说明 如何创建 Markdown 笔记 不管我再怎么说 Markdown 的语法记忆负担小、简单，在最初你都会有点儿晕。在这里给大家分享个小技巧： 最初只需要记住 # 标题一、## 标题二、1. 第一点、* 这一点，用这几个写写日志、需求文档、小文章，排版上足够了； 逐渐的你发现有些文字需要重点指出，那么还可以使用 **加粗**、*斜体* 来对文字做重点说明； 如果你是名程序员，那么可以用 ` 把代码块包起来，渲染后可以关键字高亮；123456789101112131415161718194. 学生的话，你可以用 &gt; 做引用&gt; 书是人类进步的阶梯，终生的伴侣，最诚挚的朋友。——高尔基#### Markdown 标记符号简要规范**下文仅是我以自己的方式阐述这些语法的具体用法，供参考****1. 标题**在行首插入 1 到 6个 `#`，分别表示标题 1 到标题 6![标题](http://oiizs6l0g.bkt.clouddn.com/Markdown活学活用3.png)**2. 有序列表 / 无序列表**在行首增加 `1.`、`2.`、`3.`，即数字和英文句点, 不要求数字一定要连续，可以都是`1.`在行首增加 `*` 或 `-`![有、无序列表](http://oiizs6l0g.bkt.clouddn.com/Markdown活学活用2.png)**3. 文本样式**![粗体、斜体、删除线](http://oiizs6l0g.bkt.clouddn.com/Markdown活学活用4.png)**4. 分割线** 123456789-------------************______________**5. 引用**如果你需要引用一小段别处的句子，你可以用 `&gt; 这里是引用的话`&gt; 书是人类进步的阶梯，终生的伴侣，最诚挚的朋友。——高尔基并支持 **多级引用** 使用多个 右尖括号 `&gt;`，表示多级引用。 这里是一级引用内容 这里是二级引用内容 这里是三级引用内容12345678&gt; 这里是一级引用内容&gt; &gt; 这里是二级引用内容&gt; &gt; &gt; 这里是三级引用内容**6. 行内代码块 和 代码框**如果你是个程序猿，需要在文章里优雅的引用代码框，只需在代码前后增加 三个反单引号：` ``` `， 如果需要在行内添加代码块，使用 `代码` 表示行内代码块；让我们聊聊 `iOS攻城狮` int main(int argc, char * argv[]) {@autoreleasepool {return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));}}12345678910111213141516171819202122**7. 插入图片 和 链接** 插入图片格式： `![本地图片](http://cdn.wiz.cn/wp-content/uploads/custompbwaters.github.io)` 插入链接格式：` [链接显示说明](网址)` &gt; P.S : 这里的图片可以是本地图片，也可以是 网络图片。 ![](http://upload-images.jianshu.io/upload_images/2230763-05939fa7a5df62c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ![本地图片](http://upload-images.jianshu.io/upload_images/2230763-cdd0fc1a085fcbdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![](http://upload-images.jianshu.io/upload_images/2230763-a00835b06e5ec64c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![网络图片](http://upload-images.jianshu.io/upload_images/2230763-2fd3aceb036ac541.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)插入链接：`[简书](http://jianshu.io)` ---&gt; [简书](http://jianshu.io) **8. 插入表格**插入表格使用以下语法: ` | 列名 | ` ` |:-:| ` 水平排列模式**意思为**：`| :- |` 居左， `| :-: |` 居中, `| -: | ` 居右样式一： 表格1 表格2 表格3 居左 居中 居右 12345| 表格1 |表格2 | 表格3 ||:--- |:-:|---:|| 居左 | 居中 | 居右|样式二： | 表格1 |表格2 | 表格3||-|-|-| P.S: 中间几个减号都可以| 居左 | 居中 | 居右 || 居左 | 居中 | 居右 |12345678| 表格1 |表格2 | 表格3 ||-|-|-|| 居左 | 居中 | 居右|| 居左 | 居中 | 居右|**P.S : 注脚**使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。这是第二个注脚[^footnote2]的样例。 [^footnote]: 这是一个 注脚 的 文本。[^footnote2]: 这是另一个 注脚 的 文本。P.S:[^这里面可以任一写]```这是一个注脚1的样例。这是第二个注脚2的样例 这是一个 注脚1 的 文本。 ↩这是另一个 注脚2 的 文本。 ↩ 9. 目录在任何你想要展示Markdown 笔记目录的地方，添加 [TOC] ， 在阅读模式下，标题1~6样式的内容会被提取出来作为目录，相当于大纲功能。例如： 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>工具&amp;插件</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>工具&amp;插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 管理库工具CocoaPods「安装+问题解决+活用」续更]]></title>
    <url>%2FToolsAndPlugins%2FCocoaPods.html</url>
    <content type="text"><![CDATA[Write in the first 在开发 OS X 和 iOS 应用程序中，CocoaPods 作为库依赖管理工具就是一把利器。 相信很多开发者跟我当初一样，在 CocoaPods 的安装上踩了无数的坑，接着就是报错问题一个一个的来，以至于不能正常使用，更不用说活用的技巧了。作为【iOS 程序员】的我们，掌握CocoaPods 的使用是必不可少的基本技能了。 在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量@jianshu - 白开水ln。 目录： CocoaPods 相关介绍 CocoaPods 安装 开始使用 安装过程中报错问题解决 指令补充 CocoaPods 均可参考的资料 Contents【相关介绍】 1. CocoaPods 是什么? CocoaPods 是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具。利用 CocoaPods，可以定义自己的依赖关系 (称作 pods)，并且随着时间的变化，以 及在整个开发环境中对第三方库的版本管理非常方便。 2. CocoaPods 背后的理念主要体现在两个方面 在工程中引入第三方代码 会涉及到许多内容。针对 Objective-C 初级开发者来说，工程文件的配置会让 人很沮丧。 在配置 build phases 和 linker flags 过程中，会引起许多人为因素的 错误，CocoaPods 简化了这一切，它能够自动配置编译选项，而且涉及到第三方库的更新升级也可以通过 CocoaPods 进行手动管理更新。 3. CocoaPods 的原理 它是将所有的依赖库都放到另一个名为 Pods 项目中，然后 让主项目依赖 Pods 项目，这样，源码管理工作都从主项目移到了Pods项目中。 Pods项目最终会编译成一个名为 libPods.a 的文件，主项目只需要依赖这个.a 文件即可。 对于资源文件，CocoaPods 提供了一个名为 Pods-resources.sh 的 bash 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目 标目录中。 CocoaPods 通过一个名为 Pods.xcconfig 的文件来在编译时设置所有的依赖 和 参数。 CocoaPods 是用 ruby 实现的，要想使用它首先需要有 ruby 的环境。幸运的是 OS X系统 默认已经可以运行 ruby 了。但是有时候 ruby 版本过低是无法正常支持 CocoaPods 的使用，所以需要先安装更新升级 rvm 和 ruby。 3. Homebrew、Rvm、Ruby 简介 官网及相关链接【Rvm 官网】:https://www.rvm.io/【Ruby 官网】:https://rubygems.org/【Rvm 安装指南】:https://rvm.io/rvm/install【Homebrew 官网】:http://brew.sh/index_zh-cn.html【ruby 镜像 - taobao】:https://ruby.taobao.org/【ruby 镜像 - china】:https://gems.ruby-china.org/ Homebrew 介绍Homebrew 是一个软件包管理器，用于在mac上安装一些os x上没有的UNiX工具；类似于360软件管理器。 Rvm 介绍Rvm 全称 Ruby Version Manager ，是安装和管理 ruby 的一种工具。 摘录：RVM is a command-line tool which allows you to easily install,manage, and work with multiple ruby environments from interpreters to sets of gems. Ruby 介绍Ruby 是一种面向对象的脚本语言，简单易用，功能强大。能跨平台和可移植性好等等。其实就是种脚本语言。Ruby 的软件源使用的是亚马逊的云服务，国内网络环境下载时可能会出现各种不稳定和超时，所以自带的需要翻墙，可以将 官方 ruby 源 替换成国内 淘宝 ruby 源（https://ruby.taobao.org/ ）或者是由 China ruby 源 （https://gems.ruby-china.org/ ）。据消息了解，2016.06【taboo Gems】停止维护了，建议使用 【ruby-china】源。 Installation【CocoaPods 安装】 第一步：检查安装 rvm 环境提示：不管需不需要升级 ruby，rvm 可以让你拥有多个版本的Ruby，并且可以在多个版本之间自由切换。如果已经安装过跳到第2步。12345678910查看是否安装$ rvm -v 输出结果:（ 存在 rvm 环境）LNdeMacBook-Pro:~ sunhui$ rvm -vrvm 1.29.1 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io/]输出结果:（不存在 rvm 环境）LNdeMacBook-Pro:~ sunhui$ rvm -v-bash: rvm: command not found 1234567891011情况二：如果不存在 rvm 环境，先安装配置 rvm 环境① 指令安装 rvm$ curl -L get.rvm.io | bash -s stable② 然后，载入 RVM 环境$ source ~/.bashrc$ source ~/.bash_profile③ 等待终端加载完毕，后输入$ rvm -v如果能显示版本号则安装成功了。 第二步：检查 ruby 版本环境提示：CocoaPods 目前安装需要Ruby的版本大于2.2.2，不然会报错：Error installing pods: activesupport requires Rubyversion &gt;= 2.2.2。目前Mac系统默认自带是2.0，所以需要升级。1234567891011121314151617181920212223① 查看已安装的ruby:$ ruby -v② 列出ruby可安装的版本信息rvm list known③ 指定 ruby 版本进行更新$ rvm install 2.3.0④ 这里一定要设置为默认版本rvm use 2.3.0 --default等待时间，完成后 Ruby Gems 就安装好了补充：1.卸载一个已安装版本$ rvm remove 1.9.22.检查 gem ruby 版本号$ sudo gem -v3.更新 gem ruby 版本号:（建议 升级到 2.6.x 以上）$ gem update --system 第三步：更换源我们需要来修改更换源（由于国内被墙）所以要把源切换至 ruby-china 在终端执行以下命令12345678910111213141516171.更新gem$ sudo gem update --system2.先移除现有的源$ gem sources --remove https://rubygems.org/如果安装了淘宝的镜像$ gem sources --remove https://ruby.taobao.org/ 3.使用新的源$ gem sources -a https://gems.ruby-china.org/4.验证新源是否替换成功$ gem sources -l只有在终端中出现下面文字才表明你上面的命令是成功的：*** CURRENT SOURCES ***说明 CocoaPods 前期配置完毕 第四步：安装Cocoapods提示：安装 CocoaPods（ sudo 表示管理员执行指令 ）（ 此处需要输入一次密码 ）这里有几种选择，你看心情来吧 ~ 选择一：123451.在终端输入以下命令：$ sudo gem install -n /usr/local/bin cocoapods$ pod setup这个过程会很慢，据说大多都是挂机一晚上才装好的，继续往下看吧，总有更好的。 选择二：1234561.执行：$ git clone https://git.coding.net/CocoaPods/Specs.git ~/.cocoapods/repos/master2.切记要：$ pod repo update感觉也就几分钟的样子， 先随便搜索一个第三方库，如：12$ pod search AFNetWorking有结果不报错说明已经安装成功了。 选择三：1234把你同事已经装好了CocoaPodscocoapods目录下的 repo 目录拷贝下来，放进自己的目录里。再 $ pod setup。 验证是否安装成功1234$ pod --version如果验证成功，显示版本号，如，0.39.0，说明可以安装全部完成.如果显示-bash: po: command not found，说明没有装好 Getting Started【开始使用】 第一步 ：我们先创建这个神奇的 PodFile。在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile123456789101.cd 到目录文件夹$ cd /Users/ln/Desktop/LNTestDemo2.提示如果不知道第三方库版本的情况下，建议先查找一下当前所需第三方库的最新版本，如：$ pod search &apos;AFNetworking&apos;3.创建 Podfile 配置文件$ vim Podfile 第二步 ：键盘输入 i ，进入 Podfile 配置文件的编辑模式Podfile 配置文件固定语句： 12345678910111213141516171819说明：可能有些人看到的固定语句不一样，但是大同小异，基本上都能实现最终效果。(~&gt; 可以指定对应版本，不指定默认为最新版本)# Uncomment this line to define a global platform for your projectplatform :ios, &apos;8.0&apos;target &apos;LNTestDemo&apos; do // 你的项目名称,自行替换# Uncomment this line if you&apos;re using Swift or would like to use dynamic frameworks# Pods for LNTestDemopod &apos;AFNetworking&apos;, &apos;~&gt;3.1.0&apos;pod &apos;SDWebImage&apos;pod &apos;MBProgressHUD&apos;pod &apos;FMDB&apos;pod &apos;Masonry&apos;pod &apos;MJExtension&apos;pod &apos;MJRefresh&apos;# use_frameworks!# pod &apos;ReactiveCocoa&apos;end 按一次 Esc 按键退出编辑模式12保存并退出:wq 这时候，你会发现你的项目目录中，出现一个名字为Podfile的文件，而且文件内容就是你刚刚输入的内容。注意，Podfile文件应该和你的工程文件.xcodeproj在同一个目录下。 现在，你就可以利用CocoPods下载AFNetworking等类库了。还是在终端中的当前项目目录下，运行以下命令：12下载第三方库文件到项目工程中$ pod install 注意： 1、以后打开项目就用 CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。否则无法关联pod下来的类库。 2、每次更改了Podfile文件,你需要重新执行一次pod update命令。 3、CocoaPods在执行pod install和pod update时，会默认先更新一次CocoPods的spec仓库索引。使用--no-repo-update参数可以禁止其做索引更新操作12$ pod install --no-repo-update$ pod update --no-repo-update 4、验证框架是否支持cocoaPods1$ pod search MJRefresh 提供：在线搜索验证在线，能搜出说明支持 https://cocoapods.org 5、cocoaPods 隐藏目录 前往—&gt;个人—&gt;.cocoapods .cocoapods/repos/master/Specs放着所有第三方库的索引文件，如下图 技巧：如果master/Specs下载不成功，试着，手动拷贝这个目录试试 6、【卸载 CocoaPods 安装】和【回退到指定 CocoaPods 版本】12345卸载 CocoaPods 安装$ sudo gem uninstall cocoa pods回退到指定 CocoaPods 版本$ sudo gem install -n /usr/local/bin cocoapods --version 0.39 7、查看 CocoaPods 下载进度还有一点需要注意，pod setup在执行时，会输出Setting up CocoaPods master repo，但是会等待比较久的时间。这步其实是 Cocoapods 在将它的信息下载到 ~/.cocoapods目录下，如果你等太久，可以试着 cd 到那个目录，用du -sh *来查看下载进度12执行语句$ sudo gem install -n /usr/local/bin cocoapods 8、在使用时，导入第三方库，应是&lt; &gt;12#import &lt;UIImageView+WebCache.h&gt;#import &lt;AFNetworking.h&gt; 9、使用pod install命令安装框架后的大致过程：1234567891.分析依赖:该步骤会分析Podfile,查看不同类库之间的依赖情况。如果有多个类库依赖于同一个类库，但是依赖于不同的版本，那么cocoaPods会自动设置一个兼容的版本。2.下载依赖:根据分析依赖的结果，下载指定版本的类库到本地项目中。3.生成Pods项目：创建一个Pods项目专门用来编译和管理第三方框架，CocoaPods会将所需的框架，库等内容添加到项目中，并且进行相应的配置。4.整合Pods项目：将Pods和项目整合到一个工作空间中，并且设置文件链接。 CocoaPods【安装过程中报错问题解决】说明：此部分所列举的问题均是在执行相关指令时出现的报错1、Rvm 环境搭建1234567891011121314151617181920211.报错指令：$ rvm install 2.3.02.报错问题：Error running &apos;requirements_osx_brew_update_system ruby-2.3.0&apos;,showing last 15 lines of /Users/jijiucheng/.rvm/log/1475769205_ruby-2.3.0/update_system.log............Requirements installation failed with status: 1.curl: (35) Server aborted the SSL handshake3.报错原因：网络问题，因为需要翻墙，所以网络不稳定；建议选择 VPN，保证线路的稳定性。4.问题解决：（指令一行一行输入）$ cd /usr/local$ git remote set-url origin git://mirrors.ustc.edu.cn/brew.git$ echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.bashrc5.解决方案： 解决方案连接：https://segmentfault.com/q/1010000004276750 1234567891011121314151.报错指令：$ rvm install 2.3.02.报错信息：Error running &apos;__rvm_make -j 1&apos;,showing last 15 lines of /Users/jijiucheng/.rvm/log/1475769349_ruby-2.3.0/make.log............There has been an error while running make. Halting the installation.3.报错原因：缺少 Xcode 工具，xcode command line4.问题解决：$ xcode-select --install 解决方案连接1：http://stackoverflow.com/questions/35228481/error-running-rvm-make-install解决方案连接2：http://www.th7.cn/Program/Ruby/201609/966343.shtml 12345678910111213141516171.报错指令：$ rvm install 2.3.02.报错信息：muxuguixiandeMacBook-Pro:local jijiucheng$ rvm install 2.3.0Already installed ruby-2.3.0.To reinstall use:.rvm reinstall ruby-2.3.0.Gemset &apos;&apos; does not exist, &apos;rvm ruby-2.3.0 do rvm gemset create &apos; first, or append &apos;--create&apos;.3.报错原因：指令不对，已经存在 ruby-2.3.0 的文件残留，需要重新安装；4.问题解决：$ rvm reinstall ruby-2.3.0 2、Ruby 环境搭建待总结 ~ ~欢迎你补充，我会及时加上，相互学习，我们的分享会让很多人少踩一些坑，少花费一点时间，学习到实用的知识。可下面留言~ 3、CocoaPods 配置使用1234567891011121314151617181920211.报错指令：$ pod install2.报错信息：muxuguixiandeMacBook-Pro:NFCustomer jijiucheng$ pod installSetting up CocoaPods master repo[!] Unable to add a source with url `https://github.com/CocoaPods/Specs.git` named `master`.You can try adding it manually in `~/.cocoapods/repos` or via `pod repo add`.3.报错原因：由于安装了多个Xcode导致路径变了，需要变换路径：sudo xcode-select -switch /Applications/Xcode.app sudo xcode-select -switch /Applications/Xcode\ 2.app4.问题解决：$ sudo xcode-select -switch /Applications/Xcode.app5.资料补充：出现 Setting up CocoaPods master repo，说明 Cocoapods 在将它的信息下载到 ~/.cocoapods 里；新创建终端窗口，输入 cd ~/.cocoapods ，回车，输入 du -sh * 命令来查看文件大小，每隔几分钟查看一次，这个目录最终大小是100多M（ 本人这里大概 800M + ），就是完成了。 解决方案连接1：https://zhidao.baidu.com/question/2205760733872673348.html解决方案连接2：http://blog.csdn.net/zhangjunjian127/article/details/47954981 instruction【指令补充】 1、Rvm 指令库12345678910111213$ ruby -v # 查看ruby 版本 $ rvm list known # 列出已知的 ruby 版本$ rvm install 2.3.0 # 选择指定 ruby 版本进行更新 $ rvm get stable # 更新 rvm$ rvm use 2.2.2 # 切换到指定 ruby 版本$ rvm use 2.2.2 --default # 设置指定 ruby 版本为默认版本 $ rvm list # 查询已安装的 ruby 版本 $ rvm remove 1.9.2 # 卸载移除 指定 ruby 版本$ curl -L https://get.rvm.io | bash -s stable # 安装 rvm 环境$ curl -sSL https://get.rvm.io | bash -s stable --ruby # 默认安装 rvm 最新版本$ curl -sSL https://get.rvm.io | bash -s stable --ruby=2.3.0 # 安装 rvm 指定版本$ source ~/.rvm/scripts/rvm # 载入 rvm 2、gem 指令库123456789101112131415161718192021222324252627282930313233343536373839$ gem -v # 查看 gem 版本$ gem source # 查看 gem 配置源$ gem source -l # 查看 gem 配置源目录$ gem sources -a url # 添加 gem 配置源（url 需换成网址）$ gem sources --add url # 添加 gem 配置源（url 需换成网址）$ gem sources -r url # 删除 gem 配置源（url 需换成网址）$ gem sources --remove url # 删除 gem 配置源（url 需换成网址）$ gem update # 更新 所有包$ gem update --system # 更新 Ruby Gems 软件$$ gem install rake # 安装 rake，从本地或远程服务器$ gem install rake --remote # 安装 rake，从远程服务器$ gem install watir -v 1.6.2 # 安装 指定版本的 watir$ gem install watir --version 1.6.2 # 安装 指定版本的 watir$ gem uninstall rake # 卸载 rake 包$ gem list d # 列出 本地以 d 打头的包$ gem query -n &apos;&apos;[0-9]&apos;&apos; --local # 查找 本地含有数字的包$ gem search log --both # 查找 从本地和远程服务器上查找含有 log 字符串的包$ gem search log --remoter # 查找 只从远程服务器上查找含有 log 字符串的包$ gem search -r log # 查找 只从远程服务器上查找含有log字符串的包$$ gem help # 提醒式的帮助$ gem help install # 列出 install 命令 帮助$ gem help examples # 列出 gem 命令使用一些例子$ gem build rake.gemspec # 把 rake.gemspec 编译成 rake.gem$ gem check -v pkg/rake-0.4.0.gem # 检测 rake 是否有效$ gem cleanup # 清除 所有包旧版本，保留最新版本$ gem contents rake # 显示 rake 包中所包含的文件$ gem dependency rails -v 0.10.1 # 列出 与 rails 相互依赖的包$ gem environment # 查看 gem 的环境$$ sudo gem -v # 查看 gem 版本（以管理员权限）$ sudo gem install cocoa pods # 安装 CocoaPods（以管理员权限）$ sudo gem install cocoapods # 安装 CocoaPods（以管理员权限）$ sudo gem install cocoapods --pre # 安装 CocoaPods 至预览版（以管理员权限）$ sudo gem install cocoapods -v 0.39.0 # 安装 CocoaPods 指定版本（以管理员权限）$ sudo gem update cocoapods # 更新 CocoaPods 至最新版（以管理员权限）$ sudo gem update cocoapods --pre # 更新 CocoaPods 至预览版（以管理员权限）$ sudo gem uninstall cocoapods -v 0.39.0 # 移除 CocoaPods 指定版本（以管理员权限） 3、pod 指令库123456$ pod setup # CocoaPods 将信息下载到~/.cocoapods/repos 目录下。如果安装 CocoaPods 时不执行此命令，在初次执行 pod intall 命令时，系统也会自动执行该指令$ pod --version # 检查 CocoaPods 是否安装成功及其版本号$ pod install # 安装 CocoaPods 的配置文件 Podfile CocoaPods 均可参考的资料 01 rvm、Ruby环境和CocoaPods安装使用及相关报错问题解决02 2017最新CocoaPods安装03 CocoaPods: pod search 搜索类库失败的解决办法04 整理Cocoapods安装05 cocoa pods安装报错06 新手安装CocoaPods07 安装cocoaPods以及在OSX10.11.5问题总结08 CocoaPods安装过程与问题解决09 Cocoapods 的安装和使用以及问题解决10 最新cocoapods步骤（主要针对Xcode8以上）11 创建CocoaPods的制作过程12 CocoaPods新版使用，遇到的那些坑！13 Write in the last 附上一张图： 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>工具&amp;插件</category>
      </categories>
      <tags>
        <tag>工具&amp;插件</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 核心动画—「CALayer图层」]]></title>
    <url>%2FiOSNET%2FCALayer.html</url>
    <content type="text"><![CDATA[本篇文章主要从【Core Animation 之 CALayer】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： UIView和CALayer的类定义 UIView和CALayer的区别和选择 CALayer的基本操作 CATransform3D CGAffineTransform 真正的高阶技巧 iOS Core Animation 1.UIView和CALayer的类定义1.CALayer的介绍CALayer 是定义在 QuartzCore 框架中，从下图可以看出UIView内部定义了一个CALayer对象，它是用来在屏幕上显示内容展示的矩形区域；CALayer是个与UIView很类似的概念，同样有backgroundColor、frame等相似的属性，我们可以将UIView看做一种特殊的CALayer。但实际上UIView是对CALayer封装，在CALayer的基础上再添加交互功能。UIView的显示必须依赖于CALayer。我们同样可以跟新建view一样新建一个layer，然后添加到某个已有的layer上，同样可以对layer调整大小、位置、透明度等。一layer可以有两种用途：一是对view相关属性的设置，包括圆角、阴影、边框等参数；二是实现对view的动画操控。因此对一个view进行动画，本质上是对该view的.layer进行动画操作； 2.UIView和CALayer的区别和选择UIView和CALayer区别1.在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，CALayer 在背后提供内容的绘制和显示；两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint(锚点)。 2.当UIView需要显示到屏幕上时（UIView 做为 Layer 的 CALayerDelegate，View 显示内容由CALayer 的 display），会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。换句话说，UIView本身不具备显示的功能，是因为它内部的图层（CALayer）才有显示功能 3.Layer 的 frame 是由它的 bounds、position、anchorPoint 和 transform 共同决定的；View 的 frame 只是简单的返回 Layer的 frame，同样 View 的 bounds 和 center 也是返回 Layer 的一些属性。 4.UIView 多了一个事件处理的功能,也就是说 UIView 可以处理用户的触摸事件,而 CALayer 不可以。 UIView和CALayer选择通过CALayer，也能做出和 UIImageView 一样的效果，相比较UIView多了一个事件处理的功能； 所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要进行交互，用UIView和CALayer都可以； 当然，CALayer 的性能会高一些，因为它少了事件处理的功能，更轻量级(实际开发中还是建议使用UIView,可扩展性强)； 2.CALayer的基本操作1.CALayer的常用属性 属性 描述 bounds 图层大小 position 图层中心点位置，相当于UIView的center opacity 透明度，相当于UIView的alpha anchorPoint 和中心position重合的点，称为锚点，范围在(0~1,0~1)，默是（0.5,0.5） contents image添加到layer的contents opacity 透明度，相当于UIView的alpha contentsRect 设置图片显示的尺寸，取值0~1(x0, y0, W1, H1)，如 CGRectMake(0, 0, 1, 0.5);只将图像的上半部分显示在整个layer中； CATransform3D 形变属性(设置平移、缩放和旋转时的 3D效果) cornerRadius / masksToBounds 圆角半径 / 属性为YES才显示圆角效果 2.创建自定义的CALayer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// layer基本使用- (void)layerWithUIView&#123; // 自定义图层 CALayer *layer = [CALayer layer]; layer.bounds = CGRectMake(0, 0, 100, 100); layer.contents = (id)[UIImage imageNamed:@"阿狸头像"].CGImage;? layer.backgroundColor = [UIColor redColor].CGColor;? layer.position = self.view.center; layer.anchorPoint = CGPointMake(0.5, 1); // 默认是自带阴影的效果, 默认为0. self.redView.layer.shadowOpacity = 1; // 添加图层到根图层 [self.view.layer addSublayer:layer]; ***********其它属性**************** // 设置阴影的颜色 layer.shadowColor = [UIColor blackColor].CGColor; // 设置阴影的偏移量((x,y) 例:右下) layer.shadowOffset = CGSizeMake(10, 10); // 设置阴影的模糊程度 layer.shadowRadius = 10; // 设置边框的宽度(注意:是往里面走的) 和 颜色 layer.borderWidth = 5; layer.borderColor = [UIColor blueColor].CGColor; // 设置圆角半径 layer.cornerRadius = 50; // 图层中绘制的图片无法正确显示，解决:把超过根层以外的东西剪切掉(UIView自带的层,我们称为是根层) layer.masksToBounds = YES; // 设置图层的代理 layer.delegate = self; // setNeedsDisplayh会调用drawRect:方法 [layer setNeedsDisplay];&#125;``` 注解：- 1、阴影效果无法 和 `masksToBounds`同时使用;- 2、裁剪：`masksToBounds` 是 `CALayer` 的属性；`clipsToBounds` 是 `UIView` 的属性；- 3、`CGImage` 和 `CGColor` 的解释： - `CALayer`是定义在`QuartzCore`框架中的`CGImageRef`、`CGColorRef`两种数据类型是定义在`CoreGraphics`框架中的 - `UIColor`、`UIImage`是定义在`UIKit`框架中的`QuartzCore`框架和`CoreGraphics`框架是可以跨平台使用的，在`iOS`和`Mac OS X`上都能使用，但是`UIKit`只能在`iOS`中使用，为了保证可移植性，`QuartzCore`不能使用`UIImage`、`UIColor`，只能使用`CGImageRef`、`CGColorRef`，即需要：`.CGImage` 和 `.CGColor`. #### 3.CATransform3D&gt;注意：使用KVC快速设置时，Key Paths值一定不要写错```objc// 触摸开始调用- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // CATransform3D，设置平移、缩放和旋转时的 3D效果 [UIView animateWithDuration:1 animations:^&#123; // 方式一：CATransform3D普通设置 // 平移 (CGFloat sx, CGFloat sy, CGFloat sz) self.imageView.layer.transform = CATransform3DTranslate(self.imageView.layer.transform, 10, 0, 0); // 缩放 self.imageView.layer.transform = CATransform3DScale(self.imageView.layer.transform, 1.2, 1.2, 0); // 旋转 self.imageView.layer.transform = CATransform3DMakeRotation(M_PI, 0, 0, 1); // 方式二：CATransform3D KVC快速设置 // 把结构体转成对象 //NSValue *value = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI, 0, 0, 1)]; //[self.imageView.layer setValue:value forKeyPath:@"transform"]; // 通过KVC快速平移(translation)、缩放(sacle)、旋转(rotation) // 平移 [self.imageView.layer setValue:@(100) forKeyPath:@"transform.translation.y"]; // 缩放 [self.imageView.layer setValue:@(0.5) forKeyPath:@"transform.scale"]; // 旋转 [self.imageView.layer setValue:@(M_PI_4) forKeyPath:@"transform.rotation"]; &#125;];&#125; PS.在这里我就不用图片了，我就劳动一下吧(图片的不好复制不是吗)，福利奉上转场效果key paths Transform field value key paths Field Key Path Description translation.x 设置为一个NSNumber对象的值是沿着x轴平移。 translation.y 设置为一个NSNumber对象的值沿y轴平移。 translation.z 设置为一个NSNumber对象的值沿z轴平移。 translation 设置为一个NSValue对象包含一个NSSize或CGSize数据类型。数据类型表示将在x和y轴。 scale.x 设置为一个NSNumber对象的值是x轴缩放。 scale.y 设置为一个NSNumber对象的值是y轴缩放。 scale.z 设置为一个NSNumber对象的值是z轴缩放。 scale 设置为一个NSNumber对象的值是所有三个规模因素的平均值。 rotation.x 设置为一个NSNumber对象的值是旋转,弧度,x轴。 rotation.y 设置为一个NSNumber对象的值是旋转,弧度,y轴。 rotation.z 设置为一个NSNumber对象的值是旋转,弧度,z轴。 rotation 设置为一个NSNumber对象的值是旋转,弧度,z轴。这个字段是一样设置旋转。z域。 4.CGAffineTransform1234567891011121314// 旋转，参数指定为弧度，M_PI &lt;－&gt; 180CGAffineTransformMakeRotation(CGFloat angle);// 缩放, sx：指x轴缩放的比例,sy 在y轴上的缩放比例CGAffineTransformMakeScale(CGFloat sx, CGFloat sy);// 平移 tx：在x轴上平移 ty 是在y上平移CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty);// 让你的view回到最原始的状态，没有缩放，没有旋转，没有平移ballView.transform = CGAffineTransformIdentity;// 指定在y轴上 平移ballView.transform = CGAffineTransformMakeTranslation(0, -300); 真正的高阶技巧 iOS Core Animation强力推荐👍《iOS Core Animation: Advanced Techniques》这本书很深入的将了Core Animation的原理性的东西，是一本讲解Core Animation原理非常深入的书，如果把整本书全部读完，理解，我相信iOS 中的动画就是件很轻松的事情了，可惜是英文的; 在网上也找到了这本书完整的中文翻译，如果感兴趣，可以去看看 ios核心动画高级技巧 最后附上这张图： 期待 如果在阅读过程中遇到 error，希望你能 Issues 我，谢谢。 如果你想为【本文相关】分享点什么，也希望你能 Issues 我，我非常想为这篇文章增加更多实用的内容，谢谢。 「博客原文」，对本文我会【不定时、持续更新、一些 学习心得与文章、实用才是硬道理】^_^. Write in the first【写在最前】 iOS 动画主要是指 Core Animation 框架。官方使用文档地址为: Core Animation Guide。 Core Animation 是iOS和macOS平台上负责图形渲染与动画的基础框架。Core Animation 可以作用与动画视图或者其他可视元素，为你完成了动画所需的大部分绘帧工作。你只需要配置少量的动画参数（如开始点的位置和结束点的位置）即可使用 Core Animation 的动画效果。 Core Animation 将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。|这种自动化的图形加速技术让动画拥有更高的帧率并且显示效果更加平滑，不会加重CPU的负担而影响程序的运行速度。 本篇文章主要从【iOS动画 Core Animation】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量；@ 白开水ln。 目录： 系统自带的 animationImages UIView代码块加Block UIView [begin commit]模式 使用CoreAnimation中的类1.CATransition 转场动画1.CATransaction动画事务2.CABasicAnimation 基础动画2.CASpringAnimation 弹簧动画3.CAKeyframeAnimation 关键帧动画4.CAAnimationGroup 动画组5.AnimationWithKeyPath的值 物理动效(重力、碰撞、吸附、推力、关联)1.UICollisionBehavior碰撞2.UISnapBehavior吸附3.UIPushBehavior推力4.UIAttachmentBehavior关联 粒子系统 facebook pop动画 iOS动画调用方式1.系统自带的 animationImages1234UIImageView *imageView;imageView.animationImages = @[image1,image2...];[imageView startAnimating];[imageView stopAnimating]; 2.UIView代码块加Block123456789101112131415161718192021222324/** Duration 动画持续时间 animations 动画过程 */[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; animations:&lt;#^(void)animations#&gt;];// 执行动画 和 动画完成的回调[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;];/** delay 等待时间 options 动画类型 */[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; options:&lt;#(UIViewAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;];/** 弹性动画 damping 阻尼，范围0-1，阻尼越接近于0，弹性效果越明显 velocity 弹性复位的速度 */[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; usingSpringWithDamping:&lt;#(CGFloat)#&gt; initialSpringVelocity:&lt;#(CGFloat)#&gt; options:&lt;#(UIViewAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;];// 关键帧动画[UIView animateKeyframesWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; options:&lt;#(UIViewKeyframeAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;]; 3.UIView [begin commit]模式123456789101112131415161718192021222324#pragma mark - 使用UIView [begin,commit]模式- (void)uiViewAnimation &#123; // 可以嵌套但是必须成对出现 UIViewAnimationTransition type = UIViewAnimationTransitionNone; [UIView beginAnimations:nil context:nil]; // 动画的持续时间 [UIView setAnimationDuration:1]; // 动画类型 [UIView setAnimationTransition:type forView:_redView cache:YES]; // 动画代理 //[UIView setAnimationDelegate:self]; //[UIView setAnimationWillStartSelector:@selector(annimationStart)]; //[UIView setAnimationDidStopSelector:@selector(annimationStop)]; [UIView commitAnimations];&#125;- (void)animationDidStart:(CAAnimation *)anim &#123; NSLog(@"%s, line = %d",__FUNCTION__,__LINE__);&#125;- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag &#123; NSLog(@"%s, line = %d",__FUNCTION__,__LINE__);&#125; 4.使用CoreAnimation中的类 1.CATransition 转场动画 CATransition属性 描述 type 过渡的类型 subType 过渡的方向 startProgress 动画起点(在整体动画的百分比) endProgress 动画终点(在整体动画的百分比) addAnimation: forKey: 把转场动画添加到layer上 创建步骤 1.创建动画对象 2.设置转场类型 3.给图层添加动画 示例代码：123456789101112131415#pragma mark - 交叉淡化过渡-(void)fadeAnimation&#123; [self changeShowContens]; // 1.创建动画对象 CATransition *anima = [CATransition animation]; // 2.设置转场类型 anima.type = kCATransitionFade;// 设置动画的类型 //anima.type = @"cube";// 设置动画的类型 anima.subtype = kCATransitionFromRight; // 设置动画的方向 //anima.startProgress = 0.3;// 设置动画起点 //anima.endProgress = 0.8;// 设置动画终点 anima.duration = 1.0f;// 设置动画执行时长 // 3.给图层添加动画 [_imageView.layer addAnimation:anima forKey:@"fadeAnimation"];&#125; 效果： 2.CATransition转场动画过渡类型在这里我就不用图片了，我就劳动一下吧(图片的不好复制不是吗)，奉上转场效果 api 类型字符串 效果说明 关键字 方向 fade 交叉淡化过渡 YES push 新视图把旧视图推出去 YES moveIn 新视图移到旧视图上面 YES reveal 将旧视图移开,显示下面的新视图 YES cube 立方体翻滚效果 oglFlip 上下左右翻滚效果 suckEffect 收缩效果,如一块布被抽走 NO rippleEffect 水滴效果 NO pageCurl 向上翻页效果 pageUnCurl 向下翻页效果 cameraIrisHollowOpen 相机镜头打开效果 NO cameraIrisHollowClose 相机镜头关闭效果 NO 动画常用属性 描述 rotation.x 设置为一个NSNumber对象的值是旋转,弧度,x轴。 duration 动画的持续时间 beginTime 动画的开始时间 repeatCount 动画的重复次数 autoreverses 执行的动画按照原动画返回执行 timingFunction 控制动画的显示节奏 Linear 匀速，EaseIn 先慢后快，EaseOut 先快后慢，EaseInEaseOut 先慢后快再慢，Default 默认中间比较快 3.CATransaction动画事务事务(CATransaction)负责协调多个动画原子更新的显示操作,是动画里面的一个基本单元，动画的产生必然伴随着layer的Animatable属性的变化，而layer属性的变化必须属于某一个事务。因此 ，核心动画依赖于事务。可以通过事物关闭隐式动画:1234567891011121314151617181920212223241、事务的作用：保证一个或多个layer的一个或多个属性变化同时进行。2、事务的种类：隐式和显示3、隐式：没有明显调用事务的方法，由系统自动生成事务。比如上面提到的设置一个layer的position属性，则会在当前线程自动生成一个事务，并在下一个runLoop中自动commit.通过如下方法可以关闭隐式动画的设置:[CATransaction begin];// 开启事务[CATransaction setDisableActions:YES];// 关闭隐式动画self.myview.layer.position = CGPointMake(10, 10);[CATransaction commit];// 提交事务4、显示:明显调用事务的方法[CATransaction begin] 和 [CATransaction commit]，必须写在两者之间.5、CA事务的可设置属性(会覆盖隐式动画的设置)animationDuration：动画时间animationTimingFunction：动画时间曲线disableActions：是否关闭动画completionBlock：动画执行完毕的回调事务支持嵌套使用:当最外层的事务commit后动画才会开始。6、通过修改layer上的属性产生的动画效果，称之为 隐式动画通过手动添加动画对象产生的动画，称之为 显式动画 4.CABasicAnimation 基础动画 CABasicAnimation重要属性 描述 fromValue keyPath对应的初始值 toValue keyPath对应的结束值 removedOnCompletion 动画完成时,是否删除动画 fillMode 设置让动画效果最后执行状态 基础动画创建步骤 1、初始化动画并设置动画属性 2、设置动画属性初始值（可以省略）、结束值以及其他动画属性 3、给图层添加动画 我们先看下面这个移动动画实例：12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma mark - 位移动画- (void)positionAnimation &#123; // 1.创建动画对象并设置动画属性 CABasicAnimation *basicAnimation = [CABasicAnimation animationWithKeyPath:@"position"]; // 2.设置动画 初始值(可以省略) 和 结束值 // 把CGPoint转换成id类型,使用NSValue basicAnimation.fromValue = [NSValue valueWithCGPoint:CGPointMake(50, kScreenHeight/2)]; basicAnimation.toValue = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth- 50, kScreenHeight/2)]; // 设置动画的其他属性值 // 动画执行时长2秒（默认0.2s) basicAnimation.duration = 1.0f; // 设置重复次数,HUGE_VALF可看做无穷大 //basicAnimation.repeatCount = HUGE_VALF; // 设置重复时间（重复时间 / 执行时长 = 重复次数) //basicAnimation.repeatDuration = 4; // 设置延迟执行2秒 //basicAnimation.beginTime = CACurrentMediaTime() + 2; // 动画时间曲线 kCAMediaTimingFunctionLinear 线性变换 平缓 //basicAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]; // 自动反转(怎么去就怎么回来) //basicAnimation.autoreverses = YES; // 设置动画代理 //basicAnimation.delegate = self; /** 如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。(不设置这两个属性值默认回到原始位置) 2016-06-15 13:15:24.350 iOS常用动画[14625:325800] 动画前X = 137.500000 2016-06-15 13:15:24.350 iOS常用动画[14625:325800] 动画后X = 137.500000 */ //basicAnimation.removedOnCompletion = NO;// 动画完成时,会自动删除动画 //basicAnimation.fillMode = kCAFillModeForwards;// 设置让动画效果最后执行状态 // 3.给图层添加动画（注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取） [self.redView.layer addAnimation:basicAnimation forKey:@"positionAnimation"]; // 移除动画 //[self.redView.layer removeAnimationForKey:@"positionAnimation"]; //[self.redView.layer removeAllAnimations];&#125; 效果： CASpringAnimation 弹簧动画 属性 描述 mass 质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大 stiffnes 刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快 damping 阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快 initivelocity 初始速率，动画视图的初始速度大小;速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反 settingDuration 结算时间(根据动画相关参数估算弹簧开始运动到停止的时间，动画设置的时间最好根据此时间来设置) CASpringAnimation和UIView的SpringAnimation对比:CASpringAnimation 可以设置更多弹簧动画效果的属性，可以实现更复杂的弹簧效果，可以和其他动画组合UIView的SpringAnimation实际上就是通过CASpringAnimation来实现的。 代码示例：12345678910111213141516171819202122#pragma mark - 弹簧动画- (void)springAnimation &#123; CASpringAnimation * springAnimation = [CASpringAnimation animationWithKeyPath:@"transform.scale"]; // 质量,越大弹簧幅度越大 springAnimation.mass = 10.0; // 弹性系数,越大运动越快 springAnimation.stiffness = 500; // 阻尼系数,越大停止越快 springAnimation.damping = 100.0; // 初始速率,正方向相同、负方向相反 springAnimation.initialVelocity = 30.f; springAnimation.duration = springAnimation.settlingDuration; springAnimation.toValue = [NSNumber numberWithFloat:1.5]; //springAnimation.removedOnCompletion = NO; //springAnimation.fillMode = kCAFillModeForwards; springAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; [self.redView.layer addAnimation:springAnimation forKey:@"boundsAni"];&#125; 效果： 3.CAKeyframeAnimation 关键帧动画可以让我们在更细的粒度上控制动画的行为，关键帧动画需要指定几个关键的点，从而让动画沿着这些点运动，这几个点就称之为 关键帧 CAKeyframeAnimation属性 描述 values 指定关键点的值 path 可以设置一个CGPathRef / CGMutablePathRef，让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略. keyTimes 是走到某一个关键点花费的时间百分比(0～1)，keyTimes中的每一个时间值都对应values中的每一帧(两个数组的个数必须一致)，当keyTimes没有设置的时候,各个关键帧的时间是平分的。 通过 设置不同的属性值values 动画 关键帧动画创建第一种方式 通过 绘制路径path 动画 关键帧动画创建第二种方式 代码示例：12345678910111213141516171819202122232425// 角度转弧度#define angleToRadian(angle) ((angle) / 180.0 * M_PI)#pragma mark 关键帧动画values- (void)valuesAnimation &#123; // 1.创建动画对象 CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"transform.rotation"]; // 2.设置动画属性值 //NSValue *value1 = [NSValue valueWithCGPoint:&lt;#(CGPoint)#&gt;]; animation.values = @[@(angleToRadian(-5)),@(angleToRadian(5)),@(angleToRadian(-5))]; animation.duration = 1; animation.repeatCount = MAXFLOAT; //animation.keyTimes = @[@(0.0),@(1),@(0.1)]; // 如果不用反转,也可以在values里面写 //animation.autoreverses = YES; // 动画结束时的状态（不设置回到原始位置） //anim.removedOnCompletion = NO; //anim.fillMode = kCAFillModeForwards; // 3.给图层添加动画 [self.iconImage.layer addAnimation:animation forKey:@"valuesAnimation"];&#125; 代码示例：1234567891011121314151617181920212223242526#pragma mark 关键帧动画第二种方式- (void)translationAnimation2 &#123; // 1.创建关键帧动画并设置动画属性 CAKeyframeAnimation *moveAnimation = [CAKeyframeAnimation animationWithKeyPath:@"position"]; moveAnimation.duration = 2; // 2.设置关键帧动画的行进路径（绘制贝塞尔曲线） moveAnimation.path = self.path.CGPath; // 3.添加动画到图层，添加动画后就会执行动画 [self.ballView.layer addAnimation:moveAnimation forKey:nil]; // 设置最终的状态(不设置就是回到原始位置) self.ballView.layer.position = CGPointMake(330, 200);&#125;// 绘制贝塞尔曲线- (void)drawRect:(CGRect)rect &#123; self.path = [[UIBezierPath alloc]init]; [[UIColor redColor] setStroke]; self.path.lineWidth = 5; [self.path moveToPoint:CGPointMake(30, 200)]; [self.path addCurveToPoint:CGPointMake(330, 200) controlPoint1:CGPointMake(100, 50) controlPoint2:CGPointMake(200, 300)]; [self.path stroke];&#125; 效果： 4.CAAnimationGroup 动画组 CAAnimationGroup属性 描述 animations 用来保存一组动画对象的NSArray CFTimeInterval 时间间隔 代码示例：123456789101112131415161718192021222324252627#pragma mark 动画组(同时)- (void)groupAnimation1 &#123; // 位移动画 CAKeyframeAnimation *animation1 = [CAKeyframeAnimation animationWithKeyPath:@"position"]; NSValue *value0 = [NSValue valueWithCGPoint:CGPointMake(0, kScreenHeight/2-50)]; NSValue *value1 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth/3, kScreenHeight/2-50)]; NSValue *value2 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth/3, kScreenHeight/2+50)]; NSValue *value3 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth*2/3, kScreenHeight/2+50)]; NSValue *value4 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth*2/3, kScreenHeight/2-50)]; NSValue *value5 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth, kScreenHeight/2-50)]; animation1.values = @[value0,value1,value2,value3,value4,value5]; // 缩放动画 CABasicAnimation *animation2 = [CABasicAnimation animationWithKeyPath:@"transform.scale"]; animation2.fromValue = [NSNumber numberWithFloat:0.8f]; animation2.toValue = [NSNumber numberWithFloat:2.0f]; // 旋转动画 CABasicAnimation *animation3 = [CABasicAnimation animationWithKeyPath:@"transform.rotation"]; animation3.toValue = [NSNumber numberWithFloat:M_PI *4]; // 创建动画组 CAAnimationGroup *groupAnimation = [CAAnimationGroup animation]; groupAnimation.animations = @[animation1,animation2,animation3]; groupAnimation.duration = 4; [self.redView.layer addAnimation:groupAnimation forKey:@"groupAnimation"];&#125; 效果： 5.AnimationWithKeyPath的值在这里我就不用图片了，我就劳动一下吧(图片的不好复制不是吗)，福利奉上转场效果 key pathsTransform field value key paths Field Key Path Description rotation.x 设置为一个NSNumber对象的值是旋转,弧度,x轴。 rotation.y 设置为一个NSNumber对象的值是旋转,弧度,y轴。 rotation.z 设置为一个NSNumber对象的值是旋转,弧度,z轴。 rotation 设置为一个NSNumber对象的值是旋转,弧度,z轴。这个字段是一样设置旋转。z域。 scale.x 设置为一个NSNumber对象的值是x轴的比例因子。 scale.y 设置为一个NSNumber对象的值是y轴的比例因子。 scale.z 设置为一个NSNumber对象的值是z轴的比例因子。 scale 设置为一个NSNumber对象的值是所有三个规模因素的平均值。 translation.x 设置为一个NSNumber对象的值是沿着x轴。 translation.y 设置为一个NSNumber对象的值沿y轴。 translation.z 设置为一个NSNumber对象的值沿z轴。 translation 设置为一个NSValue对象包含一个NSSize或CGSize数据类型。数据类型表示将在x和y轴。 核心动画综合案例 5.物理动效(重力、碰撞、吸附、推力、关联)123456ios7之后提供的物理动效UIGravityBehavior 重力UICollisionBehavior 碰撞UISnapBehavior 吸附UIPushBehavior 推力UIAttachmentBehavior 关联 以下示例，我们就直接来代码，看效果了，中间会有部分解释； 1.UICollisionBehavior碰撞，示例：模仿重力 + 碰撞 的行为12345678910111213141516171819202122232425262728// 先指定一个参考视图来初始化animatorself.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];#pragma mark 模仿重力 和 碰撞效果- (void)animations &#123; // 添加重力 UIGravityBehavior *gravity = [[UIGravityBehavior alloc]initWithItems:@[self.ballView]]; // 添加碰撞 UICollisionBehavior *collision = [[UICollisionBehavior alloc]initWithItems:@[self.ballView]]; // 把参考视图的边界作为我的碰撞边界 collision.translatesReferenceBoundsIntoBoundary = YES; // 添加一个自定义的行为，修改动效参数 UIDynamicItemBehavior *itemBehavior = [[UIDynamicItemBehavior alloc]initWithItems:@[self.ballView]]; /** 弹性系数 density 1.0 密度 elasticity 0.0 弹性 friction 0.0 摩擦 resistance 0.0 阻力 */ itemBehavior.elasticity = 0.5; // 把重力和碰撞行为添加到动画执行者中 [self.animator addBehavior:gravity]; [self.animator addBehavior:collision]; [self.animator addBehavior:itemBehavior];&#125; 效果： 2.UISnapBehavior吸附，示例：模仿吸附 + 重力 的行为123456789101112- (void)doAnimation&#123; //[self.animator removeAllBehaviors]; // 添加一个吸附行为，指定吸附的点 UISnapBehavior *snap = [[UISnapBehavior alloc]initWithItem:self.ballView snapToPoint:CGPointMake(self.view.frame.size.width *0.5, self.view.frame.size.height - 100)]; // 添加一个重力的行为 UIGravityBehavior *gravity = [[UIGravityBehavior alloc]initWithItems:@[self.ballView]]; [self.animator addBehavior:snap]; [self.animator addBehavior:gravity];&#125; 效果： 3.UIPushBehavior推力，示例：模仿推力 + 碰撞 的行为123456789101112131415161718192021222324252627282930313233#pragma mark 添加点击手势- (void)addTapGestrue &#123; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(handleTapGestrue:)]; [self.ballView addGestureRecognizer:tap];&#125;- (void)handleTapGestrue:(UITapGestureRecognizer*)gesture&#123; // 球的中心点 CGPoint ballCenter = self.ballView.center; // 点击点 CGPoint tapPoint = [gesture locationInView:self.view]; CGFloat offsetX = tapPoint.x - ballCenter.x; CGFloat offsetY = tapPoint.y - ballCenter.y; CGFloat angle = atan2(offsetY, offsetX); CGFloat distance = sqrt(pow(offsetX, 2) + pow(offsetY, 2)); // 添加推力行为 UIPushBehavior *push = [[UIPushBehavior alloc]initWithItems:@[self.ballView] mode:UIPushBehaviorModeInstantaneous]; // 设置角度 [push setAngle:angle]; // 设置推力大小 // 每1个magnigude将会引起100/平方秒的加速度 [push setMagnitude:distance/100]; // 添加碰撞行为 UICollisionBehavior *collision = [[UICollisionBehavior alloc]initWithItems:@[self.ballView]]; collision.translatesReferenceBoundsIntoBoundary = YES; [self.animator addBehavior:push]; [self.animator addBehavior:collision];&#125; 效果： 4.UIAttachmentBehavior关联，示例：模仿推力 + 碰撞 的行为123456789- (void)doAnimation&#123; // UIAttachmentBehavior 可以设置和某一个点 UIAttachmentBehavior *attachment = [[UIAttachmentBehavior alloc]initWithItem:self.blueView attachedToItem:self.ballView]; // 关联的长度 [attachment setLength:100]; UIGravityBehavior *gravity = [[UIGravityBehavior alloc]initWithItems:@[self.blueView]]; [self.animator addBehavior:attachment]; [self.animator addBehavior:gravity];&#125; 效果： 6.粒子系统12CAEmitterCellCAEmitterLayer 7.facebook pop动画123456使用之前先讨论以下POP和核心动画的主要区别CoreAnimation 的动画是加在layer上CoreAnimation的动画只是表面而已，并没有真正的修改frame等属性值pop的动画可以添加到任何对象pop的底层是基于CADisplaylinkpop的动画真正的修改frame等属性值 pop使用：1234POP默认支持三种动画，但同时也支持自定义动画POPDecayAnimation 减速动画POPSpringAnimation 弹簧效果POPSpringAnimation 飞入效果 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>核心动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 核心动画—「Core Animation动画基础框架」]]></title>
    <url>%2FiOSNET%2FCoreAnimation.html</url>
    <content type="text"><![CDATA[Write in the first iOS 动画主要是指 Core Animation 框架。官方使用文档地址为: Core Animation Guide。 Core Animation 是iOS和macOS平台上负责图形渲染与动画的基础框架。Core Animation 可以作用与动画视图或者其他可视元素，为你完成了动画所需的大部分绘帧工作。你只需要配置少量的动画参数（如开始点的位置和结束点的位置）即可使用 Core Animation 的动画效果。 Core Animation 将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。|这种自动化的图形加速技术让动画拥有更高的帧率并且显示效果更加平滑，不会加重CPU的负担而影响程序的运行速度。 本篇文章主要从【iOS动画 Core Animation】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： 系统自带的 animationImages UIView代码块加Block UIView [begin commit]模式 使用CoreAnimation中的类1.CATransition 转场动画1.CATransaction动画事务2.CABasicAnimation 基础动画2.CASpringAnimation 弹簧动画3.CAKeyframeAnimation 关键帧动画4.CAAnimationGroup 动画组5.AnimationWithKeyPath的值 物理动效(重力、碰撞、吸附、推力、关联)1.UICollisionBehavior碰撞2.UISnapBehavior吸附3.UIPushBehavior推力4.UIAttachmentBehavior关联 粒子系统 facebook pop动画 iOS动画调用方式1.系统自带的 animationImages1234UIImageView *imageView;imageView.animationImages = @[image1,image2...];[imageView startAnimating];[imageView stopAnimating]; 2.UIView代码块加Block123456789101112131415161718192021222324/** Duration 动画持续时间 animations 动画过程 */[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; animations:&lt;#^(void)animations#&gt;];// 执行动画 和 动画完成的回调[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;];/** delay 等待时间 options 动画类型 */[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; options:&lt;#(UIViewAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;];/** 弹性动画 damping 阻尼，范围0-1，阻尼越接近于0，弹性效果越明显 velocity 弹性复位的速度 */[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; usingSpringWithDamping:&lt;#(CGFloat)#&gt; initialSpringVelocity:&lt;#(CGFloat)#&gt; options:&lt;#(UIViewAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;];// 关键帧动画[UIView animateKeyframesWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; options:&lt;#(UIViewKeyframeAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;]; 3.UIView [begin commit]模式123456789101112131415161718192021222324#pragma mark - 使用UIView [begin,commit]模式- (void)uiViewAnimation &#123; // 可以嵌套但是必须成对出现 UIViewAnimationTransition type = UIViewAnimationTransitionNone; [UIView beginAnimations:nil context:nil]; // 动画的持续时间 [UIView setAnimationDuration:1]; // 动画类型 [UIView setAnimationTransition:type forView:_redView cache:YES]; // 动画代理 //[UIView setAnimationDelegate:self]; //[UIView setAnimationWillStartSelector:@selector(annimationStart)]; //[UIView setAnimationDidStopSelector:@selector(annimationStop)]; [UIView commitAnimations];&#125;- (void)animationDidStart:(CAAnimation *)anim &#123; NSLog(@"%s, line = %d",__FUNCTION__,__LINE__);&#125;- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag &#123; NSLog(@"%s, line = %d",__FUNCTION__,__LINE__);&#125; 4.使用CoreAnimation中的类 1.CATransition 转场动画 CATransition属性 描述 type 过渡的类型 subType 过渡的方向 startProgress 动画起点(在整体动画的百分比) endProgress 动画终点(在整体动画的百分比) addAnimation: forKey: 把转场动画添加到layer上 创建步骤 1.创建动画对象 2.设置转场类型 3.给图层添加动画 示例代码：123456789101112131415#pragma mark - 交叉淡化过渡-(void)fadeAnimation&#123; [self changeShowContens]; // 1.创建动画对象 CATransition *anima = [CATransition animation]; // 2.设置转场类型 anima.type = kCATransitionFade;// 设置动画的类型 //anima.type = @"cube";// 设置动画的类型 anima.subtype = kCATransitionFromRight; // 设置动画的方向 //anima.startProgress = 0.3;// 设置动画起点 //anima.endProgress = 0.8;// 设置动画终点 anima.duration = 1.0f;// 设置动画执行时长 // 3.给图层添加动画 [_imageView.layer addAnimation:anima forKey:@"fadeAnimation"];&#125; 效果： 2.CATransition转场动画过渡类型在这里我就不用图片了，我就劳动一下吧(图片的不好复制不是吗)，奉上转场效果 api 类型字符串 效果说明 关键字 方向 fade 交叉淡化过渡 YES push 新视图把旧视图推出去 YES moveIn 新视图移到旧视图上面 YES reveal 将旧视图移开,显示下面的新视图 YES cube 立方体翻滚效果 oglFlip 上下左右翻滚效果 suckEffect 收缩效果,如一块布被抽走 NO rippleEffect 水滴效果 NO pageCurl 向上翻页效果 pageUnCurl 向下翻页效果 cameraIrisHollowOpen 相机镜头打开效果 NO cameraIrisHollowClose 相机镜头关闭效果 NO 动画常用属性 描述 rotation.x 设置为一个NSNumber对象的值是旋转,弧度,x轴。 duration 动画的持续时间 beginTime 动画的开始时间 repeatCount 动画的重复次数 autoreverses 执行的动画按照原动画返回执行 timingFunction 控制动画的显示节奏 Linear 匀速，EaseIn 先慢后快，EaseOut 先快后慢，EaseInEaseOut 先慢后快再慢，Default 默认中间比较快 3.CATransaction动画事务事务(CATransaction)负责协调多个动画原子更新的显示操作,是动画里面的一个基本单元，动画的产生必然伴随着layer的Animatable属性的变化，而layer属性的变化必须属于某一个事务。因此 ，核心动画依赖于事务。可以通过事物关闭隐式动画:1234567891011121314151617181920212223241、事务的作用：保证一个或多个layer的一个或多个属性变化同时进行。2、事务的种类：隐式和显示3、隐式：没有明显调用事务的方法，由系统自动生成事务。比如上面提到的设置一个layer的position属性，则会在当前线程自动生成一个事务，并在下一个runLoop中自动commit.通过如下方法可以关闭隐式动画的设置:[CATransaction begin];// 开启事务[CATransaction setDisableActions:YES];// 关闭隐式动画self.myview.layer.position = CGPointMake(10, 10);[CATransaction commit];// 提交事务4、显示:明显调用事务的方法[CATransaction begin] 和 [CATransaction commit]，必须写在两者之间.5、CA事务的可设置属性(会覆盖隐式动画的设置)animationDuration：动画时间animationTimingFunction：动画时间曲线disableActions：是否关闭动画completionBlock：动画执行完毕的回调事务支持嵌套使用:当最外层的事务commit后动画才会开始。6、通过修改layer上的属性产生的动画效果，称之为 隐式动画通过手动添加动画对象产生的动画，称之为 显式动画 4.CABasicAnimation 基础动画 CABasicAnimation重要属性 描述 fromValue keyPath对应的初始值 toValue keyPath对应的结束值 removedOnCompletion 动画完成时,是否删除动画 fillMode 设置让动画效果最后执行状态 基础动画创建步骤 1、初始化动画并设置动画属性 2、设置动画属性初始值（可以省略）、结束值以及其他动画属性 3、给图层添加动画 我们先看下面这个移动动画实例：12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma mark - 位移动画- (void)positionAnimation &#123; // 1.创建动画对象并设置动画属性 CABasicAnimation *basicAnimation = [CABasicAnimation animationWithKeyPath:@"position"]; // 2.设置动画 初始值(可以省略) 和 结束值 // 把CGPoint转换成id类型,使用NSValue basicAnimation.fromValue = [NSValue valueWithCGPoint:CGPointMake(50, kScreenHeight/2)]; basicAnimation.toValue = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth- 50, kScreenHeight/2)]; // 设置动画的其他属性值 // 动画执行时长2秒（默认0.2s) basicAnimation.duration = 1.0f; // 设置重复次数,HUGE_VALF可看做无穷大 //basicAnimation.repeatCount = HUGE_VALF; // 设置重复时间（重复时间 / 执行时长 = 重复次数) //basicAnimation.repeatDuration = 4; // 设置延迟执行2秒 //basicAnimation.beginTime = CACurrentMediaTime() + 2; // 动画时间曲线 kCAMediaTimingFunctionLinear 线性变换 平缓 //basicAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]; // 自动反转(怎么去就怎么回来) //basicAnimation.autoreverses = YES; // 设置动画代理 //basicAnimation.delegate = self; /** 如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。(不设置这两个属性值默认回到原始位置) 2016-06-15 13:15:24.350 iOS常用动画[14625:325800] 动画前X = 137.500000 2016-06-15 13:15:24.350 iOS常用动画[14625:325800] 动画后X = 137.500000 */ //basicAnimation.removedOnCompletion = NO;// 动画完成时,会自动删除动画 //basicAnimation.fillMode = kCAFillModeForwards;// 设置让动画效果最后执行状态 // 3.给图层添加动画（注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取） [self.redView.layer addAnimation:basicAnimation forKey:@"positionAnimation"]; // 移除动画 //[self.redView.layer removeAnimationForKey:@"positionAnimation"]; //[self.redView.layer removeAllAnimations];&#125; 效果： CASpringAnimation 弹簧动画 属性 描述 mass 质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大 stiffnes 刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快 damping 阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快 initivelocity 初始速率，动画视图的初始速度大小;速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反 settingDuration 结算时间(根据动画相关参数估算弹簧开始运动到停止的时间，动画设置的时间最好根据此时间来设置) CASpringAnimation和UIView的SpringAnimation对比:CASpringAnimation 可以设置更多弹簧动画效果的属性，可以实现更复杂的弹簧效果，可以和其他动画组合UIView的SpringAnimation实际上就是通过CASpringAnimation来实现的。 代码示例：12345678910111213141516171819202122#pragma mark - 弹簧动画- (void)springAnimation &#123; CASpringAnimation * springAnimation = [CASpringAnimation animationWithKeyPath:@"transform.scale"]; // 质量,越大弹簧幅度越大 springAnimation.mass = 10.0; // 弹性系数,越大运动越快 springAnimation.stiffness = 500; // 阻尼系数,越大停止越快 springAnimation.damping = 100.0; // 初始速率,正方向相同、负方向相反 springAnimation.initialVelocity = 30.f; springAnimation.duration = springAnimation.settlingDuration; springAnimation.toValue = [NSNumber numberWithFloat:1.5]; //springAnimation.removedOnCompletion = NO; //springAnimation.fillMode = kCAFillModeForwards; springAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; [self.redView.layer addAnimation:springAnimation forKey:@"boundsAni"];&#125; 效果： 3.CAKeyframeAnimation 关键帧动画可以让我们在更细的粒度上控制动画的行为，关键帧动画需要指定几个关键的点，从而让动画沿着这些点运动，这几个点就称之为 关键帧 CAKeyframeAnimation属性 描述 values 指定关键点的值 path 可以设置一个CGPathRef / CGMutablePathRef，让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略. keyTimes 是走到某一个关键点花费的时间百分比(0～1)，keyTimes中的每一个时间值都对应values中的每一帧(两个数组的个数必须一致)，当keyTimes没有设置的时候,各个关键帧的时间是平分的。 通过 设置不同的属性值values 动画 关键帧动画创建第一种方式 通过 绘制路径path 动画 关键帧动画创建第二种方式 代码示例：12345678910111213141516171819202122232425// 角度转弧度#define angleToRadian(angle) ((angle) / 180.0 * M_PI)#pragma mark 关键帧动画values- (void)valuesAnimation &#123; // 1.创建动画对象 CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"transform.rotation"]; // 2.设置动画属性值 //NSValue *value1 = [NSValue valueWithCGPoint:&lt;#(CGPoint)#&gt;]; animation.values = @[@(angleToRadian(-5)),@(angleToRadian(5)),@(angleToRadian(-5))]; animation.duration = 1; animation.repeatCount = MAXFLOAT; //animation.keyTimes = @[@(0.0),@(1),@(0.1)]; // 如果不用反转,也可以在values里面写 //animation.autoreverses = YES; // 动画结束时的状态（不设置回到原始位置） //anim.removedOnCompletion = NO; //anim.fillMode = kCAFillModeForwards; // 3.给图层添加动画 [self.iconImage.layer addAnimation:animation forKey:@"valuesAnimation"];&#125; 代码示例：1234567891011121314151617181920212223242526#pragma mark 关键帧动画第二种方式- (void)translationAnimation2 &#123; // 1.创建关键帧动画并设置动画属性 CAKeyframeAnimation *moveAnimation = [CAKeyframeAnimation animationWithKeyPath:@"position"]; moveAnimation.duration = 2; // 2.设置关键帧动画的行进路径（绘制贝塞尔曲线） moveAnimation.path = self.path.CGPath; // 3.添加动画到图层，添加动画后就会执行动画 [self.ballView.layer addAnimation:moveAnimation forKey:nil]; // 设置最终的状态(不设置就是回到原始位置) self.ballView.layer.position = CGPointMake(330, 200);&#125;// 绘制贝塞尔曲线- (void)drawRect:(CGRect)rect &#123; self.path = [[UIBezierPath alloc]init]; [[UIColor redColor] setStroke]; self.path.lineWidth = 5; [self.path moveToPoint:CGPointMake(30, 200)]; [self.path addCurveToPoint:CGPointMake(330, 200) controlPoint1:CGPointMake(100, 50) controlPoint2:CGPointMake(200, 300)]; [self.path stroke];&#125; 效果： 4.CAAnimationGroup 动画组 CAAnimationGroup属性 描述 animations 用来保存一组动画对象的NSArray CFTimeInterval 时间间隔 代码示例：123456789101112131415161718192021222324252627#pragma mark 动画组(同时)- (void)groupAnimation1 &#123; // 位移动画 CAKeyframeAnimation *animation1 = [CAKeyframeAnimation animationWithKeyPath:@"position"]; NSValue *value0 = [NSValue valueWithCGPoint:CGPointMake(0, kScreenHeight/2-50)]; NSValue *value1 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth/3, kScreenHeight/2-50)]; NSValue *value2 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth/3, kScreenHeight/2+50)]; NSValue *value3 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth*2/3, kScreenHeight/2+50)]; NSValue *value4 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth*2/3, kScreenHeight/2-50)]; NSValue *value5 = [NSValue valueWithCGPoint:CGPointMake(kScreenWidth, kScreenHeight/2-50)]; animation1.values = @[value0,value1,value2,value3,value4,value5]; // 缩放动画 CABasicAnimation *animation2 = [CABasicAnimation animationWithKeyPath:@"transform.scale"]; animation2.fromValue = [NSNumber numberWithFloat:0.8f]; animation2.toValue = [NSNumber numberWithFloat:2.0f]; // 旋转动画 CABasicAnimation *animation3 = [CABasicAnimation animationWithKeyPath:@"transform.rotation"]; animation3.toValue = [NSNumber numberWithFloat:M_PI *4]; // 创建动画组 CAAnimationGroup *groupAnimation = [CAAnimationGroup animation]; groupAnimation.animations = @[animation1,animation2,animation3]; groupAnimation.duration = 4; [self.redView.layer addAnimation:groupAnimation forKey:@"groupAnimation"];&#125; 效果： 5.AnimationWithKeyPath的值在这里我就不用图片了，我就劳动一下吧(图片的不好复制不是吗)，福利奉上转场效果 key pathsTransform field value key paths Field Key Path Description rotation.x 设置为一个NSNumber对象的值是旋转,弧度,x轴。 rotation.y 设置为一个NSNumber对象的值是旋转,弧度,y轴。 rotation.z 设置为一个NSNumber对象的值是旋转,弧度,z轴。 rotation 设置为一个NSNumber对象的值是旋转,弧度,z轴。这个字段是一样设置旋转。z域。 scale.x 设置为一个NSNumber对象的值是x轴的比例因子。 scale.y 设置为一个NSNumber对象的值是y轴的比例因子。 scale.z 设置为一个NSNumber对象的值是z轴的比例因子。 scale 设置为一个NSNumber对象的值是所有三个规模因素的平均值。 translation.x 设置为一个NSNumber对象的值是沿着x轴。 translation.y 设置为一个NSNumber对象的值沿y轴。 translation.z 设置为一个NSNumber对象的值沿z轴。 translation 设置为一个NSValue对象包含一个NSSize或CGSize数据类型。数据类型表示将在x和y轴。 核心动画综合案例 5.物理动效(重力、碰撞、吸附、推力、关联)123456ios7之后提供的物理动效UIGravityBehavior 重力UICollisionBehavior 碰撞UISnapBehavior 吸附UIPushBehavior 推力UIAttachmentBehavior 关联 以下示例，我们就直接来代码，看效果了，中间会有部分解释； 1.UICollisionBehavior碰撞，示例：模仿重力 + 碰撞 的行为12345678910111213141516171819202122232425262728// 先指定一个参考视图来初始化animatorself.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];#pragma mark 模仿重力 和 碰撞效果- (void)animations &#123; // 添加重力 UIGravityBehavior *gravity = [[UIGravityBehavior alloc]initWithItems:@[self.ballView]]; // 添加碰撞 UICollisionBehavior *collision = [[UICollisionBehavior alloc]initWithItems:@[self.ballView]]; // 把参考视图的边界作为我的碰撞边界 collision.translatesReferenceBoundsIntoBoundary = YES; // 添加一个自定义的行为，修改动效参数 UIDynamicItemBehavior *itemBehavior = [[UIDynamicItemBehavior alloc]initWithItems:@[self.ballView]]; /** 弹性系数 density 1.0 密度 elasticity 0.0 弹性 friction 0.0 摩擦 resistance 0.0 阻力 */ itemBehavior.elasticity = 0.5; // 把重力和碰撞行为添加到动画执行者中 [self.animator addBehavior:gravity]; [self.animator addBehavior:collision]; [self.animator addBehavior:itemBehavior];&#125; 效果： 2.UISnapBehavior吸附，示例：模仿吸附 + 重力 的行为123456789101112- (void)doAnimation&#123; //[self.animator removeAllBehaviors]; // 添加一个吸附行为，指定吸附的点 UISnapBehavior *snap = [[UISnapBehavior alloc]initWithItem:self.ballView snapToPoint:CGPointMake(self.view.frame.size.width *0.5, self.view.frame.size.height - 100)]; // 添加一个重力的行为 UIGravityBehavior *gravity = [[UIGravityBehavior alloc]initWithItems:@[self.ballView]]; [self.animator addBehavior:snap]; [self.animator addBehavior:gravity];&#125; 效果： 3.UIPushBehavior推力，示例：模仿推力 + 碰撞 的行为123456789101112131415161718192021222324252627282930313233#pragma mark 添加点击手势- (void)addTapGestrue &#123; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(handleTapGestrue:)]; [self.ballView addGestureRecognizer:tap];&#125;- (void)handleTapGestrue:(UITapGestureRecognizer*)gesture&#123; // 球的中心点 CGPoint ballCenter = self.ballView.center; // 点击点 CGPoint tapPoint = [gesture locationInView:self.view]; CGFloat offsetX = tapPoint.x - ballCenter.x; CGFloat offsetY = tapPoint.y - ballCenter.y; CGFloat angle = atan2(offsetY, offsetX); CGFloat distance = sqrt(pow(offsetX, 2) + pow(offsetY, 2)); // 添加推力行为 UIPushBehavior *push = [[UIPushBehavior alloc]initWithItems:@[self.ballView] mode:UIPushBehaviorModeInstantaneous]; // 设置角度 [push setAngle:angle]; // 设置推力大小 // 每1个magnigude将会引起100/平方秒的加速度 [push setMagnitude:distance/100]; // 添加碰撞行为 UICollisionBehavior *collision = [[UICollisionBehavior alloc]initWithItems:@[self.ballView]]; collision.translatesReferenceBoundsIntoBoundary = YES; [self.animator addBehavior:push]; [self.animator addBehavior:collision];&#125; 效果： 4.UIAttachmentBehavior关联，示例：模仿推力 + 碰撞 的行为123456789- (void)doAnimation&#123; // UIAttachmentBehavior 可以设置和某一个点 UIAttachmentBehavior *attachment = [[UIAttachmentBehavior alloc]initWithItem:self.blueView attachedToItem:self.ballView]; // 关联的长度 [attachment setLength:100]; UIGravityBehavior *gravity = [[UIGravityBehavior alloc]initWithItems:@[self.blueView]]; [self.animator addBehavior:attachment]; [self.animator addBehavior:gravity];&#125; 效果： 6.粒子系统12CAEmitterCellCAEmitterLayer 7.facebook pop动画123456使用之前先讨论以下POP和核心动画的主要区别CoreAnimation 的动画是加在layer上CoreAnimation的动画只是表面而已，并没有真正的修改frame等属性值pop的动画可以添加到任何对象pop的底层是基于CADisplaylinkpop的动画真正的修改frame等属性值 pop使用：1234POP默认支持三种动画，但同时也支持自定义动画POPDecayAnimation 减速动画POPSpringAnimation 弹簧效果POPSpringAnimation 飞入效果 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>核心动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 伐码猿自检—「Masonry约束」]]></title>
    <url>%2FToolsAndPlugins%2FMasonry.html</url>
    <content type="text"><![CDATA[本篇文章主要从【Masonry 使用】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： Masonry简明介绍 导入Masonry框架 Masonry 常用API &amp; 特性1.基础API2.4种设置常量的方法3.简化前缀的宏定义 &amp; 简写4.更新约束和布局 Masonry常用方法1.基本使用：设置内边距2.简单动画：priority优先级3.更新约束 mas_updateConstraints4.重写约束 mas_remakeConstraints5.比例使用 multipliedBy6.大于等于和小于等于某个值的约束 Demo小样 重要的部分代码中都有相应的注解和文字打印，运行程序可以很直观的表现 Star 在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量@jianshu - 白开水ln。 Masonry简明介绍 Masonry是一个轻量级的布局框架，适用于iOS以及OS X。它用简洁的语法对官方的AutoLayout进行了封装。 Masonry有它自己的一套框架用来描述NSLayoutConstraints布局的DSL，提高了约束代码的简洁性与可读性。 导入Masonry框架 使用Cocoapods来导入框架，在使用到该框架的文件中添加主头文件：#import &lt;Masonry/Masonry.h&gt;。 使用直接拖拽的方式拉入框架文件夹，在使用到该框架的文件中添加主头文件：#import &quot;Masonry.h&quot;。 Masonry 常用API &amp; 特性 基础API123456789mas_makeConstraints() 添加约束mas_remakeConstraints() 移除之前的约束，重新添加新的约束mas_updateConstraints() 更新约束equalTo() 参数是对象类型，一般是视图对象或者mas_width这样的坐标系对象mas_equalTo() 和上面功能相同，参数可以传递基础数据类型对象，可以理解为比上面的API更强大width() 用来表示宽度，例如代表view的宽度mas_width() 用来获取宽度的值。和上面的区别在于，一个代表某个坐标系对象，一个用来获取坐标系对象的值 Constant：Masonry提供了4种设置constant的方法1234567- (MASConstraint * (^)(MASEdgeInsets insets))insets;- (MASConstraint * (^)(CGSize offset))sizeOffset;- (MASConstraint * (^)(CGPoint offset))centerOffset;- (MASConstraint * (^)(CGFloat offset))offset; 注解： insets: 用来设置left, right, top, bottom。接受MASEdgeInsets类型值 sizeOffset: 用来设置width, height。接受CGSize类型的值 centerOffset: 用来设置centerX, centerY。接受CGPoint类型的值 offset: 可以用来设置所有的东西。接受CGFloat类型的值 简化前缀的宏定义 &amp; 简写1234// 定义这个常量，就可以不用在开发过程中使用"mas_"前缀。#define MAS_SHORTHAND// 定义这个常量，就可以让Masonry帮我们自动把基础数据类型的数据，自动装箱为对象类型。#define MAS_SHORTHAND_GLOBALS 注解：这两个宏如果想有效使用，必须要在添加Masonry头文件之前导入进去。 1234567891011121314// 完整的make.left.equalTo(view1.superview.mas_left).offset(0);//省略Attribute的make.left.equalTo(view1.superview).offset(0);//省略equalTo的make.left.offset(0);//使用equalTo替代offset的make.left.equalTo(@0);//省略所有的... 可惜会有warningmake.left; 更新约束和布局 对于约束的设置，Masonry提供了3种方法，分别为设置约束、更新约束、重写设置约束 123456789101112131415161718// 设置约束 - (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;// 更新约束- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;// 重新设置约束- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;注解：mas_makeConstraints: 初次设置约束使用。mas_updateConstraints: 更新约束时使用。如果找不着这条约束，会新增，相当于mas_makeConstraints。mas_remakeConstraints: 重新设置约束。先将view上所有约束移除，再新增约束注意：mas_updateConstraints只能更新已有约束。如果第一次使用的是left, right设置的相对宽度。更新的时候想换成使用width。不能使用mas_updateConstraints，因为已有约束里面没有width的约束，新增width之后会跟原有left, right约束冲突。此时应该使用mas_remakeConstraints 关于更新约束布局相关的API，主要用以下四个API： - (void)updateConstraintsIfNeeded 调用此方法，如果有标记为需要重新布局的约束，则立即进行重新布局，内部会调用updateConstraints方法。 - (void)updateConstraints 重写此方法，内部实现自定义布局过程。 - (BOOL)needsUpdateConstraints 当前是否需要重新布局，内部会判断当前有没有被标记的约束。 - (void)setNeedsUpdateConstraints 标记需要进行重新布局。 关于UIView重新布局相关的API，主要用以下三个API： - (void)setNeedsLayout 标记为需要重新布局。 - (void)layoutIfNeeded 查看当前视图是否被标记需要重新布局，有则在内部调用layoutSubviews方法进行重新布局。 - (void)layoutSubviews 重写当前方法，在内部完成重新布局操作。 Masonry给我们提供了4个设置优先级接口 1234567891011// 可以设置任意的优先级，接受的参数是0-1000的数字- (MASConstraint * (^)(MASLayoutPriority priority))priority; // 设置低优先级，优先级为250- (MASConstraint * (^)())priorityLow; // 设置中优先级，优先级为500- (MASConstraint * (^)())priorityMedium; // 设置高优先级，优先级为750- (MASConstraint * (^)())priorityHigh; Masonry常用方法 基本使用：设置内边距效果图往下看：创建一个View，左右上下空出10个像素 123456789101112[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.view.mas_top).with.offset(150); make.left.equalTo(self.view.mas_left).with.offset(30); make.bottom.equalTo(self.view.mas_bottom).with.offset(30); make.right.equalTo(self.view.mas_right).with.offset(30);&#125;];//【通过insets简化设置内边距的方式】，一句代码代替上面的多行[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(self.view).with.insets(UIEdgeInsetsMake(150, 30, 30, 30));&#125;]; 简单动画：priority优先级效果图往下看：优先级约束一般放在一个控件约束的最后面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950- (void)testView2 &#123; // 红色View UIView *redView = [[UIView alloc]init]; redView.backgroundColor = [UIColor redColor]; [self.view addSubview:redView]; // 蓝色View self.blueView = [[UIView alloc]init]; self.blueView.backgroundColor = [UIColor blueColor]; [self.view addSubview:self.blueView]; // 黄色View UIView *yellowView = [[UIView alloc]init]; yellowView.backgroundColor = [UIColor yellowColor]; [self.view addSubview:yellowView]; // ---红色View--- 添加约束 [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.view.mas_left).with.offset(20); make.bottom.equalTo(self.view.mas_bottom).with.offset(-80); make.height.equalTo([NSNumber numberWithInt:50]); &#125;]; // ---蓝色View--- 添加约束 [self.blueView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.mas_equalTo(redView.mas_right).with.offset(40); make.bottom.width.height.mas_equalTo(redView); &#125;]; // ---黄色View--- 添加约束 [yellowView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.mas_equalTo(self.blueView.mas_right).with.offset(40); make.right.mas_equalTo(self.view.mas_right).with.offset(-20); make.bottom.width.height.mas_equalTo(redView); // 【优先级设置为250，最高1000（默认)】 make.left.mas_equalTo(redView.mas_right).with.offset(100).priority(250); &#125;]; NSLog(@"%@",redView);&#125;// 点击屏幕移除蓝色View- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; [self.blueView removeFromSuperview]; [UIView animateWithDuration:1.0 animations:^&#123; [self.view layoutIfNeeded]; &#125;];&#125; 注解： 这里的三个View的宽度是根据约束自动推断设置的，对黄色的View设置了一个与红色View有关的priority(250)的优先级， 它同时有对蓝色View有个最高的优先级约束（make.left.mas_equalTo(self.blueView.mas_right).with.offset(40);）。 当点击屏幕是，我将蓝色View移除，此时第二优先级就是生效。 更新约束 mas_updateConstraints效果图往下看：创建一个按钮，约束好它的位置（居中，宽高等于100且小于屏幕宽高值）。每次点击一次这个按钮，其宽高将增大一定的倍数，最终其宽高等于屏幕宽高时将不再变化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)testView3 &#123; self.growingButton = [UIButton buttonWithType:UIButtonTypeSystem]; [self setWithButton:self.growingButton title:@"mas_updateConstraints更新约束-点我放大"]; [self.growingButton addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:self.growingButton]; self.scacle = 1.0; [self.growingButton mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.mas_equalTo(self.view); // 初始宽、高为100，优先级最低 make.width.height.mas_equalTo(100 * self.scacle); // 最大放大到整个view + make.width.height.lessThanOrEqualTo(self.view); &#125;];&#125;- (void)buttonClick &#123; self.scacle += 1.0; // 告诉self.view约束需要更新 [self.view setNeedsUpdateConstraints]; // 调用此方法告诉self.view检测是否需要更新约束，若需要则更新，下面添加动画效果才起作用 [self.view updateConstraintsIfNeeded]; [UIView animateWithDuration:0.3 animations:^&#123; [self.view layoutIfNeeded]; &#125;];&#125;#pragma mark - updateViewConstraints// 重写该方法来更新约束- (void)updateViewConstraints &#123; [self.growingButton mas_updateConstraints:^(MASConstraintMaker *make) &#123; // 这里写需要更新的约束，不用更新的约束将继续存在 // 不会被取代，如：其宽高小于屏幕宽高不需要重新再约束 make.width.height.mas_equalTo(100 * self.scacle); &#125;]; [super updateViewConstraints];&#125; 重写约束 mas_remakeConstraints创建一个按钮，约束好其位置（与屏幕上左右的距离为0，与屏幕底部距离为350），点击按钮后全屏展现（即与屏幕底部距离为0）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)testView4 &#123; self.isExpanded = NO; self.growingButton = [UIButton buttonWithType:UIButtonTypeSystem]; [self setWithButton:self.growingButton title:@"mas_remakeConstraints重写约束-点我展开"]; [self.growingButton addTarget:self action:@selector(testView4BtnClick) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:self.growingButton]; [self.growingButton mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.mas_equalTo(0); make.left.right.mas_equalTo(0); make.bottom.mas_equalTo(-350); &#125;]; &#125;- (void)testView4BtnClick &#123; self.isExpanded = !self.isExpanded; if (!self.isExpanded) &#123; [self.growingButton setTitle:@"mas_remakeConstraints重写约束-点我展开" forState:UIControlStateNormal]; &#125; else &#123; [self.growingButton setTitle:@"mas_remakeConstraints重写约束-点我收起" forState:UIControlStateNormal]; &#125; // 告诉self.view约束需要更新 [self.view setNeedsUpdateConstraints]; // 调用此方法告诉self.view检测是否需要更新约束，若需要则更新，下面添加动画效果才起作用 [self.view updateConstraintsIfNeeded]; [UIView animateWithDuration:0.3 animations:^&#123; [self.view layoutIfNeeded]; &#125;];&#125;#pragma mark - updateViewConstraints- (void)updateViewConstraints &#123; // 这里使用update也能实现效果 // remake会将之前的全部移除，然后重新添加 __weak __typeof(self) weakSelf = self; [self.growingButton mas_remakeConstraints:^(MASConstraintMaker *make) &#123; // 这里重写全部约束，之前的约束都将失效 make.top.mas_equalTo(0); make.left.right.mas_equalTo(0); if (weakSelf.isExpanded) &#123; make.bottom.mas_equalTo(0); &#125; else &#123; make.bottom.mas_equalTo(-350); &#125; &#125;]; [super updateViewConstraints];&#125; 注解： mas_remakeConstraints和mas_updateConstraints 的区别在于 前者重新对视图进行了约束（抛弃了之前的约束），后者是更新约束条件（保留未更新的约束)， 如：这次更新了对 height 的约束，其他对X&amp;Y以及宽的约束不变）。 比例使用 multipliedBy使用multipliedBy必须是对同一个控件本身，如果修改成相对于其它控件会出导致Crash。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)testView5 &#123; UIView *topView = [[UIView alloc]init]; [topView setBackgroundColor:[UIColor redColor]]; [self.view addSubview:topView]; UIView *topInnerView = [[UIView alloc]init]; [topInnerView setBackgroundColor:[UIColor greenColor]]; [topView addSubview:topInnerView]; UIView *bottomView = [[UIView alloc]init]; [bottomView setBackgroundColor:[UIColor blueColor]]; [self.view addSubview:bottomView]; UIView *bottomInnerView = [[UIView alloc]init]; [bottomInnerView setBackgroundColor:[UIColor blackColor]]; [bottomView addSubview:bottomInnerView]; [topView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.left.right.mas_equalTo(0); make.height.mas_equalTo(bottomView); &#125;]; [topInnerView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.right.mas_equalTo(0); // 求解❓ make.width.mas_equalTo(topInnerView.mas_height).multipliedBy(2); make.center.mas_equalTo(topView); &#125;]; [bottomView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.bottom.right.mas_equalTo(0); make.height.mas_equalTo(topView); make.top.mas_equalTo(topView.mas_bottom); &#125;]; [bottomInnerView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.bottom.mas_equalTo(bottomView); make.height.mas_equalTo(bottomInnerView.mas_width).multipliedBy(4); make.center.mas_equalTo(bottomView); &#125;]; // NSLog(@"%@",NSStringFromCGRect(topInnerView.bounds));&#125;在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量@jianshu - 白开水ln。 大于等于和小于等于某个值的约束 参考：http://www.jianshu.com/p/99c418cd11f7 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>工具&amp;插件</category>
      </categories>
      <tags>
        <tag>Masonry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 伐码猿真爱—「偷懒 || 效率 工具类」]]></title>
    <url>%2FToolsAndPlugins%2FTools.html</url>
    <content type="text"><![CDATA[自检代码不会可以多敲几次，学习的重点是思想；– 认同。BUT如果你把自己会的、熟知的、可以说写的似流水的代码，不管是在工作 或是 自学习中你还是一点一点的敲出来，是不是有点…&lt;你脑补的是啥就是啥&gt;，copy &amp; paste 你可以认为是偷懒，我认为是为了效率😊； 本篇文章主要从【伐码猿 偷懒 || 效率 工具类】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量@jianshu - 白开水ln。 工具类 示例 MyUIKit-Category UITextField+Placeholder.h 12345678910111213/* *【设置占位文字的颜色】 * @param placeholderColor 占位文字的颜色 属性 * 通过这个属性名，就可以修改textField内部的占位文字颜色 */@property UIColor *placeholderColor;/* *【方式四：runtime交换方法(修改UITextField的占位文字，且设置文字和文字颜色是无序的)】 * @param placeholder 占位文字 */- (void)setLN_Placeholder:(NSString *)placeholder; UIImage+image.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* *【返回一张没有经过渲染的图片】 * @param imageName 原始的图片 */+ (UIImage *)ln_imageWithOriginalImageName:(NSString *)imageName;- (UIImage *)ln_imageWithOriginalImage;/* *【返回一张受保护的图片(被拉伸的)】 * @param prImageName 原始的图片 */+ (instancetype)ln_resizeImage:(NSString *)imageName;- (UIImage *)ln_resizeImage;/* *【根据颜色生成一张尺寸为1*1的相同颜色图片】 * @param color 颜色 */+ (UIImage *)ln_imageWithColor:(UIColor *)color;/* *【根据传入的图片,生成一张带有边框的圆形图片】 * * @param image 原始图片 * @param borderW 边框宽度 * @param borderColor 边框颜色 */+ (UIImage *)ln_imageWithCircleImage:(NSString *)imageName Border:(CGFloat)borderW color:(UIColor *)borderColor;- (instancetype)ln_circleImageWithBorder:(CGFloat)borderW color:(UIColor *)borderColor;/* *【返回一张绘制字符串的图片】 */+ (UIImage *)ln_imageWithNSString:(NSString *)string font:(CGFloat)textFont color:(UIColor *)textColor clip:(BOOL)clip drawAtImage:(UIImage *)image drawAtPoint:(CGPoint)atPoint;/* *【根据传入的图片,返回一张圆形图片】 */- (instancetype)ln_circleImage;+ (instancetype)ln_circleImageNamed:(NSString *)name;/* *【返回一张抗锯齿图片】 * 本质：在图片生成一个透明为1的像素边框 */- (UIImage *)ln_imageAntialias;/* *【固定宽度与固定高度】 */- (UIImage *)scaleWithFixedWidth:(CGFloat)width;- (UIImage *)scaleWithFixedHeight:(CGFloat)height;/* *【裁剪图片的一部分】 */- (UIImage *)croppedImageAtFrame:(CGRect)frame;/* *【将自身填充到指定的size】 */- (UIImage *)fillClipSize:(CGSize)size; MyFoundation-Category NSString+String.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 计算字符串宽度(指当该字符串放在view时的自适应宽度) * * @param size 填入预留的大小 * @param font 字体大小 * @param isBold 字体是否加粗 * * @return 返回CGRect */- (CGRect)stringWidthRectWithSize:(CGSize)size fontOfSize:(CGFloat)font isBold:(BOOL)isBold;/** * @brief 根据字数的不同,返回UILabel中的text文字需要占用多少Size * @param size 约束的尺寸 * @param font 文本字体 * @return 文本的实际尺寸 */- (CGSize)textSizeWithContentSize:(CGSize)size font:(UIFont *)font;/** * @brief 根据文本字数/文本宽度约束/文本字体 求得text的Size * @param width 宽度约束 * @param font 文本字体 * @return 文本的实际高度 */- (CGFloat)textHeightWithContentWidth:(CGFloat)width font:(UIFont *)font;/** * @brief 根据文本字数/文本宽度约束/文本字体 求得text的Size * @param height 宽度约束 * @param font 文本字体 * @return 文本的实际长度 */- (CGFloat)textWidthWithContentHeight:(CGFloat)height font:(UIFont *)font;//--------------------------- 【正则表达式】 ------------------------------////- (BOOL)isQQ;- (BOOL)isPhoneNumber;- (BOOL)isIPAddress;//--------------------------- 【目录全路径】 ------------------------------/////** * md5加密 */+ (NSString*)md5HexDigest:(NSString*)input;/** * 根据文件名计算出文件大小 */- (unsigned long long)lx_fileSize;/** * 生成缓存目录全路径 */- (instancetype)cacheDir;/** * 生成文档目录全路径 */- (instancetype)docDir;/** * 生成临时目录全路径 */- (instancetype)tmpDir; NSDictionary+Property.h 1234/* *【字典转模型KVC实现(自动生成模型属性代码)】 */- (void)createPropertyCode; 工具图 【@码员真爱 : 真的不点进去阅读一下 ❓】【译文 &amp; 源码】 【工具类】]]></content>
      <categories>
        <category>工具&amp;插件</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 模块详解—「多线程面试、工作」看我就 🐒 了 ^_^.]]></title>
    <url>%2FiOSNET%2FMultithreading.html</url>
    <content type="text"><![CDATA[引导Copyright © 白开水ln Unauthorized shall not be *copy reprinted* 。Authorization © JaneBook：白开水ln E-mail：pbwaterln@sina.com 谈到iOS多线程，想必大家第一反应就是多线程4种实现方案 1.pthread、2.NSThread、3.GCD、4.NSOperation；它们每个的用法、特点、应用场景及注意点，文章会一一讲到。 本篇文章主要从【iOS多线程模块】学习总结，在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量@白开水ln。 目录： 多线程相关概念1.进程和线程概念2.多线程概念3.主线程4.GCD相关概念 pthread &amp; NSThread1.pthread2.NSThread1&gt; NSThread创建线程有3个方法2&gt; NSThread其它方法3&gt; NSThread线程安全4&gt; NSThread线程间通信5&gt; NSThread线程状态转换 GCD中枢调度器1.什么是GCD2.GCD基本概念3.任务&amp;队列组合使用4.GCD的优势5.GCD基本使用6.GCD常见用法和应用场景7.内存和安全8.单例模式9.总结 NSOperation操作队列1.什么是NSOperation2.NSOperation相关概念3.NSInvocationOperation &amp; NSBlockOperation4.NSOperation优势5.NSOperation基本使用6.NSOperation结合NSOperationQueue使用7.非主队列控制串行和并行执行的关键8.添加操作依赖和操作监听9.NSOperation线程间通信10.管理操作：是操作队列的方法 多线程相关概念篇 1.进程进程是指在系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。 2.线程基本概念：1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程），线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。线程的串行：1个线程中的任务的执行是串行(按顺序地执行)，如果要在1个线程中执行多个任务，那么只能一个一个按顺序执行这些任务（也就是说，在同一时间内，1个线程只能执行一个任务） 3.进程和线程的比较1、进程是CPU分配资源和调度的单位2、线程是CPU调用(执行任务)的最小单位3、一个程序可以对应多个进程，一个进程中可以有多个线程，但至少要有一个线程4、同一个进程内的线程共享进程的资源 多线程概念多线程概念：即1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务多线程并发执行：在同一时间里，CPU只能处理1条线程，只有1条线程在工作（执行）；多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。 多线程优缺点：优点：1、能适当提高程序的执行效率2、能适当提高资源利用率（CPU、内存利用率）缺点：1、开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能2、线程越多，CPU在调度线程上的开销就越大3、程序设计更加复杂：比如线程之间的通信、多线程的数据共享 主线程主线程：程序运行后，默认会开启1条线程作用：刷新显示UI,处理UI事件使用注意：1、不要将耗时操作放到主线程中去处理，会卡住线程，严重影响UI界面的流畅度，给用户界面卡顿的现象(放到子线程中执行)；2、和UI相关的刷新操作必须放到主线程中进行处理 多线程实现方案 特点 语言 频率 线程生命周期 pthread 1、一套通用的多线程API 2、适用于Unix\Linux\Windows等系统 3、跨平台\可移植 4、使用难度大 c语言 几乎不用 由程序员进行管理 NSThread 1、使用更加面向对象 2、简单易用，可直接操作线程对象 OC语言 偶尔使用 由程序员进行管理 GCD 1、旨在替代NSThread等线程技术 2、充分利用设备的多核（自动） C语言 经常使用 自动管理 NSOperation 1、基于GCD（底层是GCD） 2、比GCD多了一些更简单实用的功能 3、使用更加面向对象 OC语言 经常使用 自动管理 GCD相关概念初学GCD的时候，肯定会纠结一些看似很关键但却毫无意义的问题(不要纠结，概念理解的基础+实战，就会解决你的疑惑)，对于GCD需要关注的只有两个概念：任务、队列。 1.任务linux内核中的任务的定义是描述进程的一种结构体，而GCD中的任务只是一个代码块，它可以指一个block或者函数指针。根据这个代码块添加进入队列的方式，将任务分为异步任务和同步任务：异步任务：使用dispatch_async将任务加入队列。将异步任务加入并发队列，会开启多条线程且任务是并发执行(这也是我们最常用的一种方式)；将异步任务加入串行队列，会开启一条线程且任务是串行执行(按顺序执行)；将异步任务加入主队列，不会开启线程且任务都在主线程中执行。同步任务：使用dispatch_sync将任务加入队列。将同步任务加入并发队列，不会开启线程且任务是串行执行；将同步任务加入串行队列，不会开启线程且任务是串行执行(也没什么意义是吧)；将同步任务加入主队列，不会开启线程且任务都在主线程中执行（注意：方法在主线程调用会造成死锁，在子线程中调用不会造成死锁）。 2.队列调度队列是一个对象，它会以first-in、first-out的方式管理您提交的任务。GCD有三种队列类型并行队列：并发队列虽然是能同时执行多个任务，但这些任务仍然是按照先到先执行(FIFO)的顺序来执行的。并发队列会基于系统负载来合适地选择并发执行这些任务。并发队列一般指的就是全局队列(Global queue)，进程中存在四个全局队列：高、中(默认)、低、后台四个优先级队列，可以调用dispatch_get_global_queue函数传入优先级来访问队列。当然我们也可以用dispatch_queue_create，并指定队列类型DISPATCH_QUEUE_CONCURRENT，来自己创建一个并发队列。 串行队列：串行队列将任务以先进先出(FIFO)的顺序来执行，所以串行队列经常用来做访问某些特定资源的同步处理。你可以也根据需要创建多个队列，而这些队列相对其他队列都是并发执行的。换句话说，如果你创建了4个串行队列，每一个队列在同一时间都只执行一个任务，对这四个任务来说，他们是相互独立且并发执行的。如果需要创建串行队列，一般用dispatch_queue_create这个方法来实现，并指定队列类型DISPATCH_QUEUE_SERIAL。 主队列：主队列，与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。main queue可以调用dispatch_get_main_queue()来获得。因为main queue是与主线程相关的，所以这是一个串行队列。和其它串行队列一样，这个队列中的任务一次只能执行一个。它能保证所有的任务都在主线程执行，而主线程是唯一可用于更新 UI 的线程。 注：队列间的执行是并行的，但是也存在一些限制。比如，并行执行的队列数量受到内核数的限制，无法真正做到大量队列并行执行；比如，对于并行队列中的全局队列而言，其存在优先级关系，执行的时候也会遵循其优先顺序，而不是并行。 以上概念文言文你也许感到有点什么，下面总结简单小表格方便你查看 3.GCD总结小表格 GCD 特点 核心概念 任务：执行什么操作 队列：用来存放任务 函数 异步：可以在新的线程中执行任务，具备开启新线程的能力 同步：只能在当前线程中执行任务，不具备开启新线程的能力 队列 并发：允许多个任务并发（同时）执行（自动开启多个线程同时执行任务），并发功能只有在异步函数下才有效 串行：一个任务执行完毕后，再执行下一个任务（按顺序执行） 全局并发队列 特点：存在优先级关系（DEFAULT默认的、HIGH高的、LOW低的、BACKGROUND最低的） 主队列 特点：添加到主队列上的任务，必须在主线程执行。如果主队列发现当前主线程有任务在执行，那么主队列会暂停调用队列中的任务，直到主线程空闲为止 对于 任务与队列 之间的关系，下面总结简单小表格方便你查看 任务 &amp; 队列 并发队列(concurrent) 串行队列(serial) 主队列(get_main) 异步函数(async) 会开启多条线程，队列中的任务是并发执行 会开启一条线程，队列中的任务是串行执行 不会开启线程，所有任务都在主线程中执行 同步函数(sync) 不会开启线程，队列中的任务是串行执行 不会开启线程，队列中的任务是串行执行 不会开启线程，所有任务都在主线程中执行（注意：在主线程调用会造成死锁，在子线程中调用不会造成死锁） pthread &amp; NSThread篇 1.pthread其实这个方案开发几乎不用，只是拿来充个数，为让大家了解一下就好了简单介绍下，pthread是一套通用的多线程的API，可以在Unix / Linux / Windows 等系统跨平台使用，使用C语言编写，需要程序员自己管理线程的生命周期，使用难度较大，所以仅了解，看一遍有个印象。 pthread使用方法1234567891011121314#pragma mark - pthread创建子线程- (void)pthread &#123; //1.创建线程对象 pthread_t thread; //2.创建线程 //参数:线程对象(传递地址)，线程的属性(NULL)，指向函数的指针，函数需要接受的参数 pthread_create(&amp;thread, NULL, task, NULL);&#125;void *task(void *param) &#123; NSLog(@"%@",[NSThread currentThread]); return NULL;&#125; 打印输出：12016-02-10 19:10:36.902 多线程2.4[9565:222926] &lt;NSThread: 0x600000275540&gt;&#123;number = 3, name = (null)&#125; 应用场景：我们在iOS开发中几乎不使用pthread 2.NSThread这个方案是经过苹果封装后的，使用更加面向对象，简单易用可直接操作线程对象，但是，它的生命周期还是需要我们手动管理，所以这个方案也是偶尔用用，比如 [NSThread currentThread]用来获得当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便。下面来看看它的一些用法 1.NSThread创建线程有3个方法首先要包含头文件#import &lt;pthread.h&gt; 方法一：创建线程且手动启动12NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(task:) object:nil];[thread start]; 方法二：分离子线程并自动启动1[NSThread detachNewThreadSelector:@selector(thread:) toTarget:self withObject:nil]; 方法三：后台线程并自动启动1[self performSelectorInBackground:@selector(thread:) withObject:@"开启后台线程"]; 2.NSThread其他方法除了创建启动外，NSThread 还以很多方法，下面我列举一些常见的方法，当然我列举的并不完整，更多方法大家可以去类的定义里去看1234567891011121314151617181920212223242526272829303132333435// 取消线程- (void)cancel;// 启动线程- (void)start;// 强制停止线程+ (void)exit;// 判断某个线程的状态的属性@property (readonly, getter=isExecuting) BOOL executing;@property (readonly, getter=isFinished) BOOL finished;@property (readonly, getter=isCancelled) BOOL cancelled;// 设置和获取线程名字-(void)setName:(NSString *)n;-(NSString *)name;// 设置优先级（取值范围 0.0 ~ 1.0 之间 最高是1.0 默认优先级是0.5）+ (double)threadPriority;+ (BOOL)setThreadPriority:(double)p;// 获取当前线程信息+ (NSThread *)currentThread;// 获取主线程信息+ (NSThread *)mainThread;// 判断是否为主线程(对象方法)- (BOOL)isMainThread;// 判断是否为主线程(类方法)+ (BOOL)isMainThread;// 阻塞线程（延迟执行）+ (void)sleepForTimeInterval:(NSTimeInterval)time;+ (void)sleepUntilDate:(NSDate *)date; 2.NSThread线程安全 线程安全，解决方法采用线程加锁，需了解互斥锁 互斥锁使用格式:@synchronized (self) {// 需要锁定的代码 }注意：锁定一份代码只用一把锁，用多把锁是无效的 互斥锁的优缺点:优点:能有效防止因多线程抢夺资源造成的数据安全问题缺点:需要消耗大量的CPU资源 互斥锁注意点:锁:必须是全局唯一的（通常用self）1.注意加锁的位置2.注意加锁的前提条件,多线程共享同一块资源3.注意加锁是需要代价的,需要耗费性能的4.加锁的结果:线程同步（按顺序执行） 补充:我们知道, 属性中有atomic和nonatomic属性 atomic : setter方法线程安全, 需要消耗大量的资源 nonatomic : setter方法非线程安全, 适合内存小的移动设备 3.NSThread线程间通信线程间通信：任务从子线程回到主线程1234567/** 线程间通信(回到主线程刷新UI) 参数：回到主线程要调用那个方法、前面方法需要传递的参数、是否等待（YES执行完再执行下面代码，NO可先执行下面代码）*/[self performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:NO];[self performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:NO]; 4.NSThread线程状态转换 GCD中枢调度器 1.什么是GCD GCD全称 Grand Central Dispath，可译为”强大的中枢调度器”，基于libdispatch 纯C语言，里面包含了许多多线程相关非常强大的函数. 程序员可以既不写一句线程管理的代码又能很好地使用多线程执行任务。 2.GCD基本概念初学GCD的时候，肯定会纠结一些看似很关键但却毫无意义的问题(不要纠结，概念理解的基础+实战，就会解决你的疑惑)，对于GCD需要关注的只有两个概念：任务 &amp; 队列。而对于GCD相关的概念解读，如果你对这些都已有了解 可以忽略，如果还有疑虑可以参考一下 「iOS多线程—夯实基础「多线程基本概念」 在这里就提供 GCD主要概念简单总结小表格，方便你查看。 GCD 特点 核心概念 任务：执行什么操作 队列：用来存放任务 函数 异步：可以在新的线程中执行任务，具备开启新线程的能力 同步：只能在当前线程中执行任务，不具备开启新线程的能力 队列 并发：允许多个任务并发（同时）执行（自动开启多个线程同时执行任务），并发功能只有在异步函数下才有效 串行：一个任务执行完毕后，再执行下一个任务（按顺序执行） 全局并发队列 特点：存在优先级关系（DEFAULT默认的、HIGH高的、LOW低的、BACKGROUND最低的） 主队列 特点：添加到主队列上的任务，必须在主线程执行。如果主队列发现当前主线程有任务在执行，那么主队列会暂停调用队列中的任务，直到主线程空闲为止 3.任务&amp;队列组合使用下面总结简单小表格方便你查看 任务 &amp; 队列 并发队列(concurrent) 串行队列(serial) 主队列(get_main) 异步函数(async) 会开启多条线程，队列中的任务是并发执行 会开启一条线程，队列中的任务是串行执行 不会开启线程，所有任务都在主线程中执行 同步函数(sync) 不会开启线程，队列中的任务是串行执行 不会开启线程，队列中的任务是串行执行 不会开启线程，所有任务都在主线程中执行（注意：在主线程调用会造成死锁，在子线程中调用不会造成死锁） 4.GCD的优势易用: GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱,而是因为基于block，它能极为简单得在不同代码作用域之间传递上下文。灵活: GCD 具有在常见模式(比如互斥锁、单例模式)上的特点，且会自动管理线程的生命周期创建线程、调度任务、销毁线程），用更高性能的方法优化代码，而且GCD(C API)能提供更多的控制权力以及大量的底层函数。性能: GCD 会自动利用更多的CPU内核（比如双核、四核）,且自动根据系统负载来增减线程数量，这就减少了线程间切换以及增加了计算效率。 怎么样? 心动不, 迫不及待想要知道怎么使用GCD了吧, 那我们正式投入GCD的怀抱了~我会通过代码展示。 5.GCD基本使用12345678910111213141516171819/** 1.创建队列 queue1:全局并行队列（默认优先级，可为0）、queue2:主队列、queue3:未指定type则为串行队列、queue4:指定串行队列、queue5:指定并发队列 */dispatch_queue_t queue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_queue_t queue2 = dispatch_get_main_queue();dispatch_queue_t queue3 = dispatch_queue_create("queue3", NULL);dispatch_queue_t queue4 = dispatch_queue_create("queue4", DISPATCH_QUEUE_SERIAL);dispatch_queue_t queue5 = dispatch_queue_create("queue5", DISPATCH_QUEUE_CONCURRENT);// 2.封装异步任务添加到队列dispatch_async(queue1, ^&#123; // 任务&#125;);// 封装同步任务添加到队列dispatch_sync(queue1, ^&#123; // 任务&#125;); 6.GCD常见用法和应用场景1.dispatch_async 异步函数使用方法:(线程间通信)12345678// 1.创建子线程dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // 执行任务 ... dispatch_async(dispatch_get_main_queue(), ^&#123; // 回到主线程刷新UI ... &#125;);&#125;); 应用场景:这种用法非常常见，比如开启一个异步的网络请求，待数据返回后返回主队列刷新UI；又比如请求图片，待图片返回刷新UI或是耗时文件操作等等。 2.dispatch_after 延迟执行使用方法:(多个方法，好对比)123456789101112131415161718// 方法一:调用NSObject的方法//[self performSelector:@selector(task) withObject:nil afterDelay:2.0];// 方法二:使用NSTimer//[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(task) userInfo:nil repeats:YES];// 方法三:使用GCD(优点:可以控制任务在那个线程执行)//dispatch_queue_t queue = dispatch_get_main_queue();dispatch_queue_t queue = dispatch_get_global_queue(0, 0);/* 第一个参数:DISPATCH_TIME_NOW 从现在开始计算时间 第二个参数:延迟的时间 2.0 GCD时间单位:纳秒 第三个参数:队列 */dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), queue, ^&#123; NSLog(@"GCD----%@",[NSThread currentThread]);&#125;); 应用场景:这为我们提供了一个简单的延迟执行的方式，比如在view加载结束延迟执行一个动画等等 3.dispatch_time 延迟时间使用方法:123456789// dispatch_time_t一般在dispatch_after和dispatch_group_wait等方法里作为参数使用。这里最需要注意的是一些宏的含义。// NSEC_PER_SEC，每秒有多少纳秒。// USEC_PER_SEC，每秒有多少毫秒。// NSEC_PER_USEC，每毫秒有多少纳秒。// DISPATCH_TIME_NOW 从现在开始// DISPATCH_TIME_FOREVE 永久// time为2s的写法dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC); 4.dispatch_once_t 一次性代码使用方法:(保证某段代码在程序运行过程中只被执行1次)123456// onceToken用来记录该部分的代码是否被执行过static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; // 只执行1次的代码(这里面默认是线程安全的) NSLog(@"---once----");&#125;); 应用场景:可以使用其创建一个单例，也可以做一些其他只执行一次的代码，注意:看到一次性代码你可能会想到懒加载，提醒dispatch_once_t 不能放在懒加载中的 5.dispatch_barrier_async 栅栏函数使用方法:1234567891011121314151617181920212223// dispatch_barrier_async 作用可一个词概括一一承上启下- (void)barrier &#123; // 注意:栅栏函数(不能使用全局并发队列) //dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_queue_t queue = dispatch_queue_create("concurrent", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; NSLog(@"download1---%@",[NSThread currentThread]); &#125;); [NSThread sleepForTimeInterval:5];// 睡眠5s dispatch_async(queue, ^&#123; NSLog(@"download2---%@",[NSThread currentThread]); &#125;); [NSThread sleepForTimeInterval:5]; // 栅栏函数 dispatch_barrier_async(queue, ^&#123; NSLog(@"++++++++++++++++++++++"); &#125;); dispatch_async(queue, ^&#123; NSLog(@"download3---%@",[NSThread currentThread]); &#125;);&#125; 栅栏函数使用全局并发队列，打印输出12342016-02-11 14:45:43.228 多线程2.4[17420:450903] download1---&lt;NSThread: 0x60800007dd00&gt;&#123;number = 3, name = (null)&#125;2016-02-11 14:45:43.228 多线程2.4[17420:450906] ++++++++++++++++++++++2016-02-11 14:45:43.228 多线程2.4[17420:450943] download3---&lt;NSThread: 0x600000264440&gt;&#123;number = 5, name = (null)&#125;2016-02-11 14:45:43.228 多线程2.4[17420:450904] download2---&lt;NSThread: 0x600000260b40&gt;&#123;number = 4, name = (null)&#125; 栅栏函数使用手动创建并发队列，打印输出12342016-02-11 14:51:27.502 多线程2.4[17537:454708] download2---&lt;NSThread: 0x60000007e6c0&gt;&#123;number = 4, name = (null)&#125;2016-02-11 14:51:27.502 多线程2.4[17537:454709] download1---&lt;NSThread: 0x60800007f5c0&gt;&#123;number = 3, name = (null)&#125;2016-02-11 14:51:27.502 多线程2.4[17537:454709] ++++++++++++++++++++++2016-02-11 14:51:27.503 多线程2.4[17537:454709] download3---&lt;NSThread: 0x60800007f5c0&gt;&#123;number = 3, name = (null)&#125; 应用场景:和dispatch_group类似，dispatch_barrier也是异步任务间的一种同步方式，可以在比如文件的读写操作时使用，保证读操作的准确性。注意:dispatch_barrier_async只在自己创建的并发队列上有效。 6.dispatch_apply 快速迭代使用方法:1234567891011// 注意:会开子线程和主线程一起完成遍历任务，任务的执行是并发的- (void)apply &#123; /** iterations 遍历的次数 queue 队列(只能是并发队列，传主队列会造成死锁，传串行队列无效果) index 索引 */ dispatch_apply(4, dispatch_get_global_queue(0, 0), ^(size_t index) &#123; NSLog(@"download--%zd--%@",index,[NSThread currentThread]); &#125;);&#125; 打印输出:12342016-02-11 15:19:53.490 多线程2.4[18411:477679] download--3--&lt;NSThread: 0x608000073940&gt;&#123;number = 5, name = (null)&#125;2016-02-11 15:19:53.490 多线程2.4[18411:477641] download--0--&lt;NSThread: 0x608000066c00&gt;&#123;number = 1, name = main&#125;2016-02-11 15:19:53.490 多线程2.4[18411:477682] download--1--&lt;NSThread: 0x600000076f00&gt;&#123;number = 3, name = (null)&#125;2016-02-11 15:19:53.490 多线程2.4[18411:477680] download--2--&lt;NSThread: 0x600000077100&gt;&#123;number = 4, name = (null)&#125; 应用场景:dispatch_apply并行的运行机制，效率一般快于for循环的类串行机制（在for一次循环中的处理任务很多时差距比较大）。比如这可以用来拉取网络数据后提前算出各个控件的大小，防止绘制时计算，提高表单滑动流畅性，如果用for循环，耗时较多，并且每个表单的数据没有依赖关系，所以用dispatch_apply比较好。 7.dispatch_group_t 队列组使用方法:123456789101112131415161718192021222324252627282930// 队列组：会监听任务的执行情况，通知group- (void)group1 &#123; dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^&#123; NSLog(@"1-----%@", [NSThread currentThread]); &#125;); [NSThread sleepForTimeInterval:2]; dispatch_group_async(group, queue, ^&#123; NSLog(@"2-----%@", [NSThread currentThread]); &#125;); [NSThread sleepForTimeInterval:2]; dispatch_group_async(group, queue, ^&#123; NSLog(@"3-----%@", [NSThread currentThread]); &#125;); [NSThread sleepForTimeInterval:2]; // 方法一:组通知 // 拦截通知，当队列组中所有的任务都执行完毕的时候回进入到这个方法 //dispatch_group_notify(group, queue, ^&#123; // NSLog(@"----group_notify---"); //&#125;); // 方法二:组等待 dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@"----end----");&#125; group_notify 打印输出:123452016-02-11 15:40:30.083 多线程2.4[19029:495158] 1-----&lt;NSThread: 0x608000073ac0&gt;&#123;number = 3, name = (null)&#125;2016-02-11 15:40:32.084 多线程2.4[19029:495158] 2-----&lt;NSThread: 0x608000073ac0&gt;&#123;number = 3, name = (null)&#125;2016-02-11 15:40:34.084 多线程2.4[19029:495158] 3-----&lt;NSThread: 0x608000073ac0&gt;&#123;number = 3, name = (null)&#125;2016-02-11 15:40:36.085 多线程2.4[19029:494872] ----end----2016-02-11 15:40:36.085 多线程2.4[19029:495158] ----group_notify--- group_wait 打印输出:12342016-02-11 15:38:30.374 多线程2.4[18909:492794] 1-----&lt;NSThread: 0x608000266900&gt;&#123;number = 3, name = (null)&#125;2016-02-11 15:38:35.374 多线程2.4[18909:492794] 2-----&lt;NSThread: 0x608000266900&gt;&#123;number = 3, name = (null)&#125;2016-02-11 15:38:40.376 多线程2.4[18909:492794] 3-----&lt;NSThread: 0x608000266900&gt;&#123;number = 3, name = (null)&#125;2016-02-11 15:38:45.377 多线程2.4[18909:492734] ----end---- 注意:group_notify 拦截通知，当队列组中所有的任务都执行完毕的时候回进入到这个方法，问题? 该方法是阻塞的吗? –&gt; 内部本身是异步的。group_wait 等待.死等. 直到队列组中所有的任务都执行完毕之后才能执行，(DISPATCH_TIME_NOW : 现在，DISPATCH_TIME_FOREVER : 永远) 作用：阻塞。 8.dispatch_sync 死锁怎样会造成死锁 &amp; 如何避开死锁使用方法:12345678910111213141516- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 直接调用，主线程调用 会造成死锁 //[self syncMain]; // 正确调用，子线程中调用 不会造成死锁 [NSThread detachNewThreadSelector:@selector(syncMain) toTarget:self withObject:nil]; &#125;- (void)syncMain &#123; // 1.获得主队列 dispatch_queue_t queue = dispatch_get_main_queue(); // 2.同步函数 dispatch_sync(queue, ^&#123; NSLog(@"download1---%@",[NSThread currentThread]); &#125;); 打印输出:12341.在主线程调用 会造成死锁2.在子线程中调用 不会造成死锁2016-02-11 16:29:59.410 多线程2.4[19986:525068] download1---&lt;NSThread: 0x60800007a640&gt;&#123;number = 1, name = main&#125; 下面这种情况，也会造成死锁123456789101112// 死锁- (void)syncMain2 &#123; // 因为dispatch_apply会卡住当前线程，内部的dispatch_apply会等待外部，外部的等待内部，所以死锁。 dispatch_queue_t queue = dispatch_queue_create("queue", DISPATCH_QUEUE_SERIAL); dispatch_apply(4, queue, ^(size_t index) &#123; NSLog(@"download1--%zd--%@",index,[NSThread currentThread]); NSLog(@"+++++++++++++++"); dispatch_apply(4, queue, ^(size_t index) &#123; NSLog(@"download2--%zd--%@",index,[NSThread currentThread]); &#125;); &#125;);&#125; 9.dispatch_suspend&amp;dispatch_resume 挂起队列和恢复队列使用方法:123dispatch_queue_t queue = dispatch_get_main_queue();dispatch_suspend(queue); // 挂起(暂停)队列dispatch_resume(queue); // 恢复队列 应用场景:有时候，我们不想让队列中的某些任务马上执行，这时我们可以通过挂起操作来阻止一个队列中将要执行的任务。注意:执行挂起操作不会对已经开始执行的任务起作用，它仅仅只会阻止将要进行但是还未开始的任务。 7.内存和安全内存MRC：用dispatch_retain和dispatch_release管理dispatch_object_t内存。ARC：ARC在编译时刻自动管理dispatch_object_t内存，使用retain和release会报错。 安全dispatch_queue是线程安全的，你可以随意往里面添加任务。 补充1.注意ARC不是垃圾回收机制，是编译器特性配置MRC环境：build setting -&gt;搜索automatic ref-&gt;修改为NO 2.在MRC环境下，如果用户retain了一次，那么直接返回instance变量，不对引用计数器+1如果用户release了一次，那么什么都不做，因为单例模式在整个程序运行过程中都拥有且只有一份，程序退出之后被释放，所以不需要对引用计数器操作 8.单例模式单例也就是在程序的整个生命周期中, 该类有且仅有一个实例对象, 此时为了保证只有一个实例对象, 我们这里用到了dispatch_once函数 在这里我就整理好吧，就不直接粘上代码了，可能会很多地方用到，到时会很麻烦。下面整理了单例模式通用的宏，如果你需要可以直接拷走，是吧~1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 定义带参数的宏// MRC单例模式 &amp; ARC单例模式#define SingleH(name) +(instancetype)share##name;#if __has_feature(objc_arc)//条件满足 ARC#define SingleM(name) static id _instance;\+(instancetype)allocWithZone:(struct _NSZone *)zone\&#123;\ static dispatch_once_t onceToken;\ dispatch_once(&amp;onceToken, ^&#123;\ _instance = [super allocWithZone:zone];\ &#125;);\ return _instance;\&#125;\+(instancetype)share##name\&#123;\ return [[self alloc]init];\&#125;\-(id)copyWithZone:(NSZone *)zone\&#123;\ return _instance;\&#125;\-(id)mutableCopyWithZone:(NSZone *)zone\&#123;\ return _instance;\&#125;#else//MRC#define SingleM(name) static id _instance;\+(instancetype)allocWithZone:(struct _NSZone *)zone\&#123;\ static dispatch_once_t onceToken;\ dispatch_once(&amp;onceToken, ^&#123;\ _instance = [super allocWithZone:zone];\ &#125;);\ return _instance;\&#125;\+(instancetype)share##name\&#123;\ return [[self alloc]init];\&#125;\-(id)copyWithZone:(NSZone *)zone\&#123;\ return _instance;\&#125;\-(id)mutableCopyWithZone:(NSZone *)zone\&#123;\ return _instance;\&#125;\-(oneway void)release&#123;&#125;\-(instancetype)retain\&#123;\ return _instance;\&#125;\-(NSUInteger)retainCount\&#123;\ return MAXFLOAT;\&#125;#endif 9.总结GCD可进行线程间通信GCD可以办到线程安全GCD可用于延迟执行GCD需要注意死锁问题(不要在当前队列调用同步函数) NSOperation操作队列篇 1.什么是NSOperationNSOperation是苹果提供给我们的一套多线程解决方案。实际上NSOperation是基于GCD 的封装，完全面向对象，但是比GCD更简单易用、代码可读性也更高，使用也更好理解。使用起来也和GCD差不多，其中 NSOperation相当于GCD中的任务，而NSOperationQueue则相当于GCD中的队列。注意:NSOperation需要配合NSOperationQueue来实现多线程（1.将要操作任务封装到一个NSOperation对象中，2.将此任务添加到一个NSOperationQueue对象中，然后系统就会自动在执行任务）。因为默认情况下，NSOperation单独使用时系统同步执行操作，并没有开辟新线程的能力，只有配合NSOperationQueue才能实现异步执行。 2.NSOperation相关概念 并行(Concurrent) &amp; 串行(Serial)并行和串行描述的是任务和任务之间的执行方式，并行是任务A和任务B可以同时执行，串行是任务A执行完了任务B才能执行(按顺序执行)。 异步(Asynchronous) &amp; 同步(Synchronous)异步和同步描述的其实就是函数什么时候返回. 比如用来下载图片的函数: 同步函数只有在image下载结束之后才返回, 下载的这段时间函数只能等待，而异步函数,不会去等它完成(异步函数不会堵塞当前线程去执行下一个函数)。 并发(Concurrency) &amp; 并行(Parallelism)这个更容易混淆了, 并发和并行都是用来让不同的任务可以”同时执行”。 只是并行是真同时，而并发是假同时(是CPU地在各个进程之间快速切换, 给人一种能同时处理多任务的错觉)。 3.NSInvocationOperation&amp; NSBlockOperationNSOperation是一个抽象类,它不能直接使用,所以你必须使用NSOperation子类,系统已经给我们封装了NSBlockOperation和 NSInvocationOperation这两个实体类，不过我们更多的使用是自己继承并定制自己的操作。 1.NSInvocationOperation：使用这个类来初始化一个操作,它包括指定对象的调用selector。 2.NSBlockOperation：使用这个类来用一个或多个block初始化操作,操作本身可以包含多个块。当所有block被执行操作将被视为完成。 4.NSOperation优势 NSOperation是基于GCD的封装, 拥有更多的API(suspended, cancelled). 在NSOperationQueue中, 可以指定各个NSOperation之间的依赖关系(注意:不能相互依赖). 用KVO可以方便的监测NSOperation的状态(isExecuted, isFinished, isCancelled). 更高的可定制能力, 你可以继承NSOperation实现可复用的逻辑模块. 5.NSOperation基本使用在不使用NSOperationQueue，需要调用 start 方法来启动任务，不开启新线程，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。 1.NSInvocationOperation12345678910NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(download) object:nil];[op1 start];// 启动``` 2.NSBlockOperation```objcNSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(download) object:nil];[op1 start]; 这里，NSBlockOperation 还有一个方法：addExecutionBlock:(追加任务)，通过这个方法可以给 NSBlockOperation 添加多个执行 Block。额外操作中的任务 会开子线程并发执行任务(这里可能是子线程也可能是主线程执行) 注意下面的打印结果：1234567891011121314151617181920212223242526// 1.创建操作,封装任务NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"1----%@",[NSThread currentThread]);&#125;];NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"2----%@",[NSThread currentThread]);&#125;];NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"3----%@",[NSThread currentThread]);&#125;];// 2.追加任务[op3 addExecutionBlock:^&#123; NSLog(@"4----%@",[NSThread currentThread]);&#125;];[op3 addExecutionBlock:^&#123; NSLog(@"5----%@",[NSThread currentThread]);&#125;];[op3 addExecutionBlock:^&#123; NSLog(@"6----%@",[NSThread currentThread]);&#125;];// 3.启动[op1 start];[op2 start];[op3 start]; 打印输出:1234562016-02-13 16:13:15.690 多线程2.4[6890:173737] 1----&lt;NSThread: 0x60000006be40&gt;&#123;number = 1, name = main&#125;2016-02-13 16:13:15.691 多线程2.4[6890:173737] 2----&lt;NSThread: 0x60000006be40&gt;&#123;number = 1, name = main&#125;2016-02-13 16:13:15.692 多线程2.4[6890:173737] 3----&lt;NSThread: 0x60000006be40&gt;&#123;number = 1, name = main&#125;2016-02-13 16:13:15.692 多线程2.4[6890:174061] 4----&lt;NSThread: 0x600000079d00&gt;&#123;number = 3, name = (null)&#125;2016-02-13 16:13:15.692 多线程2.4[6890:173737] 6----&lt;NSThread: 0x60000006be40&gt;&#123;number = 1, name = main&#125;2016-02-13 16:13:15.692 多线程2.4[6890:174072] 5----&lt;NSThread: 0x600000079080&gt;&#123;number = 4, name = (null)&#125; 3.自定义子类继承NSOperation,实现内部相应的方法(重写main)1234567891011121314151617// LNOperation.m#import "LNOperation.h"@implementation LNOperation- (void)main &#123; NSLog(@"自定义NSOperation----%@",[NSThread currentThread]);&#125;// **********************我是分割线***************************//// 1.封装操作LNOperation *op1 = [[LNOperation alloc] init];LNOperation *op2 = [[LNOperation alloc] init];// 2.创建队列[op1 start];[op2 start]; 打印输出:122016-02-13 16:18:28.687 多线程2.4[7015:177012] 自定义NSOperation----&lt;NSThread: 0x60800007f780&gt;&#123;number = 1, name = main&#125;2016-02-13 16:18:28.688 多线程2.4[7015:177012] 自定义NSOperation----&lt;NSThread: 0x60800007f780&gt;&#123;number = 1, name = main&#125; 6.NSOperation结合NSOperationQueue使用NSOperationQueue 按类型来说共有两种类型：主队列、其他队列。只要添加到队列，会自动调用任务的 start 方法。1.主队列凡是添加到主队列中的任务（NSOperation），都会放到主线程中 串行执行。NSOperationQueue *queue1 = [NSOperationQueue mainQueue];2.其他队列（非主队列）添加到这种队列中的任务（NSOperation），就会自动放到子线程中 并发执行，同时具有：串行、并发功能。NSOperationQueue *queue = [[NSOperationQueue alloc] init]; 结合使用:1.添加任务到队列中 addOperation:12345678910111213141516171819202122- (void)addOperationQueue &#123; // 1.创建队列 //NSOperationQueue *queue = [NSOperationQueue mainQueue]; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.封装操作 NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task) object:nil]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@"op2--%@", [NSThread currentThread]); &#125; &#125;]; // 3.添加操作到队列 [queue addOperation:op1]; [queue addOperation:op2];&#125;- (void)task &#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@"op1--%@", [NSThread currentThread]); &#125;&#125; 使用非主队列打印输出:12342016-02-13 16:54:53.312 多线程2.4[7731:198138] op1--&lt;NSThread: 0x60800026f400&gt;&#123;number = 3, name = (null)&#125;2016-02-13 16:54:53.312 多线程2.4[7731:198134] op2--&lt;NSThread: 0x6000002662c0&gt;&#123;number = 4, name = (null)&#125;2016-02-13 16:54:53.313 多线程2.4[7731:198138] op1--&lt;NSThread: 0x60800026f400&gt;&#123;number = 3, name = (null)&#125;2016-02-13 16:54:53.313 多线程2.4[7731:198134] op2--&lt;NSThread: 0x6000002662c0&gt;&#123;number = 4, name = (null)&#125; 使用主队列打印输出:12342016-02-13 17:34:30.241 多线程2.4[8595:228001] op1--&lt;NSThread: 0x600000072340&gt;&#123;number = 1, name = main&#125;2016-02-13 17:34:30.241 多线程2.4[8595:228001] op1--&lt;NSThread: 0x600000072340&gt;&#123;number = 1, name = main&#125;2016-02-13 17:34:30.242 多线程2.4[8595:228001] op2--&lt;NSThread: 0x600000072340&gt;&#123;number = 1, name = main&#125;2016-02-13 17:34:30.242 多线程2.4[8595:228001] op2--&lt;NSThread: 0x600000072340&gt;&#123;number = 1, name = main&#125; 2.添加任务到队列中 addOperationWithBlock:,简易方法:12345678910111213NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 添加任务到队列中[queue addOperationWithBlock:^&#123; for (NSInteger i= 0; i &lt;2; i++) &#123; NSLog(@"op1--%@", [NSThread currentThread]); &#125;&#125;];[queue addOperationWithBlock:^&#123; for (NSInteger i= 0; i &lt;2; i++) &#123; NSLog(@"op2--%@", [NSThread currentThread]); &#125;&#125;]; 打印输出:12342016-02-13 17:28:12.586 多线程2.4[8446:222668] op1--&lt;NSThread: 0x600000262740&gt;&#123;number = 3, name = (null)&#125;2016-02-13 17:28:12.586 多线程2.4[8446:222667] op2--&lt;NSThread: 0x608000263d40&gt;&#123;number = 4, name = (null)&#125;2016-02-13 17:28:12.587 多线程2.4[8446:222668] op1--&lt;NSThread: 0x600000262740&gt;&#123;number = 3, name = (null)&#125;2016-02-13 17:28:12.587 多线程2.4[8446:222667] op2--&lt;NSThread: 0x608000263d40&gt;&#123;number = 4, name = (null)&#125; 7.非主队列控制串行和并行执行的关键NSOperationQueue创建的其他队列 同时具有串行、并发功能，上边我们演示了并发功能，那么下面讲讲串行功能，这里有个关键参数：maxConcurrentOperationCount 队列最大并发数(同一时间最多几个任务可以执行)误区:串行执行任务不等于只开一条线程(线程同步,要看任务的执行方式是顺序还是并发的) maxConcurrentOperationCount 描述 .&gt; 1 并发队列 = 1 串行队列 = 0 不会执行任务 = -1 特殊意义,最大值表示不受限制 123456789101112131415161718192021// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 2.设置队列最大并发数(同一时间最多几个任务可以执行)queue.maxConcurrentOperationCount = 1;// 串行// 3.封装操作NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"1---- %@",[NSThread currentThread]);&#125;];NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"2---- %@",[NSThread currentThread]);&#125;];NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"3---- %@",[NSThread currentThread]);&#125;];// 4.添加到队列[queue addOperation:op1];[queue addOperation:op2];[queue addOperation:op3]; 最大并发数 =1，打印输出:1232016-02-13 17:59:24.702 多线程2.4[9096:244592] 1---- &lt;NSThread: 0x600000071e80&gt;&#123;number = 3, name = (null)&#125;2016-02-13 17:59:24.703 多线程2.4[9096:244593] 2---- &lt;NSThread: 0x608000077080&gt;&#123;number = 4, name = (null)&#125;2016-02-13 17:59:24.703 多线程2.4[9096:244592] 3---- &lt;NSThread: 0x600000071e80&gt;&#123;number = 3, name = (null)&#125; 最大并发数 =2，打印输出:1232016-02-13 18:03:17.608 多线程2.4[9178:246935] 2---- &lt;NSThread: 0x600000267d80&gt;&#123;number = 4, name = (null)&#125;2016-02-13 18:03:17.608 多线程2.4[9178:246936] 1---- &lt;NSThread: 0x600000262280&gt;&#123;number = 3, name = (null)&#125;2016-02-13 18:03:17.612 多线程2.4[9178:246936] 3---- &lt;NSThread: 0x600000262280&gt;&#123;number = 3, name = (null)&#125; 8.添加操作依赖和操作监听NSOperation 有一个非常实用的功能，那就是 添加依赖addDependency:（也可以跨队列依赖），注意:这里不能相互依赖。只有所有依赖的对象都已经完成操作，当前NSOperation对象才会开始执行操作。需要先添加依赖关系,再将操作添加到队列中。另外，通过removeDependency方法来删除依赖对象。给操作任务 添加监听addExecutionBlock:，当任务完成后就会，走到这个Block块里面，具体怎么添加依赖和监听如下：12345678910111213141516171819202122232425262728293031323334- (void)addDependency &#123; // 1.创建队列 NSOperationQueue *queue1 = [[NSOperationQueue alloc] init]; NSOperationQueue *queue2 = [[NSOperationQueue alloc] init]; // 2.封装操作 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"1---- %@",[NSThread currentThread]); &#125;]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"2---- %@",[NSThread currentThread]); &#125;]; NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"3---- %@",[NSThread currentThread]); &#125;]; NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"4---- %@",[NSThread currentThread]); &#125;]; // 3.添加操作依赖,也可以跨队列依赖(注意：这里不能相互依赖) [op1 addDependency:op4]; [op4 addDependency:op3]; // 4.添加操作监听 [op2 addExecutionBlock:^&#123; NSLog(@"监听op2--%@",[NSThread currentThread]); &#125;]; // 5.添加到队列 [queue1 addOperation:op1]; [queue1 addOperation:op2]; [queue1 addOperation:op3]; [queue2 addOperation:op4];&#125; 打印输出:123452016-02-13 19:04:12.166 多线程2.4[10372:280459] 2---- &lt;NSThread: 0x60800007c440&gt;&#123;number = 3, name = (null)&#125;2016-02-13 19:04:12.166 多线程2.4[10372:280473] 监听op2-- &lt;NSThread: 0x60800007cbc0&gt;&#123;number = 5, name = (null)&#125;2016-02-13 19:04:12.166 多线程2.4[10372:280462] 3---- &lt;NSThread: 0x60000007aa40&gt;&#123;number = 4, name = (null)&#125;2016-02-13 19:04:12.168 多线程2.4[10372:280459] 4---- &lt;NSThread: 0x60800007c440&gt;&#123;number = 3, name = (null)&#125;2016-02-13 19:04:12.169 多线程2.4[10372:280473] 1---- &lt;NSThread: 0x60800007cbc0&gt;&#123;number = 5, name = (null)&#125; 9.NSOperation线程间通信12345678910111213141516// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 2.封装任务NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSURL *url = [NSURL URLWithString:@"http://s15.sinaimg.cn/bmiddle/4c0b78455061c1b7f1d0e"]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; self.imageView.image = image; NSLog(@"UI-- %@",[NSThread currentThread]); &#125;];&#125;]; // 3.添加操作到队列 [queue addOperation:op1]; 打印输出:12016-02-13 19:13:29.759 多线程2.4[10553:285311] UI-- &lt;NSThread: 0x60800006d2c0&gt;&#123;number = 1, name = main&#125; 【@码员真爱 : 真的不点进去阅读一下 ❓】【译文 &amp; 源码】 【工具类】 10.管理操作：是操作队列的方法队列中的任务也是有状态：已经执行完成的、正在执行、等待执行 应用场景：提高用户体验第一，当用户操作时，取消一切跟用户当前操作无关的进程，提升流畅度。（开始滚动的时候 暂停操作、滑动结束的时候 恢复操作、接收到内存警告 取消所有操作）1.添加操作依赖2.管理操作：重点！是操作队列的方法 暂停/恢复 取消操作，(暂停和取消,不能暂停或取消正在执行状态的任务，且取消不可以恢复) 开启合适的线程数量！（最多不超过6条） 一般开发的时候，会将操作队列设置成一个全局的变量（属性） 方法：123456// 判断暂停状态,YES暂停 NO恢复@property (getter=isSuspended) BOOL suspended;// 取消(不可以恢复)// 该方法内部调用了所有操作的cancel方法- (void)cancelAllOperations; 好了，就到这里吧。当然，我讲的并不完整，可能有一些知识我并没有讲到，但作为常用方法，这些已经足够了。不过我在这里只是告诉你了一些方法的功能，只是怎么把他们用到合适的地方，就需要多多实践了，看我写的这么卖力，不打赏的话得点个喜欢也是极好的。 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 网络请求—「NSURLSession会话」]]></title>
    <url>%2FiOSNET%2FNSURLSession.html</url>
    <content type="text"><![CDATA[Write in the first 苹果在 iOS9 之后已经废弃了 NSURLConnection，所以在现在的实际开发中，除了大家常见的 AFN 框架，一般使用的是 iOS7 之后推出的 NSURLSession，作为一名【iOS 开发者】，如果你只知道 AFN 框架 来进行网络请求，那就 X x 了。 本篇文章主要从【NSURLSession 详解使用】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录: NSURLSession 介绍 NSURLSession 优势 NSURLSession 子类基本使用 NSURLSessionDownloadTask 大文件下载 NSURLSessionDataTask 断点下载 | 支持离线 URLSessionDataTask 断点下载效果 1. NSURLSession 介绍1234567891011关于taskNSURLSessionTask 是一个抽象类，是一个抽象类，本身不能使用，只能使用它的子类NSURLSessionTask 有两个子类1.NSURLSessionDataTask：可以用来处理一般的网络请求，如 GET | POST 请求DataTask子类 NSURLSessionUploadTask：用于处理上传请求的时候有优势2.NSURLSessionDownloadTask：主要用于处理下载请求，有很大的优势使用步骤1.使用NSURLSession创建task2.执行task [dataTask resume] Task的类型 2. NSURLSession 优势1234561.NSURLSession 支持 http2.0 协议2.在处理下载任务的时候可以直接把数据下载到磁盘3.支持后台下载|上传4.同一个 session 发送多个请求，只需要建立一次连接（复用了TCP）5.提供了全局的 session 并且可以统一配置，使用更加方便6.下载的时候是多线程异步处理，效率更高 3. NSURLSession 子类基本使用1.GET请求12345678910111213141516171819202122232425262728293031323334353637// 1.确定urlNSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/login?username=520it&amp;pwd=520it&amp;type=JSON"];// 2.创建请求对象NSURLRequest *request = [NSURLRequest requestWithURL:url];// 3.创建Session会话对象（可以获取单例对象）NSURLSession *session = [NSURLSession sharedSession];// 4.创建Task/** Request:请求对象 completionHandler 当请求完成之后调用 data:响应体信息 response:响应头信息 error:错误信息当请求失败的时候,error有值 */// 方法一：dataTaskWithRequest: completionHandler:NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; // 拿到响应头信息 NSHTTPURLResponse *res = (NSHTTPURLResponse *)response; // 6.解析数据 NSLog(@"%@\n%@",[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding],res.allHeaderFields);&#125;];-----------------------------------------// 方法二：dataTaskWithURL: completionHandler:// 注意:dataTaskWithURL 内部会自动的将请求路径作为参数创建一个请求对象NSURLSessionDataTask *dataTask = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;&#125;];// 5.执行Task[dataTask resume];//[dataTask cancel];// 取消任务//[dataTask suspend];// 暂停任务 2.POST请求12345678910111213141516171819202122232425// 1.确定urlNSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/login"];// 2.创建请求对象NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];// 3.创建Session会话对象（可以获取单例对象）NSURLSession *session = [NSURLSession sharedSession];// 设置 请求方法request.HTTPMethod = @"POST";// 设置 请求体request.HTTPBody = [@"username=520&amp;pwd=520&amp;type=JSON" dataUsingEncoding:NSUTF8StringEncoding];// 设置 请求超时//request.timeoutInterval = 10;// 设置 请求头User-Agent// 注意:key一定要一致(用于传递数据给后台)//[request setValue:@"ios 10.1" forHTTPHeaderField:@"User-Agent"];// 4.创建Task// 注意：如果要发送POST请求，那么请使用dataTaskWithRequest,设置一些请求属性NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; // 6.解析数据&#125;];// 5.执行Task[dataTask resume]; 3.设置代理发送请求1234567891011121314151617// 1.确定URLNSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/login?username=520it&amp;pwd=520it&amp;type=JSON"];// 2.创建请求对象NSURLRequest *request = [NSURLRequest requestWithURL:url];// 3.创建会话对象,设置代理/** Configuration:配置信息,用默认的即可 delegate:代理 delegateQueue:设置代理方法在哪个线程中执行 */NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];// 4.创建TaskNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request];// 5.执行Task[dataTask resume]; 遵守&lt;NSURLSessionDataDelegate&gt; 实现 代理方法123456789101112131415161718192021222324252627282930// 1.接收到服务器的时候/** session 会话对象 dataTask 请求任务 response 响应头信息 completionHandler 回调,传给系统 */- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler &#123; /** NSURLSessionResponseCancel = 0, 取消请求,默认 NSURLSessionResponseAllow = 1, 接收数据 NSURLSessionResponseBecomeDownload = 2, 变成下载任务 NSURLSessionResponseBecomeStream 变成下载任务 9.0之后可以用 */ completionHandler(NSURLSessionResponseAllow);&#125;// 2.接收到服务器返回的数据,会调用多次（data可能是部分）- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123; // 拼接数据 [self.fileData appendData:data];&#125;// 3.请求完成 或 失败的时候调用- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; if (error) &#123; return; &#125; else &#123; // 解析数据 NSLog(@&quot;%@&quot;,[[NSString alloc] initWithData:self.fileData encoding:NSUTF8StringEncoding]); &#125;&#125; 4. 设置代理之后的强引用问题1234567问题：`NSURLSession` 对象在使用的时候，如果设置了代理， 那么 session 会对代理对象保持一个强引用，在不用的时候应该主动进行释放解决：在`dealloc`方法中进行释放， 可以通过调用 `finishTasksAndInvalidate`或`resetWithCompletionHandler` 来释放对代理对象的强引用[self.session finishTasksAndInvalidate]; 4. NSURLSessionDownloadTask 大文件下载1.DownloadTask:Block方式12345678910111213141516171819202122232425262728// 1.确定URLNSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/resources/images/minion_03.png"];// 2.创建请求对象NSURLRequest *request = [NSURLRequest requestWithURL:url];// 3.创建会话对象NSURLSession *session = [NSURLSession sharedSession];// 4.创建Task/** downloadTaskWithRequest: Block方式 注意:该方法内部已经实现了边接受数据边写入沙盒(tmp临时文件目录)的操作, 需要剪切文件,把它移动到我们指定的位置。 */NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:request completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; // 6.数据解析 NSLog(@"%@---%@",location,[NSThread currentThread]); // 7.拼接文件全路径 // 拼接文件后的本地名称:FileName @"123.png"或 [url lastPathComponent] 获取URL最后一个字节命名 NSString *fullPath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:[url lastPathComponent]]; // 8.剪切文件 [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:fullPath] error:nil]; NSLog(@"%@",fullPath);&#125;];// 5.执行Task[downloadTask resume]; 注DownloadTask:Block方式优点:不需要担心内存(边接受数据边写入沙盒(tmp临时文件目录)的操作)缺点:无法监听文件下载进度 2.DownloadTask:Dlegate方式遵守&lt;NSURLSessionDownloadDelegate&gt;协议，实现代理方法。可以在didWriteData(写数据)代理方法，监听下载进度12345678NSURL *url = [NSURL URLWithString:@"[http://120.25.226.186:32812/resources/images/minion_03.png"];](http://120.25.226.186:32812/resources/images/minion_03.png%22];)// Configuration:配置信息,用默认的即可NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:[NSURLRequest requestWithURL:url]];[downloadTask resume];// 执行Task 注DownloadTask:Dlegate方式，解决了无法监听下载进度的问题 5.DownloadTask断点下载1234567891011121314151617181920212223242526272829303132333435// 开始下载- (IBAction)starBtnClick:(id)sender &#123; NSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/resources/videos/minion_01.mp4"]; self.session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]]; self.downloadTask = [self.session downloadTaskWithRequest:[NSURLRequest requestWithURL:url]]; [self.downloadTask resume];&#125;// 暂停下载(是可以恢复的)- (IBAction)suspendBtnClick:(id)sender &#123; NSLog(@"+++++++++++++++++++暂停"); [self.downloadTask suspend];&#125;// 取消下载(注意)// cancel:取消是不能恢复// cancelByProducingResumeData:是可以恢复- (IBAction)cancelBtnClick:(id)sender &#123; NSLog(@"+++++++++++++++++++取消"); //[self.downloadTask cancel]; [self.downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) &#123; self.resumData = resumeData; &#125;];&#125;// 继续下载- (IBAction)goOnBtnClick:(id)sender &#123; NSLog(@"+++++++++++++++++++继续下载"); if (self.resumData) &#123; // 恢复下载数据(文件保存信息,保存到那个字节) != 文件数据 self.downloadTask = [self.session downloadTaskWithResumeData:self.resumData]; &#125; [self.downloadTask resume];&#125; NSURLSessionDownloadDelegate代理方法123456789101112131415161718192021222324252627282930313233343536373839404142434445/** 1.写数据(监听下载进度) session 会话对象 downloadTask 下载任务 bytesWritten 本次写入的数据大小 totalBytesWritten 下载的数据总大小 totalBytesExpectedToWrite 文件的总大小 */-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite &#123; // 获得文件的下载进度 NSLog(@"%f",1.0 * totalBytesWritten/totalBytesExpectedToWrite); self.proessView.progress = 1.0 * totalBytesWritten/totalBytesExpectedToWrite;&#125;/** 2.当恢复下载的时候调用方法 fileOffset 从什么地方下载 expectedTotalBytes 文件的总大小 */-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes &#123; NSLog(@"恢复下载--%s",__func__);&#125;/** 3.当下载完成的时候调用 location 文件的临时存储路径 */-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location &#123; NSLog(@"文件的临时存储路径--%@",location); // 1.拼接文件全路径 // downloadTask.response.suggestedFilename 文件名称 NSString *fullPath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename]; // 2.剪切文件 [[NSFileManager defaultManager]moveItemAtURL:location toURL:[NSURL fileURLWithPath:fullPath] error:nil]; NSLog(@"%@",fullPath);&#125;/** 4.请求失败 */-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; NSLog(@"didCompleteWithError");&#125; 注123局限性:1.如果用户点击暂停之后退出程序，那么需要把恢复下载的数据写一份到沙盒，代码复杂度高2.如果用户在下载中途未保存恢复下载数据即退出程序，则不具备可操作性 6. NSURLSessionDataTask 断点下载 | 支持离线 NSURLSessionDataTask 实现大文件1.开始下载、暂停下载、取消下载、恢复下载2.支持后台下载|上传（离线 断点）3.在处理下载任务的时候可以直接把数据下载到磁盘4.下载的时候 是子线程异步处理，效率更高 属性定义:123456789101112131415@interface DataTaskViewController ()&lt;NSURLSessionDataDelegate&gt;@property (weak, nonatomic) IBOutlet UIProgressView *proessView;/** 创建文件句柄 */@property (nonatomic, strong) NSFileHandle *handle;/** 文件的总大小 */@property (nonatomic, assign) NSInteger totalSize;/** 当前下载数据大小 */@property (nonatomic, assign) NSInteger currentSize;/** 获得文件全路径 */@property (nonatomic, strong) NSString *fullPath;/** 创建Task */@property (nonatomic, strong) NSURLSessionDataTask *dataTask;/** 创建会话对象 */@property (nonatomic, strong) NSURLSession *session; 懒加载（方法的独立与抽取）:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849-(NSString *)fullPath &#123; if (!_fullPath) &#123; // 获得文件全路径 // 拼接文件后的本地名称 FileName @"123.mp4" 或者 [url lastPathComponent] 获取URL最后一个字节命名 _fullPath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:FileName]; &#125; return _fullPath;&#125;-(NSURLSession *)session &#123; if (!_session) &#123; // 创建会话对象,设置代理 /* Configuration:配置信息 [NSURLSessionConfiguration defaultSessionConfiguration] delegate:代理 delegateQueue:设置代理方法在哪个线程中调用 */ _session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]]; &#125; return _session;&#125;-(NSURLSessionDataTask *)dataTask &#123; if (!_dataTask) &#123; // 1.确定url NSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/resources/videos/minion_01.mp4"]; // 2.创建请求对象 NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; // 3 设置请求头信息,告诉服务器请求那一部分数据 self.currentSize = [self getFileSize]; NSString *range = [NSString stringWithFormat:@"bytes=%zd-",self.currentSize]; [request setValue:range forHTTPHeaderField:@"Range"]; // 4.创建Task _dataTask = [self.session dataTaskWithRequest:request]; &#125; return _dataTask;&#125;-(NSInteger)getFileSize &#123; // 获得指定文件路径对应文件的数据大小 NSDictionary *fileInfoDict = [[NSFileManager defaultManager]attributesOfItemAtPath:self.fullPath error:nil]; NSLog(@"%@",fileInfoDict); NSInteger currentSize = [fileInfoDict[@"NSFileSize"] integerValue]; return currentSize;&#125; NSURLSessionDataDelegate 代理方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#pragma mark - NSURLSessionDataDelegate// 1.接收到服务器的响应 它默认会取消该请求/** session 会话对象 dataTask 请求任务 response 响应头信息 completionHandler 回调 传给系统 expectedContentLength 本次请求的数据大小 */-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler &#123; // 获得文件的总大小 self.totalSize = response.expectedContentLength + self.currentSize; if (self.currentSize == 0) &#123; // 创建空的文件 [[NSFileManager defaultManager]createFileAtPath:self.fullPath contents:nil attributes:nil]; &#125; // 创建文件句柄 self.handle = [NSFileHandle fileHandleForWritingAtPath:self.fullPath]; // 移动指针(每接收到服务器的响应，就移动指针指向文件末尾) [self.handle seekToEndOfFile]; /* NSURLSessionResponseCancel = 0,取消 默认 NSURLSessionResponseAllow = 1,接收 NSURLSessionResponseBecomeDownload = 2,变成下载任务 NSURLSessionResponseBecomeStream 变成流 */ completionHandler(NSURLSessionResponseAllow);&#125;// 2.接收到服务器返回的数据 调用多次/** session 会话对象 dataTask 请求任务 data 本次下载的数据 */-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123; // 写入数据到文件 [self.handle writeData:data]; // 计算文件的下载进度 self.currentSize += data.length; NSLog(@"%f",1.0 * self.currentSize / self.totalSize); self.proessView.progress = 1.0 * self.currentSize / self.totalSize;&#125;// 3.请求完成 或者 失败的时候调用/** session 会话对象 dataTask 请求任务 error 错误信息 */-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; // 关闭文件句柄（创建句柄,要记得在完成方法里 关闭句柄置空） [self.handle closeFile]; self.handle = nil; NSLog(@"%@",self.fullPath);&#125;// 4.清理工作/** NSURLSession,如果设置代理的话会有一个强引用不会被释放掉,当不用Session的时候， 一定要调用finishTasksAndInvalidate 和 invalidateAndCancel 释放掉. */-(void)dealloc &#123; //finishTasksAndInvalidate [self.session invalidateAndCancel];&#125; 【@码员真爱 : 真的不点进去阅读一下 ❓】【译文 &amp; 源码】 【工具类】 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage源码3—SDWebImageDownloader]]></title>
    <url>%2FSourceAnnotations%2FSDSourceCode3.html</url>
    <content type="text"><![CDATA[Write in the first SDWebImageDownloader完成了对网络图片的异步下载工作，准确说这个类是一个文件下载(工具类)，而真正的网络请求是在继承于NSOperation的SDWebImageDownloaderOperation类实现的。 本篇文章主要从【SDWebImageDownloader 文件下载】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 SDWebImageDownloader的头文件内容比较少，主要是定义了一些基本参数如下载优先级策略、最大并发数、超时时间等，比较简单，这里就不再赘述。 SDWebImageDownloader 中核心方法：下载图片的操作12345678/* * 使用给定的 URL 创建 SDWebImageDownloader 异步下载器实例 * 图像下载完成或者出现错误时会通知代理 */- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock; 在看这个方法之前我们先看另外一个方法: 12345678910111213141516171819202122232425262728293031323334353637383940//处理SDWebImageDownloaderProgressBlock和SDWebImageDownloaderCompletedBlock//主要处理对象为self.URLCallbacks字典- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123; // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data. //如果URL为空，则执行completedBlock回调，并直接返回 if (url == nil) &#123; if (completedBlock != nil) &#123; completedBlock(nil, nil, nil, NO); &#125; return; &#125; //栅栏函数 dispatch_barrier_sync(self.barrierQueue, ^&#123; BOOL first = NO; //如果URLCallbacks字典中url对应的数组不存在，那么就创建一个空的可变数组，并设置first的值为YES if (!self.URLCallbacks[url]) &#123; self.URLCallbacks[url] = [NSMutableArray new]; first = YES; &#125; // Handle single download of simultaneous download request for the same URL // 保证如果统一URL有多个下载请求，那么只下载一次 //得到URLCallbacks字典中url对应的数组 NSMutableArray *callbacksForURL = self.URLCallbacks[url]; //创建可变字典，在该字典中存放progressBlock和completedBlock，并把该字典作为元素添加到数组中（即url对应的value） NSMutableDictionary *callbacks = [NSMutableDictionary new]; if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy]; if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy]; [callbacksForURL addObject:callbacks]; self.URLCallbacks[url] = callbacksForURL; //如果URLCallbacks字典中url对应的数组不存在,那么就调用createCallback（） if (first) &#123; createCallback(); &#125; &#125;);&#125; 走完上面这个函数，我们就能确保每个请求都能和它的progressBlock和completedBlock回调一一对应，接着回到download方法继续看：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//核心方法：下载图片的操作/* * 使用给定的 URL 创建 SDWebImageDownloader 异步下载器实例 * 图像下载完成或者出现错误时会通知代理 * url:要下载的图像 URL * SDWebImageDownloaderOptions：下载选项|策略 * progressBlock：图像下载过程中被重复调用的 block，用来报告下载进度 * completedBlock：图像下载完成后被调用一次的 block * image:如果下载成功，image 参数会被设置 * error:如果出现错误，error 参数会被设置 * finished: * 如果没有使用 SDWebImageDownloaderProgressiveDownload，最后一个参数一直是 YES * 如果使用了 SDWebImageDownloaderProgressiveDownload 选项，此 block 会被重复调用 * 1)下载完成前，image 参数是部分图像，finished 参数是 NO * 2)最后一次被调用时，image 参数是完整图像，而 finished 参数是 YES * 3)如果出现错误，那么finished 参数也是 YES * 返回值：可被取消的 SDWebImageOperation */- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123; __block SDWebImageDownloaderOperation *operation; __weak __typeof(self)wself = self; //为了避免block的循环引用 //处理进度回调|完成回调等，如果该url在self.URLCallbacks并不存在，则调用createCallback block块 [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123; //处理下载超时，如果没有设置过则初始化为15秒 NSTimeInterval timeoutInterval = wself.downloadTimeout; if (timeoutInterval == 0.0) &#123; timeoutInterval = 15.0; &#125; // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise //根据给定的URL和缓存策略创建可变的请求对象，设置请求超时 //请求策略：如果是SDWebImageDownloaderUseNSURLCache则使用NSURLRequestUseProtocolCachePolicy，否则使用NSURLRequestReloadIgnoringLocalCacheData /* NSURLRequestUseProtocolCachePolicy:默认的缓存策略 1)如果缓存不存在，直接从服务端获取。 2)如果缓存存在，会根据response中的Cache-Control字段判断下一步操作，如: Cache-Control字段为must-revalidata, 则询问服务端该数据是否有更新，无更新的话直接返回给用户缓存数据，若已更新，则请求服务端. NSURLRequestReloadIgnoringLocalCacheData:忽略本地缓存数据，直接请求服务端。 */ NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval]; //设置是否使用Cookies(采用按位与） /* 关于cookies参考：http://blog.csdn.net/chun799/article/details/17206907 */ request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies); //开启HTTP管道，这可以显著降低请求的加载时间，但是由于没有被服务器广泛支持，默认是禁用的 request.HTTPShouldUsePipelining = YES; //设置请求头信息（过滤等） if (wself.headersFilter) &#123; request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders copy]); &#125; else &#123; request.allHTTPHeaderFields = wself.HTTPHeaders; &#125; //核心方法：创建下载图片的操作 operation = [[wself.operationClass alloc] initWithRequest:request options:options progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; SDWebImageDownloader *sself = wself; if (!sself) return; __block NSArray *callbacksForURL; dispatch_sync(sself.barrierQueue, ^&#123; callbacksForURL = [sself.URLCallbacks[url] copy]; &#125;); //遍历callbacksForURL数组中的所有字典，执行SDWebImageDownloaderProgressBlock回调 for (NSDictionary *callbacks in callbacksForURL) &#123; //说明：SDWebImageDownloaderProgressBlock作者可能考虑到用户拿到进度数据后会进行刷新处理，因此在主线程中处理了回调 dispatch_async(dispatch_get_main_queue(), ^&#123; SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey]; if (callback) callback(receivedSize, expectedSize); &#125;); &#125; &#125; completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123; SDWebImageDownloader *sself = wself; if (!sself) return; __block NSArray *callbacksForURL; dispatch_barrier_sync(sself.barrierQueue, ^&#123; callbacksForURL = [sself.URLCallbacks[url] copy]; //如果完成，那么把URL从URLCallbacks字典中删除 if (finished) &#123; [sself.URLCallbacks removeObjectForKey:url]; &#125; &#125;); //遍历callbacksForURL数组中的所有字典，执行SDWebImageDownloaderCompletedBlock回调 for (NSDictionary *callbacks in callbacksForURL) &#123; SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey]; if (callback) callback(image, data, error, finished); &#125; &#125; cancelled:^&#123; SDWebImageDownloader *sself = wself; if (!sself) return; //把当前的url从URLCallbacks字典中移除 dispatch_barrier_async(sself.barrierQueue, ^&#123; [sself.URLCallbacks removeObjectForKey:url]; &#125;); &#125;]; //设置是否需要解码 operation.shouldDecompressImages = wself.shouldDecompressImages; //身份认证 if (wself.urlCredential) &#123; operation.credential = wself.urlCredential; &#125; else if (wself.username &amp;&amp; wself.password) &#123; //设置 https 访问时身份验证使用的凭据 operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession]; &#125; //判断下载策略是否是高优先级的或低优先级，以设置操作的队列优先级 if (options &amp; SDWebImageDownloaderHighPriority) &#123; operation.queuePriority = NSOperationQueuePriorityHigh; &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123; operation.queuePriority = NSOperationQueuePriorityLow; &#125; //把下载操作添加到下载队列中 //该方法会调用operation内部的start方法开启图片的下载任务 [wself.downloadQueue addOperation:operation]; //判断任务的执行优先级，如果是后进先出，则调整任务的依赖关系，优先执行当前的（最后添加）任务 if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123; // Emulate LIFO execution order by systematically adding new operations as last operation's dependency [wself.lastAddedOperation addDependency:operation]; wself.lastAddedOperation = operation;//设置当前下载操作为最后一个操作 &#125; &#125;]; return operation;&#125; downloadImageWithURL方法的内容不多，通过一步步的拆分我们可以看的比较明了，下面继续看看SDWebImageDownloaderOperation这个类中做了哪些事情 SDWebImageDownloaderOperationSDWebImageDownloaderOperation继承于NSOperation重写了start方法，在start方法里创建了NSURLConnection链接对象。先看看对外开放的初始化operation方法做了哪些工作：123456789101112131415161718192021//初始化operation的方法- (id)initWithRequest:(NSURLRequest *)request options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock cancelled:(SDWebImageNoParamsBlock)cancelBlock &#123; if ((self = [super init])) &#123; _request = request; //在SDWebImageDownloader中创建的NSMutableURLRequest对象 _shouldDecompressImages = YES; //是否解图片 _shouldUseCredentialStorage = YES; //URL 连接是否询问保存连接身份验证的凭据，默认是 `YES _options = options; //下载策略 _progressBlock = [progressBlock copy]; //进度回调 _completedBlock = [completedBlock copy]; //下载完成回调 _cancelBlock = [cancelBlock copy]; //取消回调 _executing = NO; _finished = NO; _expectedSize = 0; responseFromCached = YES; // Initially wrong until `connection:willCacheResponse:` is called or not called &#125; return self;&#125; 初始化主要还是对一些参数做了配置，下面看start方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//核心方法：在该方法中处理图片下载操作- (void)start &#123; @synchronized (self) &#123; //判断当前操作是否被取消，如果被取消了，则标记任务结束，并处理后续的block和清理操作 if (self.isCancelled) &#123; self.finished = YES; [self reset]; return; &#125; //开启后台下载任务//条件编译，如果是iphone设备且大于4.0#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0 //先验证UIApplication实体是否存在 Class UIApplicationClass = NSClassFromString(@"UIApplication"); BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)]; //如果存在且允许后台下载 if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123; __weak __typeof__ (self) wself = self; //获得UIApplication单例对象 UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)]; //UIBackgroundTaskIdentifier：通过UIBackgroundTaskIdentifier可以实现有限时间内在后台运行程序 //在后台获取一定的时间去执行我们的代码 self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123; //这个回调是后台任务将被系统杀死时执行，这里取消了下载任务 __strong __typeof (wself) sself = wself;#warning 3 if (sself) &#123; [sself cancel]; //取消当前下载操作 [app endBackgroundTask:sself.backgroundTaskId]; //结束后台任务 sself.backgroundTaskId = UIBackgroundTaskInvalid; &#125; &#125;]; &#125;#endif //构建NSURLConnection向服务器发送请求(当前任务正在执行) self.executing = YES; //创建NSURLConnection对象，并设置代理（没有马上发送请求） self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO]; //获得当前线程 self.thread = [NSThread currentThread]; &#125; [self.connection start]; //发送网络请求 if (self.connection) &#123; if (self.progressBlock) &#123; //进度block的回调 self.progressBlock(0, NSURLResponseUnknownLength); &#125; //注册通知中心，在主线程中发送通知SDWebImageDownloadStartNotification【任务开始下载】 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self]; &#125;); //需要手动开启线程对应的Runloop,connection才能正常接收delegate回调 if (floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_5_1) &#123; // Make sure to run the runloop in our background thread so it can process downloaded data //确保后台线程的runloop跑起来 // Note: we use a timeout to work around an issue with NSURLConnection cancel under iOS 5 // not waking up the runloop, leading to dead threads (see https://github.com/rs/SDWebImage/issues/466) CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false); &#125; else &#123; //开启Runloop CFRunLoopRun(); &#125; //runloop关闭之后才会继续执行下面的代码 if (!self.isFinished) &#123; [self.connection cancel]; //请求失败(取消网络连接) //处理错误信息 [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@&#123;NSURLErrorFailingURLErrorKey : self.request.URL&#125;]]; &#125; &#125; else &#123; //NSURLConnection初始化失败，执行completedBlock回调 if (self.completedBlock) &#123; self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @"Connection can't be initialized"&#125;], YES); &#125; &#125; //到这里，不管下载成功与否，都注销之前注册的后台任务#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0 Class UIApplicationClass = NSClassFromString(@"UIApplication"); if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123; return; &#125; if (self.backgroundTaskId != UIBackgroundTaskInvalid) &#123; UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)]; [app endBackgroundTask:self.backgroundTaskId]; self.backgroundTaskId = UIBackgroundTaskInvalid; &#125;#endif&#125; start 方法是实现并发NSOperation的核心方法，在这个方法里创建了NSURLConnection请求并发起请求。再重点看下 NSURLConnection的两个代理方法： 当接收到服务器返回数据的时候调用该方法，可能会调用多次12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//当接收到服务器返回数据的时候调用该方法，可能会调用多次- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123; //不断拼接接收到的图片数据（二进制数据） [self.imageData appendData:data]; //如果下载图片设置的策略是options值为 SDWebImageDownloaderProgressiveDownload //即边下载边显示，而不是下载完成一次洗显示，则需要随着接收到data数据立即进行图片转化。 if ((self.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; self.expectedSize &gt; 0 &amp;&amp; self.completedBlock) &#123; // The following code is from http://www.cocoaintheshell.com/2011/05/progressive-images-download-imageio/ // Thanks to the author @Nyx0uf // Get the total bytes downloaded //获得当前已经接收到的二进制数据大小 const NSInteger totalSize = self.imageData.length; // Update the data source, we must pass ALL the data, not just the new bytes // 把图片的二进制数据转换为CGImageSourceRef CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)self.imageData, NULL); //如果是第一次（即接收到第一部分的图片数据） if (width + height == 0) &#123; CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, NULL); if (properties) &#123; NSInteger orientationValue = -1; CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight); if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;height); val = CFDictionaryGetValue(properties, kCGImagePropertyPixelWidth); if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;width); val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation); if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue); CFRelease(properties); // When we draw to Core Graphics, we lose orientation information, // which means the image below born of initWithCGIImage will be // oriented incorrectly sometimes. (Unlike the image born of initWithData // in connectionDidFinishLoading.) So save it here and pass it on later. orientation = [[self class] orientationFromPropertyValue:(orientationValue == -1 ? 1 : orientationValue)]; &#125; &#125; //接收数据中期（之前接收过一部分，但为完全） if (width + height &gt; 0 &amp;&amp; totalSize &lt; self.expectedSize) &#123; // Create the image CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(imageSource, 0, NULL);#ifdef TARGET_OS_IPHONE // Workaround for iOS anamorphic image if (partialImageRef) &#123; const size_t partialHeight = CGImageGetHeight(partialImageRef); CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef bmContext = CGBitmapContextCreate(NULL, width, height, 8, width * 4, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst); CGColorSpaceRelease(colorSpace); if (bmContext) &#123; CGContextDrawImage(bmContext, (CGRect)&#123;.origin.x = 0.0f, .origin.y = 0.0f, .size.width = width, .size.height = partialHeight&#125;, partialImageRef); CGImageRelease(partialImageRef); partialImageRef = CGBitmapContextCreateImage(bmContext); CGContextRelease(bmContext); &#125; else &#123; CGImageRelease(partialImageRef); partialImageRef = nil; &#125; &#125;#endif if (partialImageRef) &#123; UIImage *image = [UIImage imageWithCGImage:partialImageRef scale:1 orientation:orientation]; NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL]; UIImage *scaledImage = [self scaledImageForKey:key image:image]; if (self.shouldDecompressImages) &#123; image = [UIImage decodedImageWithImage:scaledImage]; &#125; else &#123; image = scaledImage; &#125; CGImageRelease(partialImageRef); dispatch_main_sync_safe(^&#123; if (self.completedBlock) &#123; self.completedBlock(image, nil, nil, NO); &#125; &#125;); &#125; &#125; //释放imageSource对象 CFRelease(imageSource); &#125; //执行progressBlock进度回调，不断更新进度信息 if (self.progressBlock) &#123; self.progressBlock(self.imageData.length, self.expectedSize); &#125;&#125; 下载完成的代理方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//当请求结束的时候会调用该方法- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection &#123; SDWebImageDownloaderCompletedBlock completionBlock = self.completedBlock; @synchronized(self) &#123; //关停当前的runloop 释放资源 CFRunLoopStop(CFRunLoopGetCurrent()); //把线程和连接对象清空 self.thread = nil; self.connection = nil; //在主线程中发出通知： //SDWebImageDownloadStopNotification 任务停止 //SDWebImageDownloadFinishNotification 任务完成 dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:self]; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:self]; &#125;); &#125; #warning 5 //请求头是否是从缓存获取？ if (![[NSURLCache sharedURLCache] cachedResponseForRequest:_request]) &#123; responseFromCached = NO; &#125; if (completionBlock) &#123; //如果下载策略options是SDWebImageDownloaderIgnoreCachedResponse&amp;&amp;responseFromCached为真，执行completionBlock 成功回调 if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; responseFromCached) &#123; completionBlock(nil, nil, nil, YES); &#125; else if (self.imageData) &#123; //如果得到图片的二进制数据 //把二进制数据转换为图片 UIImage *image = [UIImage sd_imageWithData:self.imageData]; //返回指定URL的缓存键值,即URL字符串 NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL]; //根据手机屏幕分辨率对图片进行缩放 image = [self scaledImageForKey:key image:image]; // Do not force decoding animated GIFs //如果不是gif图，解压图片 if (!image.images) &#123; //如果需要，那么对图片进行解压缩处理 if (self.shouldDecompressImages) &#123; image = [UIImage decodedImageWithImage:image]; &#125; &#125; //如果发现转换之后图片的Size为0，则执行completionBlock成功回调，图片参数传nil并报错 if (CGSizeEqualToSize(image.size, CGSizeZero)) &#123; completionBlock(nil, nil, [NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @"Downloaded image has 0 pixels"&#125;], YES); &#125; else &#123; completionBlock(image, self.imageData, nil, YES); &#125; &#125; else &#123; completionBlock(nil, nil, [NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @"Image data is nil"&#125;], YES); &#125; &#125; //释放资源 self.completionBlock = nil; [self done]; //结束后的处理&#125; SDWebImage ——知其然亦知其所以然 下载图片的核心方法使用#import &quot;SDWebImageDownloader.h&quot;12345678910111213141516171819202122232425262728293031323334/* * 使用给定的 URL 创建 SDWebImageDownloader 异步下载器实例 * * @param url 图片的URL地址 * @param options 图片下载选项（策略）,参考SDWebImageOptions的枚举值 * @param progressBlock 下载进度回调 * receivedSize 已经下载的数据大小 * expectedSize 要下载图片的总大小 * @param completedBlock 操作成功回调回调,该回调没有返回值 * Image：请求的 UIImage，如果出现错误，image参数是nil * data：图片二进制数据 * error：如果图片下载成功则error为nil,否则error有值 * @param finished： * 1.如果图像下载完成则为YES * 2.如果没有使用 SDWebImageDownloaderProgressiveDownload，最后一个参数一直是 YES * 3.如果使用了 SDWebImageDownloaderProgressiveDownload 选项，此 block 会被重复调用 * 1)下载完成前，image 参数是部分图像，finished 参数是 NO * 2)最后一次被调用时，image 参数是完整图像，而 finished 参数是 YES * 3)如果出现错误，那么finished 参数也是 YES * * @return 返回值：可被取消的 SDWebImageOperation */- (void)download3 &#123; [[SDWebImageDownloader sharedDownloader] downloadImageWithURL:[NSURL URLWithString:@"http://img4.duitang.com/uploads/blog/201310/18/20131018213446_smUw4.thumb.600_0.jpeg"] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; NSLog(@"%f",1.0 * receivedSize / expectedSize); &#125; completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123; /** 注意:completed完成后这里是在子线程中执行的 */ // 线程间通信(回到主线程刷新UI) [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; self.imageView.image = image; NSLog(@"download3--%@",[NSThread currentThread]); &#125;]; &#125;];&#125; 打印输出效果 应用场景:不需要任何的缓存处理的时候，该方法没有做任何缓存处理。注意：该方法completed完成后这里Block是在子线程中执行的。这里要进行线程间通信，不然会有警告。 这个框架有太多的东西值得我们去学习推敲，方方面面都透露着作者以及众多贡献者的智慧，我们读起来也一定会受益良多。 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage源码1—SDWebImageManager]]></title>
    <url>%2FSourceAnnotations%2FSDSourceCode1.html</url>
    <content type="text"><![CDATA[Write in the first SDWebImage 是我们经常使用的一个异步图片加载库，像这种经常用又比较重要的内容，我觉得要做到初步理解，然后梳理总结常用方法，到最后夯实基础、活学活用。 本篇文章主要从【SDWebImageManager 管理者】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 SDWebImage —&gt;知其然亦知其所以然我们就直接从 SDWebImageManager.h 入手吧 SDWebImageManager.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450/* * This file is part of the SDWebImage package. * (c) Olivier Poitrey &lt;rs@dailymotion.com&gt; * * For the full copyright and license information, please view the LICENSE * file that was distributed with this source code. */#import "SDWebImageCompat.h"#import "SDWebImageOperation.h"#import "SDWebImageDownloader.h"#import "SDImageCache.h"#pragma mark --------------------#pragma mark typedef//使用位移枚举，通过按位与&amp;按位或|的组合方式传递多个值typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123; /** * By default, when a URL fail to be downloaded, the URL is blacklisted so the library won't keep trying. * This flag disable this blacklisting. * * 默认情况下，如果一个url在下载的时候失败了，那么这个url会被加入黑名单，不会尝试再次下载。如果使用该参数，则该URL不会被添加到黑名单中。意味着会对下载失败的URL尝试重新下载。 * 此标记取消黑名单 */ SDWebImageRetryFailed = 1 &lt;&lt; 0, //失败后尝试重新下载 /** * By default, image downloads are started during UI interactions, this flags disable this feature, * leading to delayed download on UIScrollView deceleration for instance. * * 默认情况下，在 UI 交互时也会启动图像下载，此标记取消这一特性 * 会推迟到滚动视图停止滚动之后再继续下载 * 备注：NSURLConnection 的网络下载事件监听的运行循环模式是 NSDefaultRunLoopMode */ SDWebImageLowPriority = 1 &lt;&lt; 1, //低优先级 /** * This flag disables on-disk caching * * 使用该参数，将禁止磁盘缓存，只做内存缓存 */ SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, //只使用内存缓存 /** * This flag enables progressive download, the image is displayed progressively during download as a browser would do. * By default, the image is only displayed once completely downloaded. * * 此标记允许渐进式下载，就像浏览器中那样，下载过程中，图像会逐步显示出来 * 默认情况下，图像会在下载完成后一次性显示 */ SDWebImageProgressiveDownload = 1 &lt;&lt; 3, //渐进式下载 /** * Even if the image is cached, respect the HTTP response cache control, and refresh the image from remote location if needed. * The disk caching will be handled by NSURLCache instead of SDWebImage leading to slight performance degradation. * This option helps deal with images changing behind the same request URL, e.g. Facebook graph api profile pics. * If a cached image is refreshed, the completion block is called once with the cached image and again with the final image. * * Use this flag only if you can't make your URLs static with embedded cache busting parameter. * * 遵守 HTPP 响应的缓存控制，如果需要，从远程刷新图像 * 磁盘缓存将由 NSURLCache 处理，而不是 SDWebImage，这会对性能有轻微的影响 * 此选项用于处理URL指向图片发生变化的情况 * 如果缓存的图像被刷新，会调用一次 completion block，并传递最终的图像 */ SDWebImageRefreshCached = 1 &lt;&lt; 4, //刷新缓存 /** * In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for * extra time in background to let the request finish. If the background task expires the operation will be cancelled. * * 如果系统版本是iOS 4+的，那么当App进入后台后仍然会继续下载图像。 * 这是向系统请求额外的后台时间以保证下载请求完成的 * 如果后台任务过期，请求将会被取消 */ SDWebImageContinueInBackground = 1 &lt;&lt; 5, //后台下载 /** * Handles cookies stored in NSHTTPCookieStore by setting * NSMutableURLRequest.HTTPShouldHandleCookies = YES; * * 通过设置，处理保存在 NSHTTPCookieStore 中的 cookies */ SDWebImageHandleCookies = 1 &lt;&lt; 6, //处理保存在NSHTTPCookieStore中的cookies /** * Enable to allow untrusted SSL certificates. * Useful for testing purposes. Use with caution in production. * * 允许不信任的 SSL 证书 * 可以出于测试目的使用，在正式产品中慎用 */ SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, //允许不信任的 SSL 证书 /** * By default, image are loaded in the order they were queued. This flag move them to * the front of the queue and is loaded immediately instead of waiting for the current queue to be loaded (which * could take a while). * * 默认情况下，图像会按照添加到队列中的顺序被加载，此标记会将它们移动到队列前端被立即加载 * 而不是等待当前队列被加载，因为等待队列加载会需要一段时间 */ SDWebImageHighPriority = 1 &lt;&lt; 8, //高优先级（优先下载） /** * By default, placeholder images are loaded while the image is loading. This flag will delay the loading * of the placeholder image until after the image has finished loading. * * 默认情况下，在加载图像时，占位图像已经会被加载。 * 此标记会延迟加载占位图像，直到图像已经完成加载 */ SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, //延迟占位图片 /** * We usually don't call transformDownloadedImage delegate method on animated images, * as most transformation code would mangle it. * Use this flag to transform them anyway. * * 通常不会在可动画的图像上调用transformDownloadedImage代理方法，因为大多数转换代码会破坏动画文件 * 使用此标记尝试转换 */ SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, //转换动画图像 /** * By default, image is added to the imageView after download. But in some cases, we want to * have the hand before setting the image (apply a filter or add it with cross-fade animation for instance) * Use this flag if you want to manually set the image in the completion when success * * 下载完成后手动设置图片，默认是下载完成后自动放到ImageView上 */ SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11 //手动设置图像&#125;;//定义任务完成的block块typedef void(^SDWebImageCompletionBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL);//定义任务结束的block块typedef void(^SDWebImageCompletionWithFinishedBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL);//定义缓存过滤器的block块typedef NSString *(^SDWebImageCacheKeyFilterBlock)(NSURL *url);#pragma mark --------------------#pragma mark SDWebImageManagerDelegate/***************SDWebImageManagerDelegate代理协议开始***************///@class SDWebImageManager;@protocol SDWebImageManagerDelegate &lt;NSObject&gt;@optional#warning 1/** * Controls which image should be downloaded when the image is not found in the cache. * * @param imageManager The current `SDWebImageManager` * @param imageURL The url of the image to be downloaded * * @return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied. * * 如果该图片没有缓存，那么下载 * * @param imageManager：当前的SDWebImageManager * @param imageURL：要下载图片的URL地址 * * @return 如果要下载的图片在缓存中不存在，则返回NO，否则返回YES */- (BOOL)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(NSURL *)imageURL;/** * Allows to transform the image immediately after it has been downloaded and just before to cache it on disk and memory. * NOTE: This method is called from a global queue in order to not to block the main thread. * * @param imageManager The current `SDWebImageManager` * @param image The image to transform * @param imageURL The url of the image to transform * * @return The transformed image object. * * 允许在下载后立即将图像转换，并进行磁盘和内存缓存。 * * @param imageManager 当前的SDWebImageManager * @param image 要转换你的图片 * @param imageURL 要转换的图片的URL地址 * * @return 变换后的图片对象 */- (UIImage *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(UIImage *)image withURL:(NSURL *)imageURL;@end///***************SDWebImageManagerDelegate代理协议结束***************/#pragma mark --------------------#pragma mark SDWebImageManager-property//对SDWebImageManager的功能做出说明，并提供示例代码/** * The SDWebImageManager is the class behind the UIImageView+WebCache category and likes. * It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache). * You can use this class directly to benefit from web image downloading with caching in another context than * a UIView. * * Here is a simple example of how to use SDWebImageManager: * * @codeSDWebImageManager *manager = [SDWebImageManager sharedManager];[manager downloadImageWithURL:imageURL options:0 progress:nil completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (image) &#123; // do something with image &#125; &#125;]; * @endcode * * SDWebImageManager是UIImageView+WebCache 等分类后台工作的类 * SDWebImageManager是异步下载器 (SDWebImageDownloader) 和图像缓存存储 (SDImageCache) 之间的纽带 * 可以直接使用此类实现网络图像的下载 * 以下是如何使用 SDWebImageManager 的示例代码 *@code SDWebImageManager *manager = [SDWebImageManager sharedManager]; [manager downloadImageWithURL:imageURL options:0 progress:nil completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (image) &#123; // do something with image &#125; &#125;]; *@endcode */@interface SDWebImageManager : NSObject@property (weak, nonatomic) id &lt;SDWebImageManagerDelegate&gt; delegate; //遵守了SDWebImageManagerDelegate协议的代理@property (strong, nonatomic, readonly) SDImageCache *imageCache; //处理缓存@property (strong, nonatomic, readonly) SDWebImageDownloader *imageDownloader; //图片下载工具类/** * The cache filter is a block used each time SDWebImageManager need to convert an URL into a cache key. This can * be used to remove dynamic part of an image URL. * * The following example sets a filter in the application delegate that will remove any query-string from the * URL before to use it as a cache key: * * @code[[SDWebImageManager sharedManager] setCacheKeyFilter:^(NSURL *url) &#123; url = [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path]; return [url absoluteString];&#125;]; * @endcode * * "缓存过滤器"是一个block，用于每次SDWebImageManager需要将一个URL转换成一个缓存的键值 * 可用于删除图像 URL 中动态的部分 * 以下示例在 application 代理中设置一个过滤器，该过滤器会在将URL当作缓存键值之前，从URL中删除请求字符串 * [[SDWebImageManager sharedManager] setCacheKeyFilter:^(NSURL *url) &#123; url = [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path]; return [url absoluteString]; &#125;]; **/@property (nonatomic, copy) SDWebImageCacheKeyFilterBlock cacheKeyFilter; //缓存过滤器#pragma mark --------------------#pragma mark SDWebImageManager-Methods/** * Returns global SDWebImageManager instance. * * @return SDWebImageManager shared instance * * 单例方法 * @return 返回全局的 SDWebImageManager 实例(单例) */+ (SDWebImageManager *)sharedManager;//说明：下载图片调用的主方法/** * Downloads the image at the given URL if not present in cache or return the cached version otherwise. * * @param url The URL to the image * @param options A mask to specify options to use for this request * @param progressBlock A block called while image is downloading * @param completedBlock A block called when operation has been completed. * * This parameter is required. * * This block has no return value and takes the requested UIImage as first parameter. * In case of error the image parameter is nil and the second parameter may contain an NSError. * * The third parameter is an `SDImageCacheType` enum indicating if the image was retrieved from the local cache * or from the memory cache or from the network. * * The last parameter is set to NO when the SDWebImageProgressiveDownload option is used and the image is * downloading. This block is thus called repeatedly with a partial image. When image is fully downloaded, the * block is called a last time with the full image and the last parameter set to YES. * * @return Returns an NSObject conforming to SDWebImageOperation. Should be an instance of SDWebImageDownloaderOperation * * 如果URL对应的图像在缓存中不存在，那么就下载指定的图片 ，否则返回缓存的图像 * * @param url 图片的URL地址 * @param options 指定此次请求策略的选项 * @param progressBlock 图片下载进度的回调 * @param completedBlock 操作完成后的回调 * 此参数是必须的，此block没有返回值 * Image：请求的 UIImage，如果出现错误，image参数是nil * error：如果出现错误，则error有值 * cacheType：`SDImageCacheType` 枚举，标示该图像的加载方式 * SDImageCacheTypeNone：从网络下载 * SDImageCacheTypeDisk：从本地缓存加载 * SDImageCacheTypeMemory：从内存缓存加载 * finished：如果图像下载完成则为YES，如果使用 SDWebImageProgressiveDownload 选项，同时只获取到部分图片时，返回 NO * imageURL：图片的URL地址 * * @return SDWebImageOperation对象，应该是SDWebimageDownloaderOperation实例 */- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBloc completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;/** * Saves image to cache for given URL * * @param image The image to cache * @param url The URL to the image * * 根据图片的URL保存图片到缓存 * * @param image：缓存的图片 * @param url：该图片的URL地址 */- (void)saveImageToCache:(UIImage *)image forURL:(NSURL *)url;/** * Cancel all current operations * * 取消当前所有操作 */- (void)cancelAll;/** * Check one or more operations running * * 检查一个或多个操作是否正在运行 */- (BOOL)isRunning;/** * Check if image has already been cached * * @param url image url * * @return if the image was already cached * * 检查图像是否已经被缓存,如果已经缓存则返回YES * @param url:图片对应的URL * * @return 返回是否存在的BOOL值 */- (BOOL)cachedImageExistsForURL:(NSURL *)url;/** * Check if image has already been cached on disk only * * @param url image url * * @return if the image was already cached (disk only) * * 检查图像是否存在磁盘缓存（此方法仅针对磁盘进行检查，只要存在就返回YES） * * @param url 图片的url * * @return 是否存在（只检查磁盘缓存） */- (BOOL)diskImageExistsForURL:(NSURL *)url;/** * Async check if image has already been cached * * @param url image url * @param completionBlock the block to be executed when the check is finished * * @note the completion block is always executed on the main queue * * 异步检查图像是否已经有内存缓存 * * @param URL 图片对应的URL * @param completionBlock 当任务执行完毕之后调用的block * @note completionBlock始终在主队列执行 */- (void)cachedImageExistsForURL:(NSURL *)url completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;/** * Async check if image has already been cached on disk only * * @param url image url * @param completionBlock the block to be executed when the check is finished * * @note the completion block is always executed on the main queue * * 异步检查图像是否已经有磁盘缓存 * * @param URL 图片对应的URL * @param completionBlock 当任务执行完毕之后调用的block * @note completionBlock始终在主队列执行 */- (void)diskImageExistsForURL:(NSURL *)url completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;/** * Return the cache key for a given URL * * 返回指定URL的缓存键值，就是URL字符串 */- (NSString *)cacheKeyForURL:(NSURL *)url;@end#pragma mark --------------------#pragma mark Deprecated(过时的）typedef void(^SDWebImageCompletedBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType) __deprecated_msg("Block type deprecated. Use `SDWebImageCompletionBlock`");typedef void(^SDWebImageCompletedWithFinishedBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished) __deprecated_msg("Block type deprecated. Use `SDWebImageCompletionWithFinishedBlock`");@interface SDWebImageManager (Deprecated)/** * Downloads the image at the given URL if not present in cache or return the cached version otherwise. * * @deprecated This method has been deprecated. Use `downloadImageWithURL:options:progress:completed:` */- (id &lt;SDWebImageOperation&gt;)downloadWithURL:(NSURL *)url options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletedWithFinishedBlock)completedBlock __deprecated_msg("Method deprecated. Use `downloadImageWithURL:options:progress:completed:`");@end SDWebImageManager.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448/* * This file is part of the SDWebImage package. * (c) Olivier Poitrey &lt;rs@dailymotion.com&gt; * * For the full copyright and license information, please view the LICENSE * file that was distributed with this source code. */#import "SDWebImageManager.h"#import &lt;objc/message.h&gt;@interface SDWebImageCombinedOperation : NSObject &lt;SDWebImageOperation&gt;@property (assign, nonatomic, getter = isCancelled) BOOL cancelled; //取消@property (copy, nonatomic) SDWebImageNoParamsBlock cancelBlock; //取消的回调@property (strong, nonatomic) NSOperation *cacheOperation; //处理缓存的操作@end@interface SDWebImageManager ()@property (strong, nonatomic, readwrite) SDImageCache *imageCache; //可写的图片缓存@property (strong, nonatomic, readwrite) SDWebImageDownloader *imageDownloader; //图片下载任务@property (strong, nonatomic) NSMutableSet *failedURLs; //URL黑名单集合@property (strong, nonatomic) NSMutableArray *runningOperations; //当前正在执行的任务数组@end@implementation SDWebImageManager//单例类方法，该方法提供一个全局的SDWebImageManager实例+ (id)sharedManager &#123; static dispatch_once_t once; static id instance; dispatch_once(&amp;once, ^&#123; instance = [self new]; //该方法内部调用alloc init方法 &#125;); return instance;&#125;//初始化方法- (id)init &#123; if ((self = [super init])) &#123; _imageCache = [self createCache]; //初始化imageCache（单例） _imageDownloader = [SDWebImageDownloader sharedDownloader]; //初始化imageDownloader（单例） _failedURLs = [NSMutableSet new]; //初始化下载失败的URL（黑名单·空的集合） _runningOperations = [NSMutableArray new]; //初始化当前正在处理的任务（图片下载操作·空的可变数组） &#125; return self;&#125;//获取SDImageCache单例- (SDImageCache *)createCache &#123; return [SDImageCache sharedImageCache];&#125;//返回指定URL的缓存键值，就是URL字符串- (NSString *)cacheKeyForURL:(NSURL *)url &#123; //先判断是否设置了缓存过滤器，如果设置了则走cacheKeyFilterBlock,否则直接把URL转换为字符串之后返回 if (self.cacheKeyFilter) &#123; return self.cacheKeyFilter(url); &#125; else &#123; return [url absoluteString]; &#125;&#125;//检查图像是否已经被缓存,如果已经缓存则返回YES- (BOOL)cachedImageExistsForURL:(NSURL *)url &#123; NSString *key = [self cacheKeyForURL:url]; //得到图片对应的缓存KEY if ([self.imageCache imageFromMemoryCacheForKey:key] != nil) return YES; //如果该图片的内存缓存存在则返回YES return [self.imageCache diskImageExistsWithKey:key]; //如果该图片对应的内存缓存不存在，则检查磁盘缓存，并返回对应的值&#125;//检查图像是否存在磁盘缓存,如果已经缓存则返回YES- (BOOL)diskImageExistsForURL:(NSURL *)url &#123; NSString *key = [self cacheKeyForURL:url]; //得到图片对应的缓存KEY return [self.imageCache diskImageExistsWithKey:key]; //检查磁盘缓存，并返回对应的值&#125;//内存缓存处理- (void)cachedImageExistsForURL:(NSURL *)url completion:(SDWebImageCheckCacheCompletionBlock)completionBlock &#123; NSString *key = [self cacheKeyForURL:url]; //检查该url对应的图片内存缓存是否已经存在 BOOL isInMemoryCache = ([self.imageCache imageFromMemoryCacheForKey:key] != nil); //如果内存缓存存在，则直接在主线程中回调completionBlock，并返回 if (isInMemoryCache) &#123; // making sure we call the completion block on the main queue // 确保completionBlock在主线程中调用 dispatch_async(dispatch_get_main_queue(), ^&#123; if (completionBlock) &#123; completionBlock(YES); &#125; &#125;); return; &#125; //如果内存缓存不存在，那么处理查看磁盘缓存 [self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) &#123; // the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch if (completionBlock) &#123; completionBlock(isInDiskCache); &#125; &#125;];&#125;//磁盘缓存处理- (void)diskImageExistsForURL:(NSURL *)url completion:(SDWebImageCheckCacheCompletionBlock)completionBlock &#123; NSString *key = [self cacheKeyForURL:url]; //同上 [self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) &#123; // the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch if (completionBlock) &#123; completionBlock(isInDiskCache); &#125; &#125;];&#125;//加载图片的核心方法/* * 如果URL对应的图像在缓存中不存在，那么就下载指定的图片 ，否则返回缓存的图像 * * @param url 图片的URL地址 * @param options 指定此次请求策略的选项 * @param progressBlock 图片下载进度的回调 * @param completedBlock 操作完成后的回调 * 此参数是必须的，此block没有返回值 * Image：请求的 UIImage，如果出现错误，image参数是nil * error：如果出现错误，则error有值 * cacheType：`SDImageCacheType` 枚举，标示该图像的加载方式 * SDImageCacheTypeNone：从网络下载 * SDImageCacheTypeDisk：从本地缓存加载 * SDImageCacheTypeMemory：从内存缓存加载 * finished：如果图像下载完成则为YES，如果使用 SDWebImageProgressiveDownload 选项，同时只获取到部分图片时，返回 NO * imageURL：图片的URL地址 * * @return SDWebImageOperation对象，应该是SDWebimageDownloaderOperation实例 */- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123; // Invoking this method without a completedBlock is pointless //没有completedblock，那么调用这个方法是毫无意义的 NSAssert(completedBlock != nil, @"If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead"); // Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, XCode won't // throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString. //检查用户传入的URL是否正确，如果该URL是NSString类型的，那么尝试转换 if ([url isKindOfClass:NSString.class]) &#123; url = [NSURL URLWithString:(NSString *)url]; &#125; // Prevents app crashing on argument type error like sending NSNull instead of NSURL //防止因参数类型错误而导致应用程序崩溃，判断URL是否是NSURL类型的，如果不是则直接设置为nil if (![url isKindOfClass:NSURL.class]) &#123; url = nil; &#125; //初始化一个SDWebImageCombinedOperationBlock块 __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new]; __weak SDWebImageCombinedOperation *weakOperation = operation; BOOL isFailedUrl = NO; //初始化设定该URL是正确的 //加互斥锁，检索请求图片的URL是否在曾下载失败的集合中（URL黑名单） @synchronized (self.failedURLs) &#123; isFailedUrl = [self.failedURLs containsObject:url]; &#125; //如果url不正确或者 选择的下载策略不是『下载失败尝试重新下载』且该URL存在于黑名单中，那么直接返回，回调任务完成block块，传递错误信息 if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123; //该宏保证了completedBlock回调在主线程中执行 dispatch_main_sync_safe(^&#123; NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil]; completedBlock(nil, error, SDImageCacheTypeNone, YES, url); &#125;); return operation; &#125; //加互斥锁，把当前的下载任务添加到『当前正在执行任务数组』中 @synchronized (self.runningOperations) &#123; [self.runningOperations addObject:operation]; &#125; //得到该URL对应的缓存KEY NSString *key = [self cacheKeyForURL:url]; //该方法查找URLKEY对应的图片缓存是否存在，查找完毕之后把该图片（存在|不存在）和该图片的缓存方法以block的方式传递 //缓存情况查找完毕之后，在block块中进行后续处理（如果该图片没有缓存·下载|如果缓存存在|如果用户设置了下载的缓存策略是刷新缓存如何处理等等） operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123; //先判断该下载操作是否已经被取消，如果被取消则把当前操作从runningOperations数组中移除，并直接返回 if (operation.isCancelled) &#123; @synchronized (self.runningOperations) &#123; [self.runningOperations removeObject:operation]; &#125; return; &#125; //（图片不存在||下载策略为刷新缓存）且（shouldDownloadImageForURL不能响应||该图片存在缓存） if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123; //从此处开始，一直在处理downloaderOptions（即下载策略） if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; //如果图像存在，但是下载策略为刷新缓存，则通知缓存图像并尝试重新下载 dispatch_main_sync_safe(^&#123; // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server. completedBlock(image, nil, cacheType, YES, url); &#125;); &#125; // download if no image or requested to refresh anyway, and download allowed by delegate SDWebImageDownloaderOptions downloaderOptions = 0; //如果下载策略为SDWebImageLowPriority 那么downloaderOptions = 其本身 if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority; if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload; if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache; if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground; if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies; if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates; if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority; if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; //如果图片存在，且下载策略为刷新刷新缓存 // force progressive off if image already cached but forced refreshing //如果图像已缓存，但需要刷新缓存，那么强制进行刷新 downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload; // ignore image read from NSURLCache if image if cached but force refreshing //忽略从NSURLCache读取图片 downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse; &#125; //到此处位置，downloaderOptions（即下载策略）处理操作结束 //核心方法：使用下载器，下载图片 id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) &#123; if (weakOperation.isCancelled) &#123; //如果此时操作被取消，那么什么也不做 // Do nothing if the operation was cancelled // See #699 for more details // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data &#125; else if (error) &#123; //如果下载失败，则处理结束的回调，在合适的情况下把对应图片的URL添加到黑名单中 dispatch_main_sync_safe(^&#123; if (!weakOperation.isCancelled) &#123; completedBlock(nil, error, SDImageCacheTypeNone, finished, url); &#125; &#125;); if ( error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost) &#123; @synchronized (self.failedURLs) &#123; [self.failedURLs addObject:url]; &#125; &#125; &#125; else &#123;//下载成功 //先判断当前的下载策略是否是SDWebImageRetryFailed，如果是那么把该URL从黑名单中删除 if ((options &amp; SDWebImageRetryFailed)) &#123; @synchronized (self.failedURLs) &#123; [self.failedURLs removeObject:url]; &#125; &#125; //是否要进行磁盘缓存？ BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly); //如果下载策略为SDWebImageRefreshCached且该图片缓存中存在且未下载下来，那么什么都不做 if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123; // Image refresh hit the NSURLCache cache, do not call the completion block &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123; //否则，如果下载图片存在且（不是可动画图片数组||下载策略为SDWebImageTransformAnimatedImage&amp;&amp;transformDownloadedImage方法可用） //开子线程处理 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; //在下载后立即将图像转换，并进行磁盘和内存缓存 UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];#warning 2 if (transformedImage &amp;&amp; finished) &#123; BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage]; [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk]; &#125; //在主线程中回调completedBlock dispatch_main_sync_safe(^&#123; if (!weakOperation.isCancelled) &#123; completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url); &#125; &#125;); &#125;); &#125; else &#123; //得到下载的图片且已经完成，则进行缓存处理 if (downloadedImage &amp;&amp; finished) &#123; [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk]; &#125; dispatch_main_sync_safe(^&#123; if (!weakOperation.isCancelled) &#123; completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url); &#125; &#125;); &#125; &#125; if (finished) &#123; @synchronized (self.runningOperations) &#123; [self.runningOperations removeObject:operation]; &#125; &#125; &#125;]; //处理cancelBlock operation.cancelBlock = ^&#123; [subOperation cancel]; @synchronized (self.runningOperations) &#123; [self.runningOperations removeObject:weakOperation]; &#125; &#125;; &#125; else if (image) &#123; //如果图片存在，且操作没有被取消，那么在主线程中回调completedBlock，并把当前操作移除 dispatch_main_sync_safe(^&#123; if (!weakOperation.isCancelled) &#123; completedBlock(image, nil, cacheType, YES, url); &#125; &#125;); @synchronized (self.runningOperations) &#123; [self.runningOperations removeObject:operation]; &#125; &#125; else &#123; // Image not in cache and download disallowed by delegate //图片不存在缓存且不允许代理下载，那么在主线程中回调completedBlock，并把当前操作移除 dispatch_main_sync_safe(^&#123; if (!weakOperation.isCancelled) &#123; completedBlock(nil, nil, SDImageCacheTypeNone, YES, url); &#125; &#125;); @synchronized (self.runningOperations) &#123; [self.runningOperations removeObject:operation]; &#125; &#125; &#125;]; return operation;&#125;/* * 根据图片的URL保存图片到缓存 * * @param image：缓存的图片 * @param url：该图片的URL地址 */- (void)saveImageToCache:(UIImage *)image forURL:(NSURL *)url &#123; //如果图片和url存在，则对该图片进行缓存处理 if (image &amp;&amp; url) &#123; NSString *key = [self cacheKeyForURL:url]; [self.imageCache storeImage:image forKey:key toDisk:YES]; &#125;&#125;//取消当前所有的操作- (void)cancelAll &#123; @synchronized (self.runningOperations) &#123; //得到当前所有正在执行的任务 NSArray *copiedOperations = [self.runningOperations copy]; //遍历数组中所有的操作，调用所有正在执行操作的cancel方法 [copiedOperations makeObjectsPerformSelector:@selector(cancel)]; //把这些操作从runningOperations数组中移除 [self.runningOperations removeObjectsInArray:copiedOperations]; &#125;&#125;//检查一个或多个操作是否正在运行- (BOOL)isRunning &#123; BOOL isRunning = NO; //初始设定为NO，即没有 //加互斥锁，根据runningOperations数组中元素的个数来判断当前是否有任务正在执行 @synchronized(self.runningOperations) &#123; isRunning = (self.runningOperations.count &gt; 0); &#125; return isRunning;&#125;@end@implementation SDWebImageCombinedOperation//取消block的回调- (void)setCancelBlock:(SDWebImageNoParamsBlock)cancelBlock &#123; // check if the operation is already cancelled, then we just call the cancelBlock if (self.isCancelled) &#123; if (cancelBlock) &#123; cancelBlock(); &#125; _cancelBlock = nil; // don't forget to nil the cancelBlock, otherwise we will get crashes &#125; else &#123; _cancelBlock = [cancelBlock copy]; &#125;&#125;//取消操作- (void)cancel &#123; self.cancelled = YES; //如果缓存操作存在，那么取消该操作的执行并赋值为nil if (self.cacheOperation) &#123; [self.cacheOperation cancel]; self.cacheOperation = nil; &#125; //取消block的回调 if (self.cancelBlock) &#123; self.cancelBlock(); // TODO: this is a temporary fix to #809. // Until we can figure the exact cause of the crash, going with the ivar instead of the setter// self.cancelBlock = nil; _cancelBlock = nil; &#125;&#125;@end//过时的方法@implementation SDWebImageManager (Deprecated)// deprecated method, uses the non deprecated method// adapter for the completion block- (id &lt;SDWebImageOperation&gt;)downloadWithURL:(NSURL *)url options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletedWithFinishedBlock)completedBlock &#123; return [self downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, cacheType, finished); &#125; &#125;];&#125;@end SDWebImage –&gt;知其然**亦知其所以然下载图片的核心方法使用#import &quot;SDWebImageManager.h&quot;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * 如果URL对应的图像在缓存中不存在，那么就下载指定的图片，否则返回缓存的图像 * * @param url 图片的URL地址 * @param options 图片下载选项（策略）,参考SDWebImageOptions的枚举值 * @param progressBlock 下载进度回调 * receivedSize 已经下载的数据大小 * expectedSize 要下载图片的总大小 * @param completedBlock 操作成功回调回调,该回调没有返回值 * Image：请求的 UIImage，如果出现错误，image参数是nil * error：如果图片下载成功则error为nil,否则error有值 * @param cacheType：图片缓存类型（内存缓存|沙盒缓存|直接下载）,SDImageCacheType枚举 * SDImageCacheTypeNone：从网络下载 * SDImageCacheTypeDisk：从本地缓存加载 * SDImageCacheTypeMemory：从内存缓存加载 * @param finished： * 1.如果图像下载完成则为YES * 2.如果没有使用 SDWebImageDownloaderProgressiveDownload，最后一个参数一直是 YES * 3.如果使用了 SDWebImageDownloaderProgressiveDownload 选项，此 block 会被重复调用 * 1)下载完成前，image 参数是部分图像，finished 参数是 NO * 2)最后一次被调用时，image 参数是完整图像，而 finished 参数是 YES * 3)如果出现错误，那么finished 参数也是 YES * @param imageURL：图片的URL地址 * * @return SDWebImageOperation对象，应该是SDWebimageDownloaderOperation实例 */- (void)download2 &#123; [[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:@"http://img4.duitang.com/uploads/blog/201310/18/20131018213446_smUw4.thumb.600_0.jpeg"] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; NSLog(@"%f",1.0 * receivedSize / expectedSize); &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; self.imageView.image = image; NSLog(@"download2--%@",[NSThread currentThread]); switch (cacheType) &#123; case SDImageCacheTypeNone: NSLog(@"网络下载"); break; case SDImageCacheTypeDisk: NSLog(@"使用磁盘缓存"); break; case SDImageCacheTypeMemory: NSLog(@"使用内存缓存"); break; default: break; &#125; &#125;];&#125; 打印输出效果: 应用场景:只需要简单获得一张图片,不进行其它设置，该方法会做内存缓存&amp;磁盘缓存。 这个框架有太多的东西值得我们去学习推敲，方方面面都透露着作者以及众多贡献者的智慧，我们读起来也一定会受益良多。 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 网络请求—「NSURLConnection连接」]]></title>
    <url>%2FiOSNET%2FNSURLConnection.html</url>
    <content type="text"><![CDATA[本篇文章主要从【NSURLConnection 详解使用】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： 文件下载分类 使用步骤 NSData(小文件下载) NSURLConnection使用1.NSURLConnection异步GET请求2.NSURLConnection代理GET请求3.NSURLConnection相关代理方法4.NSURLConnectionPOST请求 http通信过程 GET 和 POST 区别 大文件断点下载 文件上传步骤 多线程下载文件思路 1.文件下载分类 按照开发中实际需求，如果按下载的 [文件大小] 划分，可以分为：小文件下载、大文件下载。因为小文件下载基本不需要等待，可以使用返回整个文件的下载方式来进行文件下载，比如说图片。但是大文件下载需要考虑很多情况来改善用户体验，比如说：下载进度的显示、暂停下载以及断点续传、离线断点续传，还有下载时占用手机内存情况等等。 按照开发中请求方式，如果按开发 [实现方案] 划分，可以分为：NSData、NSURLConnection（iOS9.0之后舍弃）、NSURLSession（推荐），以及使用第三方框架AFNetworking 方式下载文件。 2.使用步骤NSURLConnection发送请求步骤： 创建一个NSURL对象，设置请求路径 传入NSURL创建一个NSURLRequest对象，设置请求头和请求体 使用NSURLConnection发送请求 NSURLConnection发送请求方法：1234567891.同步请求+ (NSData *)sendSynchronousRequest:(NSURLRequest *)request returningResponse:(NSURLResponse **)response error:(NSError **)error;2.异步请求：根据对服务器返回数据的处理方式的不同block回调：+ (void)sendAsynchronousRequest:(NSURLRequest*) request queue:(NSOperationQueue*) queue completionHandler:(void (^)(NSURLResponse* response, NSData* data, NSError* connectionError)) handler;delegate异步：设置代理，通过代理方法 3.NSData(小文件下载)12345NSURL *url = [NSURL URLWithString:@"[http://pic73.nipic.com/file/20150724/18576408_175304314596_2.jpg"];](http://pic73.nipic.com/file/20150724/18576408_175304314596_2.jpg%22];)NSData *data = [NSData dataWithContentsOfURL:url];UIImage *image = [UIImage imageWithData:data];self.imageView.image = image;刷新UI要放在主线程 4.NSURLConnection使用NSURLConnection异步GET请求123456789101112131415161718192021222324// 1.确定请求路径NSURL *url = [NSURL URLWithString:@"[http://120.25.226.186:32812/login?username=520it&amp;pwd=520it&amp;type=JSON"];](http://120.25.226.186:32812/login?username=520it&amp;pwd=520it&amp;type=JSON%22];)// 2.创建请求对象NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url];// 3.发送异步请求/* Request:请求对象 queue:队列（决定代码块completionHandler的在那个线程调用） completionHandler:当请求完成(成功|失败)的时候回调 response:响应头 data:响应体 connectionError:错误信息 */[NSURLConnection sendAsynchronousRequest:request queue:[[NSOperationQueue alloc]init] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; // 4.解析数据 NSLog(@"%@",[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]); NSLog(@"%@",[NSThread currentThread]); // 转换并打印响应头信息 NSHTTPURLResponse *r = (NSHTTPURLResponse *)response; NSLog(@"--%zd---%@--",r.statusCode,r.allHeaderFields);&#125;]; NSURLConnection代理GET请求12345678910// 1.确定urlNSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/resources/videos/minion_11.mp4"];// 2.异步(自动)发送GET请求，并实现相应的代理方法// 该方法iOS9.0之后废除了（推荐使用NSURLSession）。NSURLConnection * connect = [NSURLConnection connectionWithRequest:[NSURLRequest requestWithURL:url] delegate:self];// 设置代理方法的执行队列// 说明：默认情况下，代理方法会在主线程中进行调用（为了方便开发者拿到数据后处理一些刷新UI的操作不需要考虑到线程间通信）[connect setDelegateQueue:[[NSOperationQueue alloc]init]]; NSURLConnection相关代理方法1234567891011121314151617#pragma mark - NSURLConnectionDataDelegate// 1.当 接收到服务器响应 的时候调用-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123;&#125;;// 2.接收到服务器返回数据 的时候调用,调用多次（返回的NSData二进制数据(可能是片段)）-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123; // 拼接数据 [self.resultData appendData:data];&#125;// 3.请求完成 的时候调用（通常在该方法中解析服务器返回的数据）-(void)connectionDidFinishLoading:(NSURLConnection *)connection &#123; NSLog(@"%@",[[NSString alloc]initWithData:self.resultData encoding:NSUTF8StringEncoding]);&#125;// 4.当请求失败 的时候调用-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123;&#125;; NSURLConnectionPOST请求12345678910111213141516171819202122232425// 1.确定请求路径NSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/login"];// 2.创建可变请求对象NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];// 3.设置 NSMutableURLRequest 属性// 请求方法（POST必须大写）request.HTTPMethod = @"POST";// 请求超时request.timeoutInterval = 10;// 请求头User-Agent（注意:key一定要一致(用于传递数据给后台)）[request setValue:@"ios 10.1" forHTTPHeaderField:@"User-Agent"];// 请求体信息,字符串---&gt;NSDatarequest.HTTPBody = [@"username=520it&amp;pwd=123&amp;type=JSON" dataUsingEncoding:NSUTF8StringEncoding];// 4.发送请求[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; if (connectionError) &#123; NSLog(@"--请求失败--"); &#125; else &#123; // 5.解析数据 NSLog(@"%@",[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]); &#125;&#125;]; 5.http通信过程1234567请求：请求头(NSURLRequest默认包含)+请求体(GET没有)响应：响应头(真实类型-&gt;NSHTTPURLResponse)+响应体(要解析的数据)GET：http://120.25.226.186:32812/login?username=123&amp;pwd=456&amp;type=JSON协议+主机地址+接口名称+?+参数1&amp;参数2&amp;参数3POST：http://120.25.226.186:32812/login协议+主机地址+接口名称 6.GET 和 POST 区别123456781.get请求和post请求都可以用于做获取数据请求2.在请求数据安全方面post请求比get请求安全 1).get是以明文的方式向服务器发送请求 2).post是包装到请求体body中后，在向服务器发送请求 3).get请求的参数全部暴露在接口中，一般叫做明文请求或者傻瓜式请求，post请求的参数一般是以字典的方式进行拼接，相对于get比较安全3.get请求的URL在使用过程中，会限制长度，因此长度非常长的请求建议用post请求4.对文件大小的请求：get不允许向服务器上传文件(图片，pdf，音视频)5.如果从服务器获取数据，或者查询数据，使用get请求;如果上传数据到服务器或者修改服务器上传数据使用post请求 7.大文件断点下载12341.实现思路在下载文件的时候不再是整块的从头开始下载，而是看当前文件已经下载到哪个地方，然后从该地方接着往后面下载。2.解决方案（通过设置请求头中的Range告诉服务器值请求一部分数据 来实现）边下载变写入沙盒，采用追加的方式。(这里是一个线程) 8.文件上传步骤123456789101.确定请求路径2.根据URL创建一个可变的请求对象3.设置请求对象，修改请求方式为POST4.设置请求头，告诉服务器我们将要上传文件（Content-Type）5.设置请求体（在请求体中按照既定的格式拼接要上传的文件参数和非文件参数等数据）1).拼接文件参数2).拼接非文件参数3).添加结尾标记6.使用NSURLConnection sendAsync发送异步请求上传文件7.解析服务器返回的数据 9.多线程下载文件思路12345678910需求:优化下载解决:开启多个线程下载注意:1.目前是多个线程同时工作且异步执行的，这时就不能采用直接追加的方式了(会出现数据错乱的现象)1.开启多条线程，每条线程都只下载文件的一部分（采用:通过设置请求头中的Range告诉服务器值请求一部分数据 来实现）2.创建一个和需要下载文件大小一致的文件，判断当前是那个线程，根据当前的线程来判断下载的数据应该写入到文件中的哪个位置。（假设开5条线程来下载10M的文件，那么线程1下载0-2M，线程2下载2-4M一次类推，当接收到服务器返回的数据之后应该先判断当前线程是哪个线程，假如当前线程是线程2，那么在写数据的时候就从文件的2M位置开始写入）3.代码相关：使用NSFileHandle这个类的seekToFileOfSet方法，来向文件中特定的位置写入数据。4.技术相关1).每个线程通过设置请求头下载文件中的某一个部分2).通过NSFileHandle向文件中的指定位置写数据 【@码员真爱 : 真的不点进去阅读一下 ❓】【译文 &amp; 源码】 【工具类】 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage框架学习]]></title>
    <url>%2FSourceAnnotations%2FSDLibrary.html</url>
    <content type="text"><![CDATA[Write in the first SDWebImage 是我们经常使用的一个异步图片加载库，在项目中使用SDWebImage来管理图片加载相关操作可以极大地提高开发效率，让我们更加专注于业务逻辑实现。像这种经常用又比较重要的内容，我觉得要做到初步理解，然后梳理总结常用方法，到最后夯实基础、活学活用。为此，自己本着好好学习，了解权威的目的，决定解读 SDWebImage框架。 本篇文章主要从【SD 框架结构】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： SDWebImage的概论 SDWebImage的内部结构 SDWebImage的实现原理 SDWebImage的工作流程 SDWebImage框架基本使用 SDWebImage框架内部细节 1. SDWebImage的概论 提供了一个UIImageView的category用来加载网络图片并且对网络图片的缓存进行管理 采用异步方式来下载网络图片 采用异步方式，使用memory＋disk来缓存网络图片，自动管理缓存。 支持GIF动画 支持WebP格式 同一个URL的网络图片不会被重复下载 失效的URL不会被无限重试 耗时操作都在子线程，确保不会阻塞主线程 使用GCD和ARC 支持Arm64 2. SDWebImage的内部结构 3. SDWebImage的实现原理SDWebImage 是由一个 SDImageCache(一个处理缓存的类) 和 SDWebImageDownloader(负责下载网络图片) ，而 SDWebImageManager则是管理者将前两者结合起来完成整个工作流程。 通过对UIImageView的类别扩展来实现异步加载替换图片的工作。主要用到的对象： 1.UIImageView (WebCache)类别，入口封装，实现读取图片完成后的回调 2.SDWebImageManager，对图片进行管理的中转站，记录那些图片正在读取。向下层读取Cache（调用SDImageCache），或者向网络读取对象（调用SDWebImageDownloader）。实现SDImageCache和SDWebImageDownloader的回调。 3.SDImageCache，根据URL的MD5摘要对图片进行存储和读取（实现存在内存中或者存在硬盘上两种实现）实现图片和内存清理工作。 4.SDWebImageDownloader，根据URL向网络读取数据（实现部分读取和全部读取后再通知回调两种方式 4. SDWebImage的工作流程 SDWebImage是一个成熟而且比较庞大的框架，但是在使用过程中并不需要太多的接口,这算是一种代码封装程度的体现。这里就介绍比较常用的几个接口。123456789101112131415161718192021222324252627282930313233343536梳理SDWebImage的 工作流程1.入口方法：调用 UIImageView+WebCache 的分类方法self.imageView： sd_setImageWithURL: placeholderImage: options: progress: completed:这个方法，如果传入的下载策略不是SDWebImageDelayPlaceholder 延迟显示占位图片，默认情况下先显示 placeholderImage ，同时由SDWebImageManager根据 URL 来在本地查找图片。2.进入方法：初始化 SDWebImageManager 管理器并调用：SDWebImageManager：downloadImageWithURL: options: progress: completed:1). SDWebImageManager 是将UIImageView+WebCache同SDImageCache 链接起来的类，图片缓存是在内存缓存一份,在磁盘缓存一份.3.SDImageCache：queryDiskCacheForKey: done:该方法查找 cacheKey(URL对应的缓存KEY) 对应下载图片的缓存情况，先检查是否有内存缓存4.检查该`cacheKey`对应的内存缓存，如果存在内存缓存，则直接返回，并把图片和存储方式（内存缓存）通过block块以参数的形式传递。前端来显示图片。5.如果缓存对应的key为空，那么创建一个操作NSOperation 添加到串行队列，从磁盘查找图片是否已被下载缓存。6.检查该 cacheKey 在硬盘缓存目录下尝试读取图片文件，这里回调doneBlock 结果，要在主线程中回调。7.如果存在磁盘缓存，且应该把该图片保存一份到内存缓存中（则先计算该图片的cost(成本)，如果空闲内存过小，会先清空内存缓存）。然后并把图片和存储方式（磁盘缓存）通过block块以参数的形式传递，展示图片。8.如果从硬盘缓存目录没有读取到图片,说明所有缓存都不存在该图片(无缓存)，需要下载图片。9.使用异步下载器下载图片：初始化 SDWebImageDownloader 并创建新的图片下载任务，得到一的 SDWebImageOperation 对象。SDWebImageDownloader：downloadImageWithURL: options: progress: completed: 图像下载完成或者出现错误时会通知代理10.核心方法：下载图片的操作把 SDWebImageOperation 对象添加到 NSOperationQueue 队列中开始异步下载，会调用 start 方法：SDWebImageDownloaderOperation ：在 start 方法中处理图片下载操作创建 NSURLConnection链接对象发送请求，并设置代理 5. SDWebImage框架基本使用UIImageView+WebCache.h 下载图片12345678910111213141516171819202122232425262728293031323334353637383940//下载图片的核心方法/* * 下载图片且需要获取下载进度(内存缓存&amp;磁盘缓存) * 根据图片的url下载图片并设置到ImageView上面去，异步下载并缓存 * * @param url 图片的URL地址 * @param options 图片下载选项（策略）,参考SDWebImageOptions的枚举值 * @param progressBlock 下载进度回调 * receivedSize 已经下载的数据大小 * expectedSize 要下载图片的总大小 * @param completedBlock 操作成功回调回调,该回调没有返回值 * Image：请求的 UIImage，如果出现错误，image参数是nil * error：如果图片下载成功则error为nil,否则error有值 * @param cacheType：图片缓存类型（内存缓存|沙盒缓存|直接下载）,SDImageCacheType枚举 * SDImageCacheTypeNone：从网络下载 * SDImageCacheTypeDisk：从本地缓存加载 * SDImageCacheTypeMemory：从内存缓存加载 * @param imageURL：图片的URL地址 */- (void)download1 &#123; [self.imageView sd_setImageWithURL:[NSURL URLWithString:@"http://img4.duitang.com/uploads/blog/201310/18/20131018213446_smUw4.thumb.600_0.jpeg"] placeholderImage:[UIImage imageNamed:@"placeholder"] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; NSLog(@"%f",1.0 * receivedSize / expectedSize); &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123; self.imageView.image = image; NSLog(@"download3--%@",[NSThread currentThread]); switch (cacheType) &#123; case SDImageCacheTypeNone: NSLog(@"网络下载"); break; case SDImageCacheTypeDisk: NSLog(@"使用磁盘缓存"); break; case SDImageCacheTypeMemory: NSLog(@"使用内存缓存"); break; default: break; &#125; &#125;];&#125; SDWebImageManager 管理者123456789101112131415161718192021222324252627282930313233/* * 只需要简单获得一张图片,不设置（内存缓存&amp;磁盘缓存） * 如果URL对应的图像在缓存中不存在，那么就下载指定的图片，否则返回缓存的图像 * * @param finished： * 1.如果图像下载完成则为YES * 2.如果没有使用 SDWebImageDownloaderProgressiveDownload，最后一个参数一直是 YES * 3.如果使用了 SDWebImageDownloaderProgressiveDownload 选项，此 block 会被重复调用 * 1)下载完成前，image 参数是部分图像，finished 参数是 NO * 2)最后一次被调用时，image 参数是完整图像，而 finished 参数是 YES * 3)如果出现错误，那么finished 参数也是 YES */- (void)download2 &#123; [[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:@"http://img4.duitang.com/uploads/blog/201310/18/20131018213446_smUw4.thumb.600_0.jpeg"] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; NSLog(@"%f",1.0 * receivedSize / expectedSize); &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; self.imageView.image = image; NSLog(@"download2--%@",[NSThread currentThread]); switch (cacheType) &#123; case SDImageCacheTypeNone: NSLog(@"网络下载"); break; case SDImageCacheTypeDisk: NSLog(@"使用磁盘缓存"); break; case SDImageCacheTypeMemory: NSLog(@"使用内存缓存"); break; default: break; &#125; &#125;];&#125; SDWebImageDownloader 工具类(文件下载)12345678910111213141516171819// 下载图片的核心方法/* * 不需要任何的缓存处理(没有做任何缓存处理) * 使用给定的 URL 创建 SDWebImageDownloader 异步下载器实例 */- (void)download3 &#123; [[SDWebImageDownloader sharedDownloader] downloadImageWithURL:[NSURL URLWithString:@"http://img4.duitang.com/uploads/blog/201310/18/20131018213446_smUw4.thumb.600_0.jpeg"] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; NSLog(@"%f",1.0 * receivedSize / expectedSize); &#125; completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123; /** 注意:completed完成后这里是在子线程中执行的 */ // 线程间通信(回到主线程刷新UI) [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; self.imageView.image = image; NSLog(@"download3--%@",[NSThread currentThread]); &#125;]; &#125;];&#125; 6. SDWebImage框架内部细节1.SDImageCache是怎么做数据管理的? SDImageCache分两个部分，一个是内存层面的，一个是磁盘层面的。内存层面的相当是个缓存器，以Key-Value的形式存储图片。当内存不够的时候会清除所有缓存图片。用搜索文件系统的方式做管理，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。当SDWebImageManager向SDImageCache要资源时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从磁盘读取出来，将图片对象放到内存层面做备份，再返回调用层 2.系统级内存警告如何处理（面试）?123456789// 1.清空缓存// clearDisk 清除磁盘缓存,直接删除然后重新创建(所有缓存目录中的文件全部删除，再创建一个同名空目录)// cleanDisk 清除过期的磁盘缓存,计算当前缓存的大小,和设置的最大缓存数量比较, 如果超出那么会继续删除(按照文件的创建的先后顺序)，直到小于最大缓存数量 过期是 maxCacheAge =7天[[SDWebImageManager sharedManager].imageCache cleanDisk]; // 2.取消当前所有的操作[[SDWebImageManager sharedManager] cancelAll]; 3.该框架内部对内存警告的处理方式?内部通过监听通知的方式清理缓存 1.监听到UIApplicationDidReceiveMemoryWarningNotification接收到内存警告的通知后，调用 clearMemory 方法,清除内存缓存 2.当监听到UIApplicationWillTerminateNotification接收到应用程序将要终止通知，调用 cleanDisk 方法,清理过期(默认大于一周)的磁盘缓存 3.当监听到UIApplicationDidEnterBackgroundNotification接收到应用程序进入后台通知，调用 backgroundCleanDisk 方法,清理过期磁盘缓存 补充：内存缓存: 使用NSCahce对象实现，最大内存缓存值以像素为单位磁盘缓存: 使用 NSFileManager 存储在 Cache 目录中，最大磁盘缓存是以字节为单位，最大磁盘缓存的时间默认为1周 4.最大并发数量1maxConcurrentOperationCount = 6 5.缓存文件的保存名称如何处理?SDImageCache，拿到图片的URL路径,对该路径进行MD5加密对图片进行存储和读取。 6.该框架进行缓存处理的方式?可变字典—&gt;NSCache 7.如何判断图片的类型?12345678910111213141516在判断图片类型的时候，只匹配第一个字节#import "NSData+ImageContentType.h"// 判断图片类型拿到文件的二进制数据，取出第一个字节和switch里的分支比较来判断PNG：压缩比没有JPG高，但是无损压缩，解压缩性能高，苹果推荐的图像格式！JPG：压缩比最高的一种图片格式，有损压缩！最多使用的场景，照相机！解压缩的性能不好！GIF：序列桢动图，特点：只支持256种颜色！最流行的时候在1998～1999，有专利的！SDWebImage缓存图片的名称是用URL的md5加密后生成的32位字符串作为文件名的利用通知中心观察，能够保证缓存文件的大小始终在控制范围之内！``` 示例：```objc// 5.判断图片类型NSData *imageData = [NSData dataWithContentsOfFile:@"/Users/sunhui/Desktop/Snip20170209_1.png"];NSString *typeStr = [NSData sd_contentTypeForImageData:imageData];NSLog(@"%@",typeStr);// image/png 8.播放Gif图片?1234#import "UIImage+GIF.h"// 播放Gif图片UIImage *image = [UIImage sd_animatedGIFNamed:@"imageGif"];self.imageView.image = image; 9.队列中任务的处理方式?FIFO,下载任务的执行方式：默认为先进先出 10.请求超时的时间?1downloadTimeout 默认：15秒 PS.最后分享一下学习多线程自定义NSOperation下载图片思路： 文字解析: 1.根据图片的url先去检查images(内存缓存)中该图片是否存在，如果存在就直接显示到cell上；否则去检查磁盘缓存(沙盒)。 2.如果有磁盘缓存(沙盒)，加载沙盒中对应的图片显示到cell上，再保存一份到内存缓存；否则先显示占位图片，再检查operations(操作缓存)中该图片是否正在下载，如果是 就等待下载；否则创建下载operations操作任务,保存到操作缓存中去下载。 3.下载完成后(需要主动刷新显示(采用局部刷新))，将操作从操作缓存中移除，将图片在内存缓存(先) 和 沙盒(后)中各保存一份。 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIViewApple译文]]></title>
    <url>%2FAppleTranslation%2FUIViewApple.html</url>
    <content type="text"><![CDATA[📌 导语在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。  首先附上官方原文地址 API Reference - UIView Class Relationships Inherits From 继承自: UIResponder : NSObject Conforms To 遵守: UICoordinateSpace，UIDynamicItem，UIFocusItem，UITraitEnvironment，CALayerDelegate，NSCoding，UIAppearance，UIAppearanceContainer Framework SDKs iOS 2.0+ Class📌 UIView The UIView class defines a rectangular area on the screen and the interfaces for managing the content in that area. UIView 类在屏幕和界面上定义了一块矩形区域，用来管理那块区域的内容。 📌 Overview At runtime, a view object handles the rendering of any content in its area and also handles any interactions with that content. The UIView class itself provides basic behavior for filling its rectangular area with a background color. More sophisticated content can be presented by subclassing UIView and implementing the necessary drawing and event-handling code yourself. The UIKit framework also includes a set of standard subclasses that range from simple buttons to complex tables and can be used as-is. For example, a UILabel object draws a text string and a UIImageView object draws an image. 在运行时，一个View对象处理它所在区域的内容渲染和交互。UIView类会使用背景颜色填充所在的矩形区域。更复杂的内容可以用UIView的子类来呈现，你自己来实现必要的绘画和事件处理代码。UIKit框架同时提供了一些标准子类，从简单的按钮到复杂的表格，你可以直接使用。如，UILabel 对象画文本字符串，UIImageView 对象画图像。 🏷Because view objects are the main way your application interacts with the user, they have a number of responsibilities. Here are just a few: Drawing and animation Views draw content in their rectangular area using technologies such as UIKit, Core Graphics, and OpenGL ES. Some view Declared property can be animated to new values. Layout and subview management A view may contain zero or more subviews. Each view defines its own default resizing behavior in relation to its parent view. A view can define the size and position of its subviews as needed. Event handling A view is a responder and can handle touch events and other events defined by the UIResponder class. Views can use the addGestureRecognizer: method to install gesture recognizers to handle common gestures. 因为View对象是应用与用户交互的主要途径，他们有一系列的职责。以下列出一些: 绘画和动画: View在他们的矩形区域使用UIKit，Core Graphics和OpenGL ES之类的技术绘画。 一些视图属性可以动画到新的值。 布局和子 View 管理 一个View可以包含0个或多个子View。 每个View都定义了相对父View大小改变的默认行为。 如有需要，一个View可以定义子View的大小和位置。 事件处理 View是一个响应者，可以处理 UIResponder 类定义的触摸和其他事件。 View可以使用 addGestureRecognizer 方法安装手势识别器来处理常用手势。 🏷Views can embed other views and create sophisticated visual hierarchies. This creates a parent-child relationship between the view being embedded (known as the subview) and the parent view doing the embedding (known as the superview). Normally, a subview’s visible area is not clipped to the bounds of its superview, but in iOS you can use the clipsToBounds property to alter that behavior. A parent view may contain any number of subviews but each subview has only one superview, which is responsible for positioning its subviews appropriately. View可以内嵌到其他View，创建复杂的可视层级。这会在嵌入的View(子View)和被嵌入的View(父View)间创建父子关系。正常情况下，子View的可视区域不会被父View的边界剪辑，但在iOS里你可以使用 clipsToBounds 属性来修改这个行为。一个父View可能有多个子View,但一个子View只有一个父View，它负责确定子View的位置。 🏷The geometry of a view is defined by its frame , bounds , and center properties. The frame defines the origin and dimensions of the view in the coordinate system of its superview and is commonly used during layout to adjust the size or position of the view. The center property can be used to adjust the position of the view without changing its size. The bounds defines the internal dimensions of the view as it sees them and is used almost exclusively in custom drawing code. The size portion of the frame and bounds rectangles are coupled together so that changing the size of either rectangle updates the size of both. For detailed information about how to use the UIView class, see View Programming Guide for iOS . View的几何结构是通过它的框架(frame)，边界(bounds)和中心(center)属性来定义的。frame定义了View相对父View坐标系的原点和大小，一般在View布局和调整尺寸或位置时使用。center属性可以在不改变view的大小来调整view的位置。bounds定义了view的内部尺寸，几乎只在自定义绘画代码时使用。frame的size部分和bounds矩形部分耦合在一起，所以可以使用两者中的一个或两个同时来改变view的大小。 更多关于如何使用 UIView 类，参见iOS View编程向导(View Programming Guide for iOS) NoteIn iOS 2.x, the maximum size of a UIView object is 1024 x 1024 points. In iOS 3.0 and later, views are no longer restricted to this maximum size but are still limited by the amount of memory they consume. It is in your best interests to keep view sizes as small as possible. Regardless of which version of iOS is running, you should consider tiling any content that is significantly larger than the dimensions of the screen. 注意在iOS 2.x时，UIView的最大尺寸是1024*1024点，在iOS 3.0以后，不再强制限制大小，而是受限于内存消耗。让View尽可能小，无论运行在哪个版本的iOS上，都应该考虑避免View明显大于屏幕尺寸 📌 Creating a View「创建一个View」 To create a view programmatically, you can use code like the following:以编程方式创建一个视图，您可以使用代码如下: Objective-c12CGRect viewRect = CGRectMake(10, 10, 100, 100);UIView* myView = [[UIView alloc] initWithFrame:viewRect]; swift12let viewRect = CGRect(x: 10, y: 10, width: 100, height: 100)let myView = UIView(frame: viewRect) This code creates the view and positions it at the point (10, 10) in its superview’s coordinate system (once it is added to that superview). To add a subview to another view, you use the addSubview: method. In iOS, sibling views may overlap each other without any issues, allowing complex view placement. The addSubview: method places the specified view on top of other siblings. You can specify the relative z-order of a subview by adding it using the insertSubview:aboveSubview: and insertSubview:belowSubview: methods. You can also exchange the position of already added subviews using the exchangeSubviewAtIndex:withSubviewAtIndex: method. 这段代码创建了view，并把它放在父view坐标系的(10,10)点(一旦它被加到父view)。添加一个子view到另一个view上，用addSubview:方法。在 iOS 里，同级的view可以相互覆盖，而不会有任何问题，允许复杂的view布置。addSubview放置指定的view到它的同级view的顶部。你可以使用insertSubview:aboveSubview: 和 insertSubview:belowSubview: 方法指定子view的相对z坐标。你也可以使用exchangeSubviewAtIndex:withSubviewAtIndex:方法交换已经添加的子view的位置。 🏷When creating a view, it is important to assign an appropriate value to the autoresizingMask property to ensure the view resizes correctly. View resizing primarily occurs when the orientation of your application’s interface changes but it may happen at other times as well. For example, calling the setNeedsLayout method forces your view to update its layout. 当创建一个视图，适当的属性值分配给autoresizingMask，以确保视图尺寸正确。视图调整主要发生在应用程序的接口的方向变化，但也可能发生在其他时间。例如，调用setNeedsLayout方法迫使你的视图更新它的布局。 📌 The View Drawing Cycle「绘制周期」 View drawing occurs on an as-needed basis. When a view is first shown, or when all or part of it becomes visible due to layout changes, the system asks the view to draw its contents. For views that contain custom content using UIKit or Core Graphics, the system calls the view’s drawRect: method. Your implementation of this method is responsible for drawing the view’s content into the current graphics context, which is set up by the system automatically prior to calling this method. This creates a static visual representation of your view’s content that can then be displayed on the screen. View绘画发生在需要时。当一个view第一次展示时，或者在布局变化时，它的整体或部分变得可见时，系统请求view绘出它的内容。对那些使用UIKit或Core Graphics包含自定义内容的view来说，系统会调用它的 drawRect: 方法。你对该方法的实现，负责将view的内容画进当前的图形上下文(graphics context),系统自动优先调用该方法。这里创建了view内容的静态可视展现，接着会被展示在屏幕上。 🏷When the actual content of your view changes, it is your responsibility to notify the system that your view needs to be redrawn. You do this by calling your view’s setNeedsDisplay or setNeedsDisplayInRect: method of the view. These methods let the system know that it should update the view during the next drawing cycle. Because it waits until the next drawing cycle to update the view, you can call these methods on multiple views to update them at the same time. 当view的真实内容发生改变时，你有责任通知系统你的view需要重绘。通过调用view的 setNeedsDisplay 或setNeedsDisplayInRect: 方法来通知。这些方法让系统知道它应该在下次绘画周期更新View.因为它一直等待直到下次绘画周期来更新View，你可以在多个view上调用这些方法，同时更新它们. NoteIf you are using OpenGL ES to do your drawing, you should use the GLKView class instead of subclassing UIView. For more information about how to draw using OpenGL ES, see OpenGL ES Programming Guide . 注意如果你用OpenGL ES来绘画，应该用GLKView类来代替UIView.更多信息关于如何用OpenGL ES绘画，参见 iOS OpenGL ES编程向导（see OpenGL ES Programming Guide） For detailed information about the view drawing cycle and the role your views have in this cycle, see View Programming Guide for iOS.更多关于View绘画周期和你的view的角色，参见iOS View编程向导(View Programming Guide for iOS.) 📌 Animations「动画」 Changes to several view properties can be animated—that is, changing the property creates an animation that conveys the change to the user over a short period of time. The UIView class does most of the work of performing the actual animations but you must still indicate which property changes you want to be animated. There are two different ways to initiate animations: In iOS 4 and later, use the block-based animation methods. (Recommended) Use the begin/commit animation methods. 改变多个View属性可以被动画展现，在一个短周期时间内，改变属性可以创建动画。UIView类做了很多执行动画的工作，但你仍然必须判断你需要哪些属性改变被动画。下面是两种不同的初始化动画方法： 在iOS4.0及以后的版本中，使用基于块的动画方法(推荐) 使用开始/提交(begin/commit)动画方法。 🏷The block-based animation methods (such as animateWithDuration:animations: ) greatly simplify the creation of animations. With one method call, you specify the animations to be performed and the options for the animation. However, block-based animations are available only in iOS 4 and later. If your application runs on earlier versions of iOS, you must use the beginAnimations:context: and commitAnimations class methods to mark the beginning and ending of your animations. 基于块的动画方法(像 animateWithDuration:animations: )极大地简化了动画创建。只要调用一个方法，指定动画的参数，并且执行动画。然后，基于块的动画仅在iOS4及以后版本中可用。如果你的设备运行老版本的iOS,必须使用 beginAnimations:context: 和 commitAnimations 类方法标记动画开始和结束。 The following properties of the UIView class are animatable: frame bounds center transform alpha backgroundColor 可以做成动画UIView类的属性如下: @property frame @property bounds @property center @property transform @property alpha @property backgroundColor For more information about how to configure animations, see View Programming Guide for iOS .更多关于如何配置动画，请参见视图iOS编程指南 View Programming Guide for iOS 。 📌 Threading Considerations「线程注意事项」 Manipulations to your application’s user interface must occur on the main thread. Thus, you should always call the methods of the UIView class from code running in the main thread of your application. The only time this may not be strictly necessary is when creating the view object itself but all other manipulations should occur on the main thread. 操作用户界面必须发生在主线程。因此，你必须在应用主线程调用UIView类的方法。只有在创建view对象自身时可以不用严格遵守，但其他操作必须在主线程中。 📌 Subclassing Notes「子类化(继承)说明」 The UIView class is a key subclassing point for visual content that also requires user interactions. Although there are many good reasons to subclass UIView, it is recommended that you do so only when the basic UIView class or the standard system views do not provide the capabilities that you need. Subclassing requires more work on your part to implement the view and to tune its performance. 对同样需要用户交互的可见内容来说，UIView类是一个关键的子类化点。尽管有很多好理由继承UIView，但我们只推荐在基本的UIView和系统自带的其他组件不能满足需要时继承UIView.继承UIView会在你实现的代码里消耗更多性能.(Apple写的代码比你的更好，有现成的就用现成的)。 For information about ways to avoid subclassing, see Alternatives to Subclassing .更多关于子类化信息，请参见选择子类化 Alternatives to Subclassing。 📌 Methods to Override「覆盖方法」 When subclassing UIView, there are only a handful of methods you should override and many methods that you might override depending on your needs. Because UIView is a highly configurable class, there are also many ways to implement sophisticated view behaviors without overriding custom methods, which are discussed in the Alternatives to Subclassing section. In the meantime, the following list includes the methods you might consider overriding in your UIView subclasses: Initialization: initWithFrame: - It is recommended that you implement this method. You can also implement custom initialization methods in addition to, or instead of, this method. initWithCoder: - Implement this method if you load your view from an Interface Builder nib file and your view requires custom initialization. layerClass Use this property only if you want your view to use a different Core Animation layer for its backing store. For example, if your view uses tiling to display a large scrollable area, you might want to set the property to the CATiledLayer class. Drawing and printing: drawRect: - Implement this method if your view draws custom content. If your view does not do any custom drawing, avoid overriding this method. drawRect:forViewPrintFormatter: - Implement this method only if you want to draw your view’s content differently during printing. Constraints: requiresConstraintBasedLayout Use this property if your view class requires constraints to work properly. updateConstraints - Implement this method if your view needs to create custom constraints between your subviews. alignmentRectForFrame:, frameForAlignmentRect: - Implement these methods to override how your views are aligned to other views. Layout: sizeThatFits: - Implement this method if you want your view to have a different default size than it normally would during resizing operations. For example, you might use this method to prevent your view from shrinking to the point where subviews cannot be displayed correctly. layoutSubviews - Implement this method if you need more precise control over the layout of your subviews than either the constraint or autoresizing behaviors provide. didAddSubview: , willRemoveSubview: - Implement these methods as needed to track the additions and removals of subviews. willMoveToSuperview:, didMoveToSuperview - Implement these methods as needed to track the movement of the current view in your view hierarchy. willMoveToWindow: , didMoveToWindow - Implement these methods as needed to track the movement of your view to a different window. Event Handling: touchesBegan:withEvent:, touchesMoved:withEvent:, touchesEnded:withEvent: , touchesCancelled:withEvent: - Implement these methods if you need to handle touch events directly. (For gesture-based input, use gesture recognizers.) gestureRecognizerShouldBegin: - Implement this method if your view handles touch events directly and might want to prevent attached gesture recognizers from triggering additional actions. 当子类化 UIView 时，只有少数的方法你必须覆盖，大多数方法你可以按需覆盖。因为UIView是一个高度可配的类，不用覆盖父类方法，同样有很多实现复杂的行为的途径，这些在 选择子类化 一节中介绍。你可以在你的UIView子类中考虑覆盖下面列表中的方法： 初始化 initWithFrame : 推荐覆盖。你同样可以实现自定义的初始化方法添加或代替此方法 initWithCoder : 如果你从一个Interface Builder的nib文件加载view，并且需要自定义初始化，覆盖该方法。 layerClass : 仅当你的view需要用不同的Core Animation层后备保存时才要覆盖。例如，当你的view需要用平铺方式显示一块很大的可滚动区域时，你可能想要覆盖该方法返回CATiledLayer类.(这里不是很明白) 绘画和打印 drawRect : 如果你的View画自定义的内容，就要实现该方法，否则避免覆盖该方法。 drawRect : forViewPrintFormatter:仅当你需要在打印时，打印不同内容(与显示不同)才需要实现该方法。 约束 requiresConstraintBasedLayout : – 如果你的View类需要约束才能正常工作，实现该方法 updateConstraints : 如果你的view需要在子view间创建约束，需要实现该方法 alignmentRectForFrame :, frameForAlignmentRect:– 实现这些方法覆盖你的view如何与其他view对齐 布局 sizeThatFits :: – 当你想在执行resize操作时有一个不同于默认的size，实现该方法。比如，你可以用这个方法阻止view收缩到子view不能正确显示的点 layoutSubviews : – 如果你需要更精确控制子view，而不是使用限制或autoresizing行为，就需要实现该方法。 didAddSubview :: , willRemoveSubview:跟踪子view添加或删除事件 willMoveToSuperview :, didMoveToSuperview 跟踪当前view在view层次里的运动 willMoveToWindow :,didMoveToWindow 跟踪view(即将或已经)移动到另一个Window 事件处理: touchesBegan:withEvent :, touchesMoved:withEvent:, touchesEnded:withEvent:,touchesCancelled:withEvent: 直接处理触摸事件(如果是手势，使用gesture recognizers) gestureRecognizerShouldBegin : 如果需要直接处理触摸事件，那么需要覆盖该方法，阻止手势识别器触发额外动作。 📌 Alternatives to Subclassing「替代子类化」Many view behaviors can be configured without the need for subclassing. Before you start overriding methods, consider whether modifying the following properties or behaviors would provide the behavior you need. addConstraint: - Define automatic layout behavior for the view and its subviews. autoresizingMask: - Provides automatic layout behavior when the superview’s frame changes. These behaviors can be combined with constraints. contentMode: - Provides layout behavior for the view’s content, as opposed to the frame of the view. This property also affects how the content is scaled to fit the view and whether it is cached or redrawn. hidden or alpha: - Change the transparency of the view as a whole rather than hiding or applying alpha to your view’s rendered content. backgroundColor: - Set the view’s color rather than drawing that color yourself. Subviews - Rather than draw your content using a drawRect: method, embed image and label subviews with the content you want to present. Gesture recognizers - Rather than subclass to intercept and handle touch events yourself, you can use gesture recognizers to send an Target-Action to a target object. Animations - Use the built-in animation support rather than trying to animate changes yourself. The animation support provided by Core Animation is fast and easy to use. Image-based backgrounds - For views that display relatively static content, consider using a UIImageView object with gesture recognizers instead of subclassing and drawing the image yourself. Alternatively, you can also use a generic UIView object and assign your image as the content of the view’s CALayer object. 很多view行为可以配置而不用子类化。在你开始覆盖这些方法时，考虑是否可以修改下面的属性或行为来提供你需要的功能。 addConstraint: – 为view和它的子view定义自动布局行为. autoresizingMask: – 当父view的frame改变时，提供自动布局行为。这些行为可以和约束(Constraint)合并 contentMode: -为view内容提供布局行为，与view的frame相反。这个属性同样影响内容应用view的缩放，是缓存还是重绘。 contentStretch:-定义view的部分可伸缩。这个行为通常用于实现按钮和其他复杂布局、可变尺寸、重绘代价高的view。 hidden 或 alpha: 改变view的不透明度或隐藏view backgroundColor: – 设置view的背景颜色 Subviews:不在drawRect方法里绘制你的内容，使用嵌入图片或文本子view等方式 Gesture recognizers: – 使用手势识别器替代自己手工处理touch事件 Animations:– 使用内建动画支持代替自己写动画。Core Animation提供的动画支持很快很好用 基于图片的背景 – 对那些显示相对静态内容的view来说，考虑使用UIImageView对象加上手势识别替代子类化和自己绘制图片。同样，你也可以使用一般的UIView对象，分配你的图片作为view的CALayer对象内容。 🏷Animations are another way to make visible changes to a view without requiring you to subclass and implement complex drawing code. Many properties of the UIView class are animatable, which means changes to those properties can trigger system-generated animations. Starting animations requires as little as one line of code to indicate that any changes that follow should be animated. For more information about animation support for views, see Animations. 动画是不需要子类化和实现复杂代码而让视觉改变的另一种方式。很多UIView的属性是可以动画的，意味着改变这些属性可以触发系统生成动画。启动动画只需要很少的一行代码指示那些改变需要被动画。更多view动画的信息，参考 Animations For more information about appearance and behavior configuration, see About Views in UIKit User Interface Catalog .更多关于外观和行为配置的信息，见 UIKit User Interface Catalog 目录里的 About Views 📌 Initializing a View Object「初始化View对象」 - initWithFrame: 使用指定的frame矩形，初始化并且返回新的View对象。 声明：SWIFT:1init(frame aRect: CGRect) OBJECTIVE-C: 1- (instancetype)initWithFrame:(CGRect)frame 参数aRect view的frame矩形，使用point测量。frame的原点是相对你将添加到的父view的。这个方法用frame矩形来设置中心点和边界。 返回值：一个初始化的对象，如果不能创建，返回nil. 说明：一个新的view对象必须插入到一个windows的view层级里才能使用。如果你用程序创建了一个view对象，这个方法是UIView类的指定初始器。子类可以覆盖这个方法来执行一些自定义的初始化，但必须在第一行调用super实现。如果你用Interface Builder来设计你的界面，这个方法在从nib文件创建view对象时不会被调用。nib里的对象使用initWithCoder:方法重建和初始化，它会修改view属性来匹配存储在nib文件里的属性。关于view如何从nib文件载入的详细信息，参见 Resource Programming Guide. 📌 配置View的可见外观 🏷 - backgroundColor: View的背景颜色 声明SWIFT:1@NSCopying var backgroundColor: UIColor? OBJECTIVE-C1@property(nonatomic, copy) UIColor *backgroundColor 说明:改变这个属性可以动画，默认值是nil,表现为透明。 扩展 alpha opaque 🏷 hidden：一个判断view是否隐藏的bool值 声明SWIFT:1var hidden: Bool OBJECTIVE-C1@property(nonatomic, getter=isHidden) BOOL hidden 说明:设置这个值为YES隐藏view,NO显示View,默认是NO一个隐藏的view从窗口消失并且不接收输入事件。然而，它还留在它的父view的子view列表中，并且跟往常一样参与autoresizing。隐藏一个带有子view的view,跟隐藏这些子view(包括他们的子view）有一样的效果。这个效果是含蓄的并且不会修改子view的hidden属性.如果隐藏的view是窗口的当前第一响应者，会导致下一个view成为第一响应者(得到焦点，是这个意思么？) 参考原著：https://www.pocketdigi.com/20150105/1413.html 🏷 alpha: View的不透明度 声明SWIFT:1var alpha: CGFloat OBJECTIVE-C1@property(nonatomic) CGFloat alpha 说明:这个属性的值是一个浮点值，范围从0.0到1.0,0.0代表完全透明，1.0代表完全不透明。这个值只能当前view有效，不影响内嵌的子view 改变这个属性可以动画 扩展 backgroundColor opaque 【@码员真爱 : 真的不点进去阅读一下 ❓】【译文 &amp; 源码】 【工具类】 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MJExtension框架学习]]></title>
    <url>%2FSourceAnnotations%2FMJExtensionLibrary.html</url>
    <content type="text"><![CDATA[MJExtension字典转模型框架1234A fast, convenient and nonintrusive conversion between JSON and model.转换速度快、使用简单方便的字典转模型框架 Contents 作用12345678910111213141516171819201.MJExtension是一套字典和模型之间互相转换的超轻量级框架2.JSON --&gt; Model、Core Data Model3.JSONString --&gt; Model、Core Data Model4.Model、Core Data Model --&gt; JSON5.JSON Array --&gt; Model Array、Core Data Model Array6.JSONString --&gt; Model Array、Core Data Model Array7.Model Array、Core Data Model Array --&gt; JSON Array8.Coding all properties of model in one line code.只需要一行代码，就能实现模型的所有属性进行Coding（归档和解档）1.简单的字典 --&gt; 模型2.JSON字符串 --&gt; 模型3.复杂的字典 --&gt; 模型 (模型里面包含了模型)4.复杂的字典 --&gt; 模型 (模型的数组属性里面又装着模型)5.复杂的字典 --&gt; 模型（模型属性名和字典的key不一样）6.字典数组 --&gt; 模型数组7.模型 --&gt; 字典8.模型数组 --&gt; 字典数组9.字典 --&gt; CoreData模型10.归档与解档NSCoding11.过滤字典的值 安装12345使用CocoaPods `pod 'MJExtension'`手动导入1.将`MJExtension`文件夹中的所有源代码拽入项目中2.导入主头文件：`#import "MJExtension.h"` Getting Started【开始使用】 1.JSON -&gt; Model【最简单的字典转模型】核心方法:mj_objectWithKeyValues:12345678910111213141516171819202122232425262728模型类User定义typedef enum &#123; SexMale, SexFemale&#125; Sex;@interface User : NSObject@property (copy, nonatomic) NSString *name;/* 姓名 */@property (copy, nonatomic) NSString *icon;/* 头像 */@property (assign, nonatomic) unsigned int age;/* 年龄 */@property (copy, nonatomic) NSString *height;/* 身高 */@property (strong, nonatomic) NSNumber *money;/* 资产 */@property (assign, nonatomic) Sex sex;/* 性别 */@property (assign, nonatomic, getter=isGay) BOOL gay;/* 是否是同性恋 */@end// 简单的字典 NSDictionary *dict_user = @&#123; @"name" : @"Jack", @"icon" : @"lufy.png", @"age" : @20, @"height" : @"1.55", @"money" : @100.9, @"sex" : @(SexFemale),/* 枚举需要使用NSNumber包装 */ @"gay" : @YES &#125;; User *user = [User mj_objectWithKeyValues:dict_user]; NSLog(@"MJ-%@-%@-%u-%@-%@-%u-%d",user.name,user.icon,user.age,user.height,user.money,user.sex,user.gay);//打印结果//2016-07-04 11:06:59.746 PPDemos[2432:73824] MJ-Jack-lufy.png-20-1.55-100.9-1-1 2.JSONString -&gt; Model【JSON字符串转模型】核心方法:mj_objectWithKeyValues:123456// 定义一个JSON字符串 NSString *jsonStr = @"&#123;\"name\":\"Jack\", \"icon\":\"lufy.png\", \"age\":20&#125;"; User *user = [User mj_objectWithKeyValues:jsonStr]; NSLog(@"MJ---%@----%@---%u",user.name,user.icon,user.age); // 打印结果 // 2016-07-04 11:16:04.655 PPDemos[2563:78561] MJ---Jack----lufy.png---20 3.复杂的字典【模型中嵌套模型】核心方法:mj_objectWithKeyValues:123456789101112131415//复杂的字典[模型中有个数组属性，数组里面又要装着其他模型的字典]NSDictionary *dict_m8m = @&#123; @"text" : @"Agree!Nice weather!", @"user" : @&#123; @"name" : @"Jack", @"icon" : @"lufy.png" &#125;, @"retweetedStatus" : @&#123; @"text" : @"Nice weather!", @"user" : @&#123; @"name" : @"Rose", @"icon" : @"nami.png" &#125; &#125; &#125;; 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;@class User;@class Status;//Status模型@interface Status : NSObject@property (copy, nonatomic) NSString *text;@property (strong, nonatomic) User *user;/* 其他模型类型 */@property (strong, nonatomic) Status *retweetedStatus;/* 自我模型类型 */@end//// 字典转模型，模型里面含有模型 Status *status = [Status mj_objectWithKeyValues:dict_m8m]; NSString *text = status.text; NSString *name = status.user.name; NSString *icon = status.user.icon; NSLog(@"mj-----text=%@, name=%@, icon=%@", text, name, icon); NSString *text2 = status.retweetedStatus.text; NSString *name2 = status.retweetedStatus.user.name; NSString *icon2 = status.retweetedStatus.user.icon; NSLog(@"mj-----text2=%@, name2=%@, icon2=%@", text2, name2, icon2); // 打印结果 //2016-07-04 11:45:39.675 PPDemos[2781:87089] mj-----text=Agree!Nice weather!, name=Jack, icon=lufy.png //2016-07-04 11:45:39.675 PPDemos[2781:87089] mj-----text2=Nice weather!, name2=Rose, icon2=nami.png 4.【模型中有个数组属性，数组里面又要装着其他模型】核心方法:mj_objectWithKeyValues: 和mj_objectClassInArray12345678910111213141516171819@interface Ad : NSObject@property (copy, nonatomic) NSString *image;@property (copy, nonatomic) NSString *url;@end@interface StatusResult : NSObject/** 数组中存储模型Status类型数据 */@property (strong, nonatomic) NSMutableArray *statuses;/** 数组中存储模型Ad类型数据 */@property (strong, nonatomic) NSArray *ads;@property (strong, nonatomic) NSNumber *totalNumber;@end #import "StatusResult.h"#import "MJExtension.h"@implementation StatusResult/* 数组中存储模型数据，需要说明数组中存储的模型数据类型,实现该方法 */+(NSDictionary *)mj_objectClassInArray&#123; return @&#123; @"statuses" : @"Status", @"ads" : @"Ad" &#125;;&#125;@end 在VC里实现以下来解析数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//模型中有个数组属性，数组里面又要装着其他模型 NSDictionry *dict_m8a = @&#123; @"statuses" : @[ @&#123; @"text" : @"Nice weather!", @"user" : @&#123; @"name" : @"Rose", @"icon" : @"nami.png" &#125; &#125;, @&#123; @"text" : @"Go camping tomorrow!", @"user" : @&#123; @"name" : @"Jack", @"icon" : @"lufy.png" &#125; &#125; ], @"ads" : @[ @&#123; @"image" : @"ad01.png", @"url" : @"http://www.ad01.com" &#125;, @&#123; @"image" : @"ad02.png", @"url" : @"http://www.ad02.com" &#125; ], @"totalNumber" : @"2014" &#125;;【重点，核心】&gt;&gt;数组中存储模型数据，需要说明数组中存储的模型数据类型&lt;&lt; /* [StatusResult mj_setupObjectClassInArray:^NSDictionary *&#123; return @&#123; @"statuses" : @"Status", // @"statuses" : [Status class], @"ads" : @"Ad" // @"ads" : [Ad class] &#125;; &#125;]; // Equals: StatusResult.m implements +mj_objectClassInArray method.*/ // 以上方法在VC里写，如果多个地方解析该model，就要写多次，最好在model的.m文件写！ // 字典转模型，支持模型的数组属性里面又装着模型 StatusResult *result = [StatusResult mj_objectWithKeyValues:dict_m8a]; // 打印博主信息 for (Status *status in result.statuses) &#123; NSString *text = status.text; NSString *name = status.user.name; NSString *icon = status.user.icon; NSLog(@"mj---text=%@, name=%@, icon=%@", text, name, icon); &#125; // 打印广告 for (Ad *ad in result.ads) &#123; NSLog(@"mj---image=%@, url=%@", ad.image, ad.url); &#125;// 打印结果//2016-07-04 13:47:58.994 PPDemos[3353:113055] mj---text=Nice weather!, name=Rose, icon=nami.png //2016-07-04 13:47:58.995 PPDemos[3353:113055] mj---text=Go camping tomorrow!, name=Jack, icon=lufy.png //2016-07-04 13:47:58.995 PPDemos[3353:113055] mj---image=ad01.png, url=http://www.ad01.com //2016-07-04 13:47:58.995 PPDemos[3353:113055] mj---image=ad02.png, url=http://www.ad02.com 5.【模型中的属性名和字典中的key不相同(或者需要多级映射)】核心方法:mj_objectWithKeyValues: 和mj_replacedKeyFromPropertyName123456789101112131415161718192021222324252627282930@interface Bag : NSObject@property (copy, nonatomic) NSString *name;@property (assign, nonatomic) double price;@end#import &lt;Foundation/Foundation.h&gt;@class Bag;@interface Student : NSObject@property (copy, nonatomic) NSString *ID;@property (copy, nonatomic) NSString *desc;@property (copy, nonatomic) NSString *nowName;@property (copy, nonatomic) NSString *oldName;@property (copy, nonatomic) NSString *nameChangedTime;@property (strong, nonatomic) Bag *bag;@end// 多级映射，用点语法设置@implementation Student/* 设置模型属性名和字典key之间的映射关系 */+(NSDictionary *)mj_replacedKeyFromPropertyName&#123; /* 返回的字典，key为模型属性名，value为转化的字典的多级key */ return @&#123; @"ID" : @"id", @"desc" : @"desciption", @"oldName" : @"name.oldName", @"nowName" : @"name.newName", @"nameChangedTime" : @"name.info[1].nameChangedTime", @"bag" : @"other.bag" &#125;;&#125;@end 1234567891011121314151617181920212223242526272829303132333435363738394041NSDictionry *dict_nokey = @&#123; @"id" : @"20", @"desciption" : @"kids", @"name" : @&#123; @"newName" : @"lufy", @"oldName" : @"kitty", @"info" : @[ @"test-data", @&#123; @"nameChangedTime" : @"2013-08" &#125; ] &#125;, @"other" : @&#123; @"bag" : @&#123; @"name" : @"a red bag", @"price" : @100.7 &#125; &#125; &#125;;//// // How to map// [Student mj_setupReplacedKeyFromPropertyName:^NSDictionary *&#123;// return @&#123;// @"ID" : @"id",// @"desc" : @"desciption",// @"oldName" : @"name.oldName",// @"nowName" : @"name.newName",// @"nameChangedTime" : @"name.info[1].nameChangedTime",// @"bag" : @"other.bag"// &#125;;// &#125;];// // Equals: Student.m implements +mj_replacedKeyFromPropertyName method. // 字典转模型，支持多级映射 Student *stu = [Student mj_objectWithKeyValues:dict_nokey]; // 打印 NSLog(@"ID=%@, desc=%@, oldName=%@, nowName=%@, nameChangedTime=%@", stu.ID, stu.desc, stu.oldName, stu.nowName, stu.nameChangedTime); NSLog(@"bagName=%@, bagPrice=%f", stu.bag.name, stu.bag.price); //2016-07-04 14:20:28.082 PPDemos[3602:126004] ID=20, desc=kids, oldName=kitty, nowName=lufy, nameChangedTime=2013-08 //2016-07-04 14:20:28.082 PPDemos[3602:126004] bagName=a red bag, bagPrice=100.700000 6.【将一个字典数组转成模型数组】核心方法:mj_objectArrayWithKeyValuesArray:123456789101112131415161718NSArray *dictArray = @[ @&#123; @"name" : @"Jack", @"icon" : @"lufy.png" &#125;, @&#123; @"name" : @"Rose", @"icon" : @"nami.png" &#125; ]; // 字典数组转模型数组，使用的是mj_objectArrayWithKeyValuesArray:方法 NSArray *userArray = [User mj_objectArrayWithKeyValuesArray:dictArray]; //打印 for (User *user in userArray) &#123; NSLog(@"name=%@, icon=%@", user.name, user.icon); &#125; // name=Jack, icon=lufy.png // name=Rose, icon=nami.png 7.【将一个模型转成字典】核心方法:mj_keyValues:12345678910111213141516171819//创建一个模型对象User *user = [[User alloc] init];user.name = @"Jack";user.icon = @"lufy.png";Status *status = [[Status alloc] init];status.user = user;status.text = @"Nice mood!";//模型转字典，使用的是mj_keyValues属性NSDictionary *statusDict = status.mj_keyValues;NSLog(@"%@", statusDict);/*&#123;text = "Nice mood!"; user = &#123; icon = "lufy.png"; name = Jack; &#125;;&#125;*/ 8.【将一个模型数组转成字典数组】核心代码:mj_keyValuesArrayWithObjectArray1234567891011121314151617181920212223// 创建模型数组User *user1 = [[User alloc] init];user1.name = @"Jack";user1.icon = @"lufy.png";User *user2 = [[User alloc] init];user2.name = @"Rose";user2.icon = @"nami.png";NSArray *userArray = @[user1, user2];//模型数组转字典数组，使用的是mj_keyValuesArrayWithObjectArray:方法NSArray *dictArray = [User mj_keyValuesArrayWithObjectArray:userArray];NSLog(@"%@", dictArray);/*( &#123; icon = "lufy.png"; name = Jack; &#125;, &#123; icon = "nami.png"; name = Rose; &#125;)*/ 9.Core Data1234567891011121314NSDictionary *dict = @&#123; @"name" : @"Jack", @"icon" : @"lufy.png", @"age" : @20, @"height" : @1.55, @"money" : @"100.9", @"sex" : @(SexFemale), @"gay" : @"true" &#125;;//字典转为CoreData模型NSManagedObjectContext *context = nil;User *user = [User mj_objectWithKeyValues:dict context:context];[context save:nil]; 10.归档与解档NSCoding12345678910111213@interface Bag : NSObject &lt;NSCoding&gt;@property (copy, nonatomic) NSString *name;@property (assign, nonatomic) double price;@end#import "MJExtension.h"@implementation Bag//添加了下面的宏定义MJExtensionCodingImplementation/* 实现下面的方法，说明哪些属性不需要归档和解档 */+ (NSArray *)mj_ignoredCodingPropertyNames&#123; return @[@"name"];&#125;@end 123456789101112//创建模型Bag *bag = [[Bag alloc] init];bag.name = @"Red bag";bag.price = 200.8;//获取归档路径NSString *file = [NSHomeDirectory() stringByAppendingPathComponent:@"Desktop/bag.data"];//归档[NSKeyedArchiver archiveRootObject:bag toFile:file];//解档Bag *decodedBag = [NSKeyedUnarchiver unarchiveObjectWithFile:file];NSLog(@"name=%@, price=%f", decodedBag.name, decodedBag.price);// name=(null), price=200.800000 11.【统一转换属性名（比如驼峰转下划线）】12345678910111213141516171819// Dog#import "MJExtension.h"@implementation Dog+ (NSString *)mj_replacedKeyFromPropertyName121:(NSString *)propertyName&#123; // nickName -&gt; nick_name return [propertyName mj_underlineFromCamel];&#125;@end// NSDictionaryNSDictionary *dict = @&#123; @"nick_name" : @"旺财", @"sale_price" : @"10.5", @"run_speed" : @"100.9" &#125;;// NSDictionary -&gt; DogDog *dog = [Dog mj_objectWithKeyValues:dict];// printingNSLog(@"nickName=%@, scalePrice=%f runSpeed=%f", dog.nickName, dog.salePrice, dog.runSpeed); 12.【过滤字典的值（比如字符串日期处理为NSDate、字符串nil处理为@””）】123456789101112131415161718192021@interface Book: NSObject@property (copy, nonatomic) NSString *name;@property (strong, nonatomic) NSDate *publishedTime;@end#import "MJExtension.h"@implementation Book/* 转化过程中对字典的值进行过滤和进一步转化 */- (id)mj_newValueFromOldValue:(id)oldValue property:(MJProperty *)property&#123; if ([property.name isEqualToString:@"publisher"]) &#123; if (oldValue == nil) &#123; return @""; &#125; &#125; else if (property.type.typeClass == [NSDate class]) &#123; NSDateFormatter *fmt = [[NSDateFormatter alloc] init]; fmt.dateFormat = @"yyyy-MM-dd"; return [fmt dateFromString:oldValue]; &#125; return oldValue;&#125;@end 12345678NSDictionary *dict = @&#123; @"name" : @"5分钟突破iOS开发", @"publishedTime" : @"2011-09-10" &#125;;//字典转模型，过滤name为nil的情况，把NSString转为NSDateBook *book = [Book mj_objectWithKeyValues:dict];//打印NSLog(@"name=%@, publishedTime=%@", book.name, book.publishedTime); 1.模型中有个数组属性，数组里面又要装着其他模型 12345678910111213141516171819202122//1.把字典数组转换为模型数组//使用MJExtension框架进行字典转模型self.videos = [XMGVideo objectArrayWithKeyValuesArray:videoArray];//2.重命名模型属性的名称//第一种重命名属性名称的方法，有一定的代码侵入性//设置字典中的id被模型中的ID替换+(NSDictionary *)replacedKeyFromPropertyName &#123; return @&#123; @"ID":@"id" &#125;;&#125;//第二种重命名属性名称的方法，代码侵入性为零[LNVideo setupReplacedKeyFromPropertyName:^NSDictionary *&#123; return @&#123; @"ID":@"id" &#125;;&#125;];//3.MJExtension框架内部实现原理-运行时 这个框架有太多的东西值得我们去学习推敲，方方面面都透露着作者以及众多贡献者的智慧，我们使用起来也一定会受益良多。 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 模式详解—「runtime面试、工作」看我就 🐒 了 ^_^.]]></title>
    <url>%2FiOSNET%2Fruntime.html</url>
    <content type="text"><![CDATA[引导Copyright © PBWln Unauthorized shall not be *copy reprinted* 。 对于从事 iOS 开发人员来说，所有的人都会答出「runtime 是运行时」，什么情况下用runtime?，大部分人能说出「给分类动态添加属性 || 交换方法」，再问一句「runtime 消息机制的调用流程 || 能体现runtime 强大之处的应用场景」，到这，能知道答案的寥寥无几，很少有人会说到“黑魔法”这三个字， runtime 是 iOS 编程中比较难的模块，想要深入学习 OC，那 runtime 是你必须要熟练掌握的东西，下面是我对 runtime 的整理，从零开始，由浅入深，并且带了几个 runtime 实际开发的应用场景。–&gt; 大神可选择性路过「思想」。 在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，可留言指正或是补充，以提高文章质量@ 白开水ln； 不管谁的博客上面写的文章(也包括自己)，阅读的你要敢于去验证，停止无意义的⏹copy paste。 目录： runtime 概念 runtime 消息机制 runtime 方法调用流程「消息机制」 runtime 运行时常见作用 runtime 常用开发应用场景「工作掌握」1.runtime 交换方法2.runtime 给分类动态添加属性3.runtime 字典转模型（Runtime 考虑三种情况实现） runtime 运行时其它作用「面试熟悉」1.动态添加方法2.动态变量控制3.实现NSCoding的自动归档和解档4.runtime 下Class的各项操作5.runtime 几个参数概念 什么是 method swizzling（俗称黑魔法） 最后一道面试题的注解 runtime模块简友文章推荐(❤️数量较多) 实战应用场景（持续） 后续更新 Swift3.1-runtime面试、工作 OC &amp; Swift runtime &amp; runloop 面试最常问到的题整理【建议看】 runtime.h 属性&amp;方法 &amp; Demo runtime 概念 Objective-C 是基于 C 的，它为 C 添加了面向对象的特性。它将很多静态语言在编译和链接时期做的事放到了 runtime 运行时来处理，可以说 runtime 是我们 Objective-C 幕后工作者。 runtime（简称运行时），是一套 纯C(C和汇编写的) 的API。而 OC 就是 运行时机制，也就是在运行时候的一些机制，其中最主要的是 消息机制。 对于 C 语言，函数的调用在编译的时候会决定调用哪个函数。 OC的函数调用成为消息发送，属于 动态调用过程。在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。 事实证明：在编译阶段，OC 可以 调用任何函数，即使这个函数并未实现，只要声明过就不会报错，只有当运行的时候才会报错，这是因为OC是运行时动态调用的。而 C 语言 调用未实现的函数 就会报错。 runtime 消息机制 我们写 OC 代码，它在运行的时候也是转换成了 runtime 方式运行的。任何方法调用本质：就是发送一个消息（用 runtime发送消息，OC 底层实现通过 runtime 实现）。 消息机制原理：对象根据方法编号SEL去映射表查找对应的方法实现。 每一个 OC 的方法，底层必然有一个与之对应的 runtime 方法。 简单示例：验证：方法调用，是否真的是转换为消息机制？ 必须要导入头文件 #import &lt;objc/message.h&gt; 注解1：我们导入系统的头文件，一般用尖括号。 注解2：OC 解决消息机制方法提示步骤【查找build setting -&gt; 搜索msg -&gt; objc_msgSend（YES –&gt; NO）】 注解3：最终生成消息机制,编译器做的事情，最终代码，需要把当前代码重新编译，用xcode编译器，【clang -rewrite-objc main.m 查看最终生成代码】，示例：cd main.m --&gt; 输入前面指令，就会生成 .opp文件(C++代码) 注解4：这里一般不会直接导入&lt;objc/runtime.h&gt; 示例代码：OC 方法–&gt;runtime 方法 123456789101112131415161718192021222324说明: eat(无参) 和 run(有参) 是 Person模型类中的私有方法「可以帮我调用私有方法」；// Person *p = [Person alloc];// 底层的实际写法Person *p = objc_msgSend(objc_getClass("Person"), sel_registerName("alloc"));// p = [p init];p = objc_msgSend(p, sel_registerName("init"));// 调用对象方法（本质：让对象发送消息）//[p eat];// 本质：让类对象发送消息objc_msgSend(p, @selector(eat));objc_msgSend([Person class], @selector(run:),20);//--------------------------- &lt;#我是分割线#&gt; ------------------------------//// 也许下面这种好理解一点// id objc = [NSObject alloc];id objc = objc_msgSend([NSObject class], @selector(alloc));// objc = [objc init];objc = objc_msgSend(objc, @selector(init)); runtime 方法调用流程「消息机制」 面试：消息机制方法调用流程 怎么去调用eat方法，对象方法：(保存到类对象的方法列表) ，类方法：(保存到元类(Meta Class)中方法列表)。 1.OC 在向一个对象发送消息时，runtime 库会根据对象的 isa指针找到该对象对应的类或其父类中查找方法。。 2.注册方法编号（这里用方法编号的好处，可以快速查找）。 3.根据方法编号去查找对应方法。 4.找到只是最终函数实现地址，根据地址去方法区调用对应函数。 补充：一个objc 对象的 isa 的指针指向什么？有什么作用？ 每一个对象内部都有一个isa指针，这个指针是指向它的真实类型，根据这个指针就能知道将来调用哪个类的方法。 runtime 常见作用 动态交换两个方法的实现 动态添加属性 实现字典转模型的自动转换 发送消息 动态添加方法 拦截并替换方法 实现 NSCoding 的自动归档和解档 runtime 常用开发应用场景「工作掌握」 runtime 交换方法应用场景：当第三方框架 或者 系统原生方法功能不能满足我们的时候，我们可以在保持系统原有方法功能的基础上，添加额外的功能。 需求：加载一张图片直接用[UIImage imageNamed:@&quot;image&quot;];是无法知道到底有没有加载成功。给系统的imageNamed添加额外功能（是否加载图片成功）。 方案一：继承系统的类，重写方法.（弊端：每次使用都需要导入） 方案二：使用 runtime，交换方法. 实现步骤： 1.给系统的方法添加分类 2.自己实现一个带有扩展功能的方法 3.交换方法,只需要交换一次, 案例代码：方法+调用+打印输出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (void)viewDidLoad &#123; [super viewDidLoad]; // 方案一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name; // 方案二：交换 imageNamed 和 ln_imageNamed 的实现，就能调用 imageNamed，间接调用 ln_imageNamed 的实现。 UIImage *image = [UIImage imageNamed:@"123"];&#125;#import &lt;objc/message.h&gt;@implementation UIImage (Image)/** load方法: 把类加载进内存的时候调用,只会调用一次 方法应先交换，再去调用 */+ (void)load &#123; // 1.获取 imageNamed方法地址 // class_getClassMethod（获取某个类的方法） Method imageNamedMethod = class_getClassMethod(self, @selector(imageNamed:)); // 2.获取 ln_imageNamed方法地址 Method ln_imageNamedMethod = class_getClassMethod(self, @selector(ln_imageNamed:)); // 3.交换方法地址，相当于交换实现方式;「method_exchangeImplementations 交换两个方法的实现」 method_exchangeImplementations(imageNamedMethod, ln_imageNamedMethod);&#125;/** 看清楚下面是不会有死循环的 调用 imageNamed =&gt; ln_imageNamed 调用 ln_imageNamed =&gt; imageNamed */// 加载图片 且 带判断是否加载成功+ (UIImage *)ln_imageNamed:(NSString *)name &#123; UIImage *image = [UIImage ln_imageNamed:name]; if (image) &#123; NSLog(@"runtime添加额外功能--加载成功"); &#125; else &#123; NSLog(@"runtime添加额外功能--加载失败"); &#125; return image;&#125;/** 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super 所以第二步，我们要 自己实现一个带有扩展功能的方法. + (UIImage *)imageNamed:(NSString *)name &#123; &#125; */@end// 打印输出2016-02-17 17:52:14.693 runtime[12761:543574] runtime添加额外功能--加载成功 总结：我们所做的就是在方法调用流程第三步的时候，交换两个方法地址指向。而且我们改变指向要在系统的imageNamed:方法调用前，所以将代码写在了分类的load方法里。最后当运行的时候系统的方法就会去找我们的方法的实现。 runtime 给分类动态添加属性原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。 应用场景：给系统的类添加属性的时候,可以使用runtime动态添加属性方法。注解：系统 NSObject 添加一个分类，我们知道在分类中是不能够添加成员属性的，虽然我们用了@property，但是仅仅会自动生成get和set方法的声明，并没有带下划线的属性和方法实现生成。但是我们可以通过runtime就可以做到给它方法的实现。 需求：给系统 NSObject 类动态添加属性 name 字符串。 案例代码：方法+调用+打印123456789101112131415161718192021222324252627282930@interface NSObject (Property)// @property分类:只会生成get,set方法声明,不会生成实现,也不会生成下划线成员属性@property NSString *name;@property NSString *height;@end@implementation NSObject (Property)- (void)setName:(NSString *)name &#123; // objc_setAssociatedObject（将某个值跟某个对象关联起来，将某个值存储到某个对象中） // object:给哪个对象添加属性 // key:属性名称 // value:属性值 // policy:保存策略 objc_setAssociatedObject(self, @"name", name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (NSString *)name &#123; return objc_getAssociatedObject(self, @"name");&#125;// 调用NSObject *objc = [[NSObject alloc] init];objc.name = @"123";NSLog(@"runtime动态添加属性name==%@",objc.name);// 打印输出2016-02-17 19:37:10.530 runtime[12761:543574] runtime动态添加属性--name == 123 总结：其实，给属性赋值的本质，就是让属性与一个对象产生关联，所以要给NSObject的分类的name属性赋值就是让name和NSObject产生关联，而runtime可以做到这一点。 runtime 字典转模型字典转模型的方式： 一个一个的给模型属性赋值（初学者）。 字典转模型KVC实现 KVC 字典转模型弊端：必须保证，模型中的属性和字典中的key 一一对应。 如果不一致，就会调用[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:] 报key找不到的错。 分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。 解决：重写对象的setValue:forUndefinedKey:，把系统的方法覆盖，就能继续使用KVC，字典转模型了。 字典转模型 Runtime 实现 思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值（从提醒：字典中取值，不一定要全部取出来）。 考虑情况： 1.当字典的key和模型的属性匹配不上。 2.模型中嵌套模型（模型属性是另外一个模型对象）。 3.数组中装着模型（模型的属性是一个数组，数组中是一个个模型对象）。 注解：根据上面的三种特殊情况，先是字典的key和模型的属性不对应的情况。不对应有两种，一种是字典的键值大于模型属性数量，这时候我们不需要任何处理，因为runtime是先遍历模型所有属性，再去字典中根据属性名找对应值进行赋值，多余的键值对也当然不会去看了；另外一种是模型属性数量大于字典的键值对，这时候由于属性没有对应值会被赋值为nil，就会导致crash，我们只需加一个判断即可。考虑三种情况下面一一注解； 步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类实现字典转模型。 MJExtension 字典转模型实现 底层也是对 runtime 的封装，才可以把一个模型中所有属性遍历出来。（你之所以看不懂，是 MJ 封装了很多层而已^_^.）。 这里针对字典转模型 KVC 实现，就不做详解了，如果你 对 KVC 详解使用或是实现原理 不是很清楚的，可以参考 实用「KVC编码 &amp; KVO监听 字典转模型 Runtime 方式实现：说明：下面这个示例，是考虑三种情况包含在内的转换示例，具体可以看图上的注解 1、runtime 字典转模型–&gt;字典的 key 和模型的属性不匹配「模型属性数量大于字典键值对数」，这种情况处理如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Runtime:根据模型中属性,去字典中取出对应的value给模型属性赋值// 思路：遍历模型中所有属性-&gt;使用运行时+ (instancetype)modelWithDict:(NSDictionary *)dict&#123; // 1.创建对应的对象 id objc = [[self alloc] init]; // 2.利用runtime给对象中的属性赋值 /** class_copyIvarList: 获取类中的所有成员变量 Ivar：成员变量 第一个参数：表示获取哪个类中的成员变量 第二个参数：表示这个类有多少成员变量，传入一个Int变量地址，会自动给这个变量赋值 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。 count: 成员变量个数 */ unsigned int count = 0; // 获取类中的所有成员变量 Ivar *ivarList = class_copyIvarList(self, &amp;count); // 遍历所有成员变量 for (int i = 0; i &lt; count; i++) &#123; // 根据角标，从数组取出对应的成员变量 Ivar ivar = ivarList[i]; // 获取成员变量名字 NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 处理成员变量名-&gt;字典中的key(去掉 _ ,从第一个角标开始截取) NSString *key = [ivarName substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; // 【如果模型属性数量大于字典键值对数理，模型属性会被赋值为nil】 // 而报错 (could not set nil as the value for the key age.) if (value) &#123; // 给模型中属性赋值 [objc setValue:value forKey:key]; &#125; &#125; return objc;&#125; 注解：这里在获取模型类中的所有属性名，是采取 class_copyIvarList 先获取成员变量（以下划线开头） ，然后再处理成员变量名-&gt;字典中的key(去掉 _ ,从第一个角标开始截取) 得到属性名。 原因：Ivar：成员变量,以下划线开头，Property 属性获取类里面属性 class_copyPropertyList获取类中的所有成员变量 class_copyIvarList12345678&#123; int _a; // 成员变量&#125;@property (nonatomic, assign) NSInteger attitudes_count; // 属性这里有成员变量，就不会漏掉属性；如果有属性，可能会漏掉成员变量； 使用runtime字典转模型获取模型属性名的时候，最好获取成员属性名Ivar因为可能会有个属性是没有setter和getter方法的。 2、runtime 字典转模型–&gt;模型中嵌套模型「模型属性是另外一个模型对象」，这种情况处理如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253+ (instancetype)modelWithDict2:(NSDictionary *)dict&#123; // 1.创建对应的对象 id objc = [[self alloc] init]; // 2.利用runtime给对象中的属性赋值 unsigned int count = 0; // 获取类中的所有成员变量 Ivar *ivarList = class_copyIvarList(self, &amp;count); // 遍历所有成员变量 for (int i = 0; i &lt; count; i++) &#123; // 根据角标，从数组取出对应的成员变量 Ivar ivar = ivarList[i]; // 获取成员变量名字 NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 获取成员变量类型 NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; // 替换: @\"User\" -&gt; User ivarType = [ivarType stringByReplacingOccurrencesOfString:@"\"" withString:@""]; ivarType = [ivarType stringByReplacingOccurrencesOfString:@"@" withString:@""]; // 处理成员属性名-&gt;字典中的key(去掉 _ ,从第一个角标开始截取) NSString *key = [ivarName substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; //--------------------------- &lt;#我是分割线#&gt; ------------------------------// // // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型 // 判断下value是否是字典,并且是自定义对象才需要转换 if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType hasPrefix:@"NS"]) &#123; // 字典转换成模型 userDict =&gt; User模型, 转换成哪个模型 // 根据字符串类名生成类对象 Class modelClass = NSClassFromString(ivarType); if (modelClass) &#123; // 有对应的模型才需要转 // 把字典转模型 value = [modelClass modelWithDict2:value]; &#125; &#125; // 给模型中属性赋值 if (value) &#123; [objc setValue:value forKey:key]; &#125; &#125; return objc;&#125; 3、runtime 字典转模型–&gt;数组中装着模型「模型的属性是一个数组，数组中是字典模型对象」，这种情况处理如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Runtime:根据模型中属性,去字典中取出对应的value给模型属性赋值// 思路：遍历模型中所有属性-&gt;使用运行时+ (instancetype)modelWithDict3:(NSDictionary *)dict&#123; // 1.创建对应的对象 id objc = [[self alloc] init]; // 2.利用runtime给对象中的属性赋值 unsigned int count = 0; // 获取类中的所有成员变量 Ivar *ivarList = class_copyIvarList(self, &amp;count); // 遍历所有成员变量 for (int i = 0; i &lt; count; i++) &#123; // 根据角标，从数组取出对应的成员变量 Ivar ivar = ivarList[i]; // 获取成员变量名字 NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 处理成员属性名-&gt;字典中的key(去掉 _ ,从第一个角标开始截取) NSString *key = [ivarName substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; //--------------------------- &lt;#我是分割线#&gt; ------------------------------// // // 三级转换：NSArray中也是字典，把数组中的字典转换成模型. // 判断值是否是数组 if ([value isKindOfClass:[NSArray class]]) &#123; // 判断对应类有没有实现字典数组转模型数组的协议 // arrayContainModelClass 提供一个协议，只要遵守这个协议的类，都能把数组中的字典转模型 if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123; // 转换成id类型，就能调用任何对象的方法 id idSelf = self; // 获取数组中字典对应的模型 NSString *type = [idSelf arrayContainModelClass][key]; // 生成模型 Class classModel = NSClassFromString(type); NSMutableArray *arrM = [NSMutableArray array]; // 遍历字典数组，生成模型数组 for (NSDictionary *dict in value) &#123; // 字典转模型 id model = [classModel modelWithDict3:dict]; [arrM addObject:model]; &#125; // 把模型数组赋值给value value = arrM; &#125; &#125; // 如果模型属性数量大于字典键值对数理，模型属性会被赋值为nil,而报错 if (value) &#123; // 给模型中属性赋值 [objc setValue:value forKey:key]; &#125; &#125; return objc;&#125; 总结：我们既然能获取到属性类型，那就可以拦截到模型的那个数组属性，进而对数组中每个模型遍历并字典转模型，但是我们不知道数组中的模型都是什么类型，我们可以声明一个方法，该方法目的不是让其调用，而是让其实现并返回模型的类型。 这里提到的你如果不是很清楚，建议参考我的Demo，重要的部分代码中都有相应的注解和文字打印，运行程序可以很直观的表现。 runtime 其它作用「面试熟悉」 动态添加方法应用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。 注解：OC 中我们很习惯的会用懒加载，当用到的时候才去加载它，但是实际上只要一个类实现了某个方法，就会被加载进内存。当我们不想加载这么多方法的时候，就会使用到 runtime 动态的添加方法。 需求：runtime 动态添加方法处理调用一个未实现的方法 和 去除报错。 案例代码：方法+调用+打印输出123456789101112131415161718192021222324252627282930313233343536- (void)viewDidLoad &#123; [super viewDidLoad]; Person *p = [[Person alloc] init]; // 默认person，没有实现run:方法，可以通过performSelector调用，但是会报错。 // 动态添加方法就不会报错 [p performSelector:@selector(run:) withObject:@10];&#125;@implementation Person// 没有返回值,1个参数// void,(id,SEL)void aaa(id self, SEL _cmd, NSNumber *meter) &#123; NSLog(@"跑了%@米", meter);&#125;// 任何方法默认都有两个隐式参数,self,_cmd（当前方法的方法编号）// 什么时候调用:只要一个对象调用了一个未实现的方法就会调用这个方法,进行处理// 作用:动态添加方法,处理未实现+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; // [NSStringFromSelector(sel) isEqualToString:@"run"]; if (sel == NSSelectorFromString(@"run:")) &#123; // 动态添加run方法 // class: 给哪个类添加方法 // SEL: 添加哪个方法，即添加方法的方法编号 // IMP: 方法实现 =&gt; 函数 =&gt; 函数入口 =&gt; 函数名（添加方法的函数实现（函数地址）） // type: 方法类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd class_addMethod(self, sel, (IMP)aaa, "v@:@"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;@end// 打印输出2016-02-17 19:05:03.917 runtime[12761:543574] runtime动态添加方法--跑了10米 动态变量控制 现在有一个Person类，创建 xiaoming对象 动态获取 XiaoMing 类中的所有属性 [当然包括私有] 1Ivar *ivar = class_copyIvarList([self.xiaoming class], &amp;count); 遍历属性找到对应name字段 1const char *varName = ivar_getName(var); 修改对应的字段值成20 1object_setIvar(self.xiaoMing, var, @"20"); 代码参考 1234567891011121314-(void)answer&#123; unsigned int count = 0; Ivar *ivar = class_copyIvarList([self.xiaoMing class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; Ivar var = ivar[i]; const char *varName = ivar_getName(var); NSString *name = [NSString stringWithUTF8String:varName]; if ([name isEqualToString:@"_age"]) &#123; object_setIvar(self.xiaoMing, var, @"20"); break; &#125; &#125; NSLog(@"XiaoMing's age is %@",self.xiaoMing.age); &#125; 实现NSCoding的自动归档和解档如果你实现过自定义模型数据持久化的过程，那么你也肯定明白，如果一个模型有许多个属性，那么我们需要对每个属性都实现一遍encodeObject 和 decodeObjectForKey方法，如果这样的模型又有很多个，这还真的是一个十分麻烦的事情。下面来看看简单的实现方式。 假设现在有一个Movie类，有3个属性。先看下 .h文件12345678// Movie.h文件//1. 如果想要当前类可以实现归档与反归档，需要遵守一个协议NSCoding@interface Movie : NSObject&lt;NSCoding&gt;@property (nonatomic, copy) NSString *movieId;@property (nonatomic, copy) NSString *movieName;@property (nonatomic, copy) NSString *pic_url;@end 如果是正常写法， .m 文件应该是这样的：123456789101112131415161718192021// Movie.m文件@implementation Movie- (void)encodeWithCoder:(NSCoder *)aCoder&#123; [aCoder encodeObject:_movieId forKey:@"id"]; [aCoder encodeObject:_movieName forKey:@"name"]; [aCoder encodeObject:_pic_url forKey:@"url"];&#125;- (id)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super init]) &#123; self.movieId = [aDecoder decodeObjectForKey:@"id"]; self.movieName = [aDecoder decodeObjectForKey:@"name"]; self.pic_url = [aDecoder decodeObjectForKey:@"url"]; &#125; return self;&#125;@end 如果这里有100个属性，那么我们也只能把100个属性都给写一遍吗。 不过你会使用runtime后，这里就有更简便的方法，如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445#import "Movie.h"#import &lt;objc/runtime.h&gt;@implementation Movie- (void)encodeWithCoder:(NSCoder *)encoder&#123; unsigned int count = 0; Ivar *ivars = class_copyIvarList([Movie class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; // 取出i位置对应的成员变量 Ivar ivar = ivars[i]; // 查看成员变量 const char *name = ivar_getName(ivar); // 归档 NSString *key = [NSString stringWithUTF8String:name]; id value = [self valueForKey:key]; [encoder encodeObject:value forKey:key]; &#125; free(ivars);&#125;- (id)initWithCoder:(NSCoder *)decoder&#123; if (self = [super init]) &#123; unsigned int count = 0; Ivar *ivars = class_copyIvarList([Movie class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; // 取出i位置对应的成员变量 Ivar ivar = ivars[i]; // 查看成员变量 const char *name = ivar_getName(ivar); // 归档 NSString *key = [NSString stringWithUTF8String:name]; id value = [decoder decodeObjectForKey:key]; // 设置到成员变量身上 [self setValue:value forKey:key]; &#125; free(ivars); &#125; return self;&#125;@end 这样的方式实现，不管有多少个属性，写这几行代码就搞定了。怎么，代码有点多，好说下面看看更加简便的方法：两句代码搞定。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import "Movie.h"#import &lt;objc/runtime.h&gt;#define encodeRuntime(A) \\unsigned int count = 0;\Ivar *ivars = class_copyIvarList([A class], &amp;count);\for (int i = 0; i&lt;count; i++) &#123;\Ivar ivar = ivars[i];\const char *name = ivar_getName(ivar);\NSString *key = [NSString stringWithUTF8String:name];\id value = [self valueForKey:key];\[encoder encodeObject:value forKey:key];\&#125;\free(ivars);\\#define initCoderRuntime(A) \\if (self = [super init]) &#123;\unsigned int count = 0;\Ivar *ivars = class_copyIvarList([A class], &amp;count);\for (int i = 0; i&lt;count; i++) &#123;\Ivar ivar = ivars[i];\const char *name = ivar_getName(ivar);\NSString *key = [NSString stringWithUTF8String:name];\id value = [decoder decodeObjectForKey:key];\[self setValue:value forKey:key];\&#125;\free(ivars);\&#125;\return self;\\@implementation Movie- (void)encodeWithCoder:(NSCoder *)encoder&#123; encodeRuntime(Movie)&#125;- (id)initWithCoder:(NSCoder *)decoder&#123; initCoderRuntime(Movie)&#125;@end 优化：上面是encodeWithCoder 和 initWithCoder这两个方法抽成宏。我们可以把这两个宏单独放到一个文件里面，这里以后需要进行数据持久化的模型都可以直接使用这两个宏。 runtime 下Class的各项操作下面是 runtime 下Class的常见方法 及 带有使用示例代码。各项操作，原著 http://www.jianshu.com/p/46dd81402f63 unsigned int count; 获取属性列表 12345objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count); for (unsigned int i=0; i&lt;count; i++) &#123; const char *propertyName = property_getName(propertyList[i]); NSLog(@"property----&gt;%@", [NSString stringWithUTF8String:propertyName]); &#125; 获取方法列表 12345Method *methodList = class_copyMethodList([self class], &amp;count);for (unsigned int i; i&lt;count; i++) &#123; Method method = methodList[i]; NSLog(@"method----&gt;%@", NSStringFromSelector(method_getName(method)));&#125; 获取成员变量列表 123456Ivar *ivarList = class_copyIvarList([self class], &amp;count); for (unsigned int i; i&lt;count; i++) &#123; Ivar myIvar = ivarList[i]; const char *ivarName = ivar_getName(myIvar); NSLog(@"Ivar----&gt;%@", [NSString stringWithUTF8String:ivarName]); &#125; 获取协议列表 123456__unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count); for (unsigned int i; i&lt;count; i++) &#123; Protocol *myProtocal = protocolList[i]; const char *protocolName = protocol_getName(myProtocal); NSLog(@"protocol----&gt;%@", [NSString stringWithUTF8String:protocolName]); &#125; 现在有一个Person类，和person创建的xiaoming对象,有test1和test2两个方法 获得类方法 123Class PersonClass = object_getClass([Person class]);SEL oriSEL = @selector(test1);Method oriMethod = _class_getMethod(xiaomingClass, oriSEL); 获得实例方法 123Class PersonClass = object_getClass([xiaoming class]);SEL oriSEL = @selector(test2);Method cusMethod = class_getInstanceMethod(xiaomingClass, oriSEL); 添加方法 1BOOL addSucc = class_addMethod(xiaomingClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod)); 替换原方法实现 1class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod)); 交换两个方法的实现 1method_exchangeImplementations(oriMethod, cusMethod); 常用方法12345678910111213141516171819202122232425262728293031// 得到类的所有方法 Method *allMethods = class_copyMethodList([Person class], &amp;count);// 得到所有成员变量 Ivar *allVariables = class_copyIvarList([Person class], &amp;count);// 得到所有属性 objc_property_t *properties = class_copyPropertyList([Person class], &amp;count);// 根据名字得到类变量的Ivar指针，但是这个在OC中好像毫无意义Ivar oneCVIvar = class_getClassVariable([Person class], name);// 根据名字得到实例变量的Ivar指针 Ivar oneIVIvar = class_getInstanceVariable([Person class], name);// 找到后可以直接对私有变量赋值 object_setIvar(_per, oneIVIvar, @"Mike");//强制修改name属性/* 动态添加方法： 第一个参数表示Class cls 类型； 第二个参数表示待调用的方法名称； 第三个参数(IMP)myAddingFunction，IMP是一个函数指针，这里表示指定具体实现方法myAddingFunction； 第四个参数表方法的参数，0代表没有参数； */ class_addMethod([_per class], @selector(sayHi), (IMP)myAddingFunction, 0);// 交换两个方法 method_exchangeImplementations(method1, method2);// 关联两个对象objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)/* id object :表示关联者，是一个对象，变量名理所当然也是object const void *key :获取被关联者的索引key id value :被关联者，这里是一个block objc_AssociationPolicy policy : 关联时采用的协议，有assign，retain，copy等协议，一般使用OBJC_ASSOCIATION_RETAIN_NONATOMIC*/ runtime 几个参数概念以上的几种方法应该算是runtime在实际场景中所应用的大部分的情况了，平常的编码中差不多足够用了。这里在对 runtime 几个参数概念，做一简单说明 1、objc_msgSend这是个最基本的用于发送消息的函数。其实编译器会根据情况在objc_msgSend， objc_msgSend_stret,，objc_msgSendSuper， 或 objc_msgSendSuper_stret 四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有 Super 的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有stret的函数。 2、SELobjc_msgSend函数第二个参数类型为SEL，它是selector在Objc中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:typedef struct objc_selector *SEL;其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令@selector()``或者 Runtime 系统的sel_registerName函数来获得一个SEL类型的方法选择器。 3、idobjc_msgSend第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针：typedef struct objc_object *id;那objc_object又是啥呢：struct objc_object { Class isa; };objc_object结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。 4、runtime.h里Class的定义12345678910111213141516struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;//每个Class都有一个isa指针 #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE;//父类 const char *name OBJC2_UNAVAILABLE;//类名 long version OBJC2_UNAVAILABLE;//类版本 long info OBJC2_UNAVAILABLE;//!*!供运行期使用的一些位标识。如：CLS_CLASS (0x1L)表示该类为普通class; CLS_META(0x2L)表示该类为metaclass等(runtime.h中有详细列出) long instance_size OBJC2_UNAVAILABLE;//实例大小 struct objc_ivar_list *ivars OBJC2_UNAVAILABLE;//存储每个实例变量的内存地址 struct objc_method_list **methodLists OBJC2_UNAVAILABLE;//!*!根据info的信息确定是类还是实例，运行什么函数方法等 struct objc_cache *cache OBJC2_UNAVAILABLE;//缓存 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;//协议#endif &#125; OBJC2_UNAVAILABLE; 可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。在objc_class结构体中：`ivars是objc_ivar_list指针；methodLists是指向objc_method_list指针的指针。也就是说可以动态修改*methodLists的值来添加成员方法，这也是Category`实现的原理。 上面讲到的所有东西都在Demo里，如果你感觉这样难以理解，那强烈建议你下载Demo ，运行代码加上文字注解，效果会更好，如果你觉得不错，还请为我的Demo star一个。 什么是 method swizzling（俗称黑魔法） 简单说就是进行方法交换 在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的 每个类都有一个方法列表，存放着方法的名字和方法实现的映射关系，selector的本质其实就是方法名，IMP有点类似函数指针，指向具体的Method实现，通过selector就可以找到对应的IMP。 交换方法的几种实现方式 利用 method_exchangeImplementations 交换两个方法的实现 利用 class_replaceMethod 替换方法的实现 利用 method_setImplementation 来直接设置某个方法的IMP。 这里可以参考简友这篇：【Runtime Method Swizzling开发实例汇总】http://www.jianshu.com/p/f6dad8e1b848 这里可以参考权威这篇：OC运行时黑魔法 Method Swizzling 最后一道面试题的注解 下面的代码输出什么?1234567891011@implementation Son : NSObject- (id)init&#123; self = [super init]; if (self) &#123; NSLog(@"%@", NSStringFromClass([self class])); NSLog(@"%@", NSStringFromClass([super class])); &#125; return self;&#125;@end 先思考一下，会打印出来什么❓关注我的更多干货分享 ^_^. 答案：都输出 Son class 获取当前方法的调用者的类，superClass 获取当前方法的调用者的父类，super 仅仅是一个编译指示器，就是给编译器看的，不是一个指针。 本质：只要编译器看到super这个标志，就会让当前对象去调用父类方法，本质还是当前对象在调用 这个题目主要是考察关于objc中对 self 和 super 的理解： self 是类的隐藏参数，指向当前调用方法的这个类的实例。而 super 本质是一个编译器标示符，和 self 是指向的同一个消息接受者 当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找； 而当使用 super时，则从父类的方法列表中开始找。然后调用父类的这个方法 调用 [self class] 时，会转化成 objc_msgSend 函数 12345678910111213141516id objc_msgSend(id self, SEL op, ...)- 调用 `[super class]`时，会转化成 `objc_msgSendSuper` 函数.id objc_msgSendSuper(struct objc_super *super, SEL op, ...)第一个参数是 objc_super 这样一个结构体，其定义如下 struct objc_super &#123; __unsafe_unretained id receiver; __unsafe_unretained Class super_class; &#125;;第一个成员是 receiver, 类似于上面的 objc_msgSend函数第一个参数self第二个成员是记录当前类的父类是什么，告诉程序从父类中开始找方法，找到方法后，最后内部是使用 objc_msgSend(objc_super-&gt;receiver, @selector(class))去调用， 此时已经和[self class]调用相同了，故上述输出结果仍然返回 Sonobjc Runtime 开源代码对- (Class)class方法的实现-(Class)class &#123; return object_getClass(self); &#125; runtime模块简友文章推荐(❤️数量较多) 简友 runtime模块推荐阅读文章 西木 完整总结 http://www.jianshu.com/p/6b905584f536 天口三水羊 objc_msgSend http://www.jianshu.com/p/9e1bc8d890f9 夜千寻墨 详解 http://www.jianshu.com/p/46dd81402f63 袁峥Seemygo 快速上手 http://www.jianshu.com/p/e071206103a4 郑钦洪_ 实现自动化归档 http://www.jianshu.com/p/bd24c3f3cd0a HenryCheng 消息机制 http://www.jianshu.com/p/f6300eb3ec3d 卖报的小画家Sure Method Swizzling开发实例汇总 http://www.jianshu.com/p/f6dad8e1b848 滕大鸟 OC最实用的runtime总结 http://www.jianshu.com/p/ab966e8a82e2 黑花白花 Runtime在实际开发中的应用 http://www.jianshu.com/p/851b21870d91 OC &amp; Swift Runtime 面试最常问到的题整理【建议看】说明：此面试题针对性的摘录整理，只为方便 在面试路上准备的你 ，会注有原文。 1、整理原文：2017年5月iOS招人心得（附面试题） Runtime objc在向一个对象发送消息时，发生了什么？ 什么时候会报unrecognized selector错误？iOS有哪些机制来避免走到这一步？ 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ runtime如何实现weak变量的自动置nil？ 给类添加一个属性后，在类结构体里哪些元素会发生变化？ RunLoop runloop是来做什么的？runloop和线程有什么关系？主线程默认开启了runloop么？子线程呢？ runloop的mode是用来做什么的？有几种mode？ 为什么把NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到4. 主运行循环以后，滑动scrollview的时候NSTimer却不动了？ 苹果是如何实现Autorelease Pool的？ //——————– 【我是分割线】 ———————// 整理原文：2017年iOS面试题总结，附答案 Runtime 01 问题： objc在向一个对象发送消息时，发生了什么？ 解答： 根据对象的 isa 指针找到类对象 id，在查询类对象里面的 methodLists 方法函数列表，如果没有在好到，在沿着 superClass ,寻找父类，再在父类 methodLists 方法列表里面查询，最终找到 SEL ,根据 id 和 SEL 确认 IMP（指针函数）,在发送消息； 03 问题： 什么时候会报unrecognized selector错误？iOS有哪些机制来避免走到这一步？ 解答： 当发送消息的时候，我们会根据类里面的 methodLists 列表去查询我们要动用的SEL，当查询不到的时候，我们会一直沿着父类查询，当最终查询不到的时候我们会报 unrecognized selector 错误，当系统查询不到方法的时候，会调用 +(BOOL)resolveInstanceMethod:(SEL)sel 动态解释的方法来给我一次机会来添加，调用不到的方法。或者我们可以再次使用 -(id)forwardingTargetForSelector:(SEL)aSelector 重定向的方法来告诉系统，该调用什么方法，一来保证不会崩溃。 04 问题： 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ 解答： 1、不能向编译后得到的类增加实例变量 2、能向运行时创建的类中添加实例变量。【解释】：1. 编译后的类已经注册在 runtime 中,类结构体中的 objc_ivar_list 实例变量的链表和 instance_size 实例变量的内存大小已经确定，runtime会调用 class_setvarlayout 或 class_setWeaklvarLayout 来处理strong weak 引用.所以不能向存在的类中添加实例变量。2. 运行时创建的类是可以添加实例变量，调用class_addIvar函数. 但是的在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前,原因同上. 05 问题： runtime如何实现weak变量的自动置nil？ 解答： runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。 06 问题： 给类添加一个属性后，在类结构体里哪些元素会发生变化？ 解答： instance_size ：实例的内存大小；objc_ivar_list *ivars:属性列表 RunLoop 01 问题： runloop是来做什么的？runloop和线程有什么关系？主线程默认开启了runloop么？子线程呢？ 解答： runloop: 字面意思就是跑圈，其实也就是一个循环跑圈，用来处理线程里面的事件和消息。runloop和线程的关系：每个线程如果想继续运行，不被释放，就必须有一个runloop来不停的跑圈，以来处理线程里面的各个事件和消息。主线程默认是开启一个runloop。也就是这个runloop才能保证我们程序正常的运行。子线程是默认没有开始runloop的 02 问题： runloop的mode是用来做什么的？有几种mode？ 解答： model:是runloop里面的模式，不同的模式下的runloop处理的事件和消息有一定的差别。系统默认注册了5个Mode:（1）kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。（2）UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。（3）UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。（4）GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。（5）kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。注意iOS 对以上5中model进行了封装 NSDefaultRunLoopMode、NSRunLoopCommonModes 03 问题： 为什么把NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环以后，滑动scrollview的时候NSTimer却不动了？ 解答： nstime对象是在 NSDefaultRunLoopMode下面调用消息的，但是当我们滑动scrollview的时候，NSDefaultRunLoopMode模式就自动切换到UITrackingRunLoopMode模式下面，却不可以继续响应nstime发送的消息。所以如果想在滑动scrollview的情况下面还调用nstime的消息，我们可以把nsrunloop的模式更改为NSRunLoopCommonModes. 04 问题： 苹果是如何实现Autorelease Pool的？ 解答： Autorelease Pool作用：缓存池，可以避免我们经常写relase的一种方式。其实就是延迟release，将创建的对象，添加到最近的autoreleasePool中，等到autoreleasePool作用域结束的时候，会将里面所有的对象的引用计数器 - autorelease. 后续遇到针对runtime常面相关，会及时在这里补充； 效果图 附上总结写的小样 Demo，「重要的部分代码中都有相应的注解和文字打印，运行程序可以很直观的表现」—-&gt; [@码员] 【@码员真爱 : 真的不点进去阅读一下 ❓】【译文 &amp; 源码】 【工具类】 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 模式详解—「Runloop面试、工作」看我就 🐒 了 ^_^.]]></title>
    <url>%2FiOSNET%2Frunloop.html</url>
    <content type="text"><![CDATA[待总结，明天再来看就有了 ！ ！ ！ 可先参考：http://www.jianshu.com/p/d6c5c0bf97fd]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>runloop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UI控件详解—「UIScrollView滚动视图」]]></title>
    <url>%2FiOSUI%2FUIScrollView.html</url>
    <content type="text"><![CDATA[引导 “ 本文不适合老司机… ”Copyright © PBWln Unauthorized shall not be reproduced. 本文章将介绍 iOS UI控件 详解，最常使用的三大控件之一 UIScrollView，将会分成两篇文章完整的讲述 UIScrollView 的常用属性方法使用（包括优化方面）及注意点 和 实战开发使用场景案例，文章编写周期会长一些，用到那点实用的东西，会及时补充。 本篇文章主要从【 UIScrollView 属性方法注解】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： UIScrollView概念 UIScrollView基本使用(滚动) UIScrollView属性与方法1.属性 &amp; 方法2.使用格式 &amp; 说明：3.简明注解： UIScrollView代理方法1.滑动代理方法相关2.缩放代理方法相关3.部分代理方法简明示例 UIScrollView处理触摸事件原理 常见需求示例 &amp; 原理解析1.导航栏半透明效果2.控件导航悬停3.下拉头部图片放大4.正反无限轮播（3张）重点 UIScrollView底层实现 正反无限轮播（2张） UIScrollView.h属性和方法 期待 &amp; 后续 UIScrollView概念 我还是喜欢先看官方的说明： 上图简明释义：可以展示比设备屏幕更大区域的内容，我们可以通过手指滑动来查看内容视图（content view）的每一部分内容，也可以通过手指捏合来对内容视图进行缩放操作。 UIScrollView 是一个非常重要的控件，UITableView、UICollectionView和UITextView等常用控件全部继承自UIScrollView，而UIWebView控件内部也是基于UIScrollView实现的。而UIScrollView继承自UIView，至于它可以滚动的原因我下面会有原理说明。 UIScrollView基本使用(滚动) UIScrollView的使用很简单，基本使用方式如下 3点： 12345678910// 1.创建滚动视图UIScrollView *scrollView = [[UIScrollView alloc] init];scrollView.frame = CGRectMake(0,0,375,150);[self addSubview:scrollView];// 2. 设置滚动范围（内容视图的大小）scrollView.contentSize = CGSizeMake(ImageViewCount * self.bounds.size.width, 0);// 3. 添加内容[scrollView addSubview:[UIImageView new]]; 说明：如果想让UIScrollView进行滚动,必须设置可以滚动的范围 UIScrollView属性与方法 属性 &amp; 方法：12345678910111213141516属性 &amp; 方法：#pragma mark ------------------#pragma mark - 内容视图属性方法相关/** 内容视图的原点相对于scrollView的原点的偏移量(上/左 方向偏移为正数,下/右 方向偏移为负数),默认为CGPointZero */@property(nonatomic) CGPoint contentOffset; // default CGPointZero/** 内容视图的大小,默认为CGSizeZero */@property(nonatomic) CGSize contentSize; // default CGSizeZero/** 为内容视图周围增加可滚动区域,默认为UIEdgeInsetsZero */@property(nonatomic) UIEdgeInsets contentInset; // default UIEdgeInsetsZero. add additional scroll area around content// 代理@property(nullable,nonatomic,weak) id&lt;UIScrollViewDelegate&gt; delegate; // default nil. weak reference/** 设置内容视图的原点相对于scrollView的原点的偏移量 */- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated; // animate at constant velocity to new offset 使用格式 &amp; 说明：1234567891011121314151617使用格式 &amp; 说明：// 内容滚动大小（说明：设置的大小 &gt; scrollView.bounds 才可以滚动，哪个方向不滚动可直接设置为0 如:width = 0 或是 height = 0）self.scrollView.contentSize = CGSizeMake(3 * ScreenViewW, ScreenViewH); // 内容偏移量（说明：内容视图的左上角到scrollView左上角的一个偏移量，计算时以内容视图的左上角为基准，默认（0,0）开始）scrollView.contentOffset = CGPointMake(150, 0);// 内边距（top +,left +,bottom -,right -）scrollView.contentInset = UIEdgeInsetsMake(10, 10, 10, 10);// 设置scorllView的代理，当滚动事件事件发生时，相应的代理方法被调用（说明：苹果设计的代理属性为什么是weak？注解在下面）// 可以看到前面定义属性类型为 id,可知 任何OC对象都可以作为scrollView的代理，必须（1.遵守协议 2.实现协议方法）scrollView.delegate = self;// 方法：setContentOffset: 内容偏移量// 说明：方法动画结束时调用 scrollViewDidEndScrollingAnimation:(仅当animated设置为YES时才调用)[self.scrollView setContentOffset:offset animated:YES]; 简明注解：对于 UIScrollView 最重要的属性 contentSize、 contentOffset、 contentInset，要有正确的认知。 这个图很能说明，这三个属性的区别： 解答上面问题：苹果设计的代理属性为什么是weak？ 上图注解： 原因：防止造成循环引用 说明： rootViewController 指针指向控制器对象（每个控制器都有个View 被 强引用）–&gt; UIView对象（强引用 内部 属性 subViews）–&gt; 子控件数组对象（强引用 假设scr对象在第0位）–&gt; UIScrollView对象将ViewController设置为自己的代理（delegate），所以的用 弱引用 weak。 假设没有指针指向这个控制器，而delegate(weak弱引用) 没有强指针引用，控制器就会释放。 UIScrollView代理方法 滑动代理方法相关123456789101112131415161718192021222324252627282930313233343536373839@protocol UIScrollViewDelegate&lt;NSObject&gt;@optional (可选)#pragma mark ------------------#pragma mark - 滑动代理方法相关/** 当scrollView的contentOffset发生变化时调用 */- (void)scrollViewDidScroll:(UIScrollView *)scrollView; // any offset changes// called on start of dragging (may require some time and or distance to move)/** 用户即将开始拖拽scrollView是调用(注: 该方法可能需要先滑动一段时间或距离才会被调用) */- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;// called on finger up if the user dragged. velocity is in points/millisecond. targetContentOffset may be changed to adjust where the scroll view comes to rest/** 用户即将停止拖拽时调用(注: 应用程序可以通过修改targetContentOffset参数的值来调整内容视图content view停止的位置) */- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset NS_AVAILABLE_IOS(5_0);// called on finger up if the user dragged. decelerate is true if it will continue moving afterwards/** 用户已经停止拖拽时调用(注: 如果内容视图content view在停止拖拽后但由于惯性会继续滚动，减速,则decelerate参数为YES) */- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;/** 将要开始减速时调用(仅当停止拖拽后继续移动时才会被调用) */- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView; // called on finger up as we are moving/** 已经结束减速时调用(仅当停止拖拽后继续移动时才会被调用) */- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; // called when scroll view grinds to a halt/** 当-setContentOffset:animated:/-scrollRectVisible:animated:方法动画结束时调用(仅当animated设置为YES时才调用) */- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView; // called when setContentOffset/scrollRectVisible:animated: finishes. not called if not animating/** 返回是否允许点击状态栏让scrollView滑动到顶部,如果未实现该方法,则默认为YES(仅当scrollsToTop属性为YES时才调用) */- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView; // return a yes if you want to scroll to the top. if not defined, assumes YES/** 当scrollView已经滑动到顶部时调用(仅当点击状态栏让scrollView滑动到顶部才调用) */- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView; // called when scrolling animation finished. may be called immediately if already at top 缩放代理方法相关12345678910111213#pragma mark ------------------#pragma mark - 缩放代理方法相关/** 当缩放比例更改时调用 */- (void)scrollViewDidZoom:(UIScrollView *)scrollView NS_AVAILABLE_IOS(3_2); // any zoom scale changes/** 参与缩放的子视图 */- (nullable UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView; // return a view that will be scaled. if delegate returns nil, nothing happens/** 将要开始缩放时调用 */- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view NS_AVAILABLE_IOS(3_2); // called before the scroll view begins zooming its content/** 已经结束缩放时调用 */- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view atScale:(CGFloat)scale; // scale between minimum and maximum. called after any 'bounce' animations@end 部分代理方法简明示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#pragma mark ------------------#pragma mark - UIScrollViewDelegate// 只要scrollView滚动就会调用该方法- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; //由于该方法在视图滚动中一直调用，所以不要在这里做耗时的计算 NSLog(@"视图正在滚动----");&#125;// 用户即将开始拖动时,停止定时器- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123; NSLog(@"滚动视图内容即将被拖动");&#125;// 用户即将停止拖动时调用- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123; NSLog(@"滚动视图的内容即将停止拖动"); &#125;// 用户已经停止拖动时调用 (decelerate 指定是否有减速动作 Dragging 拖)- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; if (decelerate == NO) &#123; NSLog(@"用户已经停止拖动,停止滚动"); &#125;else&#123; NSLog(@"用户已经停止拖动,但是由于惯性会减速滚动"); &#125;&#125;// 手动滚动 减速完毕会调用(停止滚动),开启定时器// 只要设置了scrollView的分页显示，当手动(使用手指)滚动结束后，该代理方法会被调用- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; NSLog(@"减速结束,内容视图停止");&#125;// 指定在scollView上哪一个视图被缩放-(UIView*)viewForZoomingInScrollView:(UIScrollView *)scrollView&#123; //NSLog(@"346"); return [scrollView.subviews objectAtIndex:0]; &#125;// 只要scrollView缩放就会调用该方法- (void)scrollViewDidZoom:(UIScrollView *)scrollView&#123; //由于该方法在视图缩放中一直调用，所以不要在这里做耗时的计算 NSLog(@"视图正在缩放----");&#125; UIScrollView处理触摸事件原理 当用户在UIScrollView的一个子视图上按下时，UIScrollView并不知道用户是想要滑动内容视图还是点击对应子视图，所以在按下的一瞬间，事件UIEvent从UIApplication传递到UIScrollView后，其会先将该事件拦截而不会立即传递给对应的子视图,同时开始一个150ms的倒计时，并监听用户接下来的行为 当倒计时结束前，如果用户的手指发生了移动，则直接滚动内容视图，不会将该事件传递给对应的子视图; 当倒计时结束时，如果用户的手指位置没有改变，则调用自身的-touchesShouldBegin:withEvent:inContentView:方法询问是否将事件传递给对应的子视图(如果返回NO，则该事件不会传递给对应的子视图,如果返回YES，则该事件会传递给对应的子视图，默认为YES)。 当事件被传递给子视图后,如果手指位置又发生了移动，则调用自身的-touchesShouldCancelInContentView:方法询问是否取消已经传递给子视图的事件。 常见需求示例 &amp; 原理解析 导航栏半透明效果原理解析: 默认情况下，在有UINavigationBar存在时，系统为了防止UIScrollView被遮挡，其contentInset和scrollIndicatorInsets属性都会被设置为UIEdgeInsetsMake(64, 0, 0, 0);在有UITabBar存在时，系统为了防止UIScrollView被遮挡，其contentInset和scrollIndicatorInsets属性都会被设置为UIEdgeInsetsMake(0, 0, 49, 0) 因此，为了使用此种半透明效果，可以直接将UIScrollView的frame设置为整个屏幕的大小。 注1: 系统只在UIScrollView是控制器视图的第0个子视图时才会自动修改contentInset和scrollIndicatorInsets属性。 注2: 如果不想让系统自动修改contentInset和scrollIndicatorInsets属性，可以设置self.automaticallyAdjustsScrollViewInsets = NO; 控件导航悬停原理解析: 通过-scrollViewDidScroll:代理方法跟踪contentOffset的的变化,当不满足悬停条件时，待悬停控件属于UIScrollView的子视图，当满足悬停条件时，待悬停控件属于UIScrollView的父视图的子视图。 12345678910111213141516171819- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; if (scrollView.contentOffset.y &gt;= 100) &#123; CGRect rect = label.frame; rect.origin.y = 0; label.frame = rect; [self.view addSubview:label]; &#125; else &#123; CGRect rect = label.frame; rect.origin.y = 100; label.frame = rect; [scrollView addSubview:label]; &#125;&#125; 下拉头部图片放大原理解析: 通过-scrollViewDidScroll:代理方法跟踪contentOffset的的变化,根据contentOffset动态设置图片的缩放比例。 12345678// 以"动态修改图片缩放比例于1倍和2倍之间"为例- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat scale = 1 - (scrollView.contentOffset.y / 100); scale = (scale &gt;= 1) ? scale : 1; scale = (scale &lt;= 2) ? scale : 2; imageView.transform = CGAffineTransformMakeScale(scale, scale);&#125; 正反无限轮播（3张）原理解析: 手动滚动：只创建三张图片： leftImageView、centerImageView、rightImageView，定义中间显示页码为 centerPage ，设置初始self.centerPage = 0;，而左右图片页码都以 centerPage 表示，通过 scrollViewDidEndDecelerating: 方法判断contentOffsest.x 和 scrollView.frame.size.width 比较，使改变 self.centerPage的值，然后对应页码滚动取数组中的图片，始终显示中间一张。 定时器滚动： 将定时器添加到 Runloop 的 NSRunLoopCommonModes下，触发方法中设置setContentOffset: animated:YES 方法动画结束时调用 scrollViewDidEndScrollingAnimation:(仅当animated设置为YES时才调用)，这个方法下 self.centerPage++;。OK了 监听图片点击当图片被点击的时候，我们往往需要执行某些操作，因此需要监听图片的点击，思路如下： 1.定义一个block属性暴露给外界void(^LNBlock)(NSInteger index)，（不会block的可以用代理，或者看这里 Block模式详解）。 2.设置centerImageView的userInteractionEnabled为YES。 3.给scrollView添加一个点击的手势 4.在手势方法里调用block，并传入图片索引 核心代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#pragma mark - 添加三张图片- (void)createContentViews&#123; // 把3张imageView对象添加到scrollView上 CGRect frame = self.bounds; self.leftImageView = [[UIImageView alloc] initWithFrame:frame]; frame.origin.x += ScreenViewW; self.centerImageView = [[UIImageView alloc] initWithFrame:frame]; frame.origin.x += ScreenViewW; self.rightImageView = [[UIImageView alloc] initWithFrame:frame]; [self.scrollView addSubview:self.leftImageView]; [self.scrollView addSubview:self.centerImageView]; [self.scrollView addSubview:self.rightImageView];&#125;#pragma mark - set方法赋值- (void)setCenterPage:(NSInteger)centerPage &#123; _centerPage = centerPage; if (_centerPage &lt; 0) &#123; // 向右滑动显示左面图片,值与0比较 _centerPage = self.imageArray.count - 1; &#125; if (_centerPage &gt; self.imageArray.count - 1) &#123; _centerPage = 0; // 向左滑动显示右面图片,值与count-1 比较 &#125; // Page: left和right用center表示 NSInteger leftPage = _centerPage - 1 &lt; 0 ? self.imageArray.count -1 : _centerPage - 1; NSInteger rightPage = _centerPage +1 &gt; self.imageArray.count - 1 ? 0 : _centerPage + 1; // 赋值 self.leftImageView.image = self.imageArray[leftPage]; self.centerImageView.image = self.imageArray[_centerPage]; self.rightImageView.image = self.imageArray[rightPage]; // 显示中间那一页（注:这里不要使用动画） [self.scrollView setContentOffset:CGPointMake(self.scrollView.frame.size.width, 0)]; // 设置pageControl的页码 self.pageControl.currentPage = _centerPage; &#125;#pragma mark - UIScrollViewDelegate// 手动滚动 减速完毕会调用(停止滚动),开启定时器// 只要设置了scrollView的分页显示，当手动(使用手指)滚动结束后，该代理方法会被调用- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123; // 判断contentOffsest.x if (scrollView.contentOffset.x &gt; scrollView.frame.size.width) &#123; // 下一张 self.centerPage++; &#125; else if (scrollView.contentOffset.x &lt; scrollView.frame.size.width)&#123; // 上一张 self.centerPage--; &#125; [self startTimer]; NSLog(@"手动减速完毕,开启定时器 当前页 %ld",self.centerPage);&#125; UIScrollView底层实现123456789101112131415NS_CLASS_AVAILABLE_IOS(2_0) @interface UIScrollView : UIView &lt;NSCoding&gt;#pragma mark ------------------#pragma mark - 内置手势识别器// Change `panGestureRecognizer.allowedTouchTypes` to limit scrolling to a particular set of touch types./** 拖动手势 */@property(nonatomic, readonly) UIPanGestureRecognizer *panGestureRecognizer NS_AVAILABLE_IOS(5_0);// `pinchGestureRecognizer` will return nil when zooming is disabled./** 捏合手势 */@property(nullable, nonatomic, readonly) UIPinchGestureRecognizer *pinchGestureRecognizer NS_AVAILABLE_IOS(5_0);// `directionalPressGestureRecognizer` is disabled by default, but can be enabled to perform scrolling in response to up / down / left / right arrow button presses directly, instead of scrolling indirectly in response to focus updates./** 定向手势识别器 */@property(nonatomic, readonly) UIGestureRecognizer *directionalPressGestureRecognizer UIKIT_AVAILABLE_TVOS_ONLY(9_0); 总结：UIScrollView 继承自UIView，内部加了手势，之所以可以滑动，是改变了bounds，若手指向上滑动，y++，内容就会向上滑动。这样我们也可以用 给UIView 添加个 Pan手势 实现滚动效果。本文为「简书-白开水ln」作者原创；我的写作，希望能简化到初学者尽快入门和老司机繁琐回顾 ^_^. 正反无限轮播（2张）大致原理：最底层是一个UIView，上面有一个UIScrollView以及UIPageControl，scrollView上有两个UIImageView，imageView宽高 = scrollview宽高 = view宽高; 假设轮播控件的宽度为x高度为y，我们设置scrollview的contentSize.width为3x，并让scrollview的水平偏移量为x，既显示最中间内容。 具体细节请移步这里阅读：轮播两个ImageView实现 http://www.jianshu.com/p/ef03ec7f23b2 参考：iOS控件详解之UIScrollView 正反无限轮播 效果图 附上总结写的小样 Demo，重要的部分代码中都有相应的注解和文字打印，运行程序可以很直观的表现 ！ 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UI控件详解—「UITableView表格视图」]]></title>
    <url>%2FiOSUI%2FUITableView.html</url>
    <content type="text"><![CDATA[引导 “ 本文不适合老司机… ” 本文章将介绍 iOS UI布局 详解，最常使用的三大控件之一 UITableView，将会分成两篇文章完整的讲述UITableView的常用属性方法使用（包括优化方面）及注意点 和 实战开发使用场景案例，文章编写周期会长一些，用到那点实用的东西，会及时补充。 本篇文章主要从【UITableView 属性方法注解】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： 概念1.UITableView的概念2.UITableViewCell的概念3.UITableViewController的概念 UITableView的使用步骤1.大致个人总结六步 UITableView的常用属性 UITableViewCell的常用属性 UITableView的代理方法 UITableViewController的使用 UITableViewCell的重用 UITableViewCell的优化 UITableView重要属性图解 UITableView.h 属性&amp;方法 期待后续 &amp; About me 概念 UITableView的概念 简化可释义为 &quot;表格视图&quot; 或是 &quot;列表视图&quot;， 且 支持选择和编辑的信息。在iOS开发中做列表数据类型的应用，最常用的做法就是使用UITableView控件。 UITbaleView 继承自 UIScrollView，因此支持竖直滚动，而且在 UIScrollView 做了性能优化，当然你也可以做到水平滚动，把cell 旋转一下就可以了。 UITableViewCell的概念 简化意思就是 UITableView的每一行都是一个UITableViewCell。其中类包含属性和方法用于设置和管理单元格； UITableView内部有个默认的子控件：contentView，填充整个UITableViewCell的父控件。 UITableView的子控件实质都在contentView上。 UITableViewController的概念 简化意思就是 这个类是一个自带（管理）tableView 的控制器。 在Xcode 中 cmd UITableViewController 点进去，看到 1NS_CLASS_AVAILABLE_IOS(2_0) @interface UITableViewController : UIViewController 简化意思就是UITableViewController是已经遵循了UITableViewDelegate，UITableViewDataSource代理的控制器 UITableView使用步骤 下面示例以 tableView代码自定义不等高Cell 为例： 第一步：创建 UITableView，采用懒加载方式。 12345678910111213141516- (UITableView *)tableView &#123; if (_tableView == nil) &#123; _tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0,kScreenWidth, kScreenHeight) style:UITableViewStylePlain];// Plain单组数据悬停 Grouped多组数据不悬停 _tableView.dataSource = self;// 数据源 _tableView.delegate = self;// 代理 _tableView.separatorStyle = UITableViewCellSeparatorStyleNone;// 分割线 _tableView.estimatedRowHeight = 100;// 预设高度 //[self.view addSubview:self.tableView];// 这里不要忘记添加上 //--------------------------- tableView 常用属性 ------------------------------// // &#125; return _tableView;&#125; 第二步：设置数据源和代理，遵守对应协议。 1@interface LNTableViewAttributeVC () 第三步：设置数据数组，采用懒加载方式加载数据（使用MJExtension字典数组转模型数组）。 1234567- (NSMutableArray *)dataArray&#123; if (!_dataArray) &#123; _dataArray = [LNStatus mj_objectArrayWithFilename:@"statuses.plist"]; &#125; return _dataArray;&#125; 第四步：创建自定义Cell（视图继承UITableViewCell）。 1.定义模型类对象。 2.定义子控件属性。 3.在initWithStyle:style reuseIdentifier:reuseIdentifier，添加子控件(设置约束Masonry)。 4.在 layoutSubviews 设置子控件的 frame. 5.模型类对象set方法setStatus:设置子控件的数据(赋值)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// LNStatusViewCell.h@class LNStatus;@interface LNStatusViewCell : UITableViewCell/** 模型类对象 */@property (nonatomic, strong) LNStatus *status;@end//--------------------------- &lt;#我是分割线#&gt; ------------------------------//// LNStatusViewCell.m@interface LNStatusViewCell ()/* 头像 */@property (nonatomic, weak) UIImageView *iconImageView;/* 配图 */@property (nonatomic, weak) UIImageView *pictureImageView;/* vip */@property (nonatomic, weak) UIImageView *vipImageView;/* 名称 */@property (nonatomic, weak) UILabel *nameLabel;/** 文字 */@property (nonatomic, weak) UILabel *text_Label;// 自定义控件不要与系统textLabel重名@end@implementation LNStatusViewCell/*1. 添加子控件(设置约束)(如:文字和颜色,一次性的设置) 注意点:把所有有可能显示的子控件都先添加进去 */- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier&#123; if (self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]) &#123; // 图像 // 配图 // vip // 昵称 // 正文 // 自定义分割线 UILabel *lineLabel = [[UILabel alloc] initWithFrame:CGRectZero]; lineLabel.backgroundColor = [UIColor colorWithWhite:0.5 alpha:0.5]; [self.contentView addSubview:lineLabel]; [lineLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.bottom.left.right.equalTo(self.contentView).with.offset(0); make.height.mas_equalTo(1.0f); &#125;]; &#125; return self;&#125;// 2.设置子控件的frame/* - (void)layoutSubviews&#123; [super layoutSubviews]; &#125; */// 3.set方法设置子控件的数据(赋值)- (void)setStatus:(LNStatus *)status&#123; _status = status; self.iconImageView.image = [UIImage imageNamed:status.icon]; self.nameLabel.text = status.name; self.text_Label.text = status.text; if (status.isVip) &#123;// 有无皇冠 self.vipImageView.hidden = NO; self.nameLabel.textColor = [UIColor redColor]; &#125; else &#123; self.vipImageView.hidden = YES; self.nameLabel.textColor = [UIColor blackColor]; &#125; if (status.picture) &#123;// 有无配图(有配图再赋值,无配图就不赋值) self.pictureImageView.hidden = NO; self.pictureImageView.image = [UIImage imageNamed:status.picture]; &#125; else &#123; self.pictureImageView.hidden = YES; &#125; /** 这里的下文会介绍到 */ self.iconImageView.frame = self.status.iconFrame; self.nameLabel.frame = self.status.nameFrame; self.vipImageView.frame = self.status.vipFrame; self.text_Label.frame = self.status.textFrame; self.pictureImageView.frame = self.status.pictureFrame;&#125; 第五步：创建自定义模型类（模型继承NSObject）。 1.定义模型属性。 2.提供构造方法(对象方法和类方法)。 3.定义对应模型frame属性（注解：Cell的动态行高，这里解决方案: 在heightForRowAtIndexPath:这个方法返回之前就要计算cell的高度，即把cell子控件的frame封装到模型中，cellHeight返回行高(相当于懒加载)）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@interface LNStatus : NSObject// 1.定义模型属性/* 文字 */@property (nonatomic, copy) NSString *text;/* 头像 */@property (nonatomic, copy) NSString *icon;/* 名称 */@property (nonatomic, copy) NSString *name;/** VIP 到时候访问的时候可以.vip ,也可以.isVip */@property (nonatomic, assign, getter=isVip) BOOL vip;/* 配图 */@property (nonatomic, copy) NSString *picture;/** 用MJExtension字典转模型框架,下面可以不写 */// 2.提供构造方法//+ (instancetype)statusWithDict:(NSDictionary *)dict;//--------------------------- 返回cell的高度封装 ------------------------------/////** 图像的frame */@property (nonatomic, assign) CGRect iconFrame;/** 昵称的frame */@property (nonatomic, assign) CGRect nameFrame;/** vip的frame */@property (nonatomic, assign) CGRect vipFrame;/** 正文frame */@property (nonatomic, assign) CGRect textFrame;/** 配图的frame */@property (nonatomic, assign) CGRect pictureFrame;/** 返回cell的高度 */@property (nonatomic, assign) CGFloat cellHeight;// LNStatus.m//+ (instancetype)statusWithDict:(NSDictionary *)dict &#123;// // 字典赋值模型属性//&#125;// get方法返回行高(相当于懒加载)- (CGFloat)cellHeight&#123; if (_cellHeight == 0) &#123; /** 图像 */ self.iconFrame = CGRectMake(iconX, iconY, iconWH, iconWH); /** 昵称：字符串自适应宽(昵称文字没有换行) */ self.nameFrame = CGRectMake(nameX, nameY, nameSize.width, nameSize.height); /** vip */ if (self.isVip) &#123; self.vipFrame = CGRectMake(vipX, vipY, vipW, vipH); &#125; /** 正文：字符串自适应宽高(文字有换行) */ self.textFrame = CGRectMake(textX, textY, textW, textH); /** 配图 */ if (self.picture) &#123; // 有配图 self.pictureFrame = CGRectMake(pictureX, pictureY, pictureWH, pictureWH); _cellHeight = CGRectGetMaxY(self.pictureFrame) + space; &#125; else &#123; _cellHeight = CGRectGetMaxY(self.textFrame) + space; &#125; &#125; return _cellHeight;&#125; 第六步：实现DataSource数据源（必须） 和Delegate代理（可选）协议方法创建自定义模型类（模型继承NSObject）。 123456789101112131415161718192021222324#pragma mark ------------------#pragma mark - UITableViewDataSource// TableView中 有多少组Sections// 说明：单组数据可不实现方法，默认返回1- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123; return 1;&#125;// 每组Sections 有多少行Rows- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return self.dataArray.count;&#125;// 每行 cell内容- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 1.cell注册（只要用到forIndexPath:就必须要注册） //[self.tableView registerClass:[LNStatusViewCell class] forCellReuseIdentifier:cellID]; // 2.cell复用队列(访问缓存池) LNStatusViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID forIndexPath:indexPath]; // 3.设置数据(数据数组赋值模型类) cell.status = self.dataArray[indexPath.row]; return cell;&#125; 123456789#pragma mark ------------------#pragma mark - UITableViewDelegate// 解决方案:在这个方法返回之前就要计算cell的高度，即返回cell的高度封装在模型中- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; LNStatus *status = self.dataArray[indexPath.row]; return status.cellHeight;&#125; UITableView基本使用效果图 UITableView常用属性 全局设置行row高： 12345678属性：@property (nonatomic) CGFloat rowHeight;使用格式：self.tableView.rowHeight = 70;说明：默认是44 全局设置区头(区尾)高： 1234567属性：@property (nonatomic) CGFloat sectionHeaderHeight; @property (nonatomic) CGFloat sectionFooterHeight;使用格式：self.tableView.sectionHeaderHeight = 50;self.tableView.sectionFooterHeight = 50; 设置分割线的样式、铺满和颜色： 12345678910111213141516属性：@property (nonatomic) UITableViewCellSeparatorStyle separatorStyle __TVOS_PROHIBITED;@property (nonatomic, strong, nullable) UIColor *separatorColor UI_APPEARANCE_SELECTOR __TVOS_PROHIBITED;@property (nonatomic) UIEdgeInsets separatorInset NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR;使用格式：self.tableView.separatorStyle = UITableViewCellSeparatorStyleSingleLine;self.tableView.separatorColor = [UIColor redColor];self.tableView.separatorInset = UIEdgeInsetsMake(0, 0, 0, 0);说明：设置 StyleNone 代表隐藏分割线，[UIColor clearColor]为透明色对象枚举UITableViewCellSeparatorStyle常用的枚举元素：UITableViewCellSeparatorStyleNone // 隐藏分割线UITableViewCellSeparatorStyleSingleLine // 默认样式UITableViewCellSeparatorStyleSingleLineEtched // 仅支持在grouped样式，但是和默认样式没什么区别 设置tableView表格头(尾)视图： 1234567属性：@property (nonatomic, strong, nullable) UIView *tableHeaderView; @property (nonatomic, strong, nullable) UIView *tableFooterView; 使用格式：self.tableView.tableHeaderView = [[UISwitch alloc] init];self.tableView.tableFooterView = [[UISwitch alloc] init]; 设置table背景视图和颜色： 1234567属性：@property (nonatomic, strong, nullable) UIView *backgroundView NS_AVAILABLE_IOS(3_2);@property (nonatomic, copy, nullable) UIColor *backgroundColor;使用格式：self.tableView.backgroundView = [[UIView alloc] init];self.tableView.backgroundColor = [UIColor grayColor]; 设置TableView的cell的预设高度(性能优化)： 12345678属性：@property (nonatomic) CGFloat estimatedRowHeight NS_AVAILABLE_IOS(7_0);使用格式：self.tableView.estimatedRowHeight = 100;说明：这里的高度也不是越大越好，要适时而定 隐藏多余分割线： 12使用格式：self.tableView.tableFooterView = [[UIView alloc] init]; 设置右侧索引文字和背景颜色： 1234567属性：@property (nonatomic, strong, nullable) UIColor *sectionIndexColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;@property (nonatomic, strong, nullable) UIColor *sectionIndexBackgroundColor NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR; 使用格式：self.tableView.sectionIndexColor = [UIColor grayColor];self.tableView.sectionIndexBackgroundColor = [UIColor yellowColor]; UITableViewCell的常用属性 设置cell附加样式（比如右侧的箭头）： 12345属性：@property (nonatomic) UITableViewCellAccessoryType accessoryType; 使用格式：cell.accessoryType = UITableViewCellAccessoryCheckmark; 设置cell右边的指示控件（比如右侧的开关）： 12345属性：@property (nonatomic, strong) UIView *accessoryView;使用格式：cell.accessoryView = [[UISwitch alloc] init]; 设置cell选中样式(StyleNone选中不变灰色)： 12345属性：@property (nonatomic) UITableViewCellSelectionStyle selectionStyle; 使用格式：cell.selectionStyle = UITableViewCellSelectionStyleNone; 设置cell的背景控件： 12345678910属性：@property (nonatomic, strong) UIView *backgroundView;使用格式：UIView *bg = [[UIView alloc] init];bg.backgroundColor = [UIColor redColor];cell.backgroundView = bg;说明：背景控件 和 背景颜色 同时存在时，(优先级: backgroundView &gt; backgroundColor) 设置cell的背景颜色： 123456789属性：@property(nullable, nonatomic,copy) UIColor *backgroundColor使用格式：cell.backgroundColor = [UIColor blueColor];说明：还可以设置cell的子控件背景图片cell.textLabel.backgroundColor = [UIColor greenColor]; 设置cell选中时背景View： 1234567属性：@property (nonatomic, strong) UIView *selectedBackgroundView;使用格式：UIView *seletedBg = [[UIView alloc] init];seletedBg.backgroundColor = [UIColor purpleColor];cell.selectedBackgroundView = seletedBg; UITableView的代理方法 返回每一行cell的高度： 12345678方法 和 使用格式：- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 获取indexPath// if (indexPath.row%2) &#123;// return 100;// &#125;else return 44;&#125; 当选中某一行cell的时候就会调用这个方法： 1234方法 和 使用格式：- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; NSLog(@"选中第%ld区---第%ld行 ",indexPath.section,indexPath.row);&#125; 返回每一组的区头(区尾) 标题 和 控件： 12345678910111213方法 和 使用格式：// 区头(区尾)标题- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section&#123; return @"简书-白开水ln";&#125;// 区头(区尾)View- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section &#123; return [[UISwitch alloc] init];&#125;说明：标题 和 View 同时存在时，View 会覆盖 Title 返回每一组的头部(尾部)高度： 123456789方法 和 使用格式：- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123; // 获取indexPath NSIndexPath *indexPath = [[NSIndexPath alloc]initWithIndex:section]; if (indexPath.section == 0) &#123; return 60; &#125;else return 30;&#125; 返回右侧索引标题： 12345方法 和 使用格式：-(NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView&#123; //return [self.dataArray valueForKeyPath:@"title"]; return @[@"黄焖鸡小份",@"黄焖鸡中份",@"黄焖鸡大份",];&#125; 返回某一行缩进： 1234方法 和 使用格式：- (NSInteger)tableView:(UITableView *)tableView indentationLevelForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return 7;&#125; UITableViewController的使用 将控制器设置为UITableView的方法和步骤 第一步：创建新的类或修改原有的ViewController类，继承自UITableViewController 第二步：在Main.storyboard中删除自带的UIViewController控制器，然后往里面拖一个UITableViewController控制器 第三步：修改新拖进来的TableViewController控制器的自定义类名为第一步中继承自UITableViewController类的类名 第四步：勾选TableViewController控制器为程序启动第一个加载的控制器 注意点： tableVieController有个tableView属性，指向一个tableView。 tableView的dataSource和delegate属性指向的就是这个控制器，并且这个控制器已经遵守了UITableViewDataSource和UITableViewDelegate。 每个控制器的内部都有一个view属性，在tableVieController中，view和tableView属性指向的是同一个对象（控制器的view就是tableView）。 UITableViewCell的重用 原因： iOS设备的内存有限，如果用 UITableView显示成千上万条数据，就需要成千上万个UITableViewCell对象的话，那将会耗尽iOS设备的内存。 有可能导致显示数据错乱。 原理： 当滚动列表时，部分UITableViewCell会移出窗口，UITableView会将窗口外的UITableViewCell放入一个缓存池中，等待重用 当UITableView要求dataSource返回UITableViewCell时，dataSource会先查看这个对象池，如果池中有未使用的UITableViewCell，dataSource会用新的数据配置这个UITableViewCell，然后返回给UITableView，重新显示到窗口中，从而避免创建新的UITableViewCell对象 Cell重用的实现代码 方法一： 1.定义一个cell的重用标识 2.根据这个ID去缓存池中看有没有可循环利用的cell 3.如果缓存池中没有可循环利用的cell，自己创建 123456789101112- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 1. 定义一个重用标识 static NSString *cellID = @"cellID"; // 2. 根据这个cellID去缓存池中看有没有可循环利用的cell UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cellID"]; // 3. 如果缓存池中没有可循环利用的cell, 自己创建 if (cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"cellID"]; &#125; return cell;&#125; 方法二： 1.定义一个cell的重用标识。 2.根据这个ID去缓存池中看有没有可循环利用的cell。 3.如果缓存池中没有会看有没有，根据ID这个标识注册对应的cell类型。 4.如果有注册，会根据这个ID创建对应的类型的cell，并且会绑定这个ID标识，返回这个cell。 12345678910111213141516171819202122// 1. 定义一个重用标识static NSString *cellID = @"CellID";static NSString *testID = @"testID";- (void)viewDidLoad &#123; [super viewDidLoad]; // 3. 根据ID 这个标识 注册 对应的cell类型是UITableViewCell [self.tableView registerClass:[LNTableViewCell class] forCellReuseIdentifier:cellID]; [self.tableView registerNib:[UINib nibWithNibName:NSStringFromClass([LNTableViewXibCell class]) bundle:nil] forCellReuseIdentifier: testID];&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; // 2. 根据这个ID去缓存池中看有没有可循环利用的cell LNTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (indexPath.row%2 == 0) &#123; LNTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier: CellID]; return cell; &#125;else&#123; LNTableViewXibCell *cell = [tableView dequeueReusableCellWithIdentifier:testID]; return cell; &#125;&#125; 总结： 不同类型的Cell共存（重要点是CellID不同）。 UITableViewCell的优化 UITableView 的优化主要从三个方面入手： 1.提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法； 2.异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口； 3.滑动时按需加载，按照用户滚动的速度去选择加载哪个cell。这个在大量图片展示，网络加载的时候很管用！（SDWebImage已经实现异步加载，配合这条性能杠杠的）。 除了上面最主要的三个方面外，还有很多几乎大伙都很熟知的优化点： 1.正确使用reuseIdentifier来重用Cells。 2.尽量使所有的view opaque，包括Cell自身。 3.尽量少用或不用透明图层。 4.如果Cell内显示的内容来自web，使用异步加载，缓存请求结果。 5.减少subviews的数量。 6.在heightForRowAtIndexPath:中尽量不使用。cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果。 7.尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示。 案例（按需加载）： 原理：在快速滑动松手后滚动的cell个数超过预定的个数，只显示最后出现的cell的前三个cell，把这三个cell的indexPath存到数组中，在数据源方法里判断如果数组count&gt;0，且数组不包含当前的indexPath，那就说明此cell是在快速滑动中需要隐藏的： 123456789101112131415161718192021//按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123; NSIndexPath *ip = [_titleTableView indexPathForRowAtPoint:CGPointMake(0, targetContentOffset-&gt;y)]; NSIndexPath *cip = [[_titleTableView indexPathsForVisibleRows] firstObject]; NSInteger skipCount = 1; // 这里我为了方便演示写的1，大家可以按需求自行设定 if (labs(cip.row-ip.row)&gt;skipCount) &#123;// 此方法可以获取将要显示的组// visibleSections = [NSSet setWithArray:[[_titleTableView indexPathsForVisibleRows] valueForKey:@"section"]]; NSArray *temp = [_titleTableView indexPathsForRowsInRect:CGRectMake(0, targetContentOffset-&gt;y, _titleTableView.frame.size.width, _titleTableView.frame.size.height)]; NSMutableArray *arr = [NSMutableArray arrayWithArray:temp]; if (velocity.y&lt;0) &#123; // 上滑 NSIndexPath *indexPath = [temp lastObject]; if (indexPath.row+33) &#123; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-3 inSection:indexPath.section]]; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-2 inSection:indexPath.section]]; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-1 inSection:indexPath.section]]; &#125; &#125; [needLoadArr addObjectsFromArray:arr]; &#125;&#125; 相应的，每次开始拖动的时候去清空数组。还有种情况，如果界面上有显示空白cell的时候突然手动停止滚动呢? 123456789101112- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView &#123; [needLoadArr removeAllObjects]; // 清空数组 // 取到当前界面上能显示的indexPaths，判断是否有隐藏 NSArray *indexpaths = [_titleTableView indexPathsForVisibleRows]; UITableViewCell *firstCell = [_titleTableView cellForRowAtIndexPath:indexpaths.firstObject]; UITableViewCell *lastCell = [_titleTableView cellForRowAtIndexPath:indexpaths.lastObject]; // 在当前可见的区域中，第一个cell或者最后一个cell是隐藏状态，那么重新加载可见区域内的cell if (firstCell.isHidden == true || lastCell.isHidden == true) &#123; [_titleTableView reloadRowsAtIndexPaths:indexpaths withRowAnimation:UITableViewRowAnimationNone]; &#125;&#125;也可以把判断的代码写在scrollView停止滚动监听方法里，但是个人觉得没必要，因为这种情况必定是手动触碰去停止的，这里处理没问题 数据源方法： 12345678 if (needLoadArr.count &gt; 0) &#123; if (![needLoadArr containsObject:indexPath]) &#123;// NSLog(@"该cell是快速滑动中的cell，所以隐藏"); cell.hidden = true; return cell; &#125; &#125; cell.hidden = false; // 正常显示的cell 附上：按需加载参考 VVeboTableViewDemo： 这位前辈在tableView优化上做到了极致。 总结：tableView性能优化的方式有很多，但不是所有的我们都需要。比如不是必需要显示的界面，预先计算行高就是浪费（用户流量）。应适时而定。站在用户体验的角度开发才是好的伐码猿。 UITableView重要属性图解 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage源码2—SDImageCache]]></title>
    <url>%2FSourceAnnotations%2FSDSourceCode2.html</url>
    <content type="text"><![CDATA[Write in the first SDImageCache 是 SDWebImage 的重要部件之一，它是一个单例类，完成了对图片的内存缓存、异步磁盘缓存、图片缓存查询等功能，这也是其优秀性能的原因所在，即下载过的图片将被缓存到内存和本地磁盘，当再次请求相同图片时直接从缓存中提取图片，从而大大提高了加载速度。SDWebImage 的作者对核心方法都做了比较好的注释，这也大大提高了我们的阅读速度。 本篇文章主要从【SDImageCache 缓存器】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 SDWebImage –&gt;知其然亦「知其所以然」我们就直接从 SDImageCache.h 入手吧 SDImageCache.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402/* * This file is part of the SDWebImage package. * (c) Olivier Poitrey &lt;rs@dailymotion.com&gt; * * For the full copyright and license information, please view the LICENSE * file that was distributed with this source code. */#import &lt;Foundation/Foundation.h&gt;#import "SDWebImageCompat.h"//缓存类型的枚举typedef NS_ENUM(NSInteger, SDImageCacheType) &#123; /** * The image wasn't available the SDWebImage caches, but was downloaded from the web. */ SDImageCacheTypeNone, //不使用 SDWebImage 缓存，从网络下载 /** * The image was obtained from the disk cache. */ SDImageCacheTypeDisk, //使用磁盘缓存 /** * The image was obtained from the memory cache. */ SDImageCacheTypeMemory //使用内存缓存&#125;;//定义SDWebImageQueryCompletedBlock块，处理查询回调，参数（图片，缓存类型枚举）typedef void(^SDWebImageQueryCompletedBlock)(UIImage *image, SDImageCacheType cacheType);//定义SDWebImageCheckCacheCompletionBlock块，处理内存缓存检查回调，参数（是否有缓存）typedef void(^SDWebImageCheckCacheCompletionBlock)(BOOL isInCache);//定义SDWebImageCalculateSizeBlock块，处理缓存空间回调，参数（文件大小，总大小）typedef void(^SDWebImageCalculateSizeBlock)(NSUInteger fileCount, NSUInteger totalSize);/** * SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed * asynchronous so it doesn’t add unnecessary latency to the UI. * * SDImageCache 维护一个内存缓存以及一个"可选"的磁盘缓存。磁盘缓存的写入操作是异步执行，因此不会造成 UI 的延迟 */@interface SDImageCache : NSObject/** * Decompressing images that are downloaded and cached can improve performance but can consume lot of memory. * Defaults to YES. Set this to NO if you are experiencing a crash due to excessive memory consumption. * * 解压缩图片能提高性能，但是会占用较大的内存空间。 * 默认为YES，如果你的任务对内存空间敏感，建议设置为NO */@property (assign, nonatomic) BOOL shouldDecompressImages;/** * disable iCloud backup [defaults to YES] * * 禁用iCloud备份,默认为YES */@property (assign, nonatomic) BOOL shouldDisableiCloud;/** * use memory cache [defaults to YES] * * 使用内存缓存，默认为YES */@property (assign, nonatomic) BOOL shouldCacheImagesInMemory;/** * The maximum "total cost" of the in-memory image cache. The cost function is the number of pixels held in memory. * * 内存映像缓存中的最大“总成本”。"成本"是在内存中存储的像素数。成本概念要与NSCache相关 */@property (assign, nonatomic) NSUInteger maxMemoryCost;/** * The maximum number of objects the cache should hold. * * 缓存中可以存放缓存的最大数量，与NSCache相关 */@property (assign, nonatomic) NSUInteger maxMemoryCountLimit;/** * The maximum length of time to keep an image in the cache, in seconds * * 缓存的最长时间，以秒为单位，默认为1周 */@property (assign, nonatomic) NSInteger maxCacheAge;/** * The maximum size of the cache, in bytes. * * 缓存图像总大小，以字节为单位，默认数值为0，表示不作限制 */@property (assign, nonatomic) NSUInteger maxCacheSize;#pragma mark --------------------#pragma mark Methods/** * Returns global shared cache instance * @return SDImageCache global instance * * 单例方法，获得一个全局的缓存实例 */+ (SDImageCache *)sharedImageCache;/** * Init a new cache store with a specific namespace * @param ns The namespace to use for this cache store * * 使用指定的命名空间实例化一个新的缓存存储 * @param ns 缓存存储使用的命名空间 */- (id)initWithNamespace:(NSString *)ns;/** * Init a new cache store with a specific namespace and directory * @param ns The namespace to use for this cache store * @param directory Directory to cache disk images in * * 使用指定的命名空间实例化一个新的缓存存储和目录 * @param ns 缓存存储使用的命名空间 * @param directory 缓存映像所在目录 */- (id)initWithNamespace:(NSString *)ns diskCacheDirectory:(NSString *)directory;//设置磁盘缓存路径-(NSString *)makeDiskCachePath:(NSString*)fullNamespace;/** * Add a read-only cache path to search for images pre-cached by SDImageCache * Useful if you want to bundle pre-loaded images with your app * @param path The path to use for this read-only cache path * * 如果希望在 bundle 中存储预加载的图像，可以添加一个只读的缓存路径 * 让 SDImageCache 从 Bundle 中搜索预先缓存的图像 * @param path 只读缓存路径(mainBundle中的全路径) */- (void)addReadOnlyCachePath:(NSString *)path;/** * Store an image into memory and disk cache at the given key. * * @param image The image to store * @param key The unique image cache key, usually it's image absolute URL * * 使用指定的键将图像保存到内存和磁盘缓存 * * @param image 要保存的图片 * @param key 唯一的图像缓存键，通常是图像的完整 URL */- (void)storeImage:(UIImage *)image forKey:(NSString *)key;/** * Store an image into memory and optionally disk cache at the given key. * * @param image The image to store * @param key The unique image cache key, usually it's image absolute URL * @param toDisk Store the image to disk cache if YES * * 使用指定的键将图像保存到内存和可选的磁盘缓存 * * @param image 要保存的图片 * @param key 唯一的图像缓存键，通常是图像的完整 URL * @param toDisk 如果是 YES，则将图像缓存到磁盘 */- (void)storeImage:(UIImage *)image forKey:(NSString *)key toDisk:(BOOL)toDisk;/** * Store an image into memory and optionally disk cache at the given key. * * @param image The image to store * @param recalculate BOOL indicates if imageData can be used or a new data should be constructed from the UIImage * @param imageData The image data as returned by the server, this representation will be used for disk storage * instead of converting the given image object into a storable/compressed image format in order * to save quality and CPU * @param key The unique image cache key, usually it's image absolute URL * @param toDisk Store the image to disk cache if YES * * 使用指定的键将图像保存到内存和可选的磁盘缓存 * * @param image 要保存的图像 * @param recalculate 是否直接使用 imageData，还是从 UIImage 重新构造数据 * @param imageData 从服务器返回图像的二进制数据，表示直接保存到磁盘 而不是将给定的图像对象转换成一个可存储/可压缩的图像格式，从而保留图片质量并降低 CPU 开销 * @param key 唯一的图像缓存键，通常是图像的完整 URL * @param toDisk 如果是 YES，则将图像缓存到磁盘 */- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk;/** * Query the disk cache asynchronously. * * @param key The unique key used to store the wanted image * * 异步查询磁盘缓存 * * @param key 保存图像的唯一键 * @param doneBlock 查询结束后的回调 */- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock;/** * Query the memory cache synchronously. * * @param key The unique key used to store the wanted image * * 同步查询内存缓存 * * @param key 保存图像的唯一键 */- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key;/** * Query the disk cache synchronously after checking the memory cache. * * @param key The unique key used to store the wanted image * * 查询内存缓存之后同步查询磁盘缓存 * * @param key 保存图像的唯一键 */- (UIImage *)imageFromDiskCacheForKey:(NSString *)key;/** * Remove the image from memory and disk cache synchronously * * @param key The unique image cache key * * 同步从内存和磁盘缓存删除图像 * * @param key 保存图像的唯一键 */- (void)removeImageForKey:(NSString *)key;/** * Remove the image from memory and disk cache asynchronously * * @param key The unique image cache key * @param completion An block that should be executed after the image has been removed (optional) * * 同步从内存和磁盘缓存删除图像 * * @param key 保存图像的唯一键 * @param completion 当图片被删除后会调用该block块 */- (void)removeImageForKey:(NSString *)key withCompletion:(SDWebImageNoParamsBlock)completion;/** * Remove the image from memory and optionally disk cache asynchronously * * @param key The unique image cache key * @param fromDisk Also remove cache entry from disk if YES * * 同步从内存和可选磁盘缓存删除图像 * * @param key 保存图像的唯一键 * @param fromDisk 如果是 YES，则从磁盘删除缓存 */- (void)removeImageForKey:(NSString *)key fromDisk:(BOOL)fromDisk;/** * Remove the image from memory and optionally disk cache asynchronously * * @param key The unique image cache key * @param fromDisk Also remove cache entry from disk if YES * @param completion An block that should be executed after the image has been removed (optional) * * 同步从内存和可选磁盘缓存删除图像 * * @param key 保存图像的唯一键 * @param fromDisk 如果是 YES，则从磁盘删除缓存 * @param completion 当图片被删除后会调用该block块 */- (void)removeImageForKey:(NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(SDWebImageNoParamsBlock)completion;/** * Clear all memory cached images * * 删除所有内存缓存的图像 */- (void)clearMemory;/** * Clear all disk cached images. Non-blocking method - returns immediately. * @param completion An block that should be executed after cache expiration completes (optional) * * 删除所有磁盘缓存的图像。 * @param completion 删除操作后的块代码回调（可选） */- (void)clearDiskOnCompletion:(SDWebImageNoParamsBlock)completion;/** * Clear all disk cached images * @see clearDiskOnCompletion: * * 删除所有磁盘缓存的图像 * @see clearDiskOnCompletion:方法 */- (void)clearDisk;/** * Remove all expired cached image from disk. Non-blocking method - returns immediately. * @param completionBlock An block that should be executed after cache expiration completes (optional) * * 从磁盘中删除所有过期的缓存图像。 * @param completion 删除操作后的块代码回调（可选） */- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock;/** * Remove all expired cached image from disk * @see cleanDiskWithCompletionBlock: * * 从磁盘中删除所有过期的缓存图像 * @see cleanDiskWithCompletionBlock:方法 */- (void)cleanDisk;/** * Get the size used by the disk cache * * 获得磁盘缓存占用空间 */- (NSUInteger)getSize;/** * Get the number of images in the disk cache * * 获得磁盘缓存图像的个数 */- (NSUInteger)getDiskCount;/** * Asynchronously calculate the disk cache's size. * * 异步计算磁盘缓存的大小 */- (void)calculateSizeWithCompletionBlock:(SDWebImageCalculateSizeBlock)completionBlock;/** * Async check if image exists in disk cache already (does not load the image) * * @param key the key describing the url * @param completionBlock the block to be executed when the check is done. * @note the completion block will be always executed on the main queue * * 异步检查图像是否已经在磁盘缓存中存在（不加载图像） * @param key 保存图像的唯一键 * @param completionBlock 当图片被删除后会调用该block块 * @note completionBlock总是在主线程 */- (void)diskImageExistsWithKey:(NSString *)key completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;/** * Check if image exists in disk cache already (does not load the image) * * @param key the key describing the url * * @return YES if an image exists for the given key * * 检查图像是否已经在磁盘缓存中存在（不加载图像） * * @param key 保存图像的唯一键 * @return 如果该图片存在，则返回YES */- (BOOL)diskImageExistsWithKey:(NSString *)key;/** * Get the cache path for a certain key (needs the cache path root folder) * * @param key the key (can be obtained from url using cacheKeyForURL) * @param path the cache path root folder * * @return the cache path * * 获得指定 key 对应的缓存路径(需要指定缓存路径的根目录) * * @param key 键（可以调用cacheKeyForURL方法获得） * @param path 缓存路径根文件夹 */- (NSString *)cachePathForKey:(NSString *)key inPath:(NSString *)path;/** * Get the default cache path for a certain key * * @param key the key (can be obtained from url using cacheKeyForURL) * * @return the default cache path * * 获得指定 key 的默认缓存路径 * * @param key 键（可以调用cacheKeyForURL方法获得） * * @return 默认缓存路径 */- (NSString *)defaultCachePathForKey:(NSString *)key;@end 虽然方法看上去挺多的但其实核心的方法就是对图片缓存的增、删、查的实现，只不过每种功能可能有多种实现方式，但本质上是一样的，我们只需关注核心的几个方法即可。 SDWebImage实现了内存缓存和磁盘缓存，内存缓存是通过NSCache实现，磁盘缓存是通过NSFileManager来实现文件的存储，磁盘缓存是异步实现的。 初始化首先定义了一个继承于NSCache的类AutoPurgeCache，当收到内存警告时，默认清除所有缓存1234567891011121314151617181920212223@interface AutoPurgeCache : NSCache@end@implementation AutoPurgeCache//初始化- (id)init&#123; self = [super init]; if (self) &#123; //监听到UIApplicationDidReceiveMemoryWarningNotification（应用程序发生内存警告）通知后，调用removeAllObjects方法 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(removeAllObjects) name:UIApplicationDidReceiveMemoryWarningNotification object:nil]; &#125; return self;&#125;//移除通知- (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidReceiveMemoryWarningNotification object:nil];&#125;@end 初始化SDImageCache123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//单例类方法，该方法提供一个全局的SDImageCache实例+ (SDImageCache *)sharedImageCache &#123; static dispatch_once_t once; static id instance; dispatch_once(&amp;once, ^&#123; instance = [self new]; &#125;); return instance;&#125;//初始化方法，默认的缓存空间名称为default- (id)init &#123; return [self initWithNamespace:@&quot;default&quot;];&#125;//使用指定的命名空间实例化一个新的缓存存储- (id)initWithNamespace:(NSString *)ns &#123; //根据传入的命名空间设置磁盘缓存路径 NSString *path = [self makeDiskCachePath:ns]; return [self initWithNamespace:ns diskCacheDirectory:path];&#125;//使用指定的命名空间实例化一个新的缓存存储和目录- (id)initWithNamespace:(NSString *)ns diskCacheDirectory:(NSString *)directory &#123; if ((self = [super init])) &#123; //拼接默认的磁盘缓存目录 NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns]; // initialise PNG signature data //初始化PNG数据签名 8字节 kPNGSignatureData = [NSData dataWithBytes:kPNGSignatureBytes length:8]; // Create IO serial queue //创建处理IO操作的串行队列 _ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL); // Init default values //初始化默认的最大缓存时间 == 1周 _maxCacheAge = kDefaultCacheMaxCacheAge; // Init the memory cache //初始化内存缓存，使用NSCache _memCache = [[AutoPurgeCache alloc] init]; _memCache.name = fullNamespace; // Init the disk cache //初始化磁盘缓存，如果磁盘缓存路径不存在则设置为默认值，否则根据命名空间重新设置 if (directory != nil) &#123; _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace]; &#125; else &#123; NSString *path = [self makeDiskCachePath:ns]; _diskCachePath = path; &#125; // Set decompression to YES //设置图片是否解压缩，默认为YES _shouldDecompressImages = YES; // memory cache enabled // 内存缓存是否可用 _shouldCacheImagesInMemory = YES; // Disable iCloud //禁用iCloud备份,默认为YES _shouldDisableiCloud = YES; //同步函数+串行队列：初始化文件管理者 dispatch_sync(_ioQueue, ^&#123; _fileManager = [NSFileManager new]; &#125;);#if TARGET_OS_IPHONE // Subscribe to app events //监听应用程序通知 //当监听到UIApplicationDidReceiveMemoryWarningNotification（系统级内存警告） //调用clearMemory方法,清除内存缓存 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(clearMemory) name:UIApplicationDidReceiveMemoryWarningNotification object:nil]; //当监听到UIApplicationWillTerminateNotification（程序将终止） //调用cleanDisk方法,清理过期(默认大于一周)的磁盘缓存 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(cleanDisk) name:UIApplicationWillTerminateNotification object:nil]; //当监听到UIApplicationDidEnterBackgroundNotification（进入后台） //调用backgroundCleanDisk方法,清理过期磁盘缓存 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backgroundCleanDisk) name:UIApplicationDidEnterBackgroundNotification object:nil];#endif &#125; return self;&#125;//移除通知- (void)dealloc &#123; [[NSNotificationCenter defaultCenter] removeObserver:self]; SDDispatchQueueRelease(_ioQueue);&#125; 以上就是SDImageCache的初始化过程，主要是初始化内存缓存对象以及初始化磁盘缓存目录，以及对一些默认参数的赋值。 缓存图片虽然SDImageCache有多个存储图片的方法，但都是基于下面这一个方法并传入不同的参数而已：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//使用指定的键将图像保存到内存和可选的磁盘缓存- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk &#123; //如果图片或对应的key为空，那么就直接返回 if (!image || !key) &#123; return; &#125; // if memory cache is enabled //如果内存缓存可用 if (self.shouldCacheImagesInMemory) &#123; //计算该图片的『成本』 NSUInteger cost = SDCacheCostForImage(image); //把该图片保存到内存缓存中 [self.memCache setObject:image forKey:key cost:cost]; &#125; //判断是否需要沙盒缓存 if (toDisk) &#123; //异步函数+串行队列：开子线程异步处理block中的任务 dispatch_async(self.ioQueue, ^&#123; //拿到服务器返回的图片二进制数据 NSData *data = imageData; //如果图片存在且（直接使用imageData||imageData为空） if (image &amp;&amp; (recalculate || !data)) &#123;#if TARGET_OS_IPHONE // We need to determine if the image is a PNG or a JPEG // PNGs are easier to detect because they have a unique signature (http://www.w3.org/TR/PNG-Structure.html) // The first eight bytes of a PNG file always contain the following (decimal) values: // 137 80 78 71 13 10 26 10 // If the imageData is nil (i.e. if trying to save a UIImage directly or the image was transformed on download) // and the image has an alpha channel, we will consider it PNG to avoid losing the transparency //获得该图片的alpha信息 int alphaInfo = CGImageGetAlphaInfo(image.CGImage); BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone || alphaInfo == kCGImageAlphaNoneSkipFirst || alphaInfo == kCGImageAlphaNoneSkipLast); //判断该图片是否是PNG图片 BOOL imageIsPng = hasAlpha; // But if we have an image data, we will look at the preffix if ([imageData length] &gt;= [kPNGSignatureData length]) &#123; imageIsPng = ImageDataHasPNGPreffix(imageData); &#125; //如果判定是PNG图片，那么把图片转变为NSData压缩 if (imageIsPng) &#123; data = UIImagePNGRepresentation(image); &#125; else &#123; //否则采用JPEG的方式 data = UIImageJPEGRepresentation(image, (CGFloat)1.0); &#125;#else data = [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];#endif &#125; if (data) &#123; //确定_diskCachePath路径是否有效，如果无效则创建 if (![_fileManager fileExistsAtPath:_diskCachePath]) &#123; [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL]; &#125; // get cache Path for image key // 根据key获得缓存路径 NSString *cachePathForKey = [self defaultCachePathForKey:key]; // transform to NSUrl //把路径转换为NSURL类型 NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey]; //使用文件管理者在缓存路径创建文件，并设置数据 [_fileManager createFileAtPath:cachePathForKey contents:data attributes:nil]; // disable iCloud backup //如果禁用了iCloud备份 if (self.shouldDisableiCloud) &#123; //标记沙盒中不备份文件（标记该文件不备份） [fileURL setResourceValue:[NSNumber numberWithBool:YES] forKey:NSURLIsExcludedFromBackupKey error:nil]; &#125; &#125; &#125;); &#125;&#125;//使用指定的键将图像保存到内存和磁盘缓存- (void)storeImage:(UIImage *)image forKey:(NSString *)key &#123; [self storeImage:image recalculateFromImage:YES imageData:nil forKey:key toDisk:YES];&#125;//使用指定的键将图像保存到内存和可选的磁盘缓存- (void)storeImage:(UIImage *)image forKey:(NSString *)key toDisk:(BOOL)toDisk &#123; [self storeImage:image recalculateFromImage:YES imageData:nil forKey:key toDisk:toDisk];&#125; 至此，图片缓存的过程就完成了，这时候在沙盒Library/Cache/目录下就会有一份图片的缓存。下面看一下查询图片的接口，查询内存缓存的接口比较简单，只需要一句话1234//获取该key对应的图片缓存数据- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key &#123; return [self.memCache objectForKey:key];&#125; 看一下查询磁盘缓存的接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//检查要下载图片的缓存情况/* 1.先检查是否有内存缓存 2.如果没有内存缓存则检查是否有沙盒缓存 3.如果有沙盒缓存，则把该图片做内存缓存并处理doneBlock回调 */- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123; //如果回调不存在，则直接返回 if (!doneBlock) &#123; return nil; &#125; //如果缓存对应的key为空，则直接返回，并把存储方式（无缓存）通过block块以参数的形式传递 if (!key) &#123; doneBlock(nil, SDImageCacheTypeNone); return nil; &#125; // First check the in-memory cache... //检查该KEY对应的内存缓存，如果存在内存缓存，则直接返回，并把图片和存储方式（内存缓存）通过block块以参数的形式传递 UIImage *image = [self imageFromMemoryCacheForKey:key]; if (image) &#123; doneBlock(image, SDImageCacheTypeMemory); return nil; &#125; NSOperation *operation = [NSOperation new]; //创建一个操作 //使用异步函数，添加任务到串行队列中（会开启一个子线程处理block块中的任务） dispatch_async(self.ioQueue, ^&#123; //如果当前的操作被取消，则直接返回 if (operation.isCancelled) &#123; return; &#125; @autoreleasepool &#123; //检查该KEY对应的磁盘缓存 UIImage *diskImage = [self diskImageForKey:key]; //如果存在磁盘缓存，且应该把该图片保存一份到内存缓存中，则先计算该图片的cost(成本）并把该图片保存到内存缓存中 if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123; NSUInteger cost = SDCacheCostForImage(diskImage); [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; //线程间通信，在主线程中回调doneBlock，并把图片和存储方式（磁盘缓存）通过block块以参数的形式传递 dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, SDImageCacheTypeDisk); &#125;); &#125; &#125;); return operation;&#125; 磁盘查询也是非常简单的，至于这个接口为什么返回一个NSOperation对象，我们在单独讲SDWebImageManager时再说。再来看一下清理缓存的接口，分两种情况， 一种是clearDisk一种是cleanDisk。clearDisk比较暴力，直接移除内存缓存的对象或者直接移除磁盘缓存文件夹。 1234567891011121314151617181920212223242526272829303132//清除内存缓存- (void)clearMemory &#123; //把所有的内存缓存都删除 [self.memCache removeAllObjects];&#125;//清除磁盘缓存- (void)clearDisk &#123; [self clearDiskOnCompletion:nil];&#125;//清除磁盘缓存（简单粗暴）- (void)clearDiskOnCompletion:(SDWebImageNoParamsBlock)completion&#123; //开子线程异步处理 清理磁盘缓存的操作 dispatch_async(self.ioQueue, ^&#123; //删除缓存路径 [_fileManager removeItemAtPath:self.diskCachePath error:nil]; //重新创建缓存路径 [_fileManager createDirectoryAtPath:self.diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL]; if (completion) &#123; //在主线程中处理completion回调 dispatch_async(dispatch_get_main_queue(), ^&#123; completion(); &#125;); &#125; &#125;);&#125; 着重看一下cleanDisk： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//清除过期的磁盘缓存- (void)cleanDisk &#123; [self cleanDiskWithCompletionBlock:nil];&#125;//清除过期的磁盘缓存- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &#123; dispatch_async(self.ioQueue, ^&#123; NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES]; NSArray *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey]; // This enumerator prefetches useful properties for our cache files. NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL includingPropertiesForKeys:resourceKeys options:NSDirectoryEnumerationSkipsHiddenFiles errorHandler:NULL]; // 计算过期日期 NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.maxCacheAge]; NSMutableDictionary *cacheFiles = [NSMutableDictionary dictionary]; NSUInteger currentCacheSize = 0; // Enumerate all of the files in the cache directory. This loop has two purposes: // // 1. Removing files that are older than the expiration date. // 2. Storing file attributes for the size-based cleanup pass. // 遍历缓存路径中的所有文件，此循环要实现两个目的 // 1. 删除早于过期日期的文件 // 2. 保存文件属性以计算磁盘缓存占用空间 NSMutableArray *urlsToDelete = [[NSMutableArray alloc] init]; for (NSURL *fileURL in fileEnumerator) &#123; NSDictionary *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:NULL]; // Skip directories. // 跳过目录 if ([resourceValues[NSURLIsDirectoryKey] boolValue]) &#123; continue; &#125; // Remove files that are older than the expiration date; // 记录要删除的过期文件 NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey]; if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123; [urlsToDelete addObject:fileURL]; continue; &#125; // Store a reference to this file and account for its total size. //保存文件引用，以计算总大小 NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey]; currentCacheSize += [totalAllocatedSize unsignedIntegerValue]; [cacheFiles setObject:resourceValues forKey:fileURL]; &#125; // 删除过期的文件 for (NSURL *fileURL in urlsToDelete) &#123; [_fileManager removeItemAtURL:fileURL error:nil]; &#125; // If our remaining disk cache exceeds a configured maximum size, perform a second // size-based cleanup pass. We delete the oldest files first. //如果剩余磁盘缓存空间超出最大限额，再次执行清理操作，删除最早的文件 if (self.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.maxCacheSize) &#123; // Target half of our maximum cache size for this cleanup pass. const NSUInteger desiredCacheSize = self.maxCacheSize / 2; // Sort the remaining cache files by their last modification time (oldest first). NSArray *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent usingComparator:^NSComparisonResult(id obj1, id obj2) &#123; return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]]; &#125;]; // Delete files until we fall below our desired cache size. // 循环依次删除文件，直到低于期望的缓存限额 for (NSURL *fileURL in sortedFiles) &#123; if ([_fileManager removeItemAtURL:fileURL error:nil]) &#123; NSDictionary *resourceValues = cacheFiles[fileURL]; NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey]; currentCacheSize -= [totalAllocatedSize unsignedIntegerValue]; if (currentCacheSize &lt; desiredCacheSize) &#123; break; &#125; &#125; &#125; &#125; //在主线程中处理完成回调 if (completionBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(); &#125;); &#125; &#125;);&#125; SDImageCache.m 中其它方法:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314//默认的最大缓存时间为1周static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week// PNG signature bytes and data (below)// PNG 签名字节和数据(PNG文件开始的8个字节是固定的)static unsigned char kPNGSignatureBytes[8] = &#123;0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A&#125;;static NSData *kPNGSignatureData = nil;BOOL ImageDataHasPNGPreffix(NSData *data);BOOL ImageDataHasPNGPreffix(NSData *data) &#123; //计算PNG签名数据的长度 NSUInteger pngSignatureLength = [kPNGSignatureData length]; //比较传入数据和PNG签名数据的长度，如果比签名数据长度更长，那么就只比较前面几个字节 if ([data length] &gt;= pngSignatureLength) &#123; if ([[data subdataWithRange:NSMakeRange(0, pngSignatureLength)] isEqualToData:kPNGSignatureData]) &#123; //比较前面的字节，如果内容一样则判定该图片是PNG格式的 return YES; &#125; &#125; return NO;&#125;//计算图片成本？FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *image) &#123; return image.size.height * image.size.width * image.scale * image.scale;&#125;#pragma mark --------------------#pragma mark SDImageCache@interface SDImageCache ()@property (strong, nonatomic) NSCache *memCache; //内存缓存@property (strong, nonatomic) NSString *diskCachePath; //磁盘缓存路径@property (strong, nonatomic) NSMutableArray *customPaths; //自定义路径（数组）@property (SDDispatchQueueSetterSementics, nonatomic) dispatch_queue_t ioQueue; //处理IO操作的队列@end@implementation SDImageCache &#123; NSFileManager *_fileManager; //文件管理者&#125;/* * 如果希望在 bundle 中存储预加载的图像，可以添加一个只读的缓存路径 * 让 SDImageCache 从 Bundle 中搜索预先缓存的图像 * 只读缓存路径(mainBundle中的全路径)*/- (void)addReadOnlyCachePath:(NSString *)path &#123; if (!self.customPaths) &#123; self.customPaths = [NSMutableArray new]; &#125; if (![self.customPaths containsObject:path]) &#123; [self.customPaths addObject:path]; &#125;&#125;//获得指定 key 对应的缓存路径- (NSString *)cachePathForKey:(NSString *)key inPath:(NSString *)path &#123; //获得缓存文件的名称 NSString *filename = [self cachedFileNameForKey:key]; //返回拼接后的全路径 return [path stringByAppendingPathComponent:filename];&#125;//获得指定 key 的默认缓存路径- (NSString *)defaultCachePathForKey:(NSString *)key &#123; return [self cachePathForKey:key inPath:self.diskCachePath];&#125;#pragma mark --------------------#pragma mark SDImageCache (private)//对key(通常为URL)进行MD5加密，加密后的密文作为图片的名称- (NSString *)cachedFileNameForKey:(NSString *)key &#123; const char *str = [key UTF8String]; if (str == NULL) &#123; str = ""; &#125; unsigned char r[CC_MD5_DIGEST_LENGTH]; CC_MD5(str, (CC_LONG)strlen(str), r); NSString *filename = [NSString stringWithFormat:@"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@", r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15], [[key pathExtension] isEqualToString:@""] ? @"" : [NSString stringWithFormat:@".%@", [key pathExtension]]]; return filename;&#125;#pragma mark --------------------#pragma mark SDImageCache// Init the disk cache//设置磁盘缓存路径-(NSString *)makeDiskCachePath:(NSString*)fullNamespace&#123; //获得caches路径，该框架内部对图片进行磁盘缓存，设置的缓存目录为沙盒中Library的caches目录下 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); //在caches目录下，新建一个名为【fullNamespace】的文件，沙盒缓存就保存在此处 return [paths[0] stringByAppendingPathComponent:fullNamespace];&#125;//异步检查图像是否已经在磁盘缓存中存在（不加载图像）- (BOOL)diskImageExistsWithKey:(NSString *)key &#123; //初始设置为NO BOOL exists = NO; // this is an exception to access the filemanager on another queue than ioQueue, but we are using the shared instance // from apple docs on NSFileManager: The methods of the shared NSFileManager object can be called from multiple threads safely. // 共享的 NSFileManager 对象可以保证在多线程运行时是安全的 // 检查文件是否存在 exists = [[NSFileManager defaultManager] fileExistsAtPath:[self defaultCachePathForKey:key]]; return exists;&#125;//异步检查图像是否已经在磁盘缓存中存在（不加载图像）- (void)diskImageExistsWithKey:(NSString *)key completion:(SDWebImageCheckCacheCompletionBlock)completionBlock &#123; //开子线程异步检查文件是否存在 dispatch_async(_ioQueue, ^&#123; BOOL exists = [_fileManager fileExistsAtPath:[self defaultCachePathForKey:key]]; if (completionBlock) &#123; //在主线程回调completionBlock块 dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(exists); &#125;); &#125; &#125;);&#125;//查询内存缓存之后同步查询磁盘缓存- (UIImage *)imageFromDiskCacheForKey:(NSString *)key &#123; // First check the in-memory cache.. //首先检查内存缓存，如果存在则直接返回 UIImage *image = [self imageFromMemoryCacheForKey:key]; if (image) &#123; return image; &#125; // Second check the disk cache... //接下来检查磁盘缓存，如果图片存在，且可以保存到内存缓存，则保存一份到内存缓存中 UIImage *diskImage = [self diskImageForKey:key]; if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123; NSUInteger cost = SDCacheCostForImage(diskImage); [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; //返回图片 return diskImage;&#125;- (NSData *)diskImageDataBySearchingAllPathsForKey:(NSString *)key &#123; //获得给key对应的默认的缓存路径 NSString *defaultPath = [self defaultCachePathForKey:key]; //加载该路径下面的二进制数据 NSData *data = [NSData dataWithContentsOfFile:defaultPath]; //如果有值，则直接返回 if (data) &#123; return data; &#125; NSArray *customPaths = [self.customPaths copy]; //遍历customPaths，若有值，则直接返回 for (NSString *path in customPaths) &#123; NSString *filePath = [self cachePathForKey:key inPath:path]; NSData *imageData = [NSData dataWithContentsOfFile:filePath]; if (imageData) &#123; return imageData; &#125; &#125; return nil;&#125;//获取KEY对应的磁盘缓存，如果不存在则直接返回nil- (UIImage *)diskImageForKey:(NSString *)key &#123; //得到二进制数据 NSData *data = [self diskImageDataBySearchingAllPathsForKey:key]; if (data) &#123; //把对应的二进制数据转换为图片 UIImage *image = [UIImage sd_imageWithData:data]; //处理图片的缩放 image = [self scaledImageForKey:key image:image]; //判断是否需要解压缩（解码）并进行相应的处理 if (self.shouldDecompressImages) &#123; image = [UIImage decodedImageWithImage:image]; &#125; //返回图片 return image; &#125; else &#123; return nil; &#125;&#125;//处理图片的缩放等，2倍尺寸|3倍尺寸？- (UIImage *)scaledImageForKey:(NSString *)key image:(UIImage *)image &#123; return SDScaledImageForKey(key, image);&#125;//设置内存缓存（NSCache）能保存的最大成本- (void)setMaxMemoryCost:(NSUInteger)maxMemoryCost &#123; self.memCache.totalCostLimit = maxMemoryCost;&#125;//最大内存缓存成本- (NSUInteger)maxMemoryCost &#123; return self.memCache.totalCostLimit;&#125;//最大缓存的文件数量- (NSUInteger)maxMemoryCountLimit &#123; return self.memCache.countLimit;&#125;//设置内存缓存（NSCache）的最大文件数量- (void)setMaxMemoryCountLimit:(NSUInteger)maxCountLimit &#123; self.memCache.countLimit = maxCountLimit;&#125;//当进入后台后，处理的磁盘缓存清理工作- (void)backgroundCleanDisk &#123; Class UIApplicationClass = NSClassFromString(@"UIApplication"); if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123; return; &#125; //得到UIApplication单例对象 UIApplication *application = [UIApplication performSelector:@selector(sharedApplication)]; __block UIBackgroundTaskIdentifier bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123; // Clean up any unfinished task business by marking where you // stopped or ending the task outright. // 清理任何未完成的任务 [application endBackgroundTask:bgTask]; bgTask = UIBackgroundTaskInvalid; &#125;]; // Start the long-running task and return immediately. // 启动长期运行的任务，并立即返回 [self cleanDiskWithCompletionBlock:^&#123; [application endBackgroundTask:bgTask]; bgTask = UIBackgroundTaskInvalid; &#125;];&#125;//获得大小- (NSUInteger)getSize &#123; __block NSUInteger size = 0; //同步+串行队列 dispatch_sync(self.ioQueue, ^&#123; //得到diskCachePath路径下面的所有子路径 NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath]; //遍历得到所有子路径对应文件的大小，并累加以计算所有文件的总大小 for (NSString *fileName in fileEnumerator) &#123; NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName]; NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil]; size += [attrs fileSize]; &#125; &#125;); return size;&#125;//获得磁盘文件的数量- (NSUInteger)getDiskCount &#123; //初始化为0 __block NSUInteger count = 0; dispatch_sync(self.ioQueue, ^&#123; //根据计算该路径下面的子路径的数量得到 NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath]; count = [[fileEnumerator allObjects] count]; &#125;); return count;&#125;//异步计算磁盘缓存的大小- (void)calculateSizeWithCompletionBlock:(SDWebImageCalculateSizeBlock)completionBlock &#123; //把文件路径转换为URL NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES]; //开子线程异步处理block块中的任务 dispatch_async(self.ioQueue, ^&#123; NSUInteger fileCount = 0; //初始化文件的数量为0 NSUInteger totalSize = 0; //初始化缓存的总大小为0 NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL includingPropertiesForKeys:@[NSFileSize] options:NSDirectoryEnumerationSkipsHiddenFiles errorHandler:NULL]; for (NSURL *fileURL in fileEnumerator) &#123; NSNumber *fileSize; [fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:NULL]; //累加缓存的大小 totalSize += [fileSize unsignedIntegerValue]; //累加缓存的数量 fileCount += 1; &#125; if (completionBlock) &#123; //在主线程中处理completionBlock回调 dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(fileCount, totalSize); &#125;); &#125; &#125;);&#125;@end SDWebImage –&gt;「知其然」亦知其所以然下载图片的核心方法使用#import &quot;UIImageView+WebCache.h&quot;1234567891011121314151617181920212223242526272829303132333435363738/* * 根据图片的url下载图片并设置到ImageView上面去，异步下载并缓存 * * @param url 图片的URL地址 * @param options 图片下载选项（策略）,参考SDWebImageOptions的枚举值 * @param progressBlock 下载进度回调 * receivedSize 已经下载的数据大小 * expectedSize 要下载图片的总大小 * @param completedBlock 操作成功回调回调,该回调没有返回值 * Image：请求的 UIImage，如果出现错误，image参数是nil * error：如果图片下载成功则error为nil,否则error有值 * @param cacheType：图片缓存类型（内存缓存|沙盒缓存|直接下载）,SDImageCacheType枚举 * SDImageCacheTypeNone：从网络下载 * SDImageCacheTypeDisk：从本地缓存加载 * SDImageCacheTypeMemory：从内存缓存加载 * @param imageURL：图片的URL地址 */- (void)download1 &#123; [self.imageView sd_setImageWithURL:[NSURL URLWithString:@"http://img4.duitang.com/uploads/blog/201310/18/20131018213446_smUw4.thumb.600_0.jpeg"] placeholderImage:[UIImage imageNamed:@"placeholder"] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; NSLog(@"%f",1.0 * receivedSize / expectedSize); &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123; self.imageView.image = image; NSLog(@"download3--%@",[NSThread currentThread]); switch (cacheType) &#123; case SDImageCacheTypeNone: NSLog(@"网络下载"); break; case SDImageCacheTypeDisk: NSLog(@"使用磁盘缓存"); break; case SDImageCacheTypeMemory: NSLog(@"使用内存缓存"); break; default: break; &#125; &#125;];&#125; 打印输出效果: 应用场景:下载图片且需要获取下载进度，该方法会自动做 内存缓存&amp;磁盘缓存。 这个框架有太多的东西值得我们去学习推敲，方方面面都透露着作者以及众多贡献者的智慧，我们读起来也一定会受益良多。 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 源代码管理「SVN & Git」续更]]></title>
    <url>%2FToolsAndPlugins%2FSVNGit.html</url>
    <content type="text"><![CDATA[Write in the first 开发过程中离不开源代码的管理，目地：为了解决在软件开发过程中，由源代码引发的各种蛋疼、繁琐的问题。目前开发使用较广的 版本控制系统「Git &amp; SVN」，后续会单开一篇总结正在使用的【强大的 Git 客户端：SourceTree】。 本篇文章主要从使用者角度【Git &amp; SVN 详解使用】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： 源代码管理认知 源代码管理 SVN 详解使用 SVN 基础知识概念2.SVN 客户端实用命令3.SVN 客户端实用示例4.「SVN–&gt;branch &amp; tag」分支和标签5.SVN ST 显示的文件状态 源代码管理 Git 详解使用1.Git基础知识概念2.Git 几个核心概念3.Git 工作原理 / 流程4.Git 客户端实用命令5.「Git–&gt;branch &amp; tag &amp; remote」分支、标签和远程6.Git 客户端实用示例 SVN &amp; Git 两者比较 码农们踩过的坑整理（持续~） 源代码管理认知 下面简单几点总结，来给初学者快速对源代码管理有个认知； 为什么会出现源代码管理工具 ？ 为了解决在软件开发过程中，由源代码引发的各种蛋疼、繁琐的问题。 源代码会引发哪些问题 ？ 无法后悔：做错了一个操作后，某些情况下无法返回，没有后悔药可以吃。 版本备份：费空间、费时间。 版本混乱：因版本备份过多造成混乱，难于找回正确的想要的版本。 代码冲突：多人操作同一个文件（团队开发中的常见问题）。 权限控制：无法对源代码进行精确的权限控制。 追究责任：出现了严重的 BUG，无法定位到负责人，容易耍赖。 源代码管理工具的作用是 ？ 能追踪一个项目从诞生一直到定案的过程。 记录一个项目的所有内容变化。 方便地查阅特定版本的修订情况。 温馨提示： 如果是团队开发，使用源代码管理工具是强制性的！ 如果是单人开发，也强烈建议现在就开始使用源代码管理工具。 源代码管理 SVN 详解使用 基础知识概念 SVN是集中式控制系统，需要一个中央服务器。 Repository 代码仓库，保存代码的仓库。 Server 服务器，保存所有版本的代码仓库。 Client 客户端，只保存当前用户的代码仓库。 用户名&amp;密码 访问代码仓库需要使用自己的 “用户名和密码”，从而可以区分出不同的人对代码做的修改。 SVN 客户端实用命令 svn checkout「简写svn co」：将服务器上最新的代码仓库下载到本地（只需要做一次）。 svn update「简写svn up」：从服务器上将其他人所做的修改下载到本地 （每天上班必须要做的事情）。 svn commit「简写svn ci」：将改动的文件提交到服务器（每天下班之前至少做一次）。 svn add：向本地的版本控制库中添加新文件。 svn delete、svn remove「简写svn del、svn rm」：从本地的版本控制库中删除文件。 svn move：移动文件或者目录或文件更名 svn mkdir：创建纳入版本控制下的新目录 svn revert：撤销之前的一切修改 svn merge：将两个版本之间的差异合并到当前文件 svn info：查看文件的详细信息。 svn diff：查看不同版本的区别。 svn log：查看日志信息。 svn list：列出版本库下的文件和目录列表。 svn status「简写svn st」：查看文件状态。 svn help：获取帮助信息（比如 svn help ci）。 svn lock：加锁。 svn unlock：解锁。 SVN 客户端实用示例检出： 去到公司的第一天，将项目检出（下载）至本地。svn checkout URL[PATH]svn co URL[PATH] 注意： 这里的中括号[ ]代表可选（可以省略）。 URL：代码仓库的远程地址。 [PATH]：将代码下载到本地的哪个路径（如果省略本地的路径，就下载到命令行当前所在的路径）。 提交： 将改动过的旧文件提交至服务器。svn commit-m &quot;注释&quot;[PATH]svn ci-m &quot;注释&quot;[PATH] 注意： 一定要养成写注释的良好习惯。 “注释”：”修改了User.m文件”。 [PATH]：代表是 提交哪个文件到服务器（如果省略路径，就将命令行所在路径中所有改动过的文件提交到服务器）。 添加： 提交一个新建的文件到服务器，需要2个步骤。 添加新建的文件到本地的版本控制库中：svn add。 提交刚才的添加操作到服务器：svn commit。 将文件添加到本地的版本控制库。svn add PATH PATH：代表是 添加哪个文件到版本控制库中。 删除： 删除服务器上的某个旧文件，需要做2个步骤。 将文件从本地的版本控制库中移除：svn delete、svn remove。 提交刚才的删除操作到服务器：svn commit。 将文件从本地的版本控制库中移除。svn delete PATH PATH：代表是 将哪个文件从版本控制库中移除。 更新： 将服务器上其他同事提交的，最新代码更新到本地。svn update [PATH] PATH：代表是 更新哪个文件的内容（如果省略路径，就更新命令行所在路径的所有内容）。 回滚： 改动没有被提交。这种情况下，使用svn revert就能取消之前的修改。当为单个文件时，直接svn revert 文件就行了；当为目录时，需要加上参数-r (Recursive,递归)，否则只会将改文件这个目录的改动。 改动已经被提交。这种情况下，用svn merge命令来进行回滚。先运行svn up保证拿到最新的版本，然后svn log查看并找到要回滚的版本号，如果想要更详细的了解情况，可以使用svn diff -r HEAD:2500 [文件]（回滚到版本号2500），此处的 [ ] 可以是文件、目录或整个项目。 「SVN–&gt;branch &amp; tag」分支和标签 SVN 官方推荐在一个版本库的根目录下先建立trunk、branches、tags这三个文件夹，其中 trunk 是开发主干，存放日常开发的内容；branches 存放各分支的内容，比如为不同客户定制的不同版本；tags 存放某个版本状态的标签。branhces和tags本质没有区别，都是通过svn copy方式建立的，差异在于通常branches中的内容是需要继续修改或开发的，tags中的内容是存放不再修改的，这一般通过权限设置来解决，tags通常只给管理员开放写权限。 12345678910111213141516171.新建分支svn copy master_repository_url branch_repository_url -m "your comments"2.新建空白分支svn mkdir branch_repository_url3.删除分支svn rm branch_repository_url -m "your comments"4.新建tagsvn copy master_repository_url tag_repository_url -m "your comments"5.删除tagsvn rm tag_repository_url -m "your comments"6.查看branchessvn ls ^/branches --verbose 分支与主干的合并：1234567891011121314151617181920# 分支合到主干 cd trunksvn merge -r &lt;revision where branch was cut&gt;:&lt;revision of trunk&gt; svn://branch/path# 分支当前版本为4847，想把4825到4847间的改动merge到主干# cd trunksvn merge -r 4825:4847 svn://branch/pathsvn ci -m "merge branch changes r4835:4847 into trunk"# 主干合到分支 cd branch# 在r23创建了一个分支，trunk版本号更新到了25，想把23-25之间的改动merge到分支svn merge -r 23:25 svn://trunk/pathsvn ci -m "merge trunk changes r23:25 into my branch"# cd trunk# 查看当前Branch中已经有那些改动已经被合并到Trunk中svn mergeinfo svn://branch/path# cd trunk# 查看Branch中那些改动还未合并svn merginfo svn://branch/path --show-revs eligible merge分支B到分支A12345step1: Checkout URL A # cd branch Astep2: merge URL B to your working copy of A svn merge -r 10:HEAD http://branch-b .step3: Commit A 冲突提示123456(p) postpone 暂时推后处理，我可能要和那个和我冲突的家伙商量一番(df) diff-full 把所有的修改列出来，比比看(e) edit 直接编辑冲突的文件(mc) mine-conflict 如果你很有自信可以只用你的修改，把别人的修改干掉(tc) theirs-conflict 底气不足，还是用别人修改的吧(s) show all options 显示其他可用的命令 SVN ST 显示的文件状态 &#39; &#39; 没有修改。 A 被添加到本地代码仓库。 C 冲突。 D 被删除。 I 被忽略。 M 被修改。 R 被替换。 X 外部定义创建的版本目录。 ? 文件没有被添加到本地版本库内。 ! 文件丢失或者不完整（不是通过svn命令删除的文件）。 ~ 受控文件被其他文件阻隔。 U 服务器收到文件更新了 G 本地文件以及服务器文件都已更新,而且成功的合并了 源代码管理 Git 详解使用 基础知识概念 git是一款开源的分布式版本控制工具。 在世界上所有的分布式版本控制工具中，git是最快、最简单、最流行的。 作者是Linux之父：Linus Benedict Torvalds。 当初开发git仅仅是为了辅助Linux内核的开发（管理源代码）。 Git 几个核心概念 工作区（Working Directory）：仓库文件夹里除.git目录以外的内容。 版本库（Repository）：.git目录，用于存储记录版本信息。 暂存区（stage） 分支（master）：git自动创建的第一个分支。 HEAD指针：用于指向当前分支。 Git 工作原理 / 流程 git add：将工作区文件修改添加到暂存区。 git commit：将暂存区的所有内容提交到当前分支（提交区）。 git push：将提交区内容 推送到服务器上。 git pull：从服务器上更新文件。 Git 客户端实用命令 1.git clone：从服务器上克隆(下载)最新的代码到本地。 2.git init：初始化本地仓库(在当前目录新建代码库)，也可以 git init Desktop/GitCode(在指定位置创建代码库) ，如果使用了git clone不用使用此命令。 3.git config：配置用户名和邮箱。 12345678910git config --global user.name "GO_ln"git config --global user.email "xxx @xx.com"``` - 4.`add`：将工作区的文件提交到暂存区。```objc// 添加指定文件git add GitTest/GitTest/ViewController.m// 添加本地库所有文件git add . 5.git commit：提交信息。 123456781.git commit -m 将暂存区的内容提交到提交区// 提交所有git commit -m "日志"// 提交某一个文件git commit GitTest/GitTest/ViewController.m -m"修改VC"2.把工作区中的内容提交到暂存区并从暂存区中提交到提交区git commit -am “提交信息” 6.git status：查看当前 git 的状态。 7.git push：将提交区内容 推送到服务器上。 8.checkout：撤销某次提交的某个文件。 1git checkout 8989920311bacb3f4e3ced7f82ab75ca47c318c7 GitTest/GitTest/ViewController.m 9.revert：撤销某一次提交。 1git revert 8989920311bacb3f4e3ced7f82ab75ca47c318c7 10.checkout HEAD：放弃本地某一文件的修改。 1git checkout HEAD GitTest/GitTest/ViewController.m 11.git reset：回退到某个版本并保存未追踪的改动。(通过log来查询) 1git reset 8989920311bacb3f4e3ced7f82ab75ca47c318c7 12.git reset --hard HEAD：放弃本地全部修改。 13.git reset --keep：回退到某个版本并保存未提交的改动。 1git reset --keep 8989920311bacb3f4e3ced7f82ab75ca47c318c7 14.log：查看提交日志。 15.git show：查看每次提交的具体内容。 16.diff：查看追踪文件的差异。 1234// 查看追踪文件的差异git diff// 查看某一文件的差异git diff GitTest/GitTest/ViewController.m 17.rm：删除文件。 1git rm GitTest/GitTest/ViewController.m 18.mv：修改某一个文件的名字。 12// 注意，路径要对应，否则会自动移动git mv GitTest/GitTest/ViewController.m GitTest/GitTest/View.m 19.blame：查看文件被谁修改。 1git blame GitTest/GitTest/ViewController.m 「Git–&gt;branch &amp; tag &amp; remote」分支、标签和远程 branch：分支。 12345678910111213141516171819202122232425262728293031// 查看本地分支git branch// 查看远程分支git branch -r// 查看远程和本地分支git branch -a// 创建本地分支，但是不切换git branch branch1// 新建一个分支并切换git checkout -b branch2// 新建一个分支，指向指定commitgit branch branch3 8989920311bacb3f4e3ced7f82ab75ca47c318c7// 新建一个分支，与指定的远程分支建立追踪关系git branch --track branch4 origin/master// 切换到指定分支，并更新工作区git checkout branch4// 切换到上一个分支git checkout -// 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream branch3 origin/master// 合并指定分支到当前分支git merge branch2// 选择一个commit，合并进当前分支git cherry-pick 8989920311bacb3f4e3ced7f82ab75ca47c318c7// 删除分支git branch -d branch1// 删除远程分支git push origin --delete branch1git branch -dr branch1// 将当前分支push到指定远程分支git push origin HEAD:branch1 tag：标签。 12345678910111213141516// 列出所有taggit tag// 新建一个tag在当前commitgit tag 1// 新建一个tag在指定commitgit tag 2 8989920311bacb3f4e3ced7f82ab75ca47c318c7// 删除本地taggit tag -d 1// 查看tag信息git show 2// 提交所有taggit push --tags// 删除远程taggit push origin --delete tag 2// 新建一个分支，指向某个taggit checkout -b [branch] [tag] remote：远程。 123456789101112// 查看远程库的地址列表git remote -v// 查看这个远程库的信息git remote show origin// 从远程库更新所有的信息到本地，但是不合并git fetch origin// 从远程库更新所有的信息到本地，但是不合并并清理已删除的远程分支git fetch -p origin// 从远程库更新数据并立即合并数据git pull origin branch1// 将本地数据同步到远程库中git push origin branch1 Git 客户端实用示例 1、示例：将本地代码提交到 GitHub 上。前期准备： cd Desktop/git（桌面文件夹） git clone https://github.com/CustomPBWaters/liunDemo.git（仓库的URL） cd liunDemo(github上建的文件夹) 把要上传的Demo放到建的桌面 git 文件夹里。 ls -a 会提示下步操作。 git commit -am CoreDataDemo，这里的CoreDataDemo是我本地的Demo。 12git add CoreDataDemo 把工作区的内容提交到暂存区git commit -m CoreDataDemo 把暂存区中的内容提交到提交区 git status 查看提交状态。 这时第一次提交，会让输入GitHub用户名密码。 git push 将文件推送到服务器上。 注意：要传得Demo项目中，有的含隐藏文件.git，需要删除 rm -rf .git，再上传就可以了。 2、示例：解决冲突（手动解决）。打开冲突文件，删除&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt; branch1这三行再修改成想要的，添加，提交即可。 SVN &amp; Git 两者比较 SVN &amp; Git特点 结构(最主要的区别) SVN是集中式管理，Git是分布式管理 速度 在很多情况下，git的速度远远比SVN快 难度 SVN功能简单，指令简单，入门容易。Git功能完善，指令复杂，入门简单掌握难 其他 SVN使用分支比较笨拙，git可以轻松拥有无限个分支 SVN必须联网才能正常工作，git支持本地版本控制工作 旧版本的SVN会在每一个目录置放一个.svn，git只会在根目录拥有一个.git 补充集中式版本控制 在分布式下开发者可以本地提交。 每个开发者机器上都有一个服务器的数据库。 从稳定可靠的角度来看，分布式肯定是更好的选择。 总结 这两个版本控制一直持续到现在，两者都有其优点和缺点。 个人认为两者没有绝对的优势，能够取代另一方。 但是从功能上来讲，Git 拥有SVN大致所有的功能，还拥有更多可靠，便捷，个性化的指令方便操作。 就剩最后一句话了，没错，想要复杂的功能，就要承受学习的代价。 码农们踩过的坑整理（持续~） 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>工具&amp;插件</category>
      </categories>
      <tags>
        <tag>工具&amp;插件</tag>
        <tag>SVNGit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 数据安全—「加密解密」]]></title>
    <url>%2FiOSNET%2FDataSecurity.html</url>
    <content type="text"><![CDATA[Write in the first 在写项目中，数据的安全性至关重要，而仅仅用 POST 请求提交用户的隐私数据，还是不能完全解决安全问题。因此：我们经常会用到加密技术，比如说在登录的时候，我们会先把密码用MD5加密再传输给服务器 或者 直接对所有的参数进行加密再POST到服务器。 本篇文章主要从【iOS 数据安全相关】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录: 数据安全介绍 常用加密算法 常用加密方式 Base64编码方案 加密实现代码5.1 MD5加密算法5.2 对称加密算法AES和DES5.3 非对称加密RSA HTTPS基本使用 数据安全–加密解密效果 加密实战应用场景（持续更新） Contents【相关介绍】 1.数据安全介绍 最基础的是我们发送网络请求时，使用get和post方式发送请求。两者具体区别就不做解释了，只是引出相关安全性问题 get：将参数暴露在外，（绝对不安全–&gt;明文请求或者傻瓜式请求）。 post：将参数放到请求体body中，（相对于get比较安全–&gt;但是我们可以很容易用一些软件截获请求数据。比如说Charles（青花瓷）） Charles（大部分app的数据来源都使用该工具来抓包，并做网络测试） 注意：Charles在使用中的乱码问题，可以显示包内容，然后打开info.plist文件，找到java目录下面的VMOptions，在后面添加一项：-Dfile.encoding=UTF-8 这里提供一个青花瓷破解版下载途径，供大家学习使用，商务需求，也请支持正版。 数据安全的原则 在网络上不允许传输用户隐私数据的明文,（即:App网络传输安全，指对数据从客户端传输到Server中间过程的加密，防止网络世界当中其他节点对数据的窃听）。 在本地不允许保存用户隐私数据的明文,（即:App数据存储安全，主要指在磁盘做数据持久化的时候所做的加密）。 App代码安全,（即:包括代码混淆，加密或者app加壳）。 要想非常安全的传输数据，建议使用https。抓包不可以，但是中间人攻击则有可能。建议双向验证防止中间人攻击，可以参考下文篇章。 2.常用加密算法 常用加密算法 名称 编码方案 Base64 哈希(散列)函数 MD5（消息摘要算法） SHA1 SHA256 对称加密算法 DES AES 非对称加密算法 RSA HTTPS HTTP+SSL协议 3.常用加密方式 常用加密方式 1.通过简单 BASE64编码 防止数据明文传输 2.对普通请求、返回数据，生成MD5校验（MD5中加入动态密钥），进行数据完整性（简单防篡改，安全性较低，优点：快速）校验 3.对于重要数据，使用RSA进行数字签名，起到防篡改作 4.对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密 5.要想非常安全的传输数据，建议使用https。抓包不可以，但是中间人攻击则有可能。建议双向验证防止中间人攻击 4.Base64编码方案1.Base64简单说明 描述：Base64可以成为密码学的基石，非常重要。 特点：可以将任意的二进制数据进行Base64编码 结果：所有的数据都能被编码为并只用65个字符（A~Z a~z 0~9 + / =）就能表示的文本文件。 注意：对文件进行base64编码后文件数据的变化：编码后的数据~=编码前数据的4/3，会大1/3左右。 2.Base64编码原理和处理过程 Base64编码原理 1、将所有字符转化为ASCII码 2、将ASCII码转化为8位二进制 3、将二进制3个归成一组(不足3个在后边补0)共24位，再拆分成4组，每组6位 4、统一在6位二进制前补两个0凑足8位 5、将补0后的二进制转为十进制 6、从Base64编码表获取十进制对应的Base64编码 Base64处理过程 1、转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。 2、数据不足3byte的话，于缓冲区中剩下的bit用0补足。然后，每次取出6个bit，按照其值选择查表选择对应的字符作为编码后的输出。 3、不断进行，直到全部输入数据转换完成。 4、如果最后剩下两个输入数据，在编码结果后加1个“=”； 5、如果最后剩下一个输入数据，编码结果后加2个“=”； 6、如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。 在这里提供几张图结合上面的处理过程，好理解。 Base64实现代码简单方法直接拿走，调用12345678910111213141516171819202122// 对一个字符串进行base64编码,并且返回-(NSString *)base64EncodeString:(NSString *)string &#123; // 1.先转换为二进制数据 NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding]; // 2.对二进制数据进行base64编码,完成之后返回字符串 return [data base64EncodedStringWithOptions:0];&#125;// 对base64编码之后的字符串解码,并且返回-(NSString *)base64DecodeString:(NSString *)string &#123; // 注意:该字符串是base64编码后的字符串 // 1.转换为二进制数据(完成了解码的过程) NSData *data = [[NSData alloc]initWithBase64EncodedString:string options:0]; // 2.把二进制数据在转换为字符串 return [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];&#125;//---------------------------&lt;#我是分割线#&gt;------------------------------//NSLog(@"%@",[self base64EncodeString:@"A"]);NSLog(@"%@",[self base64DecodeString:@"QQ=="]); PS.终端执行编码和解码123如：编码：base64 123.png -o 123.txt解码：base64 123.txt -o test.png -D 4.加密实现代码哈希(散列)函数特点： 算法是公开的 对相同的数据加密，得到的结果是一样的” 对不同的数据加密，得到的结果是定长的，MD5对不同的数据进行加密，得到的结果都是 32 个字符长度的字符串 信息摘要，信息”指纹”，是用来做数据识别的！ 不能逆推反算(重要) 用途： 版权 对文件进行散列判断该文件是否是正版或原版的 文件完整性验证 对整个文件进行散列，比较散列值判断文件是否完整或被篡改 密码加密，服务器并不需要知道用户真实的密码！ 搜索：如：百度搜索–&gt;老司机 皮皮虾 苍老师或是 【苍老师 老司机 皮皮虾 】上面两种方式搜索出来的内容是一样的 如何判断：对搜索的每个关键字进行三列，得到三个相对应的结果，按位相加结果如果是一样的，那搜索的内容就是一样的！ 经典加密算法：MD5、SHA1、SHA512 MD5消息摘要算法 简单介绍: MD5：全称是Message Digest Algorithm 5，译为“消息摘要算法第5版”(经MD2、MD3和MD4发展而来) 效果：对输入信息生成唯一的128位散列值（32个字符），即 32个16进制的数字。 特点: 输入两个不同的明文不会得到相同的输出值 根据输出值，不能得到原始的明文，即其过程不可逆(只能加密, 不能解密) 应用: 现在的MD5已不再是绝对安全(如：暴力破解的网站)，对此，可以对MD5稍作改进，以增加解密的难度。 解决：加盐（Salt）：在明文的固定位置插入随机串，然后再进行MD5（先加密，后乱序：先对明文进行MD5，然后对加密得到的MD5串的字符进行乱序） 注意点: 开发中，一定要和后台开发人员约定好，MD5加密的位数是16位还是32位(大多数都是32位的)，16位的可以通过32位的转换得到。 MD5加密区分 大小写，使用时要和后台约定好。 MD5公认被破解不代表其可逆，而是一段字符串加密后的密文，可以通过强大运算计算出字符串加密后的密文对应的原始字符串，但也不是绝对的被破解。 PS.暴力破解是指通过将明文和生成的密文进行配对，生成强大的数据库，在数据库中搜索，在这里就可以破解密码。破解网址 http://www.cmd5.com 提升MD5加密安全性，解决办法 1.先明文加盐，然后再进行MD5。即明文后拼接字符串（此时拼接的字符串要 足够长+足够咸+足够复杂），再进行MD5加密。如：#define salt @&quot;1342*&amp;%&amp;shlfhs390(*^^6R%@@KFGKF&quot; 2.先加密+乱序 3.乱序|加盐，多次MD5加密等 4.使用消息认证机制HMAC：给定一个”秘钥”，对明文进行加密，并且做”两次散列”！-&gt; 得到的结果，还是 32 个字符，相对安全（KEY是服务器传给你的，不是你写死的）。 消息认证机制（HMAC）简单说明 原理 消息的发送者和接收者有一个共享密钥 发送者使用共享密钥对消息加密计算得到MAC值（消息认证码） 消息接收者使用共享密钥对消息加密计算得到MAC值 比较两个MAC值是否一致 使用 客户端需要在发送的时候把（消息）+（消息·HMAC）一起发送给服务器 服务器接收到数据后，对拿到的消息用共享的KEY进行HMAC，比较是否一致，如果一致则信任 简单示例1234567891011121314151617181920212223242526272829303132333435363738394041#pragma mark - md5加密方法- (NSString *)md5String &#123; const char *str = self.UTF8String; uint8_t buffer[CC_MD5_DIGEST_LENGTH]; CC_MD5(str, (CC_LONG)strlen(str), buffer); return [self stringFromBytes:buffer length:CC_MD5_DIGEST_LENGTH];&#125;#pragma mark - HMACMD5加密方法- (NSString *)hmacMD5StringWithKey:(NSString *)key &#123; const char *keyData = key.UTF8String; const char *strData = self.UTF8String; uint8_t buffer[CC_MD5_DIGEST_LENGTH]; CCHmac(kCCHmacAlgMD5, keyData, strlen(keyData), strData, strlen(strData), buffer); return [self stringFromBytes:buffer length:CC_MD5_DIGEST_LENGTH];&#125;/** * 返回二进制 Bytes 流的字符串表示形式 * @param bytes 二进制 Bytes 数组 * @param length 数组长度 * @return 字符串表示形式 */- (NSString *)stringFromBytes:(uint8_t *)bytes length:(int)length &#123; NSMutableString *strM = [NSMutableString string]; for (int i = 0; i &lt; length; i++) &#123; [strM appendFormat:@"%02x", bytes[i]]; &#125; return [strM copy];&#125;//---------------------------&lt;#我是分割线#&gt;------------------------------//// md5加密调用NSLog(@"%@",[@"520it" md5String]);// (明文+加盐)MD5加密调用NSLog(@"%@",[[@"520it" stringByAppendingString:salt] md5String]);// hmacMD5加密调用（先加密+乱序）NSLog(@"%@",[@"520it" hmacMD5StringWithKey:@"xiaomage"]); 对称加密算法AES和DES 对称加密的特点 加密/解密使用相同的密钥 加密和解密的过程是可逆的 经典算法 DES 数据加密标准 AES 高级加密标准 提示： 加密过程是先加密，再base64编码 解密过程是先base64解码，再解密 简单示例123456789101112131415161718192021222324/** * 加密字符串并返回base64编码字符串 * * @param string 要加密的字符串 * @param keyString 加密密钥 * @param iv 初始化向量(8个字节) * * @return 返回加密后的base64编码字符串 */- (NSString *)encryptString:(NSString *)string keyString:(NSString *)keyString iv:(NSData *)iv;/** * 解密字符串 * * @param string 加密并base64编码后的字符串 * @param keyString 解密密钥 * @param iv 初始化向量(8个字节) * * @return 返回解密后的字符串 */- (NSString *)decryptString:(NSString *)string keyString:(NSString *)keyString iv:(NSData *)iv;// 调用EncryptionTools *encrypt = [EncryptionTools sharedEncryptionTools];NSLog(@"%@",[encrypt encryptString:@"LN123" keyString:@"LN" iv:nil]);NSLog(@"%@",[encrypt decryptString:@"OPcTMDB5paivqtYo9Fj+hQ==" keyString:@"LN" iv:nil]); 非对称加密RSA 非对称加密的特点 使用 公钥 加密，使用 私钥 解密 使用 私钥 加密，使用 公钥 解密（私钥签名，公钥验签） 公钥是公开的，私钥保密 加密处理安全，但是性能极差 经典算法–&gt;RSA 简单示例12345678910111213// 公钥加密时调用类方法：+ (NSString *)encryptString:(NSString *)str publicKey:(NSString *)pubKey;+ (NSData *)encryptData:(NSData *)data publicKey:(NSString *)pubKey;// 私钥解密时调用类方法+ (NSString *)decryptString:(NSString *)str privateKey:(NSString *)privKey;+ (NSData *)decryptData:(NSData *)data privateKey:(NSString *)privacy;/** 调用 */NSString *str = [RSAUtil encryptString: @"LN" publicKey:RSA_Public_key];NSLog(@"RSA公钥加密数据--&gt;\n%@",str);NSString *str1 = [RSAUtil decryptString:str privateKey:RSA_Privite_key];NSLog(@"RSA私钥解密数据--&gt;%@",str1); MAC上生成公钥、私钥的方法，及使用12345678910# MAC上生成公钥、私钥的方法@code1.打开终端，切换到自己想输出的文件夹下2.输入指令:openssl（openssl是生成各种秘钥的工具，mac已经嵌入)3.输入指令:genrsa -out rsa_private_key.pem 1024 (生成私钥，java端使用的)4.输入指令:rsa -in rsa_private_key.pem -out rsa_public_key.pem -pubout (生成公钥)5.输入指令:pkcs8 -topk8 -in rsa_private_key.pem -out pkcs8_rsa_private_key.pem -nocrypt(私钥转格式，在ios端使用私钥解密时用这个私钥)注意:在MAC上生成三个.pem格式的文件，一个公钥，两个私钥，都可以在终端通过指令vim xxx.pem 打开，里面是字符串，第三步生成的私钥是java端用来解密数据的，第五步转换格式的私钥iOS端可以用来调试公钥、私钥解密（因为私钥不留在客户端）iOS端公钥加密私钥解密、java端公钥加密私钥解密，java端私钥加密公钥解密都容易做到，iOS不能私钥加密公钥解密，只能用于验签@endcode HTTPS基本使用 https简单说明 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。 在HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。 HTTPS：URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。 注意 HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的保护。 HTTPS的信任继承基于预先安装在浏览器中的证书颁发机构（如VeriSign、Microsoft等）（意即“我信任证书颁发机构告诉我应该信任的”）。 因此，一个到某网站的HTTPS连接可被信任，如果服务器搭建自己的https 也就是说采用自认证的方式来建立https信道，这样一般在客户端是不被信任的。 所以我们一般在浏览器访问一些https站点的时候会有一个提示，问你是否继续。 HTTPS和HTTP区别 https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 实现代码 方案一：如果是自己使用NSURLSession来封装网络请求123456789101112131415161718192021222324252627282930313233// 1.创建sessionNSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];// 2.创建TaskNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"https://kyfw.12306.cn/otn"]] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; // 3.解析数据 NSLog(@"%@---%@",[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding],error);&#125;];// 4.执行task[dataTask resume];#pragma mark - 遵守&lt;NSURLSessionDataDelegate&gt;// 如果发送的请求是https的,那么才会调用该方法-(void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler &#123; /** 判断服务器传给我们的信任的类型，只有是【服务器信任的时候，才安装证书】 NSURLSessionAuthChallengeDisposition 如何处理证书 NSURLAuthenticationMethodServerTrust 服务器信任 */ if(![challenge.protectionSpace.authenticationMethod isEqualToString:@"NSURLAuthenticationMethodServerTrust"]) &#123; return; &#125; NSLog(@"%@",challenge.protectionSpace); /* NSURLCredential 授权信息 NSURLSessionAuthChallengeUseCredential = 0, 使用该证书 安装该证书 NSURLSessionAuthChallengePerformDefaultHandling = 1, 默认采用的方式,该证书被忽略 NSURLSessionAuthChallengeCancelAuthenticationChallenge = 2, 取消请求,证书忽略 NSURLSessionAuthChallengeRejectProtectionSpace = 3, 拒绝 */ NSURLCredential *credential = [[NSURLCredential alloc]initWithTrust:challenge.protectionSpace.serverTrust]; completionHandler(NSURLSessionAuthChallengeUseCredential,credential); // 注意：并不是所有的https的请求都需要安装证书(授权)的，请求一些大型的网站有的是强制安装的，如：苹果官网https://www.apple.com&#125; 方案二：如果使用AFN网络请求123456789101112131415161718AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];// 更改解析方式（请求网页源码应使用原始解析）manager.responseSerializer = [AFHTTPResponseSerializer serializer];// 设置对证书的处理方式// 允许自签名证书，必须的manager.securityPolicy.allowInvalidCertificates = YES;// 是否验证域名的CN字段（不是必须的，但是如果写YES，则必须导入证书）manager.securityPolicy.validatesDomainName = NO;[manager GET:@"https://kyfw.12306.cn/otn" parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSLog(@"success---%@",[[NSString alloc]initWithData:responseObject encoding:NSUTF8StringEncoding]);&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; NSLog(@"error---%@",error);&#125;]; 补充ATS（全称:App Transport Security） iOS9中新增App Transport Security（简称ATS）特性, 让原来请求时候用到的HTTP，全部都转向TLS1.2协议进行传输。 这意味着所有的HTTP协议都强制使用了HTTPS协议进行传输。 如果我们在iOS9下直接进行HTTP请求是会报错。系统会告诉我们不能直接使用HTTP进行请求，需要在Info.plist中控制ATS的配置。 “NSAppTransportSecurity”是ATS配置的根节点，配置了节点表示告诉系统要走自定义的ATS设置。 “NSAllowsAritraryLoads”节点控制是否禁用ATS特性，设置YES就是禁用ATS功能; 采用解决方法，修改配置信息。 【学习本文之外可以参考】网络安全——数据的加密与签名,RSA介绍关于Https安全性问题、双向验证防止中间人攻击问题 附上一张图： 附上总结写的小样 Demo，重要的部分代码中都有相应的注解和文字打印，运行程序可以很直观的表现 【@码员真爱 : 真的不点进去阅读一下 ❓】【译文 &amp; 源码】 【工具类】 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>数据安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 常用绘图—「drawRect绘制矩形」]]></title>
    <url>%2FiOSNET%2FdrawRect.html</url>
    <content type="text"><![CDATA[Write in the first 关于绘图，其实在我当前接触的项目中用得很少，但是以后肯定会接触到。像这种不常用但比较重要的内容，我觉得要做到初步理解，然后梳理总结，到最后夯实基础、活学活用。所以写这篇文章。 iOS 系统本身提供了两大绘图的框架，即 UIKit 和 Core Graphics。UIKit：像 UIImage（绘制图像）、NSString（绘制文本）、UIBezierPath（绘制形状）、UIColor。 这些类提供了功能有限但使用方便的方法来让我们完成绘图任务。一般情况下，UIKit就是我们所需要的。 Core Graphics：CoreGraphics也称为Quartz 2D 是UIKit下的主要绘图系统，频繁的用于绘制自定义视图。Core Graphics是高度集成于UIView和其他UIKit部分的。Core Graphics数据结构和函数可以通过前缀CG来识别。 本篇文章主要从【iOS绘图 drawRect】学习总结，在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： 绘图基本概念 我是Core Graphics绘图 UIBezierPath绘图概念 我是UIKit 之 UIBezierPath绘图 期待 &amp; 后续 绘图基本概念在学习绘图之前，我们先来了解一下几个基本的概念 属性 描述 drawRect:(CGRect)rect 作用：专门用来绘图 什么时候调用：当View显示的时候调用(ViewWillAppear和ViewDidAppear之间) 参数rect：当View的bounds，Note: 在drawRect方法当中系统已经帮你创建一个跟View相关联的上下文(Layer上下文),只要获取上下文就可以了 什么操作调用：1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。2、该方法在调用sizeThatFits后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。 Context 定义：图形上下文，是一个CGContextRef类型的数据，你可以将图形上下文理解为一块画布 作用：1、保存绘图信息，绘图状态；2、决定绘制的输出目标（绘制到什么地方去？// 输出目标可以是PDF文件、Bitmap或者显示器的窗口上）3、相同的一套绘图序列，指定不同的 Graphics Context,就可将相同的图像绘制到不同的目标上 path 路径，ios绘图可以想象为你拿着一支笔去画图，画几条线或几个点从而形成一个路径，之后可以利用理解去填色或者描边 stroke、fill 描边和填充，每个路径都需要填充或者描边后才能在视图中看见，他们都各自有很多样式可以设置，常见的有颜色、粗细、渐变，连接样式等等。 了解完上面的几个概念之后，我想 我们先不着急写的，首先你的知道你想实现什么效果用到什么属性值，及对属性值意思的理解。然后再结合下面的代码 就更容易理解和吸收了 Core Graphics绘图属性 描述 UIGraphicsGetCurrentContext() 获取上下文 CGContextMoveToPoint(ctx, x, y) 设置起始点 CGContextAddLineToPoint(ctx, x, y) 添加一根线到终点 CGContextAddLines(ctx, points, count) 添加线(点之间) 参数：points点数组，count数组个数 CGContextAddEllipseInRect(ctx, CGRect rect) 画椭圆，如果长宽相等就是圆 CGContextAddRect(ctx, CGRect rect) 画矩形，长宽相等就是正方形 [image drawInRect:CGRect rect] 画图片 [@”hello world” drawInRect:CGRect rect withAttributes:NSDictionary *dict] 画文字 (属性值：NSFontAttributeName字体大小、NSForegroundColorAttributeName字体颜色) CGContextAddArc(ctx, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, int clockwise) 画圆 参数：圆心的x坐标，圆心的y坐标，圆的半径，开始弧度，结束弧度，0表示顺时针 1表示逆时针 CGContextAddQuadCurveToPoint(ctx, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y); 二次曲线函数 参数：控制点 x坐标，控制点 y坐标，终点 x坐标，终点 y坐标 Note:这里使用必须要设置起点MoveToPoin CGContextAddCurveToPoint(ctx, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y) 三次曲线函数 参数：控制点1 x y坐标，控制点2 x y坐标，终点 x坐标，终点 y坐标 Note:这里使用必须要设置起点MoveToPoin CGContextStrokePath(ctx) 渲染上下文（Stroke描边,空心） CGContextFillPath(ctx) 渲染上下文（Fill填充,实心） CGContextDrawPath(ctx, CGPathDrawingMode mode) 渲染上下文 mode：1、kCGPathFill 只有填充（非零缠绕数填充），不绘制边框 2、kCGPathEOFill 奇偶规则填充（多条路径交叉时，奇数交叉填充，偶交叉不填充）3、kCGPathStroke 只有边框 4、kCGPathFillStroke 既有边框又有填充 5、kCGPathEOFillStroke 奇偶填充并绘制边框 其他属性设置 CGContextSetStrokeColorWithColor(ctx, Color) 设置线颜色 CGContextSetFillColorWithColor(ctx, Color) 设置填充色 CGContextSetLineWidth(ctx, CGFloat width); 设置线宽度 CGContextSetLineJoin(ctx, CGLineJoin join) 设置连接样式（kCGLineJoinMiter尖的、斜接, Round圆, Bevel斜面） CGContextSetLineCap(ctx, CGLineCap cap) 设置顶角样式（kCGLineCapButt, Round, Square） CGContextSetLineDash(ctx, CGFloat phase, lengths, count) 设置虚线样式（参数：phase虚线从那开始绘制；lengths C语言的数组,举个例子: 声明一个数组 CGFloat dash[] = @{3.0, 1.0}意思就是长度为3.0 间隙长度为1.0,以此类推；count lengths数组的个数） 示例代码：自定义View的步骤新建一个类,继承UIView实现- (void)drawRect:(CGRect)rect方法 我是Core Graphics绘图 1、获取上下文2、绘制路径3、添加路径到上下文4、渲染上下文（描边或填充） 12345678910111213141516171819202122232425262728293031323334- (void)drawRect:(CGRect)rect &#123;//------------------我是Core Graphics绘图------------- // 获取ctx CGContextRef ctx = UIGraphicsGetCurrentContext(); // 设置绘图的其他属性 // 设置线颜色 CGContextSetStrokeColorWithColor(ctx, [UIColor blackColor].CGColor); // 设置线宽度 CGContextSetLineWidth(ctx, 5); // 设置线颜色 [[UIColor redColor] set]; // 设置填充色 CGContextSetFillColorWithColor(ctx, [UIColor purpleColor].CGColor); // 设置连接样式（Miter尖的、斜接, Round圆, Bevel斜面） CGContextSetLineJoin(ctx, kCGLineJoinRound); // 设置顶角样式（Butt, Round, Square） CGContextSetLineCap(ctx, kCGLineCapRound); // 设置虚线样式 CGFloat lengths[] = &#123; 20, 5 &#125;; CGContextSetLineDash(ctx, 0, lengths, 2); // 画线 [self drawLine:ctx]; // 画矩形,画椭圆，多边形 [self drawSharp:ctx]; // 画图片 [self drawPicture:ctx]; // 画文字 [self drawText:ctx]; // 画圆、画弧 [self drawCircle:ctx];&#125; PS.第一个方法写的比较详细，写了使用直接画线的方式 和 path的方式。推荐使用path的方式画线。 另外，第一个方法也写了移动笔触画线和用点集合画线。后面方法只会涉及其中一种，因为方法都比较类似 画线12345678910111213141516171819202122232425262728293031323334// 画线-(void)drawLine:(CGContextRef)ctx&#123; // 画一条简单的线 CGPoint points1[] = &#123;CGPointMake(10, 80),CGPointMake(300, 80)&#125;; CGContextAddLines(ctx,points1, 2); // 画线方法一：使用CGContextAddLineToPoint画线，需要先设置一个起始点 // 设置起始点 CGContextMoveToPoint(ctx, 10, 100); // 添加一根线到终点 CGContextAddLineToPoint(ctx, 100,120); // 再添加一根线到终点，变成折线 CGContextAddLineToPoint(ctx, 150, 100); // 画线方法二： // 构造线路径的点数组 CGPoint points2[] = &#123;CGPointMake(10, 130),CGPointMake(10, 160),CGPointMake(130, 200)&#125;; CGContextAddLines(ctx,points2, 3); // 利用路径去画一组点（推荐使用路径的方式，虽然多了几行代码，但是逻辑更清晰了） // 第一个路径 CGMutablePathRef path1 = CGPathCreateMutable(); CGPathMoveToPoint(path1, &amp;CGAffineTransformIdentity, 0, 200); //CGAffineTransformIdentity 类似于初始化一些参数 CGPathAddLineToPoint(path1, &amp;CGAffineTransformIdentity, 100, 250); CGPathAddLineToPoint(path1, &amp;CGAffineTransformIdentity, 310, 210); //路径1加入context CGContextAddPath(ctx, path1); // path同样有方法CGPathAddLines(),和CGContextAddLines() // 渲染上下文 CGContextStrokePath(ctx);&#125; 画矩形,画椭圆，多边形1234567891011121314151617181920// 画矩形,画椭圆，多边形-(void)drawSharp:(CGContextRef)ctx&#123; CGContextSetFillColorWithColor(ctx, [UIColor redColor].CGColor); // 画椭圆,如果长宽相等就是圆 CGContextAddEllipseInRect(ctx, CGRectMake(0, 250, 50, 50)); // 画矩形,长宽相等就是正方形 CGContextAddRect(ctx, CGRectMake(70, 250, 50, 50)); // 画多边形，多边形是通过path完成的 CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, &amp;CGAffineTransformIdentity, 120, 250); CGPathAddLineToPoint(path, &amp;CGAffineTransformIdentity, 200, 250); CGPathAddLineToPoint(path, &amp;CGAffineTransformIdentity, 180, 300); CGPathCloseSubpath(path); CGContextAddPath(ctx, path); // 填充 CGContextFillPath(ctx);&#125; 画图片、画文字123456789101112131415// 画图片-(void)drawPicture:(CGContextRef)context&#123; UIImage *image = [UIImage imageNamed:@&quot;阿狸头像&quot;]; [image drawInRect:CGRectMake(10, 300, 100, 100)]; //CGContextDrawImage(ctx, rect, image.CGImage);&#125;// 画文字-(void)drawText:(CGContextRef)ctx&#123; NSDictionary *dict = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:18], NSForegroundColorAttributeName:[UIColor redColor]&#125;; [@&quot;hello world&quot; drawInRect:CGRectMake(120 , 350, 500, 50) withAttributes:dict];&#125; 画圆、圆弧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 画圆、圆弧-(void)drawCircle:(CGContextRef)ctx&#123; CGContextSetStrokeColorWithColor(ctx, [UIColor purpleColor].CGColor); /** 绘制路径方法一: CGContextRef c,// 上下文 CGFloat x, // 圆心的x坐标 CGFloat y, // 圆心的y坐标 CGFloat radius, // 圆的半径 CGFloat startAngle, // 开始弧度 CGFloat endAngle, // 结束弧度 int clockwise // 0表示顺时针，1表示逆时针 */ // 圆 CGContextAddArc (ctx, 100, 100, 50, 0, M_PI* 2 , 0); CGContextFillPath(ctx); // 半圆 CGContextAddArc (ctx, 100, 200, 50, 0, M_PI, 0); CGContextStrokePath(ctx); /** 三次曲线函数 CGContextRef c, CGFloat cp1x, // 控制点1 x坐标 CGFloat cp1y, // 控制点1 y坐标 CGFloat cp2x, // 控制点2 x坐标 CGFloat cp2y, // 控制点2 y坐标 CGFloat x, // 直线的终点 x坐标 CGFloat y // 直线的终点 y坐标 */ CGContextMoveToPoint(ctx, 200, 200); CGContextAddCurveToPoint(ctx, 200, 0, 300, 200, 400, 100); CGContextStrokePath(ctx); /** 二次曲线函数 CGContextRef c, CGFloat cpx, //控制点 x坐标 CGFloat cpy, //控制点 y坐标 CGFloat x, //直线的终点 x坐标 CGFloat y //直线的终点 y坐标 */ CGContextMoveToPoint(ctx, 100, 100); CGContextAddQuadCurveToPoint(ctx, 200, 0, 300, 150); CGContextStrokePath(ctx);&#125; Core Graphics绘图效果： UIBezierPath绘图概念 同样，首先你的知道你想实现什么效果用到什么属性值，及对属性值意思的理解。然后再结合下面的代码 就更容易理解和吸收了 UIKit 之 UIBezierPath绘图属性 描述 [UIBezierPath bezierPath] 创建路径 moveToPoint:(CGPoint) 设置起点 addLineToPoint:(CGPoint) 添加一根线到终点 [[UIColor redColor] set] 设置线颜色（注意:如果使用 setStroke 和 setFill 与渲染方式要相对应） addQuadCurveToPoint:(CGPoint) controlPoint:(CGPoint) 画曲线(controlPoint:弯曲方向点) bezierPathWithRect:(CGRect) 画矩形 bezierPathWithRoundedRect:(CGRect) cornerRadius:(CGFloat) 画圆角矩形 bezierPathWithOvalInRect:(CGRect) 画圆(Width = Height)、画椭圆(Width != Height) bezierPathWithArcCenter:(CGPoint) radius:(CGFloat) startAngle:(CGFloat) endAngle:(CGFloat) clockwise:(BOOL) Center:弧所在的圆心(这里不能直接用self.center,因为它是相对于它的父控件的,采用rect 宽度0.5、高度0.5)，radius:圆的半径，startAngle:开始角度， endAngle:结束角度，clockwise:YES顺时针 NO逆时针 bezierPathWithArcCenter:(CGPoint) radius:(CGFloat) startAngle:(CGFloat) endAngle:(CGFloat) clockwise:(BOOL) [path addLineToPoint:center]; 注：1、[path closePath] 从路径终点连接一根线到路径的起点，2、[path fill] 填充之前,会自动关闭路径 UIGraphicsBeginImageContextWithOptions 开启上下文（size:上下文大小, opaque:透明度(YES透明,NO不透明), scale:图片质量，一般为0和当前设备的分辨率一样) drawAtPoint:(CGPoint) 图片绘制到上下文 addClip 设置成裁剪区域 drawAtPoint:(CGPoint) blendMode:(CGBlendMode) alpha:(CGFloat) 图片绘制到上下文 drawAtPoint:(CGPoint) withAttributes:NSDictionary *dict) 文字绘制到上下文（属性值：NSFontAttributeName字体大小、NSForegroundColorAttributeName字体颜色） UIGraphicsEndImageContext() 关闭上下文 [path stroke] / [path fill] 底层做了:1.获取上下文-&gt;2.绘制路径-&gt;3.添加路径到上下文-&gt;4.渲染上下文 PS.同样第一个方法写的比较详细，且有注释实现- (void)drawRect:(CGRect)rect方法 我是UIKit 之 UIBezierPath绘图 1、获取上下文2、绘制路径3、添加路径到上下文4、渲染上下文（描边或填充） 1234567- (void)drawRect:(CGRect)rect &#123;//------------------我是UIKit 之 UIBezierPath绘图------------- [self drawLine];// 画直线、曲线 [self drawRect];// 画矩形、画椭圆 [self drawRidan];// 画弧度、扇形 画直线123456789101112131415161718192021222324252627282930/** 画直线、曲线 */- (void)drawLine&#123; // 1.获取上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 2.绘制路径 UIBezierPath *path = [UIBezierPath bezierPath]; // 设置起点 + 添加一根线到终点 [path moveToPoint:CGPointMake(10, 150)]; [path addLineToPoint:CGPointMake(160, 80)]; // 画第二条线 [path addLineToPoint:CGPointMake(130, 150)]; // 画曲线 [path moveToPoint:CGPointMake(10, 280)]; // 画曲线(controlPoint:弯曲方向点) [path addQuadCurveToPoint:CGPointMake(180, 280) controlPoint:CGPointMake(130, 130)]; // **在这里设置其他属性与上面的一样就不在写一遍了** // 3.路径添加到上下文 // UIBezierPath:UIKit框架 ,CGPathRef:CoreGraphics框架 CGContextAddPath(ctx, path.CGPath); // 4.渲染上下文 CGContextStrokePath(ctx);// 描边(空心) //CGContextFillPath(ctx);// 填充(实心)&#125; 画矩形、椭圆12345678910111213141516171819202122232425/** 画矩形、椭圆 */- (void)drawRect&#123; CGContextRef ctx = UIGraphicsGetCurrentContext(); // 画矩形 UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(10, 300, 80, 40)]; // 画圆角矩形 UIBezierPath *path1 = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(100, 300, 80, 40) cornerRadius:10]; // 画指定角为圆角的矩形 UIBezierPath *path2 = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(200, 300, 80, 40) byRoundingCorners:UIRectCornerBottomRight cornerRadii:CGSizeMake(10, 10)]; [[UIColor redColor] set]; CGContextAddPath(ctx, path.CGPath); CGContextAddPath(ctx, path1.CGPath); CGContextAddPath(ctx, path2.CGPath); CGContextStrokePath(ctx); // 使用UIBezierPath提供的绘图方法进行绘制 // 画椭圆、圆 UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(10, 370, 180, 50)]; // 使用UIBezierPath提供的绘图方法进行绘制 [path stroke];// 底层做了:1.获取上下文-&gt;2.绘制路径-&gt;3.添加路径到上下文-&gt;4.渲染上下文&#125; 画弧度、扇形1234567891011121314151617/** 画弧度、扇形 */- (void)drawRidan&#123; CGPoint center = CGPointMake(100, 430); CGFloat radius = 100; // 画弧度 clockwise:方向(顺时针或是逆时针) UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:0 endAngle:M_PI_4*3 clockwise:YES]; // 画扇形 [path addLineToPoint:center]; //[path closePath];// 从路径终点连接一根线到路径的起点 [path fill];// fill填充之前,会自动关闭路径 //[path stroke];&#125; 画图片和文字1234567891011121314151617181920212223242526272829303132/** 根据传入的图片,生成一终带有边框的圆形图片 参数:边框宽度,边框颜色,原始图片 */+ (UIImage *)imageWithImage:(UIImage *)image Border:(CGFloat)borderW color:(UIColor *)borderColor &#123; CGSize size = CGSizeMake(image.size.width + 2*borderW, image.size.height + 2*borderW); // 1.开启一个跟图片原始大小的上下文 UIGraphicsBeginImageContextWithOptions(size, NO, 0); // 2.绘制大圆 UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, size.width, size.height)]; [borderColor set];// 边框颜色 [path fill]; // 设置圆形裁剪区域 UIBezierPath *clipPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(borderW, borderW, image.size.width, image.size.height)]; [clipPath addClip]; // 3.把图片绘制到上下文当中 [image drawAtPoint:CGPointMake(borderW, borderW)]; // 3.把文字绘制到上下文当中 NSDictionary *dict = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:18.f],NSForegroundColorAttributeName:[UIColor whiteColor]&#125;; [@&quot;我是绘制上的\n图片和文字&quot; drawAtPoint:CGPointMake(0, 0) withAttributes:dict]; // 4.从上下文当中生成一张图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); // 5.关闭上下文 UIGraphicsEndImageContext(); image = newImage; return image;&#125; 效果： 如果你想更深入学习 UIBeizerPath ，这里有一篇官方译文加原理的总结 ，👍推荐一篇 UIBezierPath译文+活用 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIWebViewApple译文]]></title>
    <url>%2FAppleTranslation%2FUIWebViewApple.html</url>
    <content type="text"><![CDATA[Write in the first 随着HTML5的迅速发展与日趋成熟，越来越多的移动开发者选择使用HTML5来进行混合开发，不仅节约成本而且效果绚丽，只有一个感觉 D！(此时默默下决心我要学会☺)。 那么作为内置浏览器的WebView被重视起来，不管是iOS还是Android，都要是使用 WebView 控件来加载HTML5页面，甚至有些程序打开后只有一个WebView 控件，其他的页面都是被它加载出来网页。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 正题在这里首先附上官方原文地址 UIWebView Class Relationships Inherits From UIView 继承自: UIView Conforms To 遵守:CVarArg、Equatable、Hashable、Equa NSCoding table、UIAccessibilityIdentification、UIScrollViewDelegate Framework iOS 2.0+ ClassUIWebView You can use the UIWebView class to embed web content in your app. To do so, create a UIWebView object, attach it to a window, and send it a request to load web content. You can also use this class to move back and forward in the history of webpages, and you can even set some web content properties programmatically. 你可以使用 UIWebView 类来将网页（web content）嵌入到你的 app 中。为此，首先创建一个 UIWebView 对象，将它添加到一个 窗体（window） 上， 然后给它发送一个请求去加载网页（web content）。你还可以用这个类在网页浏览记录中后退前进（move back and forward），甚至可以设置一些网页属性（web content properties）。 Overview NoteIn apps that run in iOS 8 and later, use the WKWebView class instead of using UIWebView. Additionally, consider setting the WKPreferences property javaScriptEnabled to false if you render files that are not supposed to run JavaScript. 注意：在只支持iOS 8及以后的系统的 app 中，建议使用WKWebView，而不是 UIWebView 。值得注意的一点是，如果你要渲染的文件不支持运行 JavaScript 的话，不妨将 WKPreferences的javaScriptEnabled 属性设为 NO。 ImportantAn iOS app linked on or after iOS 10.0 must include in its Info.plist file the usage description keys for the types of data it needs to access or it will crash. To access a user’s photo data specifically, it must include NSPhotoLibraryUsageDescription and NSCameraUsageDescription. 重要：iOS应用程序链接或之后的iOS 10.0必须包括在其信息。plist文件使用描述键类型的数据需要访问或它会崩溃。访问用户的照片数据具体地说,它必须包括NSPhotoLibraryUsageDescription和NSCameraUsageDescription。 Use the loadHTMLString(_:baseURL:) method to begin loading local HTML files or the loadRequest(_:) method to begin loading web content. Use the stopLoading() method to stop loading, and the isLoading property to find out if a web view is in the process of loading. 我们可以使用 loadHTMLString:baseURL: 方法来加载本地 HTML 文件或者用 loadRequest: 方法来加载网页（web content）。我们还可以通过调用stopLoading 方法来停止加载，以及通过获取属性 loading 的值来判断一个 web view 是否还处于正在加载的过程中。 If you allow the user to move back and forward through the webpage history, then you can use the goBack() and goForward() methods as actions for buttons. Use the canGoBack and canGoForward properties to disable the buttons when the user can’t move in a direction. 如果你想让用户在浏览网页时可以前进后退，你可以通过 button 的 action 对goBack 和goForward 方法的调用来控制。当用户不能在某一个方向“移动”时，需要使用 canGoBack 和 canGoForward 属性来禁用按钮的前进后退操作。 By default, a web view automatically converts telephone numbers that appear in web content to Phone links. When a Phone link is tapped, the Phone app launches and dials the number. To turn off this default behavior, set the dataDetectorTypes property with a UIDataDetectorTypes bitfield that does not contain the phoneNumber flag. 默认情况下，一个 web view 会自动将网页中的电话号码转成一个号码链接（Phone links）。当用户在点击那个链接（Phone links）时，系统会自动启动 Phone app 并拨打那个电话号码。你可以将属性 dataDetectorTypes 的值设置为一个 UIDataDetectorTypes 位字段来关闭这个电话号码识别行为，因为UIDataDetectorTypes不包括 TypePhoneNumber 这个标志位。 You can also use the scalesPageToFit property to programmatically set the scale of web content the first time it is displayed in a web view. Thereafter, the user can change the scale using gestures. 你可以通过设置 scalesPageToFit 属性来设置网页（web content）第一次展示在一个 web view 中的页面比例。但仅仅这个属性只在首次展示时有效，首次展示之后用户仍然可以通过手势改变页面比例。 Set the delegate property to an object conforming to the UIWebViewDelegate protocol if you want to track the loading of web content. 如果你想追踪网页内容（web content）的加载，你需要将 web view 的 delegate 属性赋给一个遵守 UIWebViewDelegate 协议的对象。 ImportantYou should not embed UIWebView or UITableView objects in UIScrollView objects. If you do so, unexpected behavior can result because touch events for the two objects can be mixed up and wrongly handled. 重要：不要将 UIWebView 或 UITableView 对象嵌入到 UIScrollView 对象中。如果你这么做了，将会导致一些意想不到的结果，因为那两个嵌套的 view 的 touch 事件会被混淆并且会被错误地处理。 You can easily debug the HTML, CSS, and JavaScript contained inside a UIWebView with Web Inspector. Read Debugging Web Content on iOS to learn how to configure Web Inspector for iOS. Read the rest of Safari Web Content Guide to learn how to create web content that is optimized for Safari on iPhone and iPad. For information about basic view behaviors, see View Programming Guide for iOS. 借助 Web Inspector，可以很方便地调试一个 UIWebView 中的HTML，CSS 和 JavaScript。你可以通过阅读 Debugging Web Content on iOS 来学习如何配置 Web Inspector for iOS。你还可以通过阅读 Safari Web Content Guide 的其余部分，来学习如何创建一个为 iPhone 和 iPad 上的 Safari 而优化的网页（web content）。 如果你想了解一些关于基本的 view 的知识，不妨看一下View Programming Guide for iOS 。 Supported File Formats支持的文件格式 In addition to HTML content, UIWebView objects can be used to display other content types, such as Keynote, PDF, and Pages documents. For the best rendering of plain and rich text in your app, however, you should use UITextView instead. 除了 HTML 内容之外，UIWebView 对象还可以被用来展示其他格式的内容，比如，Keynote，PDF，Pages文件等。为了能够保证文本（plain and rich text）渲染的最佳效果，建议使用 UITextView。 State Preservation状态保存 In iOS 6 and later, if you assign a value to this view’s restorationIdentifier property, it attempts to preserve its URL history, the scaling and scrolling positions for each page, and information about which page is currently being viewed. During restoration, the view restores these values so that the web content appears just as it did before. For more information about how state preservation and restoration works, see App Programming Guide for iOS. 在iOS 6及以后版本的系统中，如果你给 web view 的 restorationIdentifier 属性赋一个值，它将会为每一页保存它的 URL 历史，缩放比例和滚动位置，以及当前正在查看的网页信息。在恢复（ restoration）过程中，那个 view 会复原（ restore）这些值，因此那个网页（web content）看起来就像它之前的样子一样。如果你想了解更多关于状态保存和恢复是如何运作的信息，不妨读一读 App Programming Guide for iOS。 For more information about appearance and behavior configuration, see Web Views. 更多关于外观和行为配置的信息，请看 Web Views。 Subclassing Notes关于继承 The UIWebView class should not be subclassed. UIWebView 不应该被继承。 SymbolsSetting the Delegate设置代理 var delegate: UIWebViewDelegate?The receiver’s delegate. 1@property(nonatomic, assign) id&lt; UIWebViewDelegate &gt; delegate The delegate is sent messages when content is loading. See UIWebViewDelegate for the optional methods this delegate may implement. ImportantBefore releasing an instance of UIWebView for which you have set a delegate, you must first set its delegate property to nil. This can be done, for example, in your dealloc method. 重要：在释放一个你已经为其设过 delegate 的 UIWebView 实例之前，你首先一定要将该 UIWebView 对象的 delegate 属性设为 nil。比如说，你可以在你的 dealloc 方法中这样做。 Loading Content加载内容1234567func load(Data, mimeType: String, textEncodingName: String, baseURL: URL)Sets the main page contents, MIME type, content encoding, and base URL.- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)encodingName baseURL:(NSURL *)baseURL; 12345func loadHTMLString(String, baseURL: URL?)Sets the main page content and base URL.- (void)loadHTMLString:(NSString *)string baseURL:(NSURL *)baseURL; 1234func loadRequest(URLRequest)Connects to a given URL by initiating an asynchronous client request.- (void)loadRequest:(NSURLRequest *)request; 1234var request: URLRequest?The URL request identifying the location of the content to load.@property(nonatomic, readonly, strong) NSURLRequest *request; 1234var isLoading: BoolA Boolean value indicating whether the receiver is done loading content.@property(nonatomic, readonly, getter=isLoading) BOOL loading; 1234func stopLoading()Stops the loading of any web content managed by the receiver.- (void)stopLoading; 1234func reload()Reloads the current page.- (void)reload; Moving Back and Forward后退前进1234var canGoBack: BoolA Boolean value indicating whether the receiver can move backward.@property(nonatomic, readonly, getter=canGoBack) BOOL canGoBack; 1234var canGoForward: BoolA Boolean value indicating whether the receiver can move forward.@property(nonatomic, readonly, getter=canGoForward) BOOL canGoForward; 1234func goBack()Loads the previous location in the back-forward list.- (void)goBack; 1234func goForward()Loads the next location in the back-forward list.- (void)goForward; Setting Web Content Properties内容相关属性的设置 1234var allowsLinkPreview: BoolA Boolean value that determines whether pressing on a link displays a preview of the destination for the link.@property(nonatomic) BOOL allowsLinkPreview; 1234var scalesPageToFit: BoolA Boolean value determining whether the webpage scales to fit the view and the user can change the scale.@property(nonatomic) BOOL scalesPageToFit; 1234var scrollView: UIScrollViewThe scroll view associated with the web view.@property(nonatomic, readonly, strong) UIScrollView *scrollView; 1234var suppressesIncrementalRendering: BoolA Boolean value indicating whether the web view suppresses content rendering until it is fully loaded into memory.@property(nonatomic) BOOL suppressesIncrementalRendering; 1234var keyboardDisplayRequiresUserAction: BoolA Boolean value indicating whether web content can programmatically display the keyboard.@property(nonatomic) BOOL keyboardDisplayRequiresUserAction; 1234var dataDetectorTypes: UIDataDetectorTypesThe types of data converted to clickable URLs in the web view’s content.@property(nonatomic) UIDataDetectorTypes dataDetectorTypes; Running JavaScript1234func stringByEvaluatingJavaScript(from: String)Returns the result of running a JavaScript script. Although this method is not deprecated, best practice is to use the evaluateJavaScript(_:completionHandler:) method of the WKWebView class instead.- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; Managing Media Playback多媒体播放1234var allowsInlineMediaPlayback: BoolA Boolean value that determines whether HTML5 videos play inline or use the native full-screen controller.@property(nonatomic) BOOL allowsInlineMediaPlayback; 1234var mediaPlaybackRequiresUserAction: BoolA Boolean value that determines whether HTML5 videos can play automatically or require the user to start playing them.@property(nonatomic) BOOL mediaPlaybackRequiresUserAction; 1234var mediaPlaybackAllowsAirPlay: BoolA Boolean value that determines whether Air Play is allowed from this view.@property(nonatomic) BOOL mediaPlaybackAllowsAirPlay; 1234var allowsPictureInPictureMediaPlayback: BoolA Boolean value that determines whether Picture in Picture playback is allowed from this view.@property(nonatomic) BOOL allowsPictureInPictureMediaPlayback; Managing Pages页面设置1234var gapBetweenPages: CGFloatThe size of the gap, in points, between pages.@property(nonatomic) CGFloat gapBetweenPages; 1234var pageCount: IntThe number of pages produced by the layout of the web view.@property(nonatomic, readonly) NSUInteger pageCount; 1234var pageLength: CGFloatThe size of each page, in points, in the direction that the pages flow.@property(nonatomic) CGFloat pageLength; 1234var paginationBreakingMode: UIWebPaginationBreakingModeThe manner in which column- or page-breaking occurs.@property(nonatomic) UIWebPaginationBreakingMode paginationBreakingMode; 1234var paginationMode: UIWebPaginationModeThe layout of content in the web view.@property(nonatomic) UIWebPaginationMode paginationMode; 最后附上 UIWebView.h作为一枚成长中的菜鸟，分享和开源精神，还是值得具备的。如果…我是说如果，可以关注下 GitHub123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//// UIWebView.h// UIKit//// Copyright (c) 2007-2015 Apple Inc. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIView.h&gt;#import &lt;UIKit/UIKitDefines.h&gt;#import &lt;UIKit/UIDataDetectors.h&gt;#import &lt;UIKit/UIScrollView.h&gt;NS_ASSUME_NONNULL_BEGINtypedef NS_ENUM(NSInteger, UIWebViewNavigationType) &#123;UIWebViewNavigationTypeLinkClicked,UIWebViewNavigationTypeFormSubmitted,UIWebViewNavigationTypeBackForward,UIWebViewNavigationTypeReload,UIWebViewNavigationTypeFormResubmitted,UIWebViewNavigationTypeOther&#125; __TVOS_PROHIBITED;typedef NS_ENUM(NSInteger, UIWebPaginationMode) &#123;UIWebPaginationModeUnpaginated,UIWebPaginationModeLeftToRight,UIWebPaginationModeTopToBottom,UIWebPaginationModeBottomToTop,UIWebPaginationModeRightToLeft&#125; __TVOS_PROHIBITED;typedef NS_ENUM(NSInteger, UIWebPaginationBreakingMode) &#123;UIWebPaginationBreakingModePage,UIWebPaginationBreakingModeColumn&#125; __TVOS_PROHIBITED;@class UIWebViewInternal;@protocol UIWebViewDelegate;NS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UIWebView : UIView &lt;NSCoding, UIScrollViewDelegate&gt;@property (nullable, nonatomic, assign) id &lt;UIWebViewDelegate&gt; delegate;@property (nonatomic, readonly, strong) UIScrollView *scrollView NS_AVAILABLE_IOS(5_0);- (void)loadRequest:(NSURLRequest *)request;- (void)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;@property (nullable, nonatomic, readonly, strong) NSURLRequest *request;// 重新加载（刷新）- (void)reload;// 停止加载- (void)stopLoading;// 回退- (void)goBack; // 前进- (void)goForward;// 是否能回退@property (nonatomic, readonly, getter=canGoBack) BOOL canGoBack;// 是否能前进@property (nonatomic, readonly, getter=canGoForward) BOOL canGoForward; // 是否正在加载中@property (nonatomic, readonly, getter=isLoading) BOOL loading;// 在OC中调用JavaScript代码- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;// 是否伸缩内容至适应屏幕当前尺寸@property (nonatomic) BOOL scalesPageToFit;@property (nonatomic) BOOL detectsPhoneNumbers NS_DEPRECATED_IOS(2_0, 3_0); // 需要进行检测的数据类型@property (nonatomic) UIDataDetectorTypes dataDetectorTypes NS_AVAILABLE_IOS(3_0);@property (nonatomic) BOOL allowsInlineMediaPlayback NS_AVAILABLE_IOS(4_0); // iPhone Safari defaults to NO. iPad Safari defaults to YES@property (nonatomic) BOOL mediaPlaybackRequiresUserAction NS_AVAILABLE_IOS(4_0); // iPhone and iPad Safari both default to YES@property (nonatomic) BOOL mediaPlaybackAllowsAirPlay NS_AVAILABLE_IOS(5_0); // iPhone and iPad Safari both default to YES@property (nonatomic) BOOL suppressesIncrementalRendering NS_AVAILABLE_IOS(6_0); // iPhone and iPad Safari both default to NO@property (nonatomic) BOOL keyboardDisplayRequiresUserAction NS_AVAILABLE_IOS(6_0); // default is YES@property (nonatomic) UIWebPaginationMode paginationMode NS_AVAILABLE_IOS(7_0);@property (nonatomic) UIWebPaginationBreakingMode paginationBreakingMode NS_AVAILABLE_IOS(7_0);@property (nonatomic) CGFloat pageLength NS_AVAILABLE_IOS(7_0);@property (nonatomic) CGFloat gapBetweenPages NS_AVAILABLE_IOS(7_0);@property (nonatomic, readonly) NSUInteger pageCount NS_AVAILABLE_IOS(7_0);@property (nonatomic) BOOL allowsPictureInPictureMediaPlayback NS_AVAILABLE_IOS(9_0);@property (nonatomic) BOOL allowsLinkPreview NS_AVAILABLE_IOS(9_0); // default is NO@end__TVOS_PROHIBITED @protocol UIWebViewDelegate &lt;NSObject&gt;@optional// UIWebView在发送请求之前，都会调用这个方法，如果返回NO，代表停止加载请求，返回YES，代表允许加载请求- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType; // 开始发送请求（加载数据）时调用这个方法- (void)webViewDidStartLoad:(UIWebView *)webView; // 请求完毕（加载数据完毕）时调用这个方法- (void)webViewDidFinishLoad:(UIWebView *)webView; // 请求错误时调用这个方法- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error;@endNS_ASSUME_NONNULL_END 【@码员真爱 : 真的不点进去阅读一下 ❓】【译文 &amp; 源码】 【工具类】 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 伐码猿熟知—循环利用&无限轮播]]></title>
    <url>%2FEncapsulationThinking%2FCycleUsing.html</url>
    <content type="text"><![CDATA[本篇文章主要从【循环利用 &amp; 无限轮播】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 循环利用 【需求】：如上图 或者是新闻类的滚动条，标题可以点击切换界面控制器，界面可以滑动查看同时切换对应标题；常用做法是，滚动条用 UIScrollView 子控件采用 UIButton，内容视图采用 tableView。 实现方案一： 内容视图可滑动，采用 UITableView + 2个tableView；tableView 只支持上下滑动，但是 也能办到左右滑动 [transform]； 【注解】：因为我们知道 tableView 的循环利用不用我们写，tableView 自带循环利用功能，我们只要往 cell 上面 加 tableView 就可以了，现在 tableView 的数据源 设置为 cell 就可以了，数据源不一定 非得是控制器，只不过一般是控制器；只要 这个 cell 遵守 数据源DataSource和实现数据源方法，就可以为tableView提供数据； 实现方案二： 内容视图可滑动，采用 UIScrollView + 2个tableView；那现在循环利用就需要我们自己做了，对比collectionView 少了cell，但是 需要在 scrollViewDidScroll: 监听 scrollView 的滑动，其实循环利用 这里在监听滑动方法里，改变tableView的 x； 实现方案三： 内容视图可滑动，采用 UICollectionView + 2个tableView；collectionView 支持上下滑动，也支持左右滑动 ;collectionView 自带循环利用，我们要做的就是 循环利用View，更换数据； 案例 以方案三 UICollectionView为例； 【引子】 如果加上网络请求（结合上图）。【政治板块】正在处于下拉刷新，这时服务器请求还没有回来，用户滑动【体育板块】，政治View循环利用过来，这时我们要做的 1.干脆点 直接取消上次的请求；用户再次滑到【政治板块】重新下拉发送请求 2.请求继续，取消头部刷新控件状态（政治和体育 同时请求数据互补干扰，只是界面会有干扰，我们改变界面上的显示就可以；1&gt; 如果政治数据请求下来可以暂存，用户再次滑到【政治板块】数据赋值上去 2&gt; 如果政治数据没有请求下来，用户再次滑到【政治板块】还是显示下拉刷新状态）； 如果你不想用户开始滑动还没有停止，下一界面的数据就展示上来了，是想让用户停止滚动后再展示； 可以遵守&lt;UICollectionViewDelegate&gt;，在 scrollViewDidEndDecelerating: 获取当前索引，根据索引发送对应模块的请求，把数据传递给CollectionViewCell，再传递给 tableView展示； 重要的是你要有方案的架子，具体 加上网络请求，再根据细节修改； 循环利用Demo小样 重要的部分代码中都有相应的注解和文字打印，运行程序可以很直观的表现，可否点个 Star 正反无限轮播（3张） 手动滚动：只创建三张图片： leftImageView、centerImageView、rightImageView，定义中间显示页码为 centerPage ，设置初始self.centerPage = 0;，而左右图片页码都以 centerPage 表示，通过 scrollViewDidEndDecelerating: 方法判断contentOffsest.x 和 scrollView.frame.size.width 比较，使改变 self.centerPage的值，然后对应页码滚动取数组中的图片，始终显示中间一张。 定时器滚动： 将定时器添加到 Runloop 的 NSRunLoopCommonModes下，触发方法中设置setContentOffset: animated:YES 方法动画结束时调用 scrollViewDidEndScrollingAnimation:(仅当animated设置为YES时才调用)，这个方法下 self.centerPage++;。OK了 监听图片点击当图片被点击的时候，我们往往需要执行某些操作，因此需要监听图片的点击，思路如下： 1.定义一个block属性暴露给外界void(^LNBlock)(NSInteger index)。 2.设置centerImageView的userInteractionEnabled为YES。 3.给scrollView添加一个点击的手势 4.在手势方法里调用block，并传入图片索引 无限轮播Demo小样 重要的部分代码中都有相应的注解和文字打印，运行程序可以很直观的表现，可否点个 Star 正反无限轮播（2张）大致原理：最底层是一个UIView，上面有一个UIScrollView以及UIPageControl，scrollView上有两个UIImageView，imageView宽高 = scrollview宽高 = view宽高; 假设轮播控件的宽度为x高度为y，我们设置scrollview的contentSize.width为3x，并让scrollview的水平偏移量为x，既显示最中间内容。 具体细节请移步这里阅读：轮播两个ImageView实现 http://www.jianshu.com/p/ef03ec7f23b2 【@码员真爱 : 真的不点进去阅读一下 ❓】【译文 &amp; 源码】 【工具类】 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>封装</category>
      </categories>
      <tags>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 封装思维—业务逻辑类]]></title>
    <url>%2FEncapsulationThinking%2Fbusiness.html</url>
    <content type="text"><![CDATA[本篇文章主要从【简易-封装业务逻辑类】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： 选择根控制器类 存储工具类1.NSUserDefaults 偏好设置，(版本号)存储和取值 1. 选择根控制器类方法：1234567// LNRootVC.h#import &lt;Foundation/Foundation.h&gt;@interface LNRootVC : NSObject/** 选择根控制器 */+ (UIViewController *)chooseWindowRootVC;@end 1234567891011121314151617181920212223242526272829303132// LNRootVC.m#import "LNSaveTool.h"#import "LNRootVC.h"#import "LNTabBarVC.h"#import "LNGuidePageCollectionVC.h"# define LNVersion @"version"@implementation LNRootVC+ (UIViewController *)chooseWindowRootVC &#123; // 1.获取当前版本号 NSString *curVersion = [NSBundle mainBundle].infoDictionary[@"CFBundleShortVersionString"]; NSLog(@"%@",curVersion); // 2.上一次版本号(NSUserDefaults工具类) NSString *lastVersion = [LNSaveTool objectForKey:LNVersion]; // 3.比较版本号 UIViewController *rootVC; if ([curVersion isEqualToString:lastVersion]) &#123; // 进入主框架 rootVC = [[LNTabBarVC alloc] init]; &#125; else &#123; // 进入新特性界面 rootVC = [[LNGuidePageCollectionVC alloc] init]; // NSUserDefaults偏好设置工具类 [LNSaveTool setObject:curVersion forKey:LNVersion]; &#125; return rootVC;&#125;@end 调用：12// 设置窗口的根控制器self.window.rootViewController = [LNRootVC chooseWindowRootVC]; 2. 存储工具类 解决:1.采用 NSUserDefaults 偏好设置，(版本号)存储和取值 1. NSUserDefaults偏好设置，存储和取值方法：123456789101112// LNSaveTool.h#import &lt;Foundation/Foundation.h&gt;@interface LNSaveTool : NSObject/** NSUserDefaults工具类:存储 */+ (void)setObject:(nullable id)value forKey:(NSString *)defaultName;/** NSUserDefaults工具类:取值 */+ (nullable id)objectForKey:(NSString *)defaultName;@end 123456789101112131415161718// LNSaveTool.m#import "LNSaveTool.h"@implementation LNSaveTool+ (void)setObject:(nullable id)value forKey:(NSString *)defaultName &#123; if (defaultName) &#123; // 需要屏蔽一下外界(传空) [[NSUserDefaults standardUserDefaults] setObject:value forKey:defaultName]; [[NSUserDefaults standardUserDefaults] synchronize];// 强制同步 &#125;&#125;+ (nullable id)objectForKey:(NSString *)defaultName &#123; return [[NSUserDefaults standardUserDefaults] objectForKey:defaultName];&#125;@end 调用：12345// 存储[LNSaveTool setObject:curVersion forKey:@"version"];// 取值NSString *lastVersion = [LNSaveTool objectForKey:@"version"];]]></content>
      <categories>
        <category>封装</category>
      </categories>
      <tags>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIBezierPath译文]]></title>
    <url>%2FAppleTranslation%2FUIBezierPathApple.html</url>
    <content type="text"><![CDATA[引导 记得刚接触 iOS 的时候, 第一次看到绘图和动画做出来的效果时，只有一个感觉酷！高大上！(默默下决心我要学会☺).在写出这些牛X效果的前提 贝塞尔曲线这个东西我觉得要做到初步理解，然后梳理总结，到最后夯实基础、活学活用。 【码员真爱 : 真的不点进去阅读一下 ❓】【译文 &amp; 源码】 【工具类】 正题在这里首先附上官方原文地址 UIBezierPath Class &amp; UIBezierPath.h 属性和方法 Relationships Inherits From NSObject 继承自: NSObject Conforms To NSCoding, NSCopying 遵守: NSCoding，NSObject Framework: UIKit in iOS 3_2 iOS 3.2+ ClassUIBezierPath The UIBezierPath class lets you define a path consisting of straight and curved line segments and render that path in your custom views.You use this class initially to specify just the geometry for your path. Paths can define simple shapes such as rectangles, ovals, and arcs or they can define complex polygons that incorporate a mixture of straight and curved line segments.After defining the shape, you can use additional methods of this class to render the path in the current drawing context. UIBezierPath 类允许你在自定义的 View 中绘制和渲染由直线和曲线组成的路径. 你可以在初始化的时候, 直接为你的 UIBezierPath 指定一个几何路径. 路径可以是简单的几何图形例如: 矩形、椭圆、弧线之类的, 也可以是相对比较复杂的由直线和曲线组成的多边形. 当你定义完图形以后, 你可以使用这个类的其他的方法将你的路径直接绘制在当前的绘图上下文中. Overview A UIBezierPath object combines the geometry of a path with attributes that describe the path during rendering. You set the geometry and attributes separately and can change them independent of one another. Once you have the object configured the way you want it, you can tell it to draw itself in the current context. Because the creation, configuration, and rendering process are all distinct steps, Bezier path objects can be reused easily in your code. You can even use the same object to render the same shape multiple times, perhaps changing the rendering options between successive drawing calls. UIBezierPath 是由几何路径 和 属性描述组成的, 属性是用来在渲染阶段描绘几何路径的, 比如线宽之类的东西. 路径和属性是完全独立的, 他们并不互相依赖, 你可以分开分开去设置他们. 一旦你以自己喜欢的方式配置了 UIBezierPath 对象, 你就可以调用方法通知UIBezierPath 在当前的绘图上下文中绘制图形了. 因为创建、 配置、 渲染路径等操作, 都是完全不同的步骤, 所以你可以在你的代码中非常容易的对UIBezierPath 对象进行复用. 你甚至可以使用同一个 UIBezierPath 对象去渲染同一个图形很多次, 你也可以再多次渲染的间隔中, 修改属性来渲染出不同样式的路径. You set the geometry of a path by manipulating the path’s current point. When you create a new empty path object, the current point is undefined and must be set explicitly. To move the current point without drawing a segment, you use the moveToPoint:method. All other methods result in the addition of either a line or curve segments to the path. The methods for adding new segments always assume you are starting at the current point and ending at some new point that you specify. After adding the segment, the end point of the new segment automatically becomes the current point. 你可以通过控制路径的当前的(起始)点来设置一条路径的形状，当你创建了一个空的UIBezierPath 对象时, 起始点currentPoint 这个属性是未定义的, 你需要手动的去设置.currentPoint. 如果你希望在不绘制任何线条的情况下移动currentPoint, 你可以使用 moveToPoint:方法. 其他的方法都会导致在你的路径中添加额外的直线或曲线. 所有构造路径相关的方法, 都会以当前路径的currentPoint 为起点, 以你指定的endPoint为终点进行绘制. 当完成绘制之后, 会自动将新增的这条线的终点设置为UIBezierPath 对象的currentPoint. A single Bezier path object can contain any number of open or closed subpaths, where each subpath represents a connected series of path segments. Calling the closePath method closes a subpath by adding a straight line segment from the current point to the first point in the subpath. Calling the moveToPoint: method ends the current subpath (without closing it) and sets the starting point of the next subpath. The subpaths of a Bezier path object share the same drawing attributes and must be manipulated as a group. To draw subpaths with different attributes, you must put each subpath in its own UIBezierPath object. 一个单一的贝塞尔路径对象能够包含任意数量的开放和闭合的子路径,在这些路径的线段中，每一个线段都是串联的. 调用closePath方法将会闭合路径, 它将会从currentPoint 到 子路经的 firstPoint起点绘制一条直线. 调用moveToPoint:方法将会结束当前的子路径, 但是并不会自动闭合当前的自路径, 并且会将currentPoint 移动到指定的点, 也就是下一条绘制路径的起始点.UIBezierPath中所有的自路径都会共享同样的绘图属性. 如果你希望绘制一些子路径, 但是不适用相同的绘图属性, 那么你就只能创建很多的UIBezierPath 对象来承载每一条路径. After configuring the geometry and attributes of a Bezier path, you draw the path in the current graphics context using the stroke and fill methods. The stroke method traces the outline of the path using the current stroke color and the attributes of the Bezier path object. Similarly, the fill method fills in the area enclosed by the path using the current fill color. (You set the stroke and fill color using the UIColor class.) 当你为UIBezierPath 对象配置完几何路径和绘图属性之后, 你就可以使用stroke描边(空心) 和 fill填充(实心) 方法在当前的绘图上下文中进行绘制了. stroke方法将会使用当前的strokeColor 和 绘图属性来描绘曲线的轮廓. 同样的, fill 方法将会使用fillColor 来填充路径所围成的图形(使用UIColor 类方法来设置strokeColor 和 fillColor). In addition to using a Bezier path object to draw shapes, you can also use it to define a new clipping region. The addClip method intersects the shape represented by the path object with the current clipping region of the graphics context. During subsequent drawing, only content that lies within the new intersection region is actually rendered to the graphics context. 除了可以用贝塞尔路径对象去绘制图形,你还可以利用它去定义个新的裁剪区域.addClip方法通过当前图形上下文裁剪的区域的路径对象来表示两个图形的相交. 在随后的绘制过程中,只有处在新的交集区域内的内容实际上是被图形上下文绘制的 然后我们就直接从UIBezierPath.h 入手吧 UIBezierPath.h 创建 UIBezierPath 创建并且返回一个新的 UIBezierPath 对象 12// Objective-C+ (instancetype)bezierPath; 通过一个矩形, 创建并且返回一个新的 UIBezierPath 对象 123456789/** * 画矩形 * 该方法将会创建一个闭合路径, 起始点是 rect 参数的的 origin, 并且按照顺时针方向添加直线, 最终形成矩形 * @param rect: 矩形路径的 Frame */// Swiftconvenience init(rect rect: CGRect)// Objective-C+ (instancetype)bezierPathWithRect:(CGRect)rect; 通过一个指定的矩形中的椭圆形, 创建并且返回一个新的 UIBezierPath 对象 123456789/** * 画圆（width = height）、画椭圆（width != height） * 该方法将会创建一个闭合路径, 该方法会通过顺时针的绘制贝塞尔曲线, 绘制出一个近似椭圆的形状. 如果 rect 参数指定了一个矩形, 那么该 UIBezierPath 对象将会描述一个圆形. * @param rect: 矩形路径的 Frame */// Swiftconvenience init(ovalInRect rect: CGRect)// Objective-C+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect; 根据一个圆角矩形, 创建并且返回一个新的 UIBezierPath 对象 1234567891011/** * 画圆角矩形 * 该方法将会创建一个闭合路径, 该方法会顺时针方向连续绘制直线和曲线. 当 rect 为正方形时且 cornerRadius 等于边长一半时, 则该方法会描述一个圆形路径. * @param rect: 矩形路径的 Frame * @param cornerRadius: 矩形的圆角半径 */// Swiftconvenience init(roundedRect rect: CGRect, cornerRadius cornerRadius: CGFloat)// Objective-C + (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius; // rounds all corners with the same horizontal and vertical radius 根据一个圆角矩形, 创建并且返回一个新的 UIBezierPath 对象 12345678910111213/** * 画指定角为圆角的矩形 * 该方法将会创建一个闭合路径, 该方法会顺时针方向连续绘制直线和曲线. * @param rect: 矩形路径的 Frame * @param corners: UIRectCorner 枚举类型, 指定矩形的哪个角变为圆角 * @param cornerRadii: 矩形的圆角半径 */// Swiftconvenience init(roundedRect rect: CGRect, byRoundingCorners corners: UIRectCorner, cornerRadii cornerRadii: CGSize)// Objective-C + (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii; 通过一个圆弧, 创建并且返回一个新的 UIBezierPath 对象 1234567891011121314151617/** * 画圆弧 * 该方法会创建出一个开放路径, 创建出来的圆弧是圆的一部分. 在默认的坐标系统中, 开始角度 和 结束角度 都是基于单位圆的(看下面这张图). 调用这个方法之后, currentPoint 将会设置为圆弧的结束点. * @param center: 弧所在的圆心（这里不能直接用self.center,因为它是相对于它的父控件的,采用rect 宽度*0.5、高度*0.5） * @param radius: 圆的半径 * @param startAngle: 开始角度 * @param endAngle: 结束角度 * @param clockwise: 是否顺时针绘制（YES顺时针 NO逆时针） */// Swiftconvenience init(arcCenter center: CGPoint, radius radius: CGFloat, startAngle startAngle: CGFloat, endAngle endAngle: CGFloat, clockwise clockwise: Bool)// Objective-C + (instancetype)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise; 通过一个 CGPath, 创建并且返回一个新的 UIBezierPath 对象 1234// Swiftconvenience init(CGPath CGPath: CGPath)// Objective-C+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath; 创建并返回一个新的BezierPath, 这个 BezierPath 的方向是原 BezierPath 的反方向 123456789 // Modified paths/** * 通过该方法反转一条路径, 并不会修改该路径的样子. 它仅仅是修改了绘制的方向 * @return: 返回一个新的 UIBezierPath 对象, 形状和原来路径的形状一样,但是绘制的方向相反. */// Swiftfunc bezierPathByReversingPath() -&gt; UIBezierPath// Objective-C - (UIBezierPath *)bezierPathByReversingPath NS_AVAILABLE_IOS(6_0); 构造路径 将 UIBezierPath 对象的 currentPoint 移动到指定的点 12345678910 // Path construction/** * 设置起点 * 如果当前有正在绘制的子路径, 该方法则会隐式的结束当前路径, 并将 currentPoint 设置为指定点. * @param point: 当前坐标系统中的某一点 */// Swiftfunc moveToPoint(_ point: CGPoint)// Objective-C - (void)moveToPoint:(CGPoint)point; 在当前子路径中追加一条直线 12345678910111213/** * 添加一根线到终点 * 该方法将会从 currentPoint 到 指定点 链接一条直线. * @param point: 绘制直线的终点坐标, 当前坐标系统中的某一点 * Note: 在追加完这条直线后, 该方法将会更新 currentPoint 为 指定点 调用该方法之前, 你必须先设置 currentPoint. 如果当前绘制路径 为空, 并且未设置 currentPoint, 那么调用该方法将不会产生任何 效果. */// Swiftfunc addLineToPoint(_ point: CGPoint)// Objective-C - (void)addLineToPoint:(CGPoint)point; 在当前子路径中追加一条圆弧 1234567891011/** * 画指定一条圆弧 * 该方法将会从 currentPoint 添加一条指定的圆弧. * 该方法的介绍和 bezierPathWithArcCenter构造方法中的一样. 请前往上文查看 * @param center: 圆心 * @param radius: 半径 * @param startAngle: 开始角度 * @param endAngle: 结束角度 * @param clockwise: 是否顺时针绘制 */ - (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise NS_AVAILABLE_IOS(4_0); 在当前 子路经中追加一条 二次贝塞尔曲线 1234567891011121314151617/** * 画二次贝塞尔曲线（由一个控制点来控制） * 该方法将会从 currentPoint 到 指定的 endPoint 追加一条二次贝塞尔曲线. * currentPoint、endPoint、controlPoint 三者的关系最终定义了二次贝塞尔曲线的形状. * 二次贝塞尔曲线的弯曲由一个控制点来控制. 如下图所示 Note: 调用该方法前, 你必须先设置 currentPoint, 如果路径为空, 并且尚未设置 currentPoint, 调用该方法则不会产生任何效果. 当添加完贝塞尔曲线后, 该方法将会自动更新 currentPoint 为 指定的结束点 * @param endPoint: 终点 * @param controlPoint: 弯曲方向点1 */// Swiftfunc addQuadCurveToPoint(_ endPoint: CGPoint, controlPoint controlPoint: CGPoint)// Objective-C - (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint; 在当前 子路经中追加一条 三次贝塞尔曲线 12345678910111213141516171819/** * 在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量@原创简书-码员白开水ln。 * 画三次贝塞尔曲线（由两个控制点来控制） * 该方法将会从 currentPoint 到 指定的 endPoint 追加一条三次贝塞尔曲线. * 三次贝塞尔曲线的弯曲由两个控制点来控制. 如下图所示 * Note: 调用该方法前, 你必须先设置 currentPoint, 如果路径为空, 并且尚未设置 currentPoint, 调用该方法则不会产生任何效果. 当添加完贝塞尔曲线后, 该方法将会自动更新 currentPoint 为 指定的结束点 * @param endPoint: 终点 * @param controlPoint1: 弯曲方向点1 * @param controlPoint2: 弯曲方向点2 */// Swiftfunc addCurveToPoint(_ endPoint: CGPoint, controlPoint1 controlPoint1: CGPoint, controlPoint2 controlPoint2: CGPoint)// Objective-C - (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2; 关闭当前子路经 12345678910/** * 闭合路径 * 该方法将会从 currentPoint 到子路经的起点 绘制一条直线, * 以此来关闭当前的自路径. 紧接着该方法将会更新 currentPoint * 为 刚添加的这条直线的终点, 也就是当前子路经的起点. */// Swiftfunc closePath()// Objective-C- (void)closePath; 移除 UIBezierPath 对象中的所有点, 效果也就等同于移除所有子路经 1234// Swiftfunc removeAllPoints()// Objective-C- (void)removeAllPoints; 将指定 UIBezierPath 中的内容添加到当前 UIBezierPath 对象中 123456789/** * 追加路径 * 该方法将会在当前 UIBezierPath 对象的路径中追加 * 指定的 UIBezierPath 对象中的内容. */// Swiftfunc appendPath(_ bezierPath: UIBezierPath)// Objective-C- (void)appendPath:(UIBezierPath *)bezierPath; UIBezierPath 中的 CGPath 对象 1234567891011/** * 获取这个属性, 你将会获得一个不可变的 CGPathRef 对象, * 他可以传入 CoreGraphics 提供的函数中 * 你可以是用 CoreGraphics 框架提供的方法创建一个路径, * 并给这个属性赋值, 当时设置了一个新的路径后, * 这个将会对你给出的路径对象进行 Copy 操作 */// Swiftvar CGPath: CGPath// Objective-C@property(nonatomic) CGPathRef CGPath; 绘图路径中的当前点 12345678/** * 该属性的值, 将会是下一条绘制的直线或曲线的起始点. * 如果当前路径为空, 那么该属性的值将会是 CGPointZero */// Swiftvar currentPoint: CGPoint &#123; get &#125;// Objective-C@property(nonatomic, readonly) CGPoint currentPoint; 绘图属性 线宽 1234567/** * 线宽属性定义了 `UIBezierPath` 对象中绘制的曲线规格. 默认为: 1.0 */// Swiftvar lineWidth: CGFloat// Objective-C@property(nonatomic) CGFloat lineWidth; 曲线终点样式 1234567891011121314/** * 该属性应用于曲线的终点和起点. 该属性在一个闭合子路经中是无效果的. 默认为: kCGLineCapButt */// Swiftvar lineCapStyle: CGLineCap// Objective-C@property(nonatomic) CGLineCap lineCapStyle;/* Line cap styles. */typedef CF_ENUM(int32_t, CGLineCap) &#123; kCGLineCapButt,// kCGLineCapRound,// 圆弧 kCGLineCapSquare //&#125;; 曲线连接点样式 1234567891011121314/** * 默认为: kCGLineJoinMiter. */// Swiftvar lineJoinStyle: CGLineJoin// Objective-C@property(nonatomic) CGLineJoin lineJoinStyle;/* Line join styles. */typedef CF_ENUM(int32_t, CGLineJoin) &#123; kCGLineJoinMiter,// 尖的 kCGLineJoinRound,// 圆弧 kCGLineJoinBevel // 斜面&#125;; 内角和外角距离 12345678910111213/** * 斜接点长度 * 两条线交汇处内角和外角之间的最大距离, 只有当连接点样式为 kCGLineJoinMiter * 时才会生效，最大限制为10 * 我们都知道, 两条直线相交时, 夹角越小, 斜接长度就越大. * 该属性就是用来控制最大斜接长度的. * 当我们设置了该属性, 如果斜接长度超过我们设置的范围, * 则连接处将会以 kCGLineJoinBevel 连接类型进行显示. */// Swiftvar miterLimit: CGFloat// Objective-C@property(nonatomic) CGFloat miterLimit; 渲染精度 12345678910111213/** * 该属性用来确定渲染曲线路径的精确度. * 该属性的值用来测量真实曲线的点和渲染曲线的点的最大允许距离. * 值越小, 渲染精度越高, 会产生相对更平滑的曲线, 但是需要花费更 * 多的计算时间. 值越大导致则会降低渲染精度, 这会使得渲染的更迅速. flatness 的默认值为 0.6. * Note: 大多数情况下, 我们都不需要修改这个属性的值. 然而当我们 希望以最小的消耗去绘制一个临时的曲线时, 我们也许会临时增 大这个值, 来获得更快的渲染速度. */// Swiftvar flatness: CGFloat// Objective-C@property(nonatomic) CGFloat flatness; 是否使用基偶填充规则 12345678/** * 设置为 YES, 则路径将会使用 基偶规则 (even-odd) 进行填充. * 设置为 NO, 则路径将会使用 非零规则 (non-zero) 规则进行填充. */// Swiftvar usesEvenOddFillRule: Bool// Objective-C@property(nonatomic) BOOL usesEvenOddFillRule; 虚线 1234567891011121314151617181920212223/** * @param pattern: 该属性是一个 C 语言的数组, 其中每一个元素都是 CGFloat 数组中的元素代表着线段每一部分的长度, 第一个元素代表线段的第一条线, 第二个元素代表线段中的第一个间隙. 这个数组中的值是轮流的. 来解释一下 什么叫轮流的. * 举个例子: 声明一个数组 CGFloat dash[] = @&#123;3.0, 1.0&#125;; 这意味着绘制的虚线的第一部分长度为3.0, 第一个间隙长度为1.0, 虚线的 第二部分长度为3.0, 第二个间隙长度为1.0. 以此类推. * @param count: 这个参数是 pattern 数组的个数 * @param phase: 这个参数代表着, 虚线从哪里开始绘制. * 举个例子: 这是 phase 为 6. pattern[] = @&#123;5, 2, 3, 2&#125;; 那么虚线将会 第一个间隙的中间部分开始绘制, 如果不是很明白就请继续往下看, 下文实战部分会对虚线进行讲解. */// Swiftfunc setLineDash(_ pattern: UnsafePointer&lt;CGFloat&gt;,count count: Int,phase phase: CGFloat)// Objective-C- (void)setLineDash:(const CGFloat *)pattern count:(NSInteger)count phase:(CGFloat)phase; 重新获取虚线的模式 123456789101112131415/** * 该方法可以重新获取之前设置过的虚线样式. * Note: pattern 这个参数的容量必须大于该方法返回数组的容量. 如果无法确定数组的容量, 那么可以调用两次该方法, 第一次 调用该方法的时候, 传入 count 参数, 然后在用 count 参数 来申请 pattern 数组的内存空间. 然后再第二次正常的调用该方法 */// Swiftfunc getLineDash(_ pattern: UnsafeMutablePointer&lt;CGFloat&gt;,count count: UnsafeMutablePointer&lt;Int&gt;,phase phase: UnsafeMutablePointer&lt;CGFloat&gt;)// Objective-C- (void)getLineDash:(CGFloat *)pattern count:(NSInteger *)count phase:(CGFloat *)phase; 绘制路径 填充路径 1234567891011/** * 填充（实心） * 该方法当前的填充颜色 和 绘图属性对路径的封闭区域进行填充. * 如果当前路径是一条开放路径, 该方法将会隐式的将路径进行关闭后进行填充 * 该方法在进行填充操作之前, 会自动保存当前绘图的状态, 所以我们不需要 * 自己手动的去保存绘图状态了. */// Swiftfunc fill()// Objective-C- (void)fill; 混合模式进行填充 12345678910111213141516/** * 该方法当前的填充颜色 和 绘图属性 (外加指定的混合模式 和 透明度) * 对路径的封闭区域进行填充. 如果当前路径是一条开放路径, 该方法将 * 会隐式的将路径进行关闭后进行填充 * 该方法在进行填充操作之前, 会自动保存当前绘图的状态, 所以我们不需要 * 自己手动的去保存绘图状态了. * * @param blendMode: 混合模式决定了如何和已经存在的被渲染过的内容进行合成 * @param alpha: 填充路径时的透明度 */// Swiftfunc fillWithBlendMode(_ blendMode: CGBlendMode,alpha alpha: CGFloat)// Objective-C- (void)fillWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha; 描边路径 1234// Swiftfunc stroke()// Objective-C- (void)stroke; 混合模式进行填充 123456789/** * @param blendMode: 混合模式决定了如何和已经存在的被渲染过的内容进行合成 * @param alpha: 填充路径时的透明度 */// Swiftfunc strokeWithBlendMode(_ blendMode: CGBlendMode,alpha alpha: CGFloat)// Objective-C- (void)strokeWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha; 剪切路径 剪切路径 123456789101112131415/** * 该方法将会修改当前绘图上下文的可视区域. * 当调用这个方法之后, 会导致接下来所有的渲染操作, 只会在剪切下来的区域内进行, 区域外的内容将不会被渲染. * 如果你希望执行接下来的绘图时, 删除剪切区域, 那么你必须在调用该方法前, 先使用CGContextSaveGState 方法保存当前的绘图状态, 当你不再需要这个剪切区域的时候, 你只需要使用 CGContextRestoreGState 方法， 来恢复之前保存的绘图状态就可以了. * @param blendMode: 混合模式决定了如何和已经存在的被渲染过的内容进行合成 * @param alpha: 填充路径时的透明度 */// Swiftfunc addClip()// Objective-C- (void)addClip; Hit Detection 是否包含某个点 123456789101112131415/** * 该方法返回一个布尔值, 当曲线的覆盖区域包含 * 指定的点(内部点)， 则返回 YES, 否则返回 NO. * Note: 如果当前的路径是一个开放的路径, 那么 就算指定点在路径覆盖范围内, 该方法仍然会 返回 NO, 所以如果你想判断一个点是否在一个 开放路径的范围内时, 你需要先Copy一份路径, 并调用 -(void)closePath; 将路径封闭, 然后 再调用此方法来判断指定点是否是内部点. * @param point: 指定点. */// Swiftfunc containsPoint(_ point: CGPoint) -&gt; Bool// Objective-C- (BOOL) containsPoint:(CGPoint)point; 路径是否为空 123456789/** * 检测当前路径是否绘制过直线或曲线. * Note: 记住, 就算你仅仅调用了 moveToPoint 方法 那么当前路径也被看做不为空. */// Swiftvar empty: Bool &#123; get &#125;// Objective-C@property (readonly, getter=isEmpty) BOOL empty; 路径覆盖的矩形区域 123456789/** * 该属性描述的是一个能够完全包含路径中所有点 * 的一个最小的矩形区域. 该区域包含二次贝塞尔 * 曲线和三次贝塞尔曲线的控制点. */// Swiftvar bounds: CGRect &#123; get &#125;// Objective-C@property (nonatomic, readonly) CGRect bounds; Apply Transform 12345678/** * 该方法将会直接对路径中的所有点进行指定的放射 * 变换操作. */// Swiftfunc applyTransform(_ transform: CGAffineTransform)// Objective-C- (void)applyTransform:(CGAffineTransform)transform; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Swiftstruct UIRectCorner : OptionSetType &#123;init(rawValue rawValue: UInt)static var TopLeft: UIRectCorner &#123; get &#125;static var TopRight: UIRectCorner &#123; get &#125;static var BottomLeft: UIRectCorner &#123; get &#125;static var BottomRight: UIRectCorner &#123; get &#125;static var AllCorners: UIRectCorner &#123; get &#125;&#125;// Objective-Cenum &#123;UIRectCornerTopLeft = 1 &lt;&lt; 0,UIRectCornerTopRight = 1 &lt;&lt; 1,UIRectCornerBottomLeft = 1 &lt;&lt; 2,UIRectCornerBottomRight = 1 &lt;&lt; 3,UIRectCornerAllCorners = ~0&#125;;typedef NSUInteger UIRectCorner;常数(Constants):UIRectCornerTopLeftThe top-left corner of the rectangle.矩形的左上角.Available in iOS 3.2 and later.UIRectCornerTopRightThe top-right corner of the rectangle.矩形的右上角.Available in iOS 3.2 and later.UIRectCornerBottomLeftThe bottom-left corner of the rectangle.矩形的左下角.Available in iOS 3.2 and later.UIRectCornerBottomRightThe bottom-right corner of the rectangle.矩形的右下角.Available in iOS 3.2 and later.UIRectCornerAllCornersAll corners of the rectangle.矩形的所有的角.Available in iOS 3.2 and later.指定的常数反映了一个没有被 仿射变换修改和已经在默认坐标系上绘制的矩形的所有角.(原点在左上角和 ??扩散的值(positive values)向下延伸到右边).导入声明(Import Statement)// Swiftimport UIKit// Objective-C@import UIKit; 实战示例UIBezierPath.h 文件大家完全的过了一遍了, 其实看上去还是蛮简单过的昂.. 接下来就到了激动人心的实战环节了. 我们来简单的写几句代码, 看看效果吧.1、bezierPathByReversingPath:路径反转12345678910111213141516171819202122232425- (void) drawRect:(CGRect)rect &#123; // 1. 随便画一个路径出来. UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint: CGPointMake(10, 10)]; [path addLineToPoint: CGPointMake(80, 40)]; [path addLineToPoint: CGPointMake( 40, 80)]; [path addLineToPoint: CGPointMake(40, 40)]; path.lineWidth = 3; // 2. 为这条路径制作一个反转路径 UIBezierPath *reversingPath = [path bezierPathByReversingPath]; reversingPath.lineWidth = 3; // 3. 为了避免两条路径混淆在一起, 我们为第一条路径做一个位移 CGAffineTransform transform = CGAffineTransformMakeTranslation(200, 0); [path applyTransform: transform]; // 4. 设置颜色, 并绘制路径 [[UIColor redColor] set]; [path stroke]; [[UIColor greenColor] set]; [reversingPath stroke];&#125; 效果： 2、setLineDash: 虚线1234567891011121314151617181920212223242526272829303132333435363738- (void) typeDashLine &#123; // 1. 先创建三条路径, 有对比更有助于理解 UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint: CGPointMake(80, 40)]; [path addLineToPoint: CGPointMake(self.frame.size.width - 40, 40)]; path.lineWidth = 2; UIBezierPath *path1 = [UIBezierPath bezierPath]; [path1 moveToPoint: CGPointMake(80, 80)]; [path1 addLineToPoint: CGPointMake(self.frame.size.width - 40, 80)]; path1.lineWidth = 2; UIBezierPath *path2 = [UIBezierPath bezierPath]; [path2 moveToPoint: CGPointMake(80, 120)]; [path2 addLineToPoint: CGPointMake(self.frame.size.width - 40, 120)]; path2.lineWidth = 2; // 2. 这部分是配置三条路径虚线的规格, 重点主要是这部分. CGFloat dashLineConfig[] = &#123;8.0, 4.0&#125;; [path setLineDash: dashLineConfig count: 2 phase: 0]; CGFloat dashLineConfig1[] = &#123;8.0, 4.0, 16.0, 8.0&#125;; [path1 setLineDash: dashLineConfig1 count: 4 phase: 0]; CGFloat dashLineConfig2[] = &#123;8.0, 4.0, 16.0, 8.0&#125;; [path2 setLineDash: dashLineConfig2 count: 4 phase: 12]; // 3. 绘制 [[UIColor orangeColor] set]; [path stroke]; [path1 stroke]; [path2 stroke];&#125; 效果： 要想做出多牛逼酷炫的动画效果，就必须承受同等学习的代价 ！ 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 文件解析—「Plist & XML & JSON」]]></title>
    <url>%2FiOSNET%2FPlistXMLJSON.html</url>
    <content type="text"><![CDATA[本文主要介绍了Plist、XML和JSON数据解析的基本知识，并展示了NSXMLParser方法、GDataXML第三方库以及NSJSONSerialization方法的实际运用案例。 目录： Plist解析本地plist文件解析 JSON解析JSON相关说明本地Json文件解析网络Json文件解析 XML解析NSXMLParser解析GDataXML解析 总结 1.Plist解析本地plist文件解析 123456789101112131415// 数据数组- (NSMutableArray *)dataArray &#123; if (!_dataArray) &#123; // 1.加载plist文件（根类型是数组 或 是字典） NSArray *fileArr = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"apps.plist" ofType:nil]]; // 2.创建临时数组 NSMutableArray *temp = [NSMutableArray array]; // 3.字典数组转模型数组 for (NSDictionary *dict in fileArr) &#123; [temp addObject:[LNApp imageWithDict:dict]]; &#125; _dataArray = temp; &#125; return _dataArray;&#125; 2.JSON解析1.JSON介绍121.JSON是一种轻量级的数据格式，一般用于数据交互2.服务器返回给客户端的数据，一般都是JSON格式或者XML格式（文件下载除外） 2.JSON相关说明1234561.JSON文档有两种结构: **对象**：以 `&#123;` 开始，以 `&#125;` 结束，是 `名称/值` 对儿的集合。名称和值中间用 `:` 隔开。多个 `名称/值` 对之间用 `,` 隔开。类似Objective-C的NSDictionary。示例: `&#123;"name" : "jack", "age" : 10&#125;` **数组**：以 `[` 开始,以 `]` 结束，中间是数据。数据以 `,` 分割。类似Objective-C的 NSArray。不同的JSON结构有不同的转化方式。示例: `&#123;"names" : ["jack", "rose", "jim"]&#125;` JSON格式与Objective-C转化对照表 JSON Objective-C 大括号{} NSDictionary 中括号[] NSArray 双引号“” NSString 数字{} NSNumber 3.JSON解析方案 JSON解析方案 第三方框架 JSONKit\SBJSON\TouchJSON 苹果原生 NSJSONSerialization(性能最好) 123456789101112采用 NSJSONSerialization--&gt;JSON解析JSON数据---&gt;OC对象(字典或数组)：反序列化[NSJSONSerialization JSONObjectWithData: options: error:]OC对象(字典或数组)---&gt;JSON数据：序列化[NSJSONSerialization dataWithJSONObject: options: error:]NSString 转 DataNSData *data = [strM dataUsingEncoding:NSUTF8StringEncoding];Data 转 NSString (data本质上是一个json字符串)NSString *str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; 4.本地Json文件解析12345678910111213// 1.加载本地json文件NSString *jsonPath = [[NSBundle mainBundle] pathForResource:@"123.json" ofType:nil];//NSString *jsonStr = [NSString stringWithContentsOfFile:jsonPath encoding:NSUTF8StringEncoding error:nil];//NSData *data = [json dataUsingEncoding:NSUTF8StringEncoding];// 2.NSString 转 NSData对象NSData *data = [[NSData alloc] initWithContentsOfFile:jsonPath];// 3.JSON---&gt;OC对象,反序列化NSArray *array = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];for (NSDictionary *dict in array) &#123; NSLog(@"localJson--%@",dict[@"name"]);&#125; 5.网络Json文件解析1234567891011121314151617181920212223242526272829// JSON数据---&gt;OC对象(字典或数组) 反序列化-(void)jsonToOC &#123; // 1.确定url NSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/login?username=520&amp;pwd=520&amp;type=JSON"]; // 2.发送异步请求 /** Request 请求对象 queue 队列,决定后面Block块在那个线程执行(主线程或子线程) */ [NSURLConnection sendAsynchronousRequest:[NSURLRequest requestWithURL:url] queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; // 3.解析数据 /** Data:二进制数据 options:返回数据类型（如果位移枚举第一个枚举值不为0,可以默认传 0或kNilOptions 表示性能最好） NSJSONReadingMutableContainers = (1UL &lt;&lt; 0), 可变字典和数组 NSJSONReadingMutableLeaves = (1UL &lt;&lt; 1), 内部所有的字符串都是可变的 ios7之后又问题 一般不用 NSJSONReadingAllowFragments = (1UL &lt;&lt; 2) 既不是字典也不是数组,则必须使用该枚举值 error:错误信息 */ NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil]; NSLog(@"%@",dict); // 面向模型开发 *+ // 字典数组---&gt;模型数组(数据数组) for (NSDictionary *dict in dictM[@"videos"]) &#123; [self.videos addObject:[LNVideos videoWithDict:dict]]; &#125; &#125;];&#125; OC对象(字典或数组)—&gt;JSON数据/序列化12345678910111213141516171819NSDictionary *dictM = @&#123; @"name":@"LN", @"age":@3 &#125;;NSArray *arrayM = @[@"123",@"456"];NSString *strM = @"WENIDNGDING";// 序列化方法:判断OC对象能否转换为JSON？BOOL isValid = [NSJSONSerialization isValidJSONObject:strM];if (!isValid) &#123; NSLog(@"%zd",isValid); return;&#125;// OC---&gt;JSON// options:NSJSONWritingPrettyPrinted对转换之后的JSON对象进行排版，无意义NSData *data = [NSJSONSerialization dataWithJSONObject:dictM options:NSJSONWritingPrettyPrinted error:nil];// 要转换为String的二进制数据,编码方式，通常采用NSUTF8StringEncodingNSLog(@"%@",[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]); 注意：并不是所有的OC对象都能转换为JSON 1.最外层必须是 NSArray or NSDictionary 2.所有的元素必须是 NSString, NSNumber, NSArray, NSDictionary, or NSNull 3.字典中所有的key都必须是 NSStrings类型的 4.NSNumbers不能死无穷大 3.XML解析1.XML介绍1231.XML：可扩展标记语言2.XML文档的三部分（声明、元素和属性）3.其它注意点（注意不能交叉包含、空行换行、XML文档只能有一个根元素等） 2.XML解析12345iOS中苹果官方提供了 NSXMLParser 和 libxml2 两种XML解析方式，也可以用第三方库 GDataXML 执行XML解析。 NSXMLParser 苹果原生，采用 SAX 方式解析。解析过程由NSXMLParserDelegate 协议方法回调。libxml2为基于C语言API的开源库，可以提供 DOM 和 SAX 两种解析方式，但使用比 NSXMLParser 麻烦。GDataXML 基于libxml2库重新封装得到，解析需配置环境和导入 GDataXMLNode 库。 3.XML解析方式:123451.SAX:从根元素开始，按顺序一个元素一个元素的往下解析，可用于解析大、小文件。采用 苹果原生NSXMLParser解析。2.DOM:一次性将整个XML文档加载到内存中，适合较小的文件。采用 第三方框架GDataXML解析。 12345678910GDataXML解析配置环境:1.导入libxml2库文件在General, Linked Frameworks and Libraries点击加号然后搜索libxml2，双击文件即可导入。2.设置libxml2的头文件搜索路径（为了能找到libxml2库的所有头文件）在Build Settings 搜索 Header Search Path中加入 /usr/include/libxml23.设置链接参数（自动链接libxml2库）在Build Settings 搜索 Other Linker Flags中加入 -lxml24.导入GDataXMLNode.h和GDataXMLNode.m文件。5.由于GDataXML是MRC处理的，因此得设置编译参数在Build Phases 选中Compile Sources 找到 GDataXMLNode.m中加入 -fno-objc-arc 声明: 4.NSXMLParser解析123456789101112131415161718192021// NSXMLParser解析，&lt;NSXMLParserDelegate&gt;代理-(void)parserXML &#123; // 1.确定url NSURL *url = [NSURL URLWithString:@"[http://120.25.226.186:32812/video?type=XML"];](http://120.25.226.186:32812/video?type=XML%22];) // 2.发送异步请求 [NSURLConnection sendAsynchronousRequest:[NSURLRequest requestWithURL:url] queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; if (connectionError)&#123;return ;&#125; // 本地XML //NSData *data = [[[NSBundle mainBundle] pathForResource:@"123" ofType:@"xml"] dataUsingEncoding:NSUTF8StringEncoding]; // 3.解析数据 // 1).创建XML解析器 NSXMLParser *parser = [[NSXMLParser alloc] initWithData:data]; // 2).设置代理 parser.delegate = self; // 3).开始解析(注意:parse方法是阻塞的,全部都解析完后才会往下走) [parser parse]; NSLog(@"%@---",parser); &#125;];&#125; 代理方法:12345678910111213141516171819202122232425#pragma mark - NSXMLParserDelegate// 1.开始解析- (void)parserDidStartDocument:(NSXMLParser *)parser &#123; NSLog(@"XML开始解析");&#125;// 2.开始解析某个元素- (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary&lt;NSString *,NSString *&gt; *)attributeDict &#123; NSLog(@"开始解析某个元素%@--%@",elementName,attributeDict); // 这里会多出一个元素是根元素(elementName是videos)，需要过滤根元素 *+ if ([elementName isEqualToString:@"videos"]) &#123; return;&#125; // 字典转模型 [self.videos addObject:[LNVideo mj_objectWithKeyValues:attributeDict]];&#125;// 3.某个元素解析完毕- (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName &#123; NSLog(@"某个元素解析完毕%@--%@",elementName,namespaceURI);&#125;// 4.结束解析- (void)parserDidEndDocument:(NSXMLParser *)parser &#123; NSLog(@"XML结束解析");&#125; NSXMLParser解析打印输出:123456789101112131415161718192016-02-19 13:20:38.341 LNnet[17935:475114] XML开始解析2016-02-19 13:20:38.342 LNnet[17935:475114] 开始解析某个元素videos--&#123; &#125;2016-02-19 13:20:38.342 LNnet[17935:475114] 开始解析某个元素video--&#123;id = 1;image = &quot;resources/images/minion_01.png&quot;;length = 10;name = &quot;\U5c0f\U9ec4\U4eba \U7b2c01\U90e8&quot;;url = &quot;resources/videos/minion_01.mp4&quot;;&#125;2016-02-19 13:20:38.344 LNnet[17935:475114] 某个元素解析完毕video--(null)2016-02-19 13:20:38.344 LNnet[17935:475114] 开始解析某个元素video--&#123;id = 2;image = &quot;resources/images/minion_02.png&quot;;length = 12;name = &quot;\U5c0f\U9ec4\U4eba \U7b2c02\U90e8&quot;;url = &quot;resources/videos/minion_02.mp4&quot;;&#125;2016-02-19 13:20:38.351 LNnet[17935:475114] XML结束解析 5.GDataXML解析按上面讲到的配置环境，进行配置。123456789101112131415161718192021222324252627// GDataXML解析-(void)gdataXML &#123; // 1.确定url NSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/video?type=XML"]; // 2.发送异步请求 [NSURLConnection sendAsynchronousRequest:[NSURLRequest requestWithURL:url] queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; if (connectionError) &#123; return ;&#125; // 3.解析数据 // 1).创建XML文档 GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data options:0 error:nil]; // 2).拿到根元素,得到根元素内部所有名称为video的子元素 NSArray *eles = [doc.rootElement elementsForName:@"video"]; // 3).遍历操作 for (GDataXMLElement *ele in eles) &#123; // 要把元素内部属性 模型 添加到self.videos(模型数组) LNVideo *video = [[LNVideo alloc] init]; video.name = [ele attributeForName:@"name"].stringValue; video.length = [ele attributeForName:@"length"].stringValue; video.image = [ele attributeForName:@"image"].stringValue; video.ID = [ele attributeForName:@"id"].stringValue; video.url = [ele attributeForName:@"url"].stringValue; [self.videos addObject:video]; NSLog(@"%@--",video.name); &#125; &#125;];&#125; GDataXML解析打印输出:1232016-02-19 13:57:54.088 LNnet[18694:496139] 小黄人 第01部--2016-02-19 13:57:54.088 LNnet[18694:496139] 小黄人 第02部--... 4.总结JSON优缺点：优点： 1.数据格式比较简单，易于读写，格式都是压缩的，占用带宽小。 2.这种语言易于解析。 3.支持多种语言，包括ActionScript,C,C#,ColdFusion,Java,JavaScript,Perl,PHP,Python,Ruby等服务器端语言，便于服务器端解析。 4.因为JSON格式能够直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，但是完成的任务不变，且易于维护。 缺点: 1.没有XML格式折这么推广的深入人心和广泛使用，没有XML那么通用 2.JSON格式目前在Web Service中的推广还属于初级阶段 XML优缺点：优点： 1.格式统一，符合标准。 2.容易与其他系统进行远程交互，数据共享比较方便 缺点： 1.XML文件格式庞大，格式复杂，传输占用带宽 2.服务器和客户端都需要花费大量代码来解析XML，不论服务器端还是客户端都使代码变得异常复杂和不容易维护。 3.客户端不同浏览器之间解析XML的方式不一致，需要重复编写很多代码。 4.服务器端和客户端解析XML花费资源和时间。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>文件解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UI控件详解—「UICollectionView综合视图」]]></title>
    <url>%2FiOSUI%2FUICollectionView.html</url>
    <content type="text"><![CDATA[Write in the first【写在最前】 UITableView 熟悉吧， UICollectionView 必须熟悉吧。在WWDC2012中的Introducing Collection Views，苹果首次介绍了UICollectionView，类似UITableView的用法使人很容易接受，但强大的自定义布局，又使其相较于UITableView有了选择它的更多理由，UITableView中的表格只支持单排列表，没有办法支持网格列表模式，CollectionView有着灵活的布局特性，这一点充分说明我们在学会UITableView的基础上，再去学习推敲CollectionView的必要性。 本篇文章主要从【UICollectionView 系统文件注解】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： UICollectionView概念 UICollectionView基本组成 UICollectionView层次结构1.UICollectionView 继承于 UIScrollView2.UICollectionViewDataSource数据源3.UICollectionViewDelegate代理4.UICollectionViewLayout自定义布局对象5.UICollectionViewFlowLayout布局对象(默认)6.UICollectionViewCell样式7.UICollectionViewLayoutAttributes布局属性 UICollectionView与UITableView比较 UICollectionView使用说明 UICollectionView基本使用 自定义FlowLayout：水平滚动相册 UICollectionView效果图 自定义FlowLayout：瀑布流 UICollectionView.h 属性&amp;方法 UICollectionView概念 本着好好学习，了解权威的目的，我们还是主动看官网的说明。 上图释义：管理有序的数据项集合和使用自定制的布局。 通俗点就是：UICollectionView 是一种新的数据展示方式，简单来说可以把他理解成多列的UITableView，可以做九宫格布局的一种view； UICollectionView基本组成 注解：如上图：你看到的就是一个最简单的UICollectionView，它包含：Cells、Supplementary Views、Decoration Views。 Cells：用于展示内容的主体，cell的尺寸和内容可以各不相同。 Supplementary Views：追加视图，类似于UITableView每个Seciton的Header View 或者Footer View，用来标记Section的View。 Decoration Views：装饰视图，完全跟数据没有关系的视图，负责给cell 或者supplementary Views添加辅助视图用的，灵活性较强。 不管多么复杂的UIcollectionView都是由着三个部件组成的。 UICollectionView层次结构 注解： 1、UICollectionView 继承于 UIScrollView1NS_CLASS_AVAILABLE_IOS(6_0) @interface UICollectionView : UIScrollView 2、UICollectionViewDataSource：主要管理视图数据源方面，告诉view要显示些什么东西以及如何显示它们。 @required（必须） 123456789@protocol UICollectionViewDataSource &lt;NSObject&gt;@required/* （必须）设置容器视图各个组Section中有【多少item】 */- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section;// The cell that is returned must be retrieved from a call to -dequeueReusableCellWithReuseIdentifier:forIndexPath:/* （必须）设置每个区中【item的内容】，类似于UITableViewCell的设置 */- (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath; @optional（可选） 123456789101112131415@optional（可选）/* （可选）设置容器视图有多少组Section，系统默认返回值为1 */- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView;// The view that is returned must be retrieved from a call to -dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:// 补充视图，这里可以充当区的头和尾，我们自己不实现的话，系统默认返回值为nil/* （可选）返回顶部视图和底部视图，通过kind参数分辨是设置顶部还是底部（补充视图） */- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath;/** （可选）询问是否指定的单元格项目是否可以移动到集合视图中的另一个位置，默认返回值为NO */- (BOOL)collectionView:(UICollectionView *)collectionView canMoveItemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(9_0);/** （可选）将指定的单元格项目从一个位置移动到集合视图中的另一个位置 */- (void)collectionView:(UICollectionView *)collectionView moveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath NS_AVAILABLE_IOS(9_0); 3、UICollectionViewDelegate：主要管理于用户交互方面，提供一些样式的小细节。 @optional（可选） 123456789101112131415161718192021222324252627@protocol UICollectionViewDelegate &lt;UIScrollViewDelegate&gt;@optional// Methods for notification of selection/deselection and highlight/unhighlight events.// The sequence of calls leading to selection from a user touch is:// (when the touch begins)// 1. -collectionView:shouldHighlightItemAtIndexPath:// 2. -collectionView:didHighlightItemAtIndexPath://// (when the touch lifts)// 3. -collectionView:shouldSelectItemAtIndexPath: or -collectionView:shouldDeselectItemAtIndexPath:// 4. -collectionView:didSelectItemAtIndexPath: or -collectionView:didDeselectItemAtIndexPath:// 5. -collectionView:didUnhighlightItemAtIndexPath:/** 下面是和高亮有关的方法： */// cell点击时是否高亮，点击cell时的样式和点击后cell的样式- (BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath;// 手指按下高亮- (void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath;// 手指松开取消高亮- (void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath;/** 当前item是否可以点击 */- (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath;/** 当前item是否取消点击 */- (BOOL)collectionView:(UICollectionView *)collectionView shouldDeselectItemAtIndexPath:(NSIndexPath *)indexPath; // called when the user taps on an already-selected item in multi-select mode 事件的处理顺序如下： 1、手指按下：shouldHighlightItemAtIndexPath (如果返回YES则向下执行，否则执行到这里为止)。 2、didHighlightItemAtIndexPath (高亮)。 3、手指松开：didUnhighlightItemAtIndexPath (取消高亮)。 4、shouldSelectItemAtIndexPath (如果返回YES则向下执行，否则执行到这里为止)。 5、didSelectItemAtIndexPath (执行选择事件)。 选中 和 取消选中 item时 ,会触发的方法 1234/* 选中item时 ,会触发的方法 */- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath;/* 取消选中item时 ,会触发的方法 */- (void)collectionView:(UICollectionView *)collectionView didDeselectItemAtIndexPath:(NSIndexPath *)indexPath; 补充视图（头部或尾部视图），显示 和 移除 12345678910111213/** 这两个方法分别是指定indexPath的cell将要显示出的时候调用, 和指定indexPath的头部或尾部视图view将要显示出来的时候调用 */- (void)collectionView:(UICollectionView *)collectionView willDisplayCell:(UICollectionViewCell *)cell forItemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0);- (void)collectionView:(UICollectionView *)collectionView willDisplaySupplementaryView:(UICollectionReusableView *)view forElementKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0);/** 这两个方法分别是指定indexPath的cell将要从collectionView中移除的的时候调用, 和指定indexPath的头部或尾部视图view将要collectionView中移除的时候调用 */- (void)collectionView:(UICollectionView *)collectionView didEndDisplayingCell:(UICollectionViewCell *)cell forItemAtIndexPath:(NSIndexPath *)indexPath;- (void)collectionView:(UICollectionView *)collectionView didEndDisplayingSupplementaryView:(UICollectionReusableView *)view forElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath; 长按某item，弹出copy（复制）和paste（粘贴）的菜单相关。 12345678910// These methods provide support for copy/paste actions on cells.// All three should be implemented if any are./** 这些方法为是 复制/粘贴操作相关 *//** 是否弹出菜单，需要返回YES */- (BOOL)collectionView:(UICollectionView *)collectionView shouldShowMenuForItemAtIndexPath:(NSIndexPath *)indexPath;/** 是否可以弹出事件，使copy和paste有效 */- (BOOL)collectionView:(UICollectionView *)collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender;/** 对事件进行相应操作 */- (void)collectionView:(UICollectionView *)collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender; 注册类型相关 1234567/** 注册要使用的cell对应的类型 */- (void)registerClass:(nullable Class)cellClass forCellWithReuseIdentifier:(NSString *)identifier;- (void)registerNib:(nullable UINib *)nib forCellWithReuseIdentifier:(NSString *)identifier;/** 注册要使用的补充视图(HeaderView 和 FooterView)对应的类型 */- (void)registerClass:(nullable Class)viewClass forSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier;- (void)registerNib:(nullable UINib *)nib forSupplementaryViewOfKind:(NSString *)kind withReuseIdentifier:(NSString *)identifier; 复用队列 123/** 复用队列 */- (__kindof UICollectionViewCell *)dequeueReusableCellWithReuseIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;- (__kindof UICollectionReusableView *)dequeueReusableSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath; 动态修改当前的Item 和 Section 1234567891011121314151617181920212223// These methods allow dynamic modification of the current set of items in the collection view/** 这些方法允许动态修改当前的Item 和 Section */// 插入Section- (void)insertSections:(NSIndexSet *)sections;// 删除Section- (void)deleteSections:(NSIndexSet *)sections;// 刷新Section- (void)reloadSections:(NSIndexSet *)sections;// 移动Section- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;// 插入Item- (void)insertItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;// 删除Item- (void)deleteItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;// 刷新Item- (void)reloadItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;// 移动Item- (void)moveItemAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath;/** 同样可以进行批量操作 */- (void)performBatchUpdates:(void (^ __nullable)(void))updates completion:(void (^ __nullable)(BOOL finished))completion; // allows multiple insert/delete/reload/move calls to be animated simultaneously. Nestable. 其它属性 和 方法相关 1234567891011121314/** 预加载 */@property (nonatomic, getter=isPrefetchingEnabled) BOOL prefetchingEnabled NS_AVAILABLE_IOS(10_0);/** 允许选择 */@property (nonatomic) BOOL allowsSelection; // default is YES/** 允许多个选择 */@property (nonatomic) BOOL allowsMultipleSelection; // default is NO/** 全局刷新 */- (void)reloadData; // discard the dataSource and delegate data and requery as necessary/** 布局动画 */- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated; // transition from one layout to another- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0); 4、UICollectionViewLayout：自定义布局，它负责了将各个cell、Supplementary View和Decoration Views进行组织。UICollectionViewLayout 是UICollectionView特有的，是UICollectionView的精髓所在，它负责将每个cell、supplementary view、decoration view进行组合，为它们设置各自的属性，包括：位置、大小、透明度、层级关系、形状等。UICollectionViewLayout决定了，UICollectionView是如何显示在界面上，从UICollectionView初始化必须要一个UICollectionViewLayout也可以看得出来，Layout对于UICollectionView的最要性。 自定义布局：只要了解5个方法（重写它方法，扩展功能） 12345678910111213141516171819202122232425/** 什么时候调用:collectionView第一次布局,collectionView刷新的时候也会调用 作用:计算cell的布局，条件:ell的位置是固定不变的. */- (void)prepareLayout;/** 作用:指定一段区域给你这段区域cell的尺寸(可以一次性返回所有cell尺寸,也可以每隔一个距离返回cell) 系统传递过来一个区域rect，我们需要返回在该区域中的item的位置信息 返回的是一个数组，数组中包含UICollectionViewLayoutAttributes 对象 */- (nullable NSArray&lt;__kindof UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect; // return an array layout attributes instances for all the views in the given rect// 在滚动的时候是否允许刷新(Invalidate)布局- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds; // return YES to cause the collection view to requery the layout for geometry information/** 什么时候调用:用户手指一松开就会调用 作用:确定最终偏移量 */- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity; // return a point at which to rest after scrolling - for layouts that want snap-to-point scrolling behavior- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset NS_AVAILABLE_IOS(7_0); // a layout can return the content offset to be applied during transition or update animations/** 由于UICollectionVeiw继承自UIScrollView，所以需要重写该函数，告诉contentSize大小 */- (CGSize)collectionViewContentSize; 5、UICollectionViewFlowLayout：主要管理布局信息方面，Apple为我们提供了一个最简单可能也是最常用的默认layout对象，UICollectionViewFlowLayout。Flow Layout简单说是一个直线对齐的layout。 我们来了解UICollectionViewFlowLayout它内部常用的属性： 12345678910111213141516171819202122232425262728NS_CLASS_AVAILABLE_IOS(6_0) @interface UICollectionViewFlowLayout : UICollectionViewLayout@property (nonatomic) CGFloat minimumLineSpacing; // 设置行之间的最小间距(竖直)@property (nonatomic) CGFloat minimumInteritemSpacing; // 设置2个item之间(列)的最小间隙(水平)，@property (nonatomic) CGSize itemSize; // 设置item的大小/** 预设item大小 */@property (nonatomic) CGSize estimatedItemSize NS_AVAILABLE_IOS(8_0); // defaults to CGSizeZero - setting a non-zero size enables cells that self-size via -preferredLayoutAttributesFittingAttributes:/** 设置滚动方向，默认是竖直滚动 V */@property (nonatomic) UICollectionViewScrollDirection scrollDirection; // default is UICollectionViewScrollDirectionVerticaltypedef NS_ENUM(NSInteger, UICollectionViewScrollDirection) &#123; UICollectionViewScrollDirectionVertical, // 默认是竖直滚动 UICollectionViewScrollDirectionHorizontal // 水平滚动&#125;;// 设置滚动方向，/** 1.如果是垂直滚动，高度起作用，宽度忽略 / 2.如果是水平滚动，宽度期作用，高度忽略 */@property (nonatomic) CGSize headerReferenceSize; // 分组的头部视图的size大小@property (nonatomic) CGSize footerReferenceSize; // 分组的尾部视图的size大小@property (nonatomic) UIEdgeInsets sectionInset; // 设置区的内边距// Set these properties to YES to get headers that pin to the top of the screen and footers that pin to the bottom while scrolling (similar to UITableView).// 头部视图悬停设为YES@property (nonatomic) BOOL sectionHeadersPinToVisibleBounds NS_AVAILABLE_IOS(9_0);// 尾部视图悬停设为YES@property (nonatomic) BOOL sectionFootersPinToVisibleBounds NS_AVAILABLE_IOS(9_0);@end 上面对FlowLayout的属性设置，当然代理方法中也有一一对应，UICollectionViewDelegateFlowLayout 常用方法： 1234567891011121314151617181920212223242526@protocol UICollectionViewDelegateFlowLayout &lt;UICollectionViewDelegate&gt;@optional/** 下面的代理方法是针对indexPath对应的item进行个性化设置 如果使用的是UICollectionViewFlowLayout布局，这些代理方法自动调用 *//** 设置指定indexPath的单元格的大小(itemSize) */- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath;/** 设置分组中的每一个单元格的上下左右的空白距离(内边距) */- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout insetForSectionAtIndex:(NSInteger)section;/** 设置分组中的单元格的行间距(竖直) */- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section;/** 设置每行中的item的(列)间距(水平) */- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section;/** 分组的头部视图的size大小，含义也是有滚动方向决定的 */- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section;/** 分组的尾部视图的size大小，含义也是有滚动方向决定的 */- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section;@end UIEdgeInsets sectionInset 内边距 6、UICollectionViewCell：相对于UItableViewCell而言，UIcollectionViewCell没有那么多样式。UIcollectionViewCell不存在所谓的style，也没有titleLabel和内置的imageView属性，UIcollectionViewCell的结构上相对比较简单。 cell：本身作为的View，这里应该就是UICollectionReusableView backgroundView ：用作cell背景的视图，设置背景图片等。 selectedBackgroundView ：cell被选中的背景视图 contentView ：内容视图，自定义的cell时应该将内容放在这个View上 补充：UIcollectionView有一个小细节：被选中的cell的自动变化，所有的cell中的子View，也包括contentView中的子View，当cell被选中是，会自动去查找view是否有被选中状态下的改变，如果在contentView中有一个imageView的selected和normal状态下的图片是不同的，那么选中cell这张图片也会从normal变成selected，不需要添加代码。 7、UICollectionViewLayoutAttributes 布局属性：在了解这个类之前，我们得先疏通一下，UIcollectionView的布局方式，首先我们之前一直提，UIcollectionView的初始化必须有一个UICollectionViewLayout，也就是我们说的，必须要有一个布局格式样式， 那么一个UIcollectionView有那么多的cell、supplementary View、decoration View，UIcollectionViewLayout是如何进行布局显示的呢？ 原来从UIcollectionViewLayout开始加载内容的时候，便默默的做了很多事：首先是去调用 prepareLayout 准备布局，然后根据当前屏幕所处位置的合适rect，得到每一个视图的UICollectionViewLayoutAttributes属性，然后在把视图按UICollectionViewLayoutAttributes中的属性描述设置视图具体的center、size等等，期间也会去调用其他方法去确定一些间距。所以UICollectionViewLayoutAttributes是每个视图决定性的布局的属性。 12345678910111213141516NS_CLASS_AVAILABLE_IOS(6_0) @interface UICollectionViewLayoutAttributes : NSObject &lt;NSCopying, UIDynamicItem&gt;@property (nonatomic) CGRect frame; // 布局视图的frame简单明了@property (nonatomic) CGPoint center; // 视图中心点@property (nonatomic) CGSize size; // 视图尺寸@property (nonatomic) CATransform3D transform3D; // 这个属性可以用来做酷炫的3D动画@property (nonatomic) CGRect bounds NS_AVAILABLE_IOS(7_0);@property (nonatomic) CGAffineTransform transform NS_AVAILABLE_IOS(7_0); // 转场属性@property (nonatomic) CGFloat alpha; // 透明度@property (nonatomic) NSInteger zIndex; // default is 0 // 层级，数字越大，层级越高（最上面）@property (nonatomic, getter=isHidden) BOOL hidden; // As an optimization, UICollectionView might not create a view for items whose hidden attribute is YES@property (nonatomic, strong) NSIndexPath *indexPath; // 如果是cell有对应的indexPath// 视图标记，是cell还是supplementary View或者decoration View@property (nonatomic, readonly) UICollectionElementCategory representedElementCategory;@property (nonatomic, readonly, nullable) NSString *representedElementKind; // nil when representedElementCategory is UICollectionElementCategoryCell UICollectionView与UITableView比较 相同点： 都需要遵守DataSource和 Delegate，实现协议方法。 待补充 不同点： 与UITableView的最大不同，布局交给了指定的UICollectionViewLayout布局对象。 UICollectionView 的cell 使用必须先注册，使用出列的方式。 UICollectionView：Supplementary 补充视图需要先注册（这里可以充当区的头和尾）。 待补充 UICollectionView 使用说明 说明：代码不重要，重要的是思维 创建UICollectionView必须要有布局参数flowLayout;(采用懒加载)UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc] init]; cell必须通过注册;registerClass: forCellWithReuseIdentifier: 自定义Cell，原因：系统cell没有任何子控件;(添加子控件image，label)。@interface LNPhotoViewCell : UICollectionViewCell FlowLayout自定义（调整cell尺寸，利用布局就做效果），原因：系统cell中每个item尺寸都一样;(继承flowLayout 或 Layout)。@interface LNFlowLayout : UICollectionViewFlowLayout 自定义布局: 只要了解5个方法（重写它方法，扩展功能） 1234567891011121314151617// 什么时候调用:collectionView第一次布局,collectionView刷新的时候也会调用// 作用:计算cell的布局，条件:ell的位置是固定不变的.- (void)prepareLayout;// 作用:指定一段区域给你这段区域cell的尺寸(可以一次性返回所有cell尺寸,也可以每隔一个距离返回cell)- (nullable NSArray&lt;__kindof UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect;// 在滚动的时候是否允许刷新(Invalidate)布局- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds;// 什么时候调用:用户手指一松开就会调用// 作用:确定最终偏移量- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity; // return a point at which to rest after scrolling - for layouts that want snap-to-point scrolling behavior// 由于UICollectionVeiw继承自UIScrollView，所以需要重写该函数，告诉contentSize大小- (CGSize)collectionViewContentSize; UICollectionView基本使用 初始化12345678910111213141516171819202122232425262728293031- (UICollectionView *)collectionView &#123; if (_collectionView == nil) &#123; UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc] init]; //sectionInset 设置区的内边距 layout.sectionInset = UIEdgeInsetsMake(20, 20, 20, 20); //设置2个item之间的最小间隙， layout.minimumInteritemSpacing = 10; //设置行之间的最小间距 layout.minimumLineSpacing = 10; //设置滚动方向，默认是垂直滚动 //layout.scrollDirection = UICollectionViewScrollDirectionHorizontal; //如果是垂直滚动，高度起作用，宽度忽略 //如果是水平滚动，宽度期作用，高度忽略 layout.headerReferenceSize = CGSizeMake(50, 50); //设置footerView的大小 layout.footerReferenceSize = CGSizeMake(50, 50); _collectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:layout]; _collectionView.backgroundColor = [UIColor whiteColor]; // 设置代理，遵守协议&lt;UICollectionViewDataSource,UICollectionViewDelegate&gt; _collectionView.dataSource = self; _collectionView.delegate = self; &#125; return _collectionView;&#125; 注册UICollectionView使用的cell类型12345678// 注册要使用的cell对应的类型[self.collectionView registerClass:[LNNumberCollectionViewCell class] forCellWithReuseIdentifier:cellID];// 注册要使用的HeaverView对应的类型[_collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"HeadViewId"];// 注册要使用的FooterView对应的类型[_collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"footViewId"]; 实现协议UICollectionViewDataSource12345678910111213141516171819202122#pragma mark ------------------#pragma mark - UICollectionViewDataSource// 多少区- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView &#123; return 3;&#125;// 多少item- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section &#123; return 20;&#125;// item内容- (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath &#123; LNNumberCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:cellID forIndexPath:indexPath]; cell.label.text = [NSString stringWithFormat:@"%ld",indexPath.item]; cell.photoImageView.image = [UIImage imageNamed:[NSString stringWithFormat:@"%ld",indexPath.item + 1]]; //cell.backgroundColor = [UIColor grayColor]; return cell;&#125; 12345678910111213141516171819//和UITableView不同：补充视图需要先注册//Supplementary 补充视图，这里可以充当区的头和尾- (UICollectionReusableView*)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath&#123; if([kind isEqual:UICollectionElementKindSectionHeader]) &#123; //指明是头 UICollectionReusableView *headView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"HeadViewId" forIndexPath:indexPath]; headView.backgroundColor = [UIColor redColor]; return headView; &#125; if ([kind isEqual:UICollectionElementKindSectionFooter]) &#123; UICollectionReusableView *footView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"footViewId" forIndexPath:indexPath]; footView.backgroundColor = [UIColor blueColor]; return footView; &#125; return nil;&#125; 实现代理UICollectionViewDelegate123456789101112131415161718// 点击item时触发- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath&#123; NSLog(@"(第%ld-区,第%ld-item)",indexPath.section,indexPath.item); [collectionView cellForItemAtIndexPath:indexPath].backgroundColor = [UIColor redColor]; &#125;// 当前item是否可以点击- (BOOL) collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(nonnull NSIndexPath *)indexPath&#123; if (indexPath.row % 2) &#123; return YES; &#125; return NO;&#125; 1234567891011121314151617//cell点击时是否高亮，点击cell时的样式和点击后cell的样式- (BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath&#123; return YES;&#125;- (void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell *cell = [collectionView cellForItemAtIndexPath:indexPath]; cell.backgroundColor = [UIColor redColor];&#125;- (void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell *cell = [collectionView cellForItemAtIndexPath:indexPath]; cell.backgroundColor = [UIColor grayColor];&#125; 123456789101112131415161718192021222324252627282930313233// 长按某item，弹出copy和paste的菜单 (这些方法为是 复制/粘贴操作相关)- (BOOL)collectionView:(UICollectionView *)collectionView shouldShowMenuForItemAtIndexPath:(NSIndexPath *)indexPath&#123; return YES;&#125;// 使copy和paste有效- (BOOL)collectionView:(UICollectionView *)collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender&#123; if ([NSStringFromSelector(action) isEqualToString:@"copy:"] || [NSStringFromSelector(action) isEqualToString:@"paste:"]) &#123; return YES; &#125; return NO;&#125;//- (void)collectionView:(UICollectionView *)collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender&#123; if([NSStringFromSelector(action) isEqualToString:@"copy:"]) &#123;// NSLog(@"-------------执行拷贝-------------"); [_collectionView performBatchUpdates:^&#123; [_section0Array removeObjectAtIndex:indexPath.row]; [_collectionView deleteItemsAtIndexPaths:@[indexPath]]; &#125; completion:nil]; &#125; else if([NSStringFromSelector(action) isEqualToString:@"paste:"]) &#123; NSLog(@"-------------执行粘贴-------------"); &#125;&#125; 布局对象UICollectionViewDelegateFlowLayout123456789101112131415161718192021222324252627282930#pragma mark ------------------#pragma mark - UICollectionViewDelegateFlowLayout//下面的代理方法是针对indexPath对应的item进行个性化设置//如果使用的是UICollectionViewFlowLayout布局，这些代理方法自动调用- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123; // indexPath.item 指定第几个cell// NSInteger item = indexPath.item;// if (item % 3 == 1) &#123;// return CGSizeMake(100, 150);// &#125;// return CGSizeMake(100, 200); return CGSizeMake(100, 150);&#125;/** 设置分组中的每一个单元格的上下左右的空白距离(内边距) */- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout insetForSectionAtIndex:(NSInteger)section;/** 设置分组中的单元格的行间距(竖直) */- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section;/** 设置每行中的item的(列)间距(水平) */- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section;/** 分组的头部视图的size大小，含义也是有滚动方向决定的 */- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section;/** 分组的尾部视图的size大小，含义也是有滚动方向决定的 */- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section; 自定义FlowLayout：水平滚动相册 核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 作用:指定一段区域给你这段区域cell的尺寸(可以一次性返回所有cell尺寸,也可以每隔一个距离返回cell)// 缩放- (nullable NSArray&lt;__kindof UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect &#123; // 设置cell尺寸 =&gt; UICollectionViewLayoutAttributes // 越靠近中心点,距离越小,缩放越大 // 求cell与中心点距离 // 1.获取当前显示cell的布局 NSArray *attrs = [super layoutAttributesForElementsInRect:self.collectionView.bounds]; for (UICollectionViewLayoutAttributes *attr in attrs) &#123; // 2.计算中心点距离 CGFloat delta = fabs((attr.center.x - self.collectionView.contentOffset.x) - self.collectionView.bounds.size.width * 0.5); // 3.计算比例 CGFloat scale = 1 - delta / (self.collectionView.bounds.size.width * 0.5) * 0.25; // 4.缩放 attr.transform = CGAffineTransformMakeScale(scale, scale); &#125; return attrs;&#125;// 什么时候调用:// 作用:确定最终偏移量// 定位:距离中心点越近，这个cell最终展示到中心点- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity &#123; // 最终偏移量 CGPoint targetP = [super targetContentOffsetForProposedContentOffset:proposedContentOffset withScrollingVelocity:velocity]; CGFloat collectionW = self.collectionView.bounds.size.width; // 1.获取最终显示的区域 CGRect targetRect = CGRectMake(targetP.x, 0, collectionW, MAXFLOAT); // 2.获取最终显示的cell NSArray *attrs = [super layoutAttributesForElementsInRect:targetRect]; // 3.获取最小间距 CGFloat minDelta = MAXFLOAT; for (UICollectionViewLayoutAttributes *attr in attrs) &#123; // 获取距离中心点的距离，注意：应该用最终的x CGFloat delta = (attr.center.x - targetP.x) - self.collectionView.bounds.size.width * 0.5; if (fabs(delta) &lt; fabs(minDelta)) &#123; minDelta = delta; &#125; &#125; // 移动间距 targetP.x += minDelta; if (targetP.x &lt; 0) &#123; targetP.x = 0; &#125; // 获取collectionView偏移量// NSLog(@"%@ %@",NSStringFromCGPoint(targetP),NSStringFromCGPoint(self.collectionView.contentOffset)); return targetP;&#125; 附图： 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源技术嘉年华「夜聊」社区，邀你加入]]></title>
    <url>%2FPerceptionWork%2FOpenSourceTechnology.html</url>
    <content type="text"><![CDATA[前些日子，我发布一个苹果官方文档的翻译，之后就有不少朋友问我：翻译苹果官方文档能做什么，开发过程用到的时候很少,浪费时间，还又没什么用。今天，刚好有时间，就在此申明一下翻译苹果官方文档的实质作用： 首先，翻译官方文档可以提高自身「英语阅读能力 和 理解能力」，增大自己的词汇量，良好的英语基础会让工作效率更上一层楼的； 其次，对于iOS开发而言，官方文档可以让你更好地理解每一个技术点实现的基本原理，知其然更要知其所以然，这样对iOS开发的进阶者和初学者都有很大的帮助； 最后，翻译官方文档可以让你更加全神贯注，写代码的过中会出现分神、思维混沌等现象，这时候你平时的官方翻译或第三方注解的锻炼，会让你更好的控制你的潜意识，让你静下心来。我已试过，很有帮助； 注意，苹果官方文档实属繁多，全部按部就班的翻译会耗时很长。为提高此翻译文章实质作用，特恳请大家：适事度量，把「官方急需的章节 或 实用广的框架」，翻译、注解出来 ，分享于码农们。 当然，在「时间 和 知识」有限内，翻译的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 分享和开源精神值得俱备 什么是开源，为什么要开源? 那么你正准备拥抱开源吗？恭喜你，开源世界欣赏你的贡献。接下来让我们聊聊什么是开源，我们为什么要开源。 “开源”意味着什么？ 当一个项目开源后，意味着 不论什么目的，所有人都可以浏览，使用，修改和分发你的项目。 开源非常的强大。因为它降低了使用的门槛，使新奇的思想得到快速的传播。 来理解它如何工作，想象下你的朋友正在吃便当，这时你带来了樱桃派。 每个人都会想要樱桃派（使用） 这个派引起了一场轰动！周围的人会想知道你的烹饪方法（浏览） 有一位朋友Alex是一名糕点师，他会建议少放一点糖（修改） 另外一位朋友Lisa要求使用它作为下个星期的晚餐（分发） 同样的，闭源就像是你去餐厅必须付钱才能吃樱桃派。但是，餐厅不会告诉你樱桃派的烹饪方法。如果你恰好抄袭了他们的派，并以你自己的名义出售，那么餐厅将会采取行动抵制你。 开源是否意味着免费? 开源最吸引之处就是它不用花钱。然而免费只是开源的价值的一个副产品。 因为 开源协议要求开源项目可以被任何人出于几乎任何目的使用，修改和分享，这些项目一般都是免费的。如果有些开源项目需要付费使用，任何人都可以合法地使用其免费版。 以上「分享 和 开源精神」内容，部分摘录于GitHub开源项目贡献指南中文版，译文附在上工程中，可下载阅读； 开源精神里最重要的，是拿来主义 这和大部分人的想法不一样。开源需要贡献、需要付出，但在贡献和付出之前，首要的是去了解、去使用已经存在的。 比如前端工程师，会经常使用模板，天天用着，会有不爽，就会想着自己去写一个模板引擎。直接去写一个没什么不对，但更好的方式是，先去开源社区搜索下同类产品。看自己的想法，是否已经有人实现了，看自己的想法中，哪些是靠谱的，哪些是不太靠谱的。 注意不要去做「纯调研」，除非你已经是这方面的专家，有过体系化的研究和深入。「纯调研」是指，找到类似的产品，浅尝辄止地跑跑 demo，就开始出表格，横向比较优劣。更笨但更有效地做法是，直接去用，比如我们选择了 Handlebars ，在项目真正使用过程中，才能深触地感受到 Handlebars 的优点及其缺点。有过这么一段深入使用经验后，类似的前端模板引擎，比如 Mustache、Hogan 等，也有大概清楚个七七八八了。 拿来主义不光能省去开发成本，还能让你扩充见识和想法，而不会成为井底之蛙还茫然自得。 在开源世界里，参与比主导更重要 遵循拿来主义，可以让你更懂得他人。在这过程中，会有欣赏、感谢，也会有抱怨、想法。 前端 DOM 操作类库中，很多公司包括支付宝都选择了 jQuery。使用过程中，jQuery 的一些 API 的设计非常赞，一些内部实现也非常漂亮。遇到这些让人欣赏的点时，别忘了将自己的感想写下来。那怕是一篇博文，或是跟朋友闲聊时的只言片语，所有这些，都是参与，都是正能量的传播。社区的赞誉，可以给 jQuery 开发团队最大的鼓励。很多坚持，是因为有肯定。 当然，jQuery 只要存在一天，就一定存在不足。比如 data 的 API 变化，比如动画不支持纯 CSS3 方式，还有 Sizzle 也并非那么完美。所有这些「缺点」，你遇到的 bug，你踩过的坑，当你有好的想法或解决方案时，不要忘记反馈给社区。jQuery 有详细的反馈渠道，一般成熟的开源社区都会有。比如托管在 GitHub 上的项目，一般都可以通过 Issues 给社区提交你的想法，甚至可以通过 Pull Request 直接提交你修改过的代码。 参与进去，可以让你更懂得美，懂得感恩之心，懂得回馈之情。这在过程中，你的功力，往往也会大增。不光是技术上的进步，还包括英语读写能力。在人性沟通上，你也会收获很多，这是无价的财富。 拿来主义是开源的第一步，参与则是开源中最漫长的一步。开发自己主导的项目不是必须的，除非你真的有很好的想法，同时刚好有旺盛的精力，否则不要轻易开始，那不代表什么，往往什么也不是。比如 Sea.js，如果 RequireJS 当初能接受我的建议，或者 FlyScript 的作者不退隐江湖，那么就不会有 Sea.js。让一些事情自然地发生，让豆瓣从土壤中发芽。更多地去享受参与，保持简单与自然。 开源的是社区，代码仅是很小的一部分 虽然代码很重要，但在开源项目里，源码只是重要的因素之一。 除了代码，还有文档、测试用例、Issues 管理、版本发布、升级策略、书籍、视频等等。jQuery、Backbone、AngularJS 等成熟项目，成熟的是社区，而不是源码。好的社区，是在 Google 中一搜索，就能找到不少资料。好的社区，是你踩过的坑，经常已经有人也踩过并整理分享出来了。 社区的形成很难，需要核心团队澎湃持久的激情，还需要天时、地利、人和。jQuery 已经形成庞大的社区，但其兄弟 YUI3 的社区，一直不是很成气候。两三年前，我想找 YUI3 的总体设计文档，以及部分组件的设计文档，搜索了很多很多地方，最后给原作者发信，依旧都未能找到我想要的资料。但 jQuery，基本每个细节，都能比较轻松地就找到相关资料和讨论。 没有社区的开源项目，其源码会一直停留在「孤芳自赏」阶段。几年前的 KISSY，还有百度的 Tangram，个人觉得都停留在初始阶段，发展很难。有社区的开源项目，其源码会活起来，会自我不断进化升华。我参与过的一个典型项目是 Backbone，倘若你现在再回过头去看 Backbone 最初提交的代码，与现在的相比，真心会觉得有点挫了。最让人不可思议的是，Backbone 最初很挫的代码，在社区的参与下，在不断的讨论和 Pull Request 中，现在已经演化成非常高质量的代码，甚至每一小段代码里，都能说出一个故事来。我现在依旧非常关注 Backbone 的每一次代码变化，特别是自己修改过的部分。从其他人的修改中，能收获很多很多。 Backbone 的例子，也展示了一个更好的开源方式：有了好的想法，就分享出来，最初的代码展现基本的思路就好，然后通过社区的参与，不断往前演化，让大家都成为开发者，群体的力量远大于个体。个人英雄式的开源方式，已经过时了，就像 sourceforge.net 一样。加入我的开源社区，也给自己一个分享开源和拿来开源的机会。 最后，知易行难。上面的道理或许大家都懂，真要做到，则是一场修行。MJ 和 LN 也才刚刚上路，旅途中，有杭州西湖惬意的微风，也有萨哈沙漠般的烈日当头。好在，选择了，就不怕远。 在分享和开源嘉年华的「夜聊」中切莫走入误区 我曾在简书上看过一篇文章，意思如果写文章只盯着阅读量和打赏，就会慢慢的开始焦虑，渐渐地失去写作的兴趣。我同意他的观点。 我们学习总结，分享和开源自己的技术类作品，也不是为了阅读量，但是有时又难免为阅读量所累，毕竟文章就是分享给人看的，如果写了一个东西，来来回回没人看，心里也难免有点失落。但是如果有人看，有人留下评论，有个时候就会萌生 大家都挺关注这个事情的，明天再写一篇更加详细的分享给大家。 而且阅读量这个东西在保证准确的前提下，是一个文章(作品)质量的硬指标，读者也难免将阅读量和文章质量联系在一起。就像在 GitHub 上找框架关注 Star 数一样，读者在找一个知识的时候，同一个关键词搜出来的结果，一个有 十万+ 的阅读量，一个阅读量只有 十来个，你会优先选择打开哪一个？ 我想说的是，开源是一种精神，分享是一种美德。千里马和伯乐都是有的。有实力有风格的牛人也是有的。猴子尚且有分享和团协精神，你为什么 不行动起来「为何甘心败于拖延症」。不做「大牛」，做只「假猴子」也不错。 程序猿的独白 是谁改变了世界？ 每个国家，人们最终尊敬的，必定是那些真正创造财富的人，而不是那些空言大话的人。程序员不但创造财富，而且努力提高创造财富的效率。所以，作为一个程序员，应该感到自信和自豪。 我有一个梦想 码农呆子、怪人也有资格获得总统奖章、国会金质奖章以及其他能够承认他们贡献的高等级的奖项。 我是一个程序员，我和其他程序员是朋友，不是敌人。我不在别人面前贬低程序员。 程序员是聪明勇敢的，而且我们也很风趣。“内向不是我们的DNA，所以我们并不是生来就内向，我可以调整我的态度和社交能力”。 说明 改内容整理摘录于大神的Issues中的一个topic【什么是开源精神 #167】https://github.com/lifesinger/blog/issues/167]]></content>
      <categories>
        <category>职场</category>
      </categories>
      <tags>
        <tag>职场</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS NSURLSessionApple译文]]></title>
    <url>%2FAppleTranslation%2FNSURLSessionApple.html</url>
    <content type="text"><![CDATA[Write in the first【写在最前】 由于 X X (自动脑补) 的苹果在 iOS9 之后已经废弃了 NSURLConnection，所以在现在的实际开发中，除了大家常见的 AFN 框架，一般使用的是 iOS7 之后推出的 NSURLSession，作为一名 iOS 开发者，如果你只知道 AFN 框架来进行网络请求，那就 X x 了。 在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 正题在这里首先附上官方原文地址 URLSession Class Relationships Inherits From NSObject 继承自: NSObject Conforms To CVarArg，Equatable，Hashable Framework iOS 7.0+ Class URLSession The NSURLSession class and related classes provide an API for downloading content. This API provides a rich set of delegate methods for supporting authentication and gives your app the ability to perform background downloads when your app is not running or, in iOS, while your app is suspended. NSURLSession 类及其相关类为下载内容提供了接口。这个 API 提供了一系列丰富的代理方法来支持授权，而且让你的 APP 在后台被挂起时也能继续下载。 Overview The URLSession class natively supports the data, file, ftp, http, and https URL schemes, with transparent support for proxy servers and SOCKS gateways, as configured in the user’s system preferences. URLSession supports the HTTP/1.1, SPDY, and HTTP/2 protocols. HTTP/2 support is described by RFC 7540, and requires a server supporting either ALPN or NPN for protocol negotiation. You can also add support for your own custom networking protocols and URL schemes (for your app’s private use) using URLProtocol. 通过代理服务器的和 SOCKS 网关为用户配置好系统设置，NSURLSession类完全支持 data, file, ftp, http, https类型的超链接。你也可以添加一些支持你自己定制的网络协议或超链接（专门为你自己的 APP 所用） ImportantThe NSURLSession API involves many different classes working together in a fairly complex way that may not be obvious if you read the reference documentation by itself. Before using this API, you should read URL Session Programming Guide to gain a conceptual understanding of how these classes interact with one another. 重要：NSURLSession 的 API 有很多你在看文档时可能感觉并不重要，但实际上却以很复杂的方式来共同发挥作用的类。用这个 API 之前，你应该看一下 URL Session Programming Guide 来了解这些类之间相互调用的一些概念。 With the NSURLSession API, your app creates one or more sessions, each of which coordinates a group of related data transfer tasks. For example, if you are writing a web browser, your app might create one session per tab or window, or one session for interactive use and another session for background downloads. Within each session, your app adds a series of tasks, each of which represents a request for a specific URL (following HTTP redirects if necessary). 通过 NSURLSession 的 API，你的 APP可以创建一个或者多个事务，其中的每一个事务都用来协助一组相关的数据来传输任务。比如，如果你在写一个浏览器，你的 APP 可能在每一栏或是每一个窗口都创建了一个事务，可能一个用来进行交互，一个用来后台下载。在每一个事务中，你的 APP 都添加了一些了的任务，其中的每一个任务就代表一个请求或是一个特定的 URL（必要时进行HTTP重定向） The tasks within a given URL session share a common session configuration object, which defines connection behavior, such as the maximum number of simultaneous connections to make to a single host, whether to allow connections over a cellular network, and so on. The behavior of a session is determined in part by which method you call when creating its configuration object: The singleton shared session (which has no configuration object) is for basic requests. It is not as customizable as sessions that you create, but it serves as a good starting point if you have very limited requirements. You access this session by calling the shared class method. See that method’s discussion for more information about its limitations. Default sessions behave much like the shared session (unless you customize them further), but let you obtain data incrementally using a delegate. You can create a default session configuration by calling the default method on the URLSessionConfiguration class. Ephemeral sessions are similar to default sessions, but do not write caches, cookies, or credentials to disk. You can create an ephemeral session configuration by calling the ephemeral method on the URLSessionConfiguration class. Background sessions let you perform uploads and downloads of content in the background while your app is not running. You can create a background session configuration by calling the backgroundSessionConfiguration(_:) method on the URLSessionConfiguration class. 给定 URL事务的这些任务共享一个事务配置 session，这个对象定义好了连接行为，比如通往同一个主机的相似连接的最大连接数，不管是通过蜂窝移动网络还是别的方式来允许连接。session 的行为一部分是由创建这个配置对象时你调用的方法来决定： 单例 shared session （没有配置对象）用于普通请求。它像你自己创建的session一样可定制，但是如果你的请求有限的话它是一个很好的起点，通过调用 sharedSession 来获取这个 session。看这个方法的文档来得到它的一些限制信息。 Default sessions 的行为和 shared session 差不多（除非你自己进行了深度定制），但你必须要通过代理方法得到增量数据。调用 NSURLSessionConfiguration 中的 defaultSessionConfiguration 方法来创建 Default session。 Ephemeral sessions和Default sessions 很相似，但是不写入 caches,cookies, 或credentials。调用 NSURLSessionConfiguration 中的 ephemeral Session Configuration 方法来创建 ephemeral session。 Background sessions 可以在你的 APP 在后台被挂起时进行上传或下载。调用 NSURLSessionConfiguration 中的 backgroundSessionConfiguration: 方法来创建 background session。 The session configuration object also contains a reference to URL cache and cookie storage objects that may be used when making requests and handling the responses, depending on the configuration and request type. session 配置对象还包含了对 URL cache 和 cookie 存储对象发起请求并处理相应的引用，具体取决于配置和请求类型。 The tasks in a session also share a common delegate that lets you provide and obtain information when various events occur—when authentication fails, when data arrives from the server, when data is ready to be cached, and so on. For all background downloads and uploads, you must provide a delegate that conforms to the URLSessionDownloadDelegateObjective-C protocol. Otherwise, if you don’t need any of the features provided by a delegate, you can use this API without providing a delegate by passing nil when you create a session. 当多种类型的事件发生时（比如授权失败时，数据传输到服务器时，数据准备好缓存时等等）session 中的任务也会共享一个通用的代理来让你提供和获取相关信息。对于所有的后台下载和上传，你必须提供一个遵从 NSURLSessionDownloadDelegate的 OC 协议。否则，如果你不需要任何由代理提供的特性，在你创建 session 时就给 delegate 传 nil 来调用这个 API。 ImportantThe session object keeps a strong reference to the delegate until your app exits or explicitly invalidates the session. If you do not invalidate the session, your app leaks memory until it exits. 重要：session 对你的 delegate 始终保持强引用，除非你的 app 退出或者 session已明确失效。如果你没有使 session 失效，你的 app 将会内存溢出，直到它终止。 Within a session, you create tasks that optionally upload data to a server, then retrieve data from the server either as a file on disk or as one or more NSData objects in memory. The NSURLSession API provides three types of tasks: Data tasks send and receive data using NSData objects. Data tasks are intended for short, often interactive requests to a server. Upload tasks are similar to data tasks, but they also send data (often in the form of a file), and support background uploads while the app is not running. Download tasks retrieve data in the form of a file, and support background downloads and uploads while the app is not running. 在 session 中，你创建了可上传数据到服务器的任务，然后通过磁盘上的文件，或是内存中的一个或多个 NSData 对象来获取数据。 NSURLSession 的 API 提供了三种类型的任务： data tasks 通过 NSData 对象来发送和接受数据。 data tasks 用于与服务器进行简短频繁的请求。 Upload tasks 和 data tasks 类似，但是他们也可以发送数据（一般是通过文件的形式），也支持 app 后台上传。 Download tasks 通过文件的形式来获取数据，并且支持 app 后台上传和下载。 Like most networking APIs, the NSURLSession API is highly asynchronous. It returns data to your app in one of two ways, depending on the methods you call: To a completion handler block that is called when a transfer finishes successfully or with an error. By calling methods on the session’s delegate as data is received and when the transfer is complete. 和大多数网络接口一样，NSURLSession是高度异步的。它通过两种方式中的其中一种来返回数据给 app，取决于你调用的方法： 当传输成功或是发生错误时调用 completion handler block； 当收到数据或是传输完成时调用 session 的代理方法。 In addition to delivering this information to delegates, the NSURLSession API provides status and progress properties that you can query if you need to make programmatic decisions based on the current state of the task (with the caveat that its state can change at any time). URL sessions also support canceling, restarting or resuming, and suspending tasks, and provide the ability to resume suspended, canceled, or failed downloads where they left off. 除了通过代理来传递数据，如果你需要通过当前任务的状态（给出一些状态警示）做一些程序上的决定， NSURLSession的 API 统一提供了状态和进度的属性，方便查询。 URL sessions 同样支持取消，重启，恢复，挂起任务，而且可以在他们停止的地方恢复挂起、取消、失败了的下载。 URL Session Class Hierarchy层级结构The NSURLSession API consists of the following classes (nested to show subclass relationships):NSURLSession API 由下面的类组成（下面的缩进显示的是子类的关系） URLSession—A session object. （一个 session 对象） URLSessionConfiguration—A configuration object used when initializing the session.（用来初始化 session 的配置对象） URLSessionTask—The base class for tasks within a session.（在 session 中表示任务的基类） URLSessionDataTask—A task for retrieving the contents of a URL as an NSData object.（用来获取 NSData 对象的 URL 的任务） URLSessionUploadTask—A task for uploading a file, then retrieving the contents of a URL as an NSData object.（用来上传文件，并接收 NSData 对象的 URL 的任务） URLSessionDownloadTask—A task for retrieving the contents of a URL as a temporary file on disk（以磁盘临时文件的形式获取 URL 的内容的任务） URLSessionStreamTask—A task for establishing a TCP/IP connection（用来建立 TCP/IP连接的任务） In addition, the NSURLSession API provides four protocols that define delegate methods your app can implement to provide more fine-grained control over session and task behavior. 除此之外，NSURLSession 还提供了4个代理， 订了代理方法，你的 app 可以实现这些代理方法，提供对 session 和 task 更加细化的控制。 URLSessionDelegate—Defines delegate methods to handle session-level events（可处理 session level 事件的代理） URLSessionTaskDelegate—Defines delegate methods to handle task-level events common to all task types（可处理和其他所有 task 类型相通的 task level 的方法的代理） URLSessionDataDelegate—Defines delegate methods to handle task-level events specific to data and upload tasks（可处理与数据和上传任务相关的 task level 的方法的代理） URLSessionDownloadDelegate—Defines delegate methods to handle task-level events specific to download tasks（处理与下载任务相关的 task level 的方法的代理） URLSessionStreamDelegate—Defines delegate methods to handle task-level events specific to stream tasks（处理与数据流相关的 task level 的方法的代理） Finally, the NSURLSession API uses a number of classes that are also commonly used with other APIs such as NSURLConnection and NSURLDownload. Some of these shared classes include: 最终，NSURLSession 的 API 使用了很多类，这些类也同样使用了其他的 API，比如 NSURLConnection 和 NSURLDownload。共同使用的类包括： NSURL—An object that contains a URL.（包含了 URL 的对象） NSURLRequest—Encapsulates metadata related to a URL request, including the URL, request method, and so on.（封装与 URL 请求，包括 URL、 请求方法等等相关的元数据） NSURLResponse—Encapsulates metadata related to a server’s response to a request, such as the content MIME type and length. (封装服务器相应的请求，如与 Content 的 MIME 类型和长度相关的元数据) NSHTTPURLResponse—Adds additional metadata specific to HTTP requests, such as response headers.（给 HTTP请求添加特定的附加元数据，比如 response headers） NSCachedURLResponse—Encapsulates an URLResponse object, along with the actual body data of the server’s response, for caching purposes.（用来缓存服务器响应的 body data 封装的一个NSURLResponse对象） Authentication and TLS Customization身份验证和 TLS 定制 When a server requests authentication or provides credentials during TLS negotiation, the URL session calls methods on its delegate, allowing you to handle the authentication or certificate validation in a custom manner. The method it calls depends on whether you are handling a task-specific challenge or a session-wide challenge. Table 1 shows the difference between the two. 当服务器要求身份验证或在 TLS 协商期间提供凭证时，URL Session 通过调用代理方法，让你可以自定义处理身份验证或证书验证。调用的代理方法取决于你是在处理 task 相关还是 session范围内的挑战。Table 1 给出了两者之间的区别。 Table 1Session-level and connection-level challenges Session-wide challenges Task-specific challenges NSURLAuthenticationMethodNTLM NSURLAuthenticationMethodDefault NSURLAuthenticationMethodNegotiate NSURLAuthenticationMethodHTTPBasic NSURLAuthenticationMethodClientCertificate NSURLAuthenticationMethodHTTPDigest NSURLAuthenticationMethodServerTrust - 对于 task 相关的挑战， session 会调用代理的URLSession:task:didReceiveChallenge:completionHandler: 方法。 对于 session 相关的授权挑战，session 会调用代理的URLSession:didReceiveChallenge:completionHandler: 方法，如果它不存在，则调用代理的URLSession:task:didReceiveChallenge:completionHandler: 方法。 If you do not implement these methods, when a request requires client authentication, the URL session attempts to authenticate as follows: Using the authentication information provided as part of the requested URL, if available By looking up Internet passwords and certificates in the user’s keychain (in macOS) or the app’s keychain (in iOS) 当请求需要客户端授权时，如果你没有实现这些方法，URL Session 会通过下面的方式来尝试授权： 如果 URL中含有授权信息的话，通过请求的 URL 中的授权信息。 在用户的钥匙串（ 在 OS X 中）或是 app 的钥匙串（在 iOS 中）寻找网络密码或是证书。 Then, if credentials are not available, or if the server rejects the credentials, the connection continues without authenticating. For HTTP and HTTPS requests, the connection attempt fails with an appropriate HTTP status code, and may provide alternative content (such as the public version of a private site). For other URL types (such as FTP),the connection fails with a connection failure. 如果验证不可用，或是服务器拒绝了验证，那这个连接将会在没有授权的情况下继续。对于 HTTP 和 HTTPs 请求来说，连接会通过一个对应的 HTTP 状态码反应尝试失败， 也可能会提供可选择的内容（比如私有网站的公开版本）。对于其他类型的 URL（比如 FTP），将会直接连接失败。 NoteKerberos authentication is handled transparently. The delegate methods described here do not apply to Kerberos authentication. 注意：erberos 身份验证的处理是公开透明的。这里描述的委托方法不适用于 Kerberos 身份验证。 App Transport Security (ATS)App 传输安全 (ATS) Starting in iOS 9.0 and OS X v10.11, a new security feature called App Transport Security (ATS) is enabled by default for all HTTP connections made with NSURLSession. ATS requires that HTTP connections use HTTPS (RFC 2818). For more information, see NSAppTransportSecurity in the Information Property List Key Reference. 从 iOS9.0 和 OS X v10.11 开始，一种称为App 传输安全（ATS）的安全特性在所有用作 HTTP 连接的 NSURLSession 中是默认启用的。ATS 要求 HTTP 连接使用 HTTPS（RFC 2818）。 想了解更多信息，请看Information Property List Key Reference 中的 NSAppTransportSecurity Using an URL Session使用 URL Session使用 NSURLSession 类发起一个请求: 创建一个 session 配置。若是用作后台的 session，这个配置必须包括一个 唯一标识（unique identifier）。 存储这个标识， 当你的 app 崩溃或是被终止或是被挂起时用它来重连 session。 创建一个 session， 指定它的配置对象，或是代理。 在每个代表一个资源请求的 session 中创建 task 对象。这些 task 对象应该是NSURLSessionTask—NSURLSessionDataTask,NSURLSessionUploadTask, or NSURLSessionDownloadTask 的子类，具体用哪个取决于你想要做什么。 每个task 开始时都处于挂起状态。你的 App 调用恢复任务后，它会开始下载其对应的资源。 在你开始一个 task 之后，session 会调用其代理方法，如下： 如果和服务器初始化握手需要一个连接 level 的挑战（比如SSL 的客户端证书），NSURLSession 会调用 URLSession:task:didReceiveChallenge:completionHandler: 或是 URLSession:didReceiveChallenge:completionHandler: 代理方法，如前面的 身份验证和 TLS 定制 所述。了解更多为 NSURLSession 写一个授权代理方法的信息，请阅读 read URL Session Programming Guide. 如果这个 task 的数据是由流提供的，NSURLSession 对象将会调用代理的 URLSession:task:needNewBodyStream: 代理方法来获取一个 提供新请求的 body data 的 NSInputStream 对象。 在初始化上传到服务器（如果可用的话）的 body 内容期间，代理会阶段性接收 URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend: 的回调来报告上传进度； 服务器发送一个响应； 如果响应表明需要授权，session 会调用代理方法URLSession:didReceiveChallenge:completionHandler: ，回到步骤2； 如果响应是一个 HTTP 重定向响应， NSURLSession 对象会调用代理方法URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler: 代理方法会用提供的 NSRULRequest 对象（遵循重定向），或是新的 NSURLRequest 对象（如果需要重定向到一个不同的 URL 的话），或是 nil（将有效的响应作为重定向响应的 body，并将它作为结果返回） 来调用所提供的 completion handler 。 如果你决定追踪重定向，返回步骤2； 如果代理没有实现这个方法，这个重定向将会被重定向的最大数字跟进。 对于一个通过调用downloadTaskWithResumeData:或 downloadTaskWithResumeData:completionHandler: 方法创建的（重复）下载任务来说，NSURLSession 会对一个新的任务对象调用URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes: 代理方法。 对于数据任务，NSURLSession 会调用URLSession:dataTask:didReceiveResponse:completionHandler: 代理方法，来决定是否要将 数据任务转换成下载任务，然后调用完成回调来继续接收或下载数据。 如果你的 app 选择将数据任务转换成下载任务，NSURLSession 会将这个新的下载任务作为一个参数来调用 urlSession:dataTask:didBecomeDownloadTask: 代理方法。调用完之后，代理不会从数据任务接收到进一步回调，而是从下载任务那里来接收回调； 在服务器传输过程中，代理会周期性地接收到一个 task-level 的回调方法来报告传输的进度。 对于数据任务，session 会在接收过程中通过真正的数据块来调用URLSession:dataTask:didReceiveData: 代理方法。对于下载任务来说，session 会通过已经成功写入磁盘的 bytes 来调用urlSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite: 代理方法。如果用户告诉 app 来暂停下载，通过cancelByProducingResumeData: 然后，如果用户要求 app 继续下载任务，将返回的恢复数据给downloadTaskWithResumeData:或 downloadTaskWithResumeData:completionHandler: 方法来创建一个新的下载任务，来继续下载。（返回步骤1） 对于数据任务，NSURLSession 对象可能会调用URLSession:dataTask:willCacheResponse:completionHandler: 方法。你的 app 应该来决定是否允许缓存。如果你没有是现在合格方法，默认会使用 session 的配置对象中的缓存方案。 如果响应是由多个部分组成的编码，session 会在didiRecieveReponse代理被多次调用之后再次调用 didRecieveData 代理方法。如果出现这样的情况，回调步骤8（处理 didRecieveResponse回调） 如果下载任务成功完成， NSURLSession 对象会通过一个临时文件的地址来调用任务的 urlSessionDownloadTask:didFinishDownloadingToURL: 方法。你的 app 必须从这个文件中读取返回的数据，或是在这个代理方法 结束之前将它移到一个永久保存的地址。 任务完成时， NSURLSession 对象会通过一个错误对象或是 nil （如果任务成功完成）来调用 urlSession:task:didCompleteWithError:如果这个下载任务是可被重新唤起的，这个 NSError 对象的 userInfo 字典中会包含 key 为NSURLSessionDownloadTaskResumeData的值。你要将这个值传给downloadTaskWithResumeData:或是 downloadTaskWithResumeData:completionHandler: 来创建一个新的下载任务以继续这个已经存在的下载任务。如果这个下载任务不能被重新唤起，你的 app 需要创建一个新的下载任务来从头开始下载。不管是哪种情况，如果传输因任何服务器错误以外的原因而失败，返回到步骤3（创建或唤起任务对象）。 注意：NSURLSession 不会通过 error 参数返回任何的服务器错误。通过 error 参数返回的错误只会是服务器端错误，比如不能解决 hostname，不能连接到 host。error codes 信息可在 URL Loading System Error Codes 中查询。服务器端错误会通过 NSHTTPURLResponse 对象中的HTTP 状态码来返回，了解更多信息，请阅读 NSHTTPURLREsponse和 NSURLResponse的文档。 14 . 如果你不需要用到 session 了，可以通过调用 invalidateAndCancel（用来取消未完成的任务）或是 finishTasksAndInvalidate(在这个对象失效前完成未完成的任务)。如果你不使这个session失效，它会在你的app终止时自动消失（除非它是一个含有正在进行的任务的后台 session） session 失效后，当所有未完成的任务被取消或是完成时，session会调用 urlSession:didBecomeInvalidWithError: 方法。当代理方法返回时，session 会处置对代理的强引用。 如果你的app 取消了一个正在进行的下载任务， 当出现错误时，NSURLSession 对象会调用代理的 URLSession:task:didCompleteWithError: 方法。 Background Transfer Considerations后台处理注意事项因为重启app（或是等待用户重新唤起时）代价是相当高的，在后台session中有些特性是不可用的。如下： session 必须提供一个传递事件的代理，因为在传输进行中app可能会退出或是重启，完成事件的回调 Block 是不支持的、（为了上传和下载），这些代理在传输过程中表现是相同的； 只有 HTTP 和 HTTPS 协议是被支持的。其他内置的网络协议和用户网络协议都不被支持； 只有上传和下载是被支持的（没有 data 任务）；重定向一直被允许；全系统同时进行的后台传输的数量是被限制的； 如果后台任务未能满足指定系统吞吐量限制，可能会被取消。也就是说，如果一个长期运行的任务在一段时间内没有发送或者接受足够的数据，它可能会被取消，以后再被唤起。所以，如果可能的话，让一个传输可被重新唤起是很重要的。 如果后台传输初始化时app是在后台，那这个任务将被当做可裁剪的。换言之，它将被当做 配置对象的 discretionary 属性为 true 的session中的一个任务。 如果这些限制和你 app 的需求有冲突，你可以在 non-background session 中将远程资源下载到一个文件中。这样，当你的用户让你的 iOS app 进入后台或是退出你的 OS X app 时，可以通过调用 cacelByProducingResumeData: 方法来暂停任何进行中的下载任务。当用户重新让 app 进入前台时恢复下载。如果你的 app 在你获取到任何恢复的数据之前终止了，就不能再恢复下载了。 注意：后台 session 是为了优化传输少量很大的资源，在必要时可以进行续传。如果可以，你可能想要调查优化服务器端行为的方法 ，来实现这样的用法，比如： 在终结点发起发送或接收 zip 或 tar格式的压缩文件的请求，而不是分开调用多次； 在终结点发起发送或接收在服务器和客户端之间的增量差异的请求； 在终结点发起一个可返回上传ID的请求，这个ID可用来追踪和恢复传输到服务器的数据； 添加一个中间的web 服务器代理请求到规范的web服务器，以方便任何上述优化。 NSCopying Behaviorsession 和 task 对象都遵从 NSCopying 协议，如下： 当你的app 拷贝一个session 或是 task 对象时，你会得到一个同样的对象； 当你的app拷贝一个配置对象时，你会得到一个你可以独立地修改的拷贝对象。 Thread Safety线程安全URL Session API 自身完全是线程安全的。你可以在任何一个线程上下文中随意创建 session 和 task，而且，当你的代理方法调用提供的 完成回调时，它的工作已自动被安排在正确的代理队列中。 本文为「简书-白开水ln」作者原创；我的写作，希望能简化到初学者尽快入门和老司机繁琐回顾 ^_^.在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 警告：你的 URLSessionDidFinishEventsForBackgroundURLSession: 代理方法可能会在第二线程中被调用。但是，在iOS中，你完成那个方法时需要在application:handleEventsForBackgroundURLSession:CompletionHandler: app 代理方法中调用completion handler。而且你必须在主线程中调用那个 completion handler。 NSURLSession 有太多的东西值得我们去学习推敲，方方面面都透露着学习的必要性，学习总结，一劳永逸，对我们日后开发一定会受益良多。作为一枚成长中的菜鸟，分享和开源精神，还是值得具备的。 【@码员真爱 : 真的不点进去阅读一下 ❓】【译文 &amp; 源码】 【工具类】 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[赞赏篇]]></title>
    <url>%2FPerceptionWork%2Fappreciates.html</url>
    <content type="text"><![CDATA[对你有新思想 或是 习惯，你可随意赞赏 ！ 对我所花费时间的一个赞助 ！便捷你我的高效学习 ！ &nbsp;About contact E-mail：pbwaterln@sina.com 「请注明来意、非诚切勿打扰、蟹蟹」WeChat-public：「🔍白开水ln，每周末分享伐码经验和可吸收思想的文章，文章首发 Blog，喜欢可 留言 | Rss」]]></content>
      <categories>
        <category>职场</category>
      </categories>
      <tags>
        <tag>赞赏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo文章简单加密访问]]></title>
    <url>%2FHexoBlog%2FHexoArticleEncryption.html</url>
    <content type="text"><![CDATA[Welcome]]></content>
      <categories>
        <category>HexoBlog</category>
      </categories>
      <tags>
        <tag>HexoBlog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo(Pages)—优化博客「续更」]]></title>
    <url>%2FHexoBlog%2FHexoPagesOptimize.html</url>
    <content type="text"><![CDATA[给自己一个记录 知识 和 时间 的空间。 拥有一个这样的独立而自由的空间是一件非常有趣的事情。 本篇整理来自网络文章，是自己搭建优化遇到使用或摘录博文常用好用的小功能点，再次整理一下，方便首次搭建少走些坑，我会及时加上出处 Content progress 文字居中（写博客时）在你博客文章中需要居中处加上下面这段代码即可，中间的文字改成你所需要的文字。123&lt;blockquote class="blockquote-center"&gt;不忘初心，这里可以写多行文字&lt;/blockquote&gt; 为博客加上GitHub丝带如果是Next主题（其他主题也差不多），添加GitHub丝带：在themes\next\layout\_layout.swig中加入相关代码，记得修改自己的链接。 相关代码你可以在GitHub官方网站 GitHub Ribbons 上进行选择。 加入作者版权信息我们可以为博客文章加入作者版权信息。例如本文地址：http://www......./ 转载请注明出处，谢谢！等等。对Next主题而言，先找到/themes/next/layout/_macro/post.swig，再找到其中的微信订阅部分，如下所示： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后直接在其上面添加如下代码段： 123456789&lt;div align="center"&gt; &#123;% if not is_index %&#125; &lt;div class="copyright"&gt; &lt;p&gt;&lt;span&gt; &lt;b&gt;本文地址：&lt;/b&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;&lt;br /&gt;&lt;b&gt;转载请注明出处，谢谢！&lt;/b&gt; &lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 当然，在上面这段代码，你可以进行一些个性化编写，可以展示你自己个性化的版权信息。 为博客加入动态背景首先找到\themes\next\layout\_layout.swig，在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）。 默认灰色线条 1&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 浅蓝色线条 1&lt;script type="text/javascript" src="/js/src/particle.js" count="50" zindex="-2" opacity="1" color="0,104,183"&gt;&lt;/script&gt; 然后在themes\source\js\src\下新建文件particle.js写上以下代码:1!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e("script"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,"zIndex",-1),o:n(i,"opacity",.5),c:n(i,"color","0,0,0"),n:n(i,"count",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle="rgba("+m.c+","+(t+.2)+")",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement("canvas"),m=t(),d="c_n"+m.l,l=u.getContext("2d"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText="position:fixed;top:0;left:0;z-index:"+m.z+";opacity:"+m.o,e("body")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 为博客加入鼠标点击显示红心鼠标点击小红心在\themes\next\source\js\src文件目录下添加love.js文件。内容为：1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 找到\themes\next\layout\_layout.swing文件，在文件的后面，&lt;/body&gt;之前 添加以下代码：12&lt;!-- 小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 给博客添加LICENSE在主题配置文件中添加下面这段代码（添加之前好好看看你的主题配置文件是否已经包含这段代码，已经包含就不用再加一遍了，因为重复会报错），这个LICENSE显示在侧边栏。12345# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: by-nc-sa#creative_commons: 添加Local Search功能安装 hexo插件在你的站点文件夹中，用shell等运行下面这行代码：1$ npm install hexo-generator-searchdb --save 编辑站点配置文件添加以下字段：12345search: path: search.xml field: post format: html limit: 10000 启用本地搜索编辑主题配置文件启用本地搜索123# Local searchlocal_search: enable: true 修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示：1$font-size-base = 16px 修改网页配色取色可以用QQ，打开QQ按Ctrl+Alt+A开始截图，将鼠标移到文字上，按住Ctrl键即可看到该颜色的16进制代码。也可以用chrome浏览器的develop tool取色，选取喜欢的颜色。 修改\themes\next\source\css\ _variables\base.styl文件，找到文件开头的colors for use across theme，加入自定义颜色，在$orange = #fc6423下加入下面这段代码：123// 下面是我自定义的颜色$my-link-blue = #0593d3 //链接颜色$my-link-hover-blue = #0477ab //鼠标悬停后颜色 修改超链接颜色打开\themes\next\source\css\ _variables\base.styl文件，像下面这样改掉这几行：12345/ Global link color.$link-color = $my-link-blue$link-hover-color = $my-link-hover-blue$link-decoration-color = $gray-lighter$link-decoration-hover-color = $my-link-hover-blue 修改小型代码块颜色我修改&lt;code&gt;样式是因为我开启了highlight，highlight在渲染&lt;pre&gt;&lt;code&gt;标签的同时也渲染了&lt;code&gt;标签，而且优先级高，所以才会出现方法一中这种不开启!important，样式就不起作用的问题。在方法一使用了!important使得此处对&lt;code&gt;的样式优先级最高，所以设置成功。 方法一打开\themes\next\source\css\ _variables\base.styl文件，修改如下：在下面这段代码：123456// Code &amp; Code Blocks// --------------------------------------------------$code-font-family = $font-family-monospace$code-font-size = 14px$code-font-size = unit(hexo-config('font.codes.size'), px) if hexo-config('font.codes.size') is a 'unit'$code-border-radius = 4px 下方加入下面这段代码:1234code &#123; color:#dd0055 !important; background:#eee !important;&#125; 方法二你也可以不用方法一（建议使用方法一，因为第二种可能会失效，被其他的样式定义覆盖），而是在source/css/_variables/custom.styl文件中设定$code-foreground和$code-background的值，也是用的优先级。123$code-foreground = #fc6423$code-background = #fc6423#此处颜色只是例子，你自己设置。 修改其他颜色修改：themes\next\source\css\_variables\.base.styl文件：123grey-dim = #666 &gt;&gt;&gt; $grey-dim = #353535$black-light = #555 &gt;&gt;&gt; $black-light = #353535$blue-bright = #87daff &gt;&gt;&gt; $blue-bright = #45c5ff 加入统计和提高索引量添加sitemap插件 谷歌与百度的站点地图，前者适用于其他搜索引擎，用来手动提交以增加收录。 sitemap 安装在你的站点文件夹中，用shell等分次运行下面这两行代码：12npm install hexo-generator-sitemap@1 --savenpm install hexo-generator-baidu-sitemap@0.1.1 --save 设置站点配置文件在站点配置文件中添加代码：12345# hexo sitemap网站地图sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml。其中sitemap.xml适合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。 其次，在站点根目录下新建一个robots.txt文件，其中添加下面的一段代码（具体网站改为你自己的网址）： 123456789101112# hexo robots.txtUser-agent: *Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://dingxuewen.github.io/sitemap.xmlSitemap: https://dingxuewen.github.io/sitemap.xml 给非友情链添加标签经过chinaz站长工具友情链接检测，发现有不必要的PR值输出，对于非友情链接的PR值输出，我们可以加上nofollow便签避免不必要的PR输出。方法是给链接加上rel=&quot;external nofollow&quot;属性。例如： 找到\themes\next\layout\_partials\footer.swig文件，将下面代码：1&#123;&#123; __('footer.powered', '&lt;a class="theme-link" href="http://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125; 改成：1&#123;&#123; __('footer.powered', '&lt;a class="theme-link" href="http://hexo.io" rel="external nofollow"&gt;Hexo&lt;/a&gt;') &#125;&#125; 将下面代码：1&lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next"&gt; 改成：1&lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow"&gt; 加入Baidu站长统计先准备一些代码。站长统计，注册并获取统计代码：12345 | &lt;script type="text/javascript"&gt; var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://"); document.write(xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' type='text/javascript'%3E%3C/script%3E"));&lt;/script&gt; 修改底栏:找到\themes\next\layout\_partials\footer.swig文件,加入上面这段代码，出于保护隐私的考虑，我编辑掉了部分关键代码，直接复制上面的无法使用。注意把上面的xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx换成你自己的站长统计代码。 在页脚加入地图在页脚加入百度地图和谷歌地图链接： 找到\themes\next\layout\_partials\footer.swig文件，百度和Google网站地图，上面已经安装了，这是插入到底栏的代码：12 | &lt;span&gt;&lt;a href="/sitemap.xml"&gt;Google网站地图&lt;/a&gt;&lt;/span&gt; | &lt;span&gt;&lt;a href="/baidusitemap.xml"&gt;百度网站地图 添加Baidu自动推送百度自动推送代码，在页面被访问时，页面URL将立即被推送给百度，可以增加百度收录：找到\themes\next\layout\_partials\footer.swig或\themes\next\layout\_macro\post.swig文件，（Next主题已经有了\themes\next\layout\_scripts\baidu-push.swig）添加下面的代码。1234567891011121314&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https')&#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else&#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt; 不蒜子统计找到\themes\next\layout\_partials\footer.swig文件，加入下面不蒜子统计代码：12345 | 本页点击 &lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt; 次 | 本站总点击 &lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt; 次 | 您是第 &lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt; 位访客&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 在标题下添加【阅读量】等现在要添加的阅读量统计也依赖下面这段代码。12&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 打开/themes/next/layout/_macro/post.swig，找到标签&lt;div class=&quot;post-meta&quot;&gt;&lt;/div&gt;，在该标签内部合适的位置（如time和categories之间或categories后面）添加：123&#123;% if not is_index %&#125; &lt;span id="busuanzi_container_page_pv"&gt; | 阅读量 &lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt; 次&lt;/span&gt;&#123;% endif %&#125; 将阅读量改为热度（更个性）还可以继续修改，看到好多人的博客不是阅读次数（阅读量），而是热度 188 ℃，那么可以继续这样修改，首先在Next主题的/themes/next/languages/zh-Hans文件中查找”阅读次数“这几个字，可以看到，在post中的visitors被定义为“阅读次数”，把这里的“阅读次数”改为“热度”。 那么怎么在页面中显示呢。打开Next主题文件夹中layout/_macro/post.swig，在这个文件里加上摄氏度的标志，在&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;下面增加一行&lt;span&gt;℃&lt;/span&gt;即可。 修改标题下分类等的样式在Next主题中，我用的是LeanCloud数据统计，默认样式是在统计数据前有个小眼睛，我感觉不好看，想把它去掉，那么打开/themes/next/layout/_macro/post.swig，找到标签&lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;，去掉下面这段代码即可：123&lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-eye"&gt;&lt;/i&gt;&lt;/span&gt; SEO优化更改首页标题格式为「关键词-网站名称-网站描述」。打开\themes\next\layout\index.swig文件，找到这行代码：1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 把它改成：123&#123;% block title %&#125; &#123;&#123; theme.keywords &#125;&#125; - &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125;&#123;% endblock %&#125; 博客部署的message设置在\hexo\node_modules\hexo-deployer-git\lib\deployer.js文件末尾找到这一句：1Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;. 改得个性化一点：1勤奋的博主又更新啦: &#123;&#123; now(\'YYYY-MM-DD HH:mm:ss\') &#125;&#125;. 为项目主页添加README在 Github 上的博客仓库主页空荡荡的，没有README。如果把README.md放入source文件夹，hexo g生成时会被解析成html文件，放到public文件夹，生成时又会自动删除。 解决方法很简单，在站点配置文件中，搜索skip_render:，在其冒号后加一个空格然后加上README.md即可。 优化主题 sidebar 头像就是为主题 sidebar 头像添加圆形化旋转的效果。修改 /themes/next/source/css/_common/components/sidebar/sidebar-author.styl 文件，我的整个 sidebar-author.styl文件的代码如下，你可以直接复制这段代码去替换你这个文件中的所有代码。有一个注意事项，就是你要保证你的头像，也就是 avatar.jpg 这个图片是正方形，不是的话你要将其修改成正方形，这样才能通过样式将其展现为很好看的正圆，否则会是一个椭圆形。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 小红心优化为博客加入鼠标点击显示小红心，但是如果我们只想在博客的某个页面添加这个功能呢？那么就可以在 \themes\next\source\js\src 文件目录下添加 love.js 文件。内容为：1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 之后呢，不在\themes\next\layout\_layout.swing 文件中添加代码，而是在你想要显示红心的页面的 Markdown 文件中加入下面这段代码,例如我就在我的留言板页面的 Markdown 文件中加入了下面这段代码。12&lt;!-- 小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 文章内文本样式Markdown 毕竟是为了方便写作，在样式上过于单调。我们可以自己来给文章加一些样式。NexT 作者提供了一个供用户自己定义样式的文件：\themes\next\source\css\_custom\custom.stly。可以按照自己的需要写。下参考： 设置动态title在 \themes\next\source\js\src 目录下新建 dytitle.js 。添加以下内容： 1234567891011121314151617&lt;!--崩溃欺骗--&gt;var OriginTitile = document.title; var titleTime; document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="icon"]').attr('href', "/img/TEP.ico"); document.title = ' 页面崩溃啦 ~ | cwyaml！'; clearTimeout(titleTime); &#125; else &#123; $('[rel="icon"]').attr('href', "/favicon.ico"); document.title = ' 噫又好了~ ' + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125; &#125;); 更改 \themes\next\layout\_layout.swig 。在 &lt;/body 之前添加：12&lt;!--卖萌--&gt;&lt;script type="text/javascript" src="/js/src/dytitle.js"&gt;&lt;/script&gt; 添加听音乐代码设置在 \themes\next\layout\_macro目录下新建 high.swig 文件，添加以下内容：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;a title="收藏到书签，偶尔High一下^_^" rel="alternate" class="mw-harlem_shake_slow wobble shake" href='javascript:( /* * Copyright (C) 2015 Rocko (rocko.xyz) &lt;rocko.zxp@gmail.com&gt; * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ function go() &#123; var songs = [ "http://m2.music.126.net/3uHnH7uQAeFwUfuvEB9lrg==/3265549619475054.mp3", "http://m2.music.126.net/NnHwR2HV-1OoKZ6R5LVy4Q==/18502581673300023.mp3", "http://m2.music.126.net/qv3RI4K7ABKJ0TyAdb3taw==/3250156397064860.mp3", "......" ]; function S() &#123; var e = document.getElementById("audio_element_id"); if(e != null)&#123; var index = parseInt(e.getAttribute("curSongIndex")); if(index &gt; songs.length - 2) &#123; index = 0; &#125; else &#123; index++; &#125; e.setAttribute("curSongIndex", index); &#125; e.src = i; e.play() &#125; function initAudioEle() &#123; var e = document.getElementById("audio_element_id"); if(e === null)&#123; e = document.createElement("audio"); e.setAttribute("curSongIndex", 0); e.id = "audio_element_id"; e.loop = false; e.bgcolor = 0; e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.addEventListener("ended", function() &#123; go(); &#125;, true); &#125; &#125; initAudioEle(); var curSongIndex = parseInt(document.getElementById("audio_element_id").getAttribute("curSongIndex")); var i = songs[curSongIndex]; S(); &#125;)()'&gt; &lt;i class="fa fa-music"&gt;&lt;/i&gt; 听音乐&lt;/a&gt; 在侧边栏引用该文件：修改 \themes\next\layout\_macro\sidebar.swig ，添加以下代码：1&#123;% include 'high.swig' %&#125; 样式修改：使 听音乐 和 RSS 并排展示。修改 \themes\next\source\css\_schemes\Pisces\_sidebar.styl文件：1display: inline-block; 添加自己喜欢的音乐：修改其中的歌曲链接即可.123456var songs = [ "http://m2.music.126.net/3uHnH7uQAeFwUfuvEB9lrg==/3265549619475054.mp3", "http://m2.music.126.net/NnHwR2HV-1OoKZ6R5LVy4Q==/18502581673300023.mp3", "http://m2.music.126.net/qv3RI4K7ABKJ0TyAdb3taw==/3250156397064860.mp3", "......" ]; 首页听音乐摇晃：需要加载 css 样式。在 themes\next\layout\_layout.swig文件的 &lt;/body&gt;标签前 添加以下代码：12&lt;!-- 听音乐摇晃 --&gt;&lt;link href="http://s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css" rel="stylesheet" type="text/css"&gt; 注意：有时候使用 Firefox 、Chrome时会提示非法插件并禁止使用，遇到这种情况我们把样式代码引入到 \themes\next\source\css\_custom\custom.stly文件即可解决。 音乐链接获取 先获取歌曲id，直接打开 网易云音乐网页版 http://music.163.com 搜索自己喜欢的音乐，点击外链生成器获取歌曲的 ID 。举个例子：（id显而易见吧） 1http://music.163.com/#/song?id=443205403 将下面网址中的两处id替换成的歌曲 id ，你将会获得一大串代码：外链就隐藏其中（如下图，自己找）。 http://music.163.com/api/song/detail/?id=425137664&amp;ids=[425137664]&amp;csrf_token= 将上一步中获取到的网址放到地址栏中，若能正常播放音乐说明获取到的网址是正确的。然后你就可以把这些歌曲添加到自己的网页中了！用这种方法有些歌曲并不能获得，不过时效很长（只要网易云能听）。 博文压缩目前知道的有两个插件可以压缩博文，hexo-all-minifier 插件和 gulp 插件。hexo-all-minifier 虽然使用比较简单，而且也可以压缩图片，但是对文章缩进（输入法全拼模式下按 Tab）不支持，所以暂时使用 gulp 压缩手段。 hexo-all-minifier 使用方法安装 hexo-all-minifier，在站点的根目录下执行以下命令：1$ npm install hexo-all-minifier --save hexo g 编译的时候就会自动压缩 HTML、JS、图片。详情参考插件介绍 hexo-all-minifier glup 使用方法hexo 依赖 gulp 插件安装，在站点的根目录下执行以下命令：12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在 package.json 同级目录下，新建 gulpfile.js 并填入以下内容：123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']); 生成博文是执行 hexo g &amp;&amp;amp; gulp 就会根据 gulpfile.js 中的配置，对 public目录中的静态资源文件进行压缩。 博文置顶修改 hero-generator-index 插件 替换文件：node_modules/hexo-generator-index/lib/generator.js 内的代码为：12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 设置文章置顶在文章 Front-matter 中添加 top 值，数值越大文章越靠前，如：1234567---title: 图集categories: [图片]tags: [picture]date: 2015-04-02 14:36:04top: 10--- embed.js本地化embed.js 是多说使用的远程脚本，你可以访问 http://static.duoshuo.com/embed.js 这个网址。右键另存为 \theme\next\source\js\src\这个文件夹。 然后打开 \themes\next\layout\_scripts\third-party\comments\duoshuo.swig 这个文件，在文件里搜索 //static.duoshuo.com/embed.js ，把它改成 /js/src/embed.js。搞定啦！ Hexo更改默认Google字体库因为一些国内的客观原因，google字体库 的访问速度一直很慢，所以生成页面后，访问系统总是会耗费一大部分的时间在加载google字体库上，而且经常加载不成功。 解决的办法是可以用国内的CDN库来替代主题中的google字体库，更改方法如下：shell中运行如下命令：1grep -ir fonts.google themes/ 找到对应的google字体库地方，用国内的CDN字体库替换，如360字体库：360前端公共库CDN。 首页分割线在 \themes\next\source\css\_custom\custom.styl 文件中添加以下代码，可以修改博客首页中每篇文章的分割线长度，我设置为了100%长度。1234567891011//index页面中每篇文章相隔的那条线.posts-expand &#123; .post-eof &#123; display: block; margin: $post-eof-margin-top auto $post-eof-margin-bottom; width: 100%; height: 3px; background: $grey-light; text-align: center; &#125;&#125; 字体、颜色等设置在\themes\next\source\css\_variables\custom.styl 文件中添加以下代码。具体功能我已经做了注释。12345678910111213141516// 标题，修改成你期望的字体族$font-family-headings = Georgia, sans// 修改成你期望的字体族$font-family-base = "Microsoft YaHei", Verdana, sans-serif// 代码字体$code-font-family = "Input Mono", "PT Mono", Consolas, Monaco, Menlo, monospace// 正文字体的大小$font-size-base = 16px// 代码字体的大小$code-font-size = 14px// 代码块颜色$code-foreground = #dd0055// Background color for &lt;body&gt;$body-bg-color = #e7e5dc //theme mist use #fdfdfd// text-color$text-color = #353535 语言配置_config.yml中的language要配置为选定的主题cilia文件夹下的language目录下的文件，如：1234language: zh-Hanslanguage: enlanguage: zh-hklanguage: zh-tw 这里修改 zh-Hans为标准的zh-cn,并添加一些汉化内容语言配置用法:1234# 不带参数的__('xxxx')# 带参数的_p('xxx',xx) 不蒜子统计显示添加站点统计配置为不蒜子统计，并且可开关1busuanzi: true 配置自己的分享国内的jiathis将themes/yilia/_partial/share_jia.ejs中的内容替换为：12345678910&lt;div class="jiathis_style"&gt; &lt;span class="jiathis_txt"&gt;&lt;%= __('post.share') %&gt;: &lt;/span&gt; &lt;a class="jiathis_button_weixin"&gt;微信&lt;/a&gt; &lt;a class="jiathis_button_cqq"&gt;QQ好友&lt;/a&gt; &lt;a class="jiathis_button_qzone"&gt;QQ空间&lt;/a&gt; &lt;a class="jiathis_button_tsina"&gt;新浪微博&lt;/a&gt; &lt;a href="http://www.jiathis.com/share?uid=2080230" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"&gt;更多&lt;/a&gt; &lt;a class="jiathis_counter_style"&gt;&lt;/a&gt;&lt;/div&gt;&lt;script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=2080230" charset="utf-8"&gt;&lt;/script&gt; 其中uid为自己在jiathis注册的uid 国外的add this将themes/yilia/_partial/share_jia.ejs中的内容替换为：123&lt;!-- Go to www.addthis.com/dashboard to customize your tools --&gt;&lt;div class="addthis_sharing_toolbox"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="http://s7.addthis.com/js/300/addthis_widget.js#pubid=ra-568f54bcfd6a7b04" async="async"&gt;&lt;/script&gt; Rss添加Rss，需要先安装rss生成模块：1npm install hexo-generator-feed --save 然后在themes/yilia/_config.yml开启rss1rss: /atom.xml 站点配置文件123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 添加站点地图插件1npm install hexo-generator-sitmap --save 会在每次hexo generator后自动生成到网站根目录 设置网站logo通过网站favicon在线制作 制作favicon图片，logo最好设置32*32。next主题：将图片放在next主题source/images目录下12# 在next主题配置文件中添加：favicon: /uploads/images/favicon.png Hexo文章简单加密访问找到themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件。按道理是添加在任何地方都行，但是推荐加在所有的&lt;meta&gt;标签之后。12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 1234567891011---title: Hexo文章简单加密访问date: 2016-12-02 tags: hexocategories: 博客keywords: - Hexo - 加密description: 文章访问密码：passwordpassword: password--- Hexo high一下是直接把这段代码当成一个菜单项加在博客主题配置的_config.yml文件中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;li&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125;&#125;)() '&gt;High一下&lt;/a&gt; &lt;/li&gt; 12345678910menu: high: javascript:void(0)menu_icons: high: play// 第一个 high 的javascript:void(0)是指a标签的跳转链接，其实这里的功能就是为了让它不跳转的，另外还有一个功能，可以把空链接的a标签悬浮变成手型的鼠标。第二个 high对应的play是展示的图标，NexT主题使用的是fontawesome图标，这里的play就是其对应的图标，想自己 diy 一下就去fontawesome上找个自己喜欢的。这样的方法简单粗暴有效，并且还有一个好处，可以直接把这个链接保存成浏览器的书签，这样就能在任何网页都能够调用这个 High一下 的方法。 high 一下自定义页面歌曲首先是在需要自定义曲子的文章中加上： 1&lt;div id="musicUrl" url="***"&gt;&lt;div&gt; 然后最终版high.js代码是这样：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165document.getElementsByClassName('menu-item-high')[0].addEventListener('click', (function()&#123; var play = false; var musicUrl = document.getElementById('musicUrl'); if(musicUrl)&#123; musicUrl = musicUrl.getAttribute('url'); &#125;else&#123; musicUrl = null; &#125; return function()&#123; if(play)&#123; console.log('Enjoying'); return; &#125; play = true; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height: e.offsetHeight, width: e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h(); paly = false; &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = musicUrl || "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "/vendors/high/high.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125; &#125;;&#125;)(), false); 修改文章链接HEXO 默认的文章链接形式为domain/year/month/day/postname，默认就是一个四级url，并且可能造成url过长，对搜索引擎是十分不友好的，我们可以改成domain/postname的形式。编辑站点_config.yml文件，修改其中的permalink字段改为permalink: :title.html即可。 夜间模式 Hexo-Next-Mist主题头部顶栏背景图片图片存放位置：选择一张心仪的图片，命名为 background.jpg，放到 source 文件夹下的 image 文件夹内。12Hexo\source\image // 图片大小我选择的是“50厘米*5厘米”，太小的话无法覆盖整个背景 背景图片设置：找到如下位置：1234567hexo\themes\next\source\css\_schemes\Mist\_header.styl打开 _header.styl，将第一行 background: 后的内容改为如下形式：方式一：本地图片.header &#123; background: url('Hexo\source\image/background.jpg'); &#125;方式一：网络图片.header &#123; background: url('http://upload-images.jianshu.io/upload_images/2230763-265f0df7e75d706a.gif?imageMogr2/auto-orient/strip'); &#125; 保存，重新生成网页即可。 打赏字体不闪动 修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下： 123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 博客文章链接无中文乱码 ☕️更新【更多实质性小功能分享，整理自网络】 未完待续 ！ 未完待续 ！ 未完待续 ！ 参考原著：摘录1、【Levi.Blog】 http://www.dingxuewen.com2、【lancelot_lewis】 https://lancelot_lewis.coding.me3、【http://www.jianshu.com/p/f054333ac9e6】 4、【】]]></content>
      <categories>
        <category>HexoBlog</category>
      </categories>
      <tags>
        <tag>HexoBlog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS NSURLConnection 到 NSURLSession 译文]]></title>
    <url>%2FAppleTranslation%2FConnectionToSession.html</url>
    <content type="text"><![CDATA[iOS 7 和 Mac OS X 10.9 Mavericks 中一个显著的变化就是对 Foundation URL 加载系统的彻底重构。 现在已经有人在深入苹果的网络层基础架构的地方做研究了，所以我想是时候来分享一些对于我对于这些新的 API 的看法和心得了，新的 API 将如何影响我们编写程序，以及它们对于 API 设计理念的影响。 NSURLConnection 作为 Core Foundation / CFNetwork 框架的 API 之上的一个抽象，在 2003 年，随着第一版的 Safari 的发布就发布了。NSURLConnection 这个名字，实际上是指代的 Foundation 框架的 URL 加载系统中一系列有关联的组件：NSURLRequest、NSURLResponse、NSURLProtocol、 NSURLCache、 NSHTTPCookieStorage、NSURLCredentialStorage 以及同名类 NSURLConnection。 NSURLRequest 被传递给 NSURLConnection。被委托对象（遵守以前的非正式协议 &lt;NSURLConnectionDelegate&gt; 和 &lt;NSURLConnectionDataDelegate&gt;）异步地返回一个 NSURLResponse 以及包含服务器返回信息的 NSData。 在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据策略（policy）以及可用性（availability）的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应以便将来的请求可以使用。 在把请求发送给服务器的过程中，服务器可能会发出鉴权查询（authentication challenge），这可以由共享的 cookie 或机密存储（credential storage）来自动响应，或者由被委托对象来响应。发送中的请求也可以被注册的 NSURLProtocol 对象所拦截，以便在必要的时候无缝地改变其加载行为。 不管怎样，NSURLConnection 作为网络基础架构，已经服务了成千上万的 iOS 和 Mac OS 程序，并且做的还算相当不错。但是这些年，一些用例——尤其是在 iPhone 和 iPad 上面——已经对 NSURLConnection 的几个核心概念提出了挑战，让苹果有理由对它进行重构。 在 2013 的 WWDC 上，苹果推出了 NSURLConnection 的继任者：NSURLSession。 和 NSURLConnection 一样，NSURLSession 指的也不仅是同名类 NSURLSession，还包括一系列相互关联的类。NSURLSession 包括了与之前相同的组件，NSURLRequest 与 NSURLCache，但是把 NSURLConnection 替换成了 NSURLSession、NSURLSessionConfiguration 以及 NSURLSessionTask 的 3 个子类：NSURLSessionDataTask，NSURLSessionUploadTask，NSURLSessionDownloadTask。 与 NSURLConnection 相比，NSURLsession 最直接的改进就是可以配置每个 session 的缓存，协议，cookie，以及证书策略（credential policy），甚至跨程序共享这些信息。这将允许程序和网络基础框架之间相互独立，不会发生干扰。每个 NSURLSession 对象都由一个 NSURLSessionConfiguration 对象来进行初始化，后者指定了刚才提到的那些策略以及一些用来增强移动设备上性能的新选项。 NSURLSession 中另一大块就是 session task。它负责处理数据的加载以及文件和数据在客户端与服务端之间的上传和下载。NSURLSessionTask 与 NSURLConnection 最大的相似之处在于它也负责数据的加载，最大的不同之处在于所有的 task 共享其创造者 NSURLSession 这一公共委托者（common delegate）。 我们先来深入探讨 task，过后再来讨论 NSURLSessionConfiguration。 NSURLSessionTask NSURLsessionTask 是一个抽象类，其下有 3 个实体子类可以直接使用：NSURLSessionDataTask、NSURLSessionUploadTask、NSURLSessionDownloadTask`。这 3 个子类封装了现代程序三个最基本的网络任务：获取数据，比如 JSON 或者 XML，上传文件和下载文件。 当一个 NSURLSessionDataTask 完成时，它会带有相关联的数据，而一个 NSURLSessionDownloadTask 任务结束时，它会带回已下载文件的一个临时的文件路径。因为一般来说，服务端对于一个上传任务的响应也会有相关数据返回，所以 NSURLSessionUploadTask 继承自 NSURLSessionDataTask。 所有的 task 都是可以取消，暂停或者恢复的。当一个 download task 取消时，可以通过选项来创建一个恢复数据（resume data），然后可以传递给下一次新创建的 download task，以便继续之前的下载。 不同于直接使用 alloc-init 初始化方法，task 是由一个 NSURLSession 创建的。每个 task 的构造方法都对应有或者没有 completionHandler 这个 block 的两个版本，例如：有这样两个构造方法 –dataTaskWithRequest:和 –dataTaskWithRequest:completionHandler:。这与 NSURLConnection 的 -sendAsynchronousRequest:queue:completionHandler: 方法类似，通过指定 completionHandler 这个 block 将创建一个隐式的 delegate，来替代该 task 原来的 delegate——session。对于需要 override 原有 session task 的 delegate 的默认行为的情况，我们需要使用这种不带 completionHandler 的版本。 NSURLSessionTask 的工厂方法 在 iOS 5 中，NSURLConnection 添加了 sendAsynchronousRequest:queue:completionHandler:这一方法，对于一次性使用的 request， 大大地简化代码，同时它也是 sendSynchronousRequest:returningResponse:error: 这个方法的异步替代品：12345678NSURL *URL = [NSURL URLWithString:@"http://example.com"];NSURLRequest *request = [NSURLRequest requestWithURL:URL];[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *error) &#123; // ...&#125;]; NSURLSession 在 task 的构造方法上延续了这一模式。不同的是，这里不会立即运行 task，而是将该 task 对象先返回，允许我们进一步的配置，然后可以使用 resume 方法来让它开始运行。 Data task 可以通过 NSURL 或 NSURLRequest 创建（使用前者相当于是使用一个对于该 URL 进行标准 GET 请求的 NSURLRequest，这是一种快捷方法）：1234567891011NSURL *URL = [NSURL URLWithString:@"http://example.com"];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSURLSession *session = [NSURLSession sharedSession];NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler: ^(NSData *data, NSURLResponse *response, NSError *error) &#123; // ... &#125;];[task resume]; Upload task 的创建需要使用一个 request，另外加上一个要上传的 NSData 对象或者是一个本地文件的路径对应的 NSURL：12345678910111213NSURL *URL = [NSURL URLWithString:@"http://example.com/upload"];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSData *data = ...;NSURLSession *session = [NSURLSession sharedSession];NSURLSessionUploadTask *uploadTask = [session uploadTaskWithRequest:request fromData:data completionHandler: ^(NSData *data, NSURLResponse *response, NSError *error) &#123; // ... &#125;];[uploadTask resume]; Download task 也需要一个 request，不同之处在于 completionHandler 这个 block。Data task 和 upload task 会在任务完成时一次性返回，但是 Download task 是将数据一点点地写入本地的临时文件。所以在 completionHandler 这个 block 里，我们需要把文件从一个临时地址移动到一个永久的地址保存起来：1234567891011121314NSURL *URL = [NSURL URLWithString:@"http://example.com/file.zip"];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSURLSession *session = [NSURLSession sharedSession];NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:request completionHandler: ^(NSURL *location, NSURLResponse *response, NSError *error) &#123; NSString *documentsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; NSURL *documentsDirectoryURL = [NSURL fileURLWithPath:documentsPath]; NSURL *newFileLocation = [documentsDirectoryURL URLByAppendingPathComponent:[[response URL] lastPathComponent]]; [[NSFileManager defaultManager] copyItemAtURL:location toURL:newFileLocation error:nil]; &#125;];[downloadTask resume]; NSURLSession 与 NSURLConnection 的 delegate 方法 总体而言，NSURLSession 的 delegate 方法是 NSURLConnection 的演化的十年中对于 ad-hoc 模式的一个显著改善。您可以查看这个映射表来进行一个完整的概览。 以下是一些具体的观察： NSURLSession 既拥有 seesion 的 delegate 方法，又拥有 task 的 delegate 方法用来处理鉴权查询。session 的 delegate 方法处理连接层的问题，诸如服务器信任，客户端证书的评估，NTLM和 Kerberos协议这类问题，而 task 的 delegate 则处理以网络请求为基础的问题，如 Basic，Digest，以及代理身份验证（Proxy authentication）等。 在 NSURLConnection 中有两个 delegate 方法可以表明一个网络请求已经结束：NSURLConnectionDataDelegate 中的 -connectionDidFinishLoading: 和 NSURLConnectionDelegate 中的 -connection:didFailWithError:，而在 NSURLSession 中改为一个 delegate 方法：NSURLSessionTaskDelegate 的 -URLSession:task:didCompleteWithError: NSURLSession 中表示传输多少字节的参数类型现在改为 int64_t，以前在 NSURLConnection 中相应的参数的类型是 long long。 由于增加了 completionHandler: 这个 block 作为参数，NSURLSession 实际上给 Foundation 框架引入了一种全新的模式。这种模式允许 delegate 方法可以安全地在主线程与运行，而不会阻塞主线程；Delgate 只需要简单地调用 dispatch_async 就可以切换到后台进行相关的操作，然后在操作完成时调用 completionHandler 即可。同时，它还可以有效地拥有多个返回值，而不需要我们使用笨拙的参数指针。以 NSURLSessionTaskDelegate 的 -URLSession:task:didReceiveChallenge:completionHandler: 方法来举例，completionHandler 接受两个参数：NSURLSessionAuthChallengeDisposition 和 NSURLCredential，前者为应对鉴权查询的策略，后者为需要使用的证书（仅当前者——应对鉴权查询的策略为使用证书，即 NSURLSessionAuthChallengeUseCredential 时有效，否则该参数为 NULL） 想要查看更多关于 session task 的信息，可以查看 WWDC Session 705: “What’s New in Foundation Networking” NSURLSessionConfiguration NSURLSessionConfiguration 对象用于对 NSURLSession 对象进行初始化。NSURLSessionConfiguration 对以前 NSMutableURLRequest 所提供的网络请求层的设置选项进行了扩充，提供给我们相当大的灵活性和控制权。从指定可用网络，到 cookie，安全性，缓存策略，再到使用自定义协议，启动事件的设置，以及用于移动设备优化的几个新属性，你会发现使用 NSURLSessionConfiguration 可以找到几乎任何你想要进行配置的选项。 NSURLSession 在初始化时会把配置它的 NSURLSessionConfiguration 对象进行一次 copy，并保存到自己的configuration属性中，而且这个属性是只读的。因此之后再修改最初配置 session 的那个configuration` 对象对于 session 是没有影响的。也就是说，configuration 只在初始化时被读取一次，之后都是不会变化的。 NSURLSessionConfiguration 的工厂方法 NSURLSessionConfiguration 有三个类工厂方法，这很好地说明了 NSURLSession 设计时所考虑的不同的使用场景。 +defaultSessionConfiguration 返回一个标准的 configuration，这个配置实际上与 NSURLConnection 的网络堆栈（networking stack）是一样的，具有相同的共享 NSHTTPCookieStorage，共享 NSURLCache 和共享 NSURLCredentialStorage。 +ephemeralSessionConfiguration 返回一个预设配置，这个配置中不会对缓存，Cookie 和证书进行持久性的存储。这对于实现像秘密浏览这种功能来说是很理想的。 +backgroundSessionConfiguration:(NSString *)identifier 的独特之处在于，它会创建一个后台 session。后台 session 不同于常规的，普通的 session，它甚至可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程（daemon）提供上下文。 想要查看更多关于后台 session 的信息，可以查看 WWDC Session 204: “What’s New with Multitasking” 配置属性 NSURLSessionConfiguration 拥有 20 个配置属性。熟练掌握这些配置属性的用处，可以让应用程序充分地利用其网络环境。 基本配置 HTTPAdditionalHeaders 指定了一组默认的可以设置出站请求（outbound request）的数据头。这对于跨 session 共享信息，如内容类型，语言，用户代理和身份认证，是很有用的。12345678910NSString *userPasswordString = [NSString stringWithFormat:@"%@:%@", user, password];NSData * userPasswordData = [userPasswordString dataUsingEncoding:NSUTF8StringEncoding];NSString *base64EncodedCredential = [userPasswordData base64EncodedStringWithOptions:0];NSString *authString = [NSString stringWithFormat:@"Basic %@", base64EncodedCredential];NSString *userAgentString = @"AppName/com.example.app (iPhone 5s; iOS 7.0.2; Scale/2.0)";configuration.HTTPAdditionalHeaders = @&#123;@"Accept": @"application/json", @"Accept-Language": @"en", @"Authorization": authString, @"User-Agent": userAgentString&#125;; networkServiceType 对标准的网络流量，网络电话，语音，视频，以及由一个后台进程使用的流量进行了区分。大多数应用程序都不需要设置这个。 allowsCellularAccess 和 discretionary 被用于节省通过蜂窝网络连接的带宽。对于后台传输的情况，推荐大家使用 discretionary 这个属性，而不是 allowsCellularAccess，因为前者会把 WiFi 和电源的可用性考虑在内。 timeoutIntervalForRequest 和 timeoutIntervalForResource 分别指定了对于请求和资源的超时间隔。许多开发人员试图使用 timeoutInterval 去限制发送请求的总时间，但其实它真正的含义是：分组（packet）之间的时间。实际上我们应该使用 timeoutIntervalForResource 来规定整体超时的总时间，但应该只将其用于后台传输，而不是用户实际上可能想要去等待的任何东西。 HTTPMaximumConnectionsPerHost 是 Foundation 框架中 URL 加载系统的一个新的配置选项。它曾经被 NSURLConnection 用于管理私有的连接池。现在有了 NSURLSession，开发者可以在需要时限制连接到特定主机的数量。 HTTPShouldUsePipelining 这个属性在 NSMutableURLRequest 下也有，它可以被用于开启 HTTP 管线化（HTTP pipelining），这可以显着降低请求的加载时间，但是由于没有被服务器广泛支持，默认是禁用的。 sessionSendsLaunchEvents 是另一个新的属性，该属性指定该 session 是否应该从后台启动。 connectionProxyDictionary 指定了 session 连接中的代理服务器。同样地，大多数面向消费者的应用程序都不需要代理，所以基本上不需要配置这个属性。 关于连接代理的更多信息可以在 CFProxySupport Reference 找到。 Cookie 策略 HTTPCookieStorage 存储了 session 所使用的 cookie。默认情况下会使用 NSHTTPCookieShorage 的 +sharedHTTPCookieStorage 这个单例对象，这与 NSURLConnection 是相同的。 HTTPCookieAcceptPolicy 决定了什么情况下 session 应该接受从服务器发出的 cookie。 HTTPShouldSetCookies 指定了请求是否应该使用 session 存储的 cookie，即 HTTPCookieSorage 属性的值。 安全策略 URLCredentialStorage 存储了 session 所使用的证书。默认情况下会使用 NSURLCredentialStorage 的 +sharedCredentialStorage 这个单例对象，这与 NSURLConnection 是相同的。 TLSMaximumSupportedProtocol 和 TLSMinimumSupportedProtocol 确定 session 是否支持 SSL 协议。 安全策略 URLCache 是 session 使用的缓存。默认情况下会使用 NSURLCache 的 +sharedURLCache 这个单例对象，这与 NSURLConnection 是相同的。 requestCachePolicy 指定了一个请求的缓存响应应该在什么时候返回。这相当于 NSURLRequest 的 -cachePolicy 方法。 自定义协议 protocolClasses 用来配置特定某个 session 所使用的自定义协议（该协议是 NSURLProtocol 的子类）的数组。 本文为「简书-白开水ln」作者原创；我的写作，希望能简化到初学者尽快入门和老司机繁琐回顾 ^_^.在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。 结论 iOS 7 和 Mac OS X 10.9 Mavericks 中 URL 加载系统的变化，是对 NSURLConnection 进行深思熟虑后的一个自然而然的进化。总体而言，苹果的 Foundation 框架团队干了一件令人钦佩的的工作，他们研究并预测了移动开发者现有的和新兴的用例，创造了能够满足日常任务而且非常好用的 API 。 尽管在这个体系结构中，某些决定对于可组合性和可扩展性而言是一种倒退，但是 NSURLSession 仍然是实现更高级别网络功能的一个强大的基础框架。 【原文】From NSURLConnection to NSURLSession【转载原著】[@]ObjC 中国 【@码员真爱 : 真的不点进去阅读一下 ❓】【译文 &amp; 源码】 【工具类】 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Naruto-Pictures]]></title>
    <url>%2FHexoBlog%2FNaruto-Pictures.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>HexoBlog</category>
      </categories>
      <tags>
        <tag>HexoBlog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo(Pages)—博客搭建同步GitHub&Coding]]></title>
    <url>%2FHexoBlog%2FHexoPagesSetup.html</url>
    <content type="text"><![CDATA[给自己一个记录 知识 和 时间 的空间。 引导 给自己一个记录知识和时间的空间 –&gt; 对你有新思想 或是 习惯 ！，拥有一个这样的独立而自由的空间是一件非常有趣的事情。 每个优秀的程序员（、📱）在成长过程都有许多个人的体会与感悟，这些感悟让他走的更远，而通常个人博客就是这样一个记录个人成长的地方。Ta，给了你分享成长的机会； 目录： 个人博客搭建方案 创建 GitHub 仓库 本地环境的准备工作 配置本地和Github的ssh传输连接 配置本地和Coding的ssh传输连接 Hexo的上线部署 Next 主题安装 Next 主题博客的站点配置 Next 主题博客的主题配置 创建分类界面 创建标签界面 写博客与发布 多终端编辑hexo博客(多台电脑) Hexo常用命令笔记 域名配置 Hexo博客搭建被坑蛋疼的报错解决集合 优化博客设置「持续更新」 个人博客搭建方案 笔者选择的是GitHubPages + Hexo + Next，一种简单高效的实现方式，当然还有其他的实现方式，如：WordPress、GitHubPages + Jekyll 等。 跟着我做，很简单几分钟你即可拥有自己的个人博客（Hello World 版）。试试吧！ 1.创建 GitHub 仓库 首先你需要拥有一个GitHub账号，注册或者登录 GitHub 创建仓库： 填写仓库名称：注意点： Respository name 中一定要输入：你的用户名.github.io。（用户名即仓库名下面会用到）其他地方不用修改，然后直接点 Create repository“按钮完成创建即可。 2. 本地环境的准备工作 主要以Mac操作进行讲解； Git安装 Git已帮大家下载好了，只需去百度云下载一份安装即可，也可去Git官网下载； 安装：直接双击 dmg 文件安装即可。 Nodejs安装 两种方式：其一去百度云下载一份直接安装；其二去Nodejs官网下载。 说明：Nodejs也可使用Nodejs版本管理器nvm安装，考虑其安装过程中存在的问题较多，操作流程也多，笔者不推荐大家使用这种方式安装。 Hexo 安装Hexo 是搭建的主角，先打开 Hexo 官网。 打开终端，输入Hexo的安装命令： 1npm install hexo-cli -g 若此命令安装不成功时，出现错误解决方法：可输入下面的命令和开机密码继续完成安装： 1sudo npm install --unsafe-perm --verbose -g hero 本地博客仓库 在你本地创建个你希望存储博客文件夹，打开终端，定位到存储博客的目录下，如下所示： 执行Hexo命令，初始化本地博客仓库： hexo init 你的用户名.github.io // 尽量和在上面创建的Github仓库使用同一个名称（我在这就坑了一次，建议使用同一个名称） 博客效果预览 上述步骤完成后，基本的博客框架就已经搭建完了，Hexo安装完成后默认使用 landscape 主题； 在终端定位到 cd xxx.github.io 文件夹下，并在终端输入下面的命令就能启动服务预览功能；1hexo s --debug # 启动服务预览 在浏览器上输入网址：http://localhost:4000/，就能预览到landscape 主题下的博客效果，具体如图： 接着来. . . 3. 配置本地和Github的ssh传输连接 首先我们需要检查你电脑上现有的ssh key： 1234cd ~/. ssh 检查本机的ssh密钥如果提示：No such file or directory 说明你是第一次使用git。 生成新的SSH Key：打开终端输入 ssh-keygen -t rsa -b 4096 -C &quot;你注册Github时的邮箱&quot; ，回车之后系统显示 Enter file in which to save the key(/xxx/.ssh/id_rsa): 我们记住（）中的地址是保存私钥保存地址及文件，之后继续一路回车到结束。 注意：输入密码的时候没有*字样的，你直接输入就可以了。最后看到这样的界面，就成功设置ssh key了： 然后 sudo cat /Users/your_user_directory/id_rsa.pub ，(提示把中间的 Users/your_user_directory/id_rsa替换成你上一步生成的地址) ，回车后把终端上显示的一大段就是 SSH Key 结果复制下来。 登陆github，在下拉菜单中点击Settings，在左侧栏中点击SSH and GPG keys，再点击右侧的New SSH key按键。此时我们可以看到下图情况，Title给这个key起个别名，在Key中，粘贴进去我们之前一步从终端保存下来的那一大段密钥。之后点击下方Add SSH key 现在我们测试一下本地和github的ssh配置是否正确，打开终端输入 ssh -T git@github.com，输入密码后，如果你看到了一句提示信息: Hi (你的注册用户名)! You&#39;ve successfully authenticated, but GitHub does not provide shell access.那么说明已经配置好了github远程仓库与本地。 4.配置本地和Coding的ssh传输连接 登录 Coding 官网，注册账号登录，点击添加项目，【项目名称填写：自己设计的名称.coding.me。(ps:这就是我们Github上个人博客的二级域名，需要把它记录下来，后面需要用)，选择*私有或者公开，点击底部的创建项目。 然后 sudo cat /Users/your_user_directory/id_rsa.pub ，(提示把中间的 Users/your_user_directory/id_rsa替换成你上一步生成的地址) ，回车后把终端上显示的一大段就是 SSH Key 结果复制下来。 点击右上角用户头像，点击左边栏的账户–&gt;SSH 公钥，把上步的 SSH Key 粘上。（提示可以看到ssh key最后的邮箱，此时GitHub和Coding是同一个注册邮箱），点击永久有效，点击添加项目。 补充：多个SSH私钥配置经验 设置多个私钥如果你的Coding 和 Github的注册邮箱不能满足一样，或者说他们有各自的ssh私钥。我们通过配置ssh连接时候，更换不同私钥文件名称来分别存储。 （ps:如果你Github已经本地生成了私钥，这块可以不做，但是coding部分的私钥文件名要区分你之前的私钥文件名）终端输入$ ssh-keygen -t rsa -b 4096 -C “你注册Github时的邮箱”，终端显示Enter file in which to save the key(/xxx/.ssh/id_rsa):id_rsa_github这里代表着，你的github远程仓库绑定的是这个邮箱，私钥名称为*id_rsa_github之后继续连续回车到结束。 建立Coding的ssh私钥终端输入$ ssh-keygen -t rsa -b 4096 -C “你注册Coding时的邮箱”，终端显示Enter file in which to save the key(/xxx/.ssh/id_rsa):id_rsa_coding这里代表着，你的coding远程仓库绑定的是这个邮箱，私钥名称为id_rsa_coding之后继续连续回车到结束 在本地保存ssh私钥文件所在的目录新建一个config配置文档，以我的为例终端输入$ vim ~/.ssh/config，里面填写如下内容，其中IdentityFile是你自己存放ssh私钥的文件名和文件路径，切记。 1Host github.com HostName github.com User git IdentityFile /home/redredleaf/.ssh/id_rsa_githubHost coding.net HostName coding.net User git IdentityFile /home/redredleaf/.ssh/id_rsa_coding 上面两步操作完后，我们的私钥文件所在目录的结构是： 注意权限如果你在$ ssh-keygen -t rsa -b 4096 -C “你注册Github时的邮箱”，这步的时候用了sudo，或者在root用户下执行的，那么你后续的ssh连接和hexo本地提交到远程仓库的命令都必须都是在root权限下执行，否则会出现Permission denied (publickey)的情况。 5.Hexo的上线部署 登陆coding后，点击左侧栏的项目–&gt;点击建立的项目–&gt;点击左侧栏的代码 ，之后页面中就能找到ssh的连接了 登陆github后，点击右上角自己的头像–&gt;点击Your profile–&gt;点击你的博客远程仓库，页面中就能找到ssh的连接了 打开【站点配置文件 _config.yml】 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: coding: 你的coding远程仓库ssh连接地址 github: 你的github远程仓库ssh连接地址 branch: master 记得 cmd+s，保存 然后执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d，再然后输入 你的博客项目名称.github.io，当成功看到Hexo的hello world的页面，这代表你的Github与Coding配置Hexo站点成功啦啦。 6. Next 主题安装 Next主题是 iissnan 所创作的一个Hexo主题，以简洁为主； 安装：在终端定位到xxx.github.io目录下，执行下面的命令后，稍等片刻，主题就下载到对应的位置；12cd xxx.github.iogit clone https://github.com/iissnan/hexo-theme-next themes/next 7.Next 主题博客的站点配置 首先，复制一份打开本地博客目录下的 _config.yml 文件，做为备份，以防改错 站点配置文件：打开之前的xxx.github.io文件夹，找到 _config.yml 即为站点配置文件，选中该文件-&gt;右击-&gt;打开方式-&gt;文本编辑（也可以选择Sublime打开），打开后就可以修改基本的博客配置了；（注意一下：在配置文件里‘#’就是注释符，相当于C语言中的‘//’） 注意：该配置文件中的键值之间一定要加空格。 关于 Hexo 配置的详细信息请前往 Hexo的官方文档(简体中文)。 站点配置文件详细配置示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site title: xxx # 博客的名字，也称站点名称subtitle: xxx # 副标题description: xxx # 对站点的描述，搜索引擎会抓取，可以自定义author: xxx # 作者名字language: zh-Hans # 语言 简体中文timezone: # 用默认的即可# URL # 这项暂时不需要配置，绑定域名后，要创建 sitemap.xml 时再配置该项## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory # 目录，不要修改source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing # 文章布局、写作格式的定义，不修改new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format # 日期 / 时间 格式，不要修改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: MMM D YYYYtime_format: H:mm:ss# Pagination # 每页显示文章数，可以自定义## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions # 配置站点所用主题和插件，这里将默认主题注释，修改为 next## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next#theme: landscape# Deployment# 本地博客部署到 github 上要配置这里## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git #git提交 repo: https://github.com/CustomPBWaters/CustomPBWaters.github.io.git # 已创建的Github仓库 prompt：配置好站点配置文件，就可以预览一下博客的效果了，步骤如下：在终端定位到 xxx.github.io 文件夹下，并在终端输入下面的命令就能启动服务预览功能；1hexo s --debug # 启动服务预览 启动成功可以看到提示，按照提示用浏览器打开提示网址，即可看到你的本地博客了，里面有一篇 Hello World 看完效果之后继续学习下面的内容… 8.博客的 Next 主题配置 主题配置文件在：xxx.github.io/themes/next/_config.yml 目录下，老规矩，先备份一份 以防改错，当然，最权威的是看 官方 的说明文档，我在这里提供一个示例，供大家参考； 温馨提示：你可以在/next/_config.yml，复制下面的键，回车找到对应的值修改，—&gt;方便 快捷；没修改完一个之后你都可以预览👀一下效果的hexo s –debug 关于主题需配置的选项略多，故采取分条讲解的形式，具体如下： 1.设置头像 123# 头像 注意：在站点下的 :/next/source/images，avatar: /images/avatar.jpg # 修改头像 2. 设置关键字 12# Set default keywords (Use a comma to separate)keywords: “iOS, 白开水, 程序员” # 修改关键字 3. 设置博客的开始时间 12# Specify the date when the site was setup#since: 2016 # 设置博客的开始时间 4. 菜单栏的设置 1234567891011121314# ------------------------------------------------ ---------------# Menu Settings# 菜单栏的设置# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: home: / # 在菜单上显示首页 archives: /archives # 在菜单显示全部(归档) categories: /categories # 在菜单上显示分类 tags: /tags # 在菜单上显示标签 #search: /search # 搜索 about: /about # 在菜单上显示关于 #sitemap: /sitemap.xml #commonweal: /404.html 5. 菜单栏的图标设置：可从 Font Awesome （简体中文）网站查询图标对应的名称填入到对应的菜单项即可 1234567891011121314# 菜单栏的图标设置,规则为：菜单（左）：图标名（右）menu_icons: enable: true home: home # 首页 archives: archive # 全部(归档) categories: th # 分类 tags: tags # 标签 #search: search # 搜索 about: user # 关于 # schedule: calendar # 时间表 # sitemap: sitemap # 网站地图 # commonweal: heartbeat # 公益 # KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome # 键映射到菜单项键 6. 设置博客的外观 1234# Schemes#scheme: Muse #默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白scheme: Mist #Muse 的紧凑版本，整洁有序的单栏外观#scheme: Pisces #双栏 Scheme 7. 设置社交链接（设置了Github、微博） 123456789# Social Links# Key is the link label showing to end users.# Value is the target link (E.g. GitHub: https://github.com/iissnan)# 设置社交链接（如:Github、微博）,这里下面一定要空两格social: # LinkLabel: Link GitHub: https://github.com/CustomPBWaters Weibo: http://weibo.com/JacklinIOS/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo # JianShu: 12345678910# Social Links Icons# 设置社交链接对应的图标social_icons: enable: true # Icon Mappings. # KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome GitHub: github Twitter: twitter Weibo: weibo #JianShu: heartbeat 1234567# Blogrolls # 设置友情链接links_title: Links#links_layout: block#links_layout: inlinelinks: #Title: http://example.com/ 白开水简书: http://www.jianshu.com/users/fd745d76c816/latest_articles 8. 设置侧栏的方向（设置成左侧） 12345# 设置侧栏的方向（设置成左侧）sidebar: # Sidebar Position, available value: left | right position: left #position: right 9. 设置博客中代码高亮显示 123456# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-theme# 代码高亮主题highlight_theme: normal 10. 设置微信支付宝赞赏功能 1234567# 打赏配置# 打赏说明文本reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！# 微信收款二维码wechatpay: /uploads/money/wechat-reward-image.jpg# 支付宝收款二维码alipay: /uploads/money/alipay-reward-image.jpg 9. 设置微信公众号订阅 12345# 设置微信公众号订阅#wechat_subscriber: enabled: true qcode: /uploads/money/alipay-reward-image.jpg description: 欢迎您扫一扫上面的微信公众号，订阅我的博客！ 10. 添加网页计数器-不蒜子 123456789101112131415161718# 添加网页计数器-不蒜子# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count:# count values only if the other configs are false enable: true# custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; # 本站总访问数 site_uv_footer: 人# custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; # 本站总访问量 site_pv_footer: 次# custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; # 本文阅读量 page_pv_footer: 次 11. 设置是否显示阅读全文1234# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true # 设置是否显示阅读全文，文章较多的话，有必要设置为 true length: 200 13. 设置网站logo通过网站favicon在线制作 制作favicon图片，logo最好设置32*32。next主题：将图片放在next主题source/images目录下12# 在next主题配置文件中添加：favicon: /uploads/images/favicon.png 13. 站点头像改成圆形在themes/next/source/css/_common/components/sidebar/sidebar-author.styl 中.site-author-image定义中增加12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 14. 加入站点内容搜索功能本站点使用的是Local Search。加入站点内容搜索功能步骤如下：需要：安装hexo-generator-searchdb1npm install hexo-generator-searchdb --save 在站点 XXX.github.io/_config.yml 中添加search字段，如下：123456# 站点内容搜索功能search: path: search.xml field: post format: html limit: 10000 15. next主题添加背景图片1.找到一个背景图片放到 hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; Bgimage（存放背景图片的文件） 的路径下； 123456/themes/next/source/css/_custom/custom.styl// Custom styles.#body &#123;# background:url(http://upload-images.jianshu.io/upload_images/2230763-265f0df7e75d706a.gif?imageMogr2/auto-orient/strip);# background-attachment: fixed;#&#125; 16. 底部logo栏更改找到 /themes/next/layout/_partials/ 下面的 footer.swig文件，打开会发现，如下图的语句： 第一个框，是下面的“日期 ❤️ XXX” 第二个框，是图当中 “由Hexo驱动” 的Hexo链接 第三个框，是“主题-Next.XX” 9.创建分类界面 先看下效果： 打开终端，定位到xxx.github.io目录下； 执行下面的命令，新建一个名为categories的页面； 1hexo new page categories 创建完成后，在对应的目录下找到index.md文件，进行如下的修改： 123456 ---title: categories # 分类名字（可为空）date: 2016-06-15 08:17:00type: "categories" # 将页面的类型设置为 categories,主题将自动为这个页面显示所有分类comments: false # 如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，设置为 false --- 10.创建标签界面 先看效果： 打开终端，定位到xxx.github.io目录下； 执行下面的命令，新建一个名为tags的页面； 1hexo new page tags 创建完成后，在对应的目录下找到index.md文件，进行如下的修改： 123456 ---title: tags # 标签名字（可为空）date: 2016-08-20 22:17:49type: "tags" # 将页面的类型设置为 tags,主题将自动为这个页面显示为标签云comments: false # 如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，设置为 false --- 注意点 格式：再次强调，设置项的键值之间一定要有空格 关于第三方服务的 ”duoshuo_info“在配置该项的时候，user_id 键对应的值不要修改，也就是保持为 0，具体原因我不清楚； 分类和标签云页面首先，要使用” hexo new page “命令生成这两个页面，否则报404。其次，这两个页面是主题自动维护的，只要我们的文章按照规矩来就行了； 11.写博客与发布 经过上述步骤，本地博客和主题设置已经完成，那么接下来就是写博客了; 温馨提示：你的博客文件需要存放到 xxx.github.io/source/_posts 文件夹中，在该文件夹下面你可以按照你的博客分类建立一系列的文件夹来管理博客原文件； 操作步骤1. 用 Markdown 写文章不管你用什么编辑 Markdown 文件，最后生成的 md 文件放到 xxx.github.io/source/_posts 文件夹或其子文件夹中即可，如：12345678910---title: 个人博客搭建详解（Windows和Mac通用版） # 这是标题date: 2016-05-20 11:26:00 # 这个时间就是本篇文章创建时间 ^_^. 可以自定的。categories: # 这里写的分类会自动汇集到 categories 页面上，分类可以多级- 博客搭建 # 一级分类- Next主题配置 # 二级分类 tags: # 这里写的标签会自动汇集到 tags 页面上- 博客搭建 # 可配置多个标签，注意格式- Next主题配置--- 温馨提示 分类和标签是自动维护的，关键是的文章要按照规定的格式写，如上格式，可以参考. Next 主题会自动生成目录，这也省了不少事; 2. 在本地运行测试在终端上定位到xxx.github.io目录下，输入命令：1hexo s --debug 3. 在浏览器查看效果在浏览器输入http://localhost:4000/ 即可看到博客的效果 4. 安装自动部署发布工具1sudo npm install hexo-deployer-git --save 5. 发布到 GitHubPages当在本地确认博客效果后，就可以将md文件生成静态网页上传至GithubPages，在终端定位到xxx.github.io目录下，执行下面的命令即可：123456hexo clean # 清除缓存 网页正常情况下可以忽略此条命令hexo g # 生成静态网页hexo d # 开始部署也可以一次性执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 温馨提示如果是第一次部署，终端会提示要求输入用户名和密码。等命令执行完之后，过几分钟打开 http://xxx.github.io 即可看到你的个人博客了。以后要发布新文章，执行上述命令即可; 12.多终端编辑hexo博客 摘录原地址：http://www.jianshu.com/p/4f9fc8aafe15 之前就想到了一个问题，如果我想要在公司写博客怎么办，或者说如果我换电脑了怎么办，因为在github中的我们github.io项目是只有编译后的文件的，没有源文件的，也就是说，如果我们的电脑坏了，打不开了，我们的博客就不能进行更新了，所以我们要把我们的源文件也上传到github上，这道题的解题思路（哈哈，突然想到这个词了）是，将我们的源文件上传至username.github.io的Hexo分支，并且设置为默认分支（分支需要自己创建），然后对我们的源文件进行版本管理，这样我们就可以在另一台电脑上pull我们的源码，然后编译完之后push上去。 更为优雅的方式是使用travis-ci，然后用webhook自动部署。你只需要写markdown，push到github就行了。根本不用关心deploy，只要维护你的markdown就行。详情请参考：http://blog.bigruan.com/2015-03-09-Continuous-Integration-Your-Hexo-Blog-With-TravisCI/ 创建Hexo分支创建两个分支：master 与 Hexo,并将Hexo设置为默认分支（这个Hexo分支就是存放我们源文件的分支，我们只需要更新Hexo分支上的内容据就好，master上的分支hexo编译的时候会更新的） 删除文件夹内原有的.git缓存文件夹并编辑.gitignore文件因为有些主题是从git上clone过来的，所以我们要先删除.git缓存文件，否则会和blog仓库冲突（.git默认是隐藏文件夹，需要先开启显示隐藏文件夹。.git文件夹被删除后整个文件对应的git仓库状态也会被清空).gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容： 1234/.deploy_git/public /_config.yml.deploy_git是hexo默认的.git配置文件夹，不需要同步 public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去 初始化仓库然后我们再初始化仓库，重新对我们的代码进行版本控制 123git initgit remote add origin &lt;server&gt;&lt;server&gt;是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端 将博客源文件上传至Hexo分支依次执行 123git add .git commit -m "..."git push origin hexo 提交网站相关的文件； 对B电脑进行的操作假设B电脑现在没有我们的源文件1234git initgit remote add origin &lt;server&gt; #将本地文件和云端仓库映射起来。git fetch --allgit reset --hard origin/master 13.Hexo常用命令笔记 hexo安装升级 123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 常用简写 12345hexo n "我的博客" == hexo new "我的博客" #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 启动本地服务 1234hexo server #Hexo #会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP 监视文件变动 123hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动hexo clean #清除缓存 网页正常情况下可以忽略此条命令 部署 12345#两个命令的作用是相同的hexo generate --deployhexo deploy --generatehexo deploy -ghexo server -g 草稿 1234# 新建草稿hexo new draft &lt;title&gt;# 发布草稿为posthexo publish draft &lt;title&gt; 模版 12345678hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo new [layout] &lt;title&gt;hexo new photo "My Gallery"hexo new "Hello World" --lang tw 写作时间 1234567变量 描述:title 标题:year 建立的年份（4 位数）:month 建立的月份（2 位数）:i_month 建立的月份（去掉开头的零）:day 建立的日期（2 位数）:i_day 建立的日期（去掉开头的零） 14.域名配置 注册购买我们先到阿里云官网注册一个帐号(官网地址)之后打开 域名购买地址，根据个人喜好选后缀为什么的顶级域名。如：.me .cn .com DNS域名解析再登陆回我们的阿里云到首页，点击右上角的控制台，继续点击左侧栏域名与网站(万网)–&gt;域名. 这里我们看到刚刚购买的域名了，点击域名那行尾部的解析，之后我们就跳转配置解析页面。我们继续点击红色添加解析按键，若有认证信息请自己通过]]></content>
      <categories>
        <category>HexoBlog</category>
      </categories>
      <tags>
        <tag>HexoBlog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 封装思维—滚动条「代码不重要，重要的是思维」]]></title>
    <url>%2FEncapsulationThinking%2FScrollBar.html</url>
    <content type="text"><![CDATA[Write in the first “ 本文不适合老司机… ”说明：代码不重要，重要的是思维。 本篇文章主要从【简易-封装新闻滚动条】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 实现功能点 1.可自定义滚动标题个数 2.滚动标题切换有字体放大和颜色渐变的效果 3.滚动标题点击可切换到对应的子控制器 4.滑动内容视图可切换到对应标题 接下来就说一下新闻类框架的搭建思路，这种框架应用也很多的，如：新闻类 和 电商类 无论做什么项目，首先就是搭建界面。1. 先分析界面，看下界面结构，结构不想好，盲目写后面会很麻烦。 第一是导航控制器，有根控制器View，有自己的业务逻辑，需要自定义控制器。 第二是根控制器View包括标题滚动条和内容展示。需要添加标题和内容滚动视图。 提示：以后我们不管写什么一定要先有思路再去写代码，思路都没有就去写代码这是没有意义的，因为你会发现你写着写着就断了。先分析结构，优先选择哪个知识点实现，当然代码不会写，我们可以多敲几遍都会了。 2. 抽取方法12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; // 导航条标题（有栈顶控制器决定）. self.navigationItem.title = @"新闻"; // iOS7以后,导航控制器中scollView顶部会添加64的额外滚动区域 self.automaticallyAdjustsScrollViewInsets = NO; // 添加标题滚动视图 [self setuptitleScrollViewollView]; // 添加内容滚动视图 [self setupContenScrollView];&#125; 提示1：这里抽过方法之后，就马上去调用（你有没有发现，有的时候写了一大堆代码，运行的时候发现没有这个效果）。要养成一种开发习惯，就是固定思维。 提示2：不要把一大堆代码都在viewDidLoad中写完再考虑抽取，一般有经验的人，再写之前就抽取好了。 添加滚动视图代码如下，里面一些其它设置，都有详解。 12345678910111213141516171819202122232425262728293031323334353637#pragma mark - 添加标题滚动视图- (void)setuptitleScrollViewollView &#123; UIScrollView *titleScrollView = [[UIScrollView alloc] init]; CGFloat y = self.navigationController.navigationBarHidden ? 20:64; // 这里的 y 值，既然是封装,要考虑严谨一点,要判断有导航条就是64,无导航条就是20. // 解决方法:是判断下导航条是否隐藏 titleScrollView.frame = CGRectMake(0, y, ScreenW, 44); [self.view addSubview:titleScrollView]; _titleScrollView = titleScrollView; //titleScrollView.backgroundColor = [UIColor greenColor]; // 水平指示器 self.titleScrollView.showsHorizontalScrollIndicator = NO;&#125;#pragma mark - 添加内容滚动视图- (void)setupContenScrollView &#123; UIScrollView *contentScrollView = [[UIScrollView alloc] init]; CGFloat y = CGRectGetMaxY(self.titleScrollView.frame); // 这里的 y 值，就是titleScrollView Y值的最大值 contentScrollView.frame = CGRectMake(0, CGRectGetMaxY(self.titleScrollView.frame), ScreenW, ScreenH- y); [self.view addSubview:contentScrollView]; _contentScrollView = contentScrollView; // 设置contentScrollView的属性 self.contentScrollView.pagingEnabled = YES;// 分页 self.contentScrollView.bounces = NO;// 弹簧 self.contentScrollView.showsHorizontalScrollIndicator = NO;// 指示器 // 设置代理,目的:监听滚动视图什么时候滚动完成 self.contentScrollView.delegate = self;&#125; 这时候基本运行，我们要写的效果的正题结构就搭建完了，然后我们就按小的模块，一个一个去写。 添加所有标题 之前 先添加所有子控制器 分析，添加所有标题，这里你怎么知道标题有多少个？ 添加每一个标题对应的子控制器，先添加子控制器根据子控制器个数就是标题的个数 这里标题采用 Button 先添加子控制器根据子控制器个数就是标题的个数。12345678910111213141516171819202122232425262728293031#pragma mark - 添加所有子控制器/** 补充: 不要这里添加颜色,应该写在对应的子控制器当中,用到的时候才加载。 */- (void)setupAllChildViewController &#123; // 头条 TopLineViewController *vc1 = [[TopLineViewController alloc] init]; vc1.title = @"头条"; [self addChildViewController:vc1]; // 热点 HotViewController *vc2 = [[HotViewController alloc] init]; vc2.title = @"热点"; [self addChildViewController:vc2]; // 视频 VideoViewController *vc3 = [[VideoViewController alloc] init]; vc3.title = @"视频"; [self addChildViewController:vc3]; // 社会 ScoietyViewController *vc4 = [[ScoietyViewController alloc] init]; vc4.title = @"社会"; [self addChildViewController:vc4]; // 订阅 ReaderViewController *vc5 = [[ReaderViewController alloc] init]; vc5.title = @"订阅"; [self addChildViewController:vc5]; // 科技 ScienceViewController *vc6 = [[ScienceViewController alloc] init]; vc6.title = @"科技"; [self addChildViewController:vc6];&#125; 然后就是设置所有标题 提示1：我们写一个功能点的时候，也没有必须非得 第一步干嘛/第二步干嘛。多数情况下是采用逆向思维，先考虑你要干什么，缺什么补什么。 提示2：定了方向，不要太过多考虑细节。先写出来把内容展示上去，再根据展示的效果是否是我们想要的(调整细节)。 12345678910111213141516171819202122232425262728293031323334353637#pragma mark - 添加所有标题按钮- (void)setupAllTitle &#123; // 添加所有标题按钮 NSInteger count = self.childViewControllers.count; CGFloat btnW = 100; // 这里每一个标题大小是固定的 CGFloat btnH = self.titleScrollView.frame.size.height; CGFloat btnX = 0; for (NSInteger i= 0; i &lt; count; i++) &#123; UIButton *titleBtn = [UIButton buttonWithType:UIButtonTypeCustom]; UIViewController *vc = self.childViewControllers[i]; [titleBtn setTitle:vc.title forState:UIControlStateNormal]; btnX = btnW * i; titleBtn.frame = CGRectMake(btnX, 0, btnW, btnH); titleBtn.tag = i; // 1.标题颜色 为黑色 [titleBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; titleBtn.titleLabel.font = [UIFont systemFontOfSize:16.f]; // 3.监听按钮的点击 [titleBtn addTarget:self action:@selector(titleClick:) forControlEvents:UIControlEventTouchUpInside]; [self.titleScrollView addSubview:titleBtn]; // 添加到标题数组 [self.titleButtons addObject:titleBtn]; // 默认选中(手动调用) if (i == 0) &#123; [self titleClick:titleBtn]; &#125; &#125; // 2.设置标题的滚动范围（需要让titleScrollView可以滚动） self.titleScrollView.contentSize = CGSizeMake(btnW * count, 0); // 3.设置内容的滚动范围（需要让contentScrollView可以滚动） self.contentScrollView.contentSize = CGSizeMake(count * ScreenW, 0);&#125; 处理标题按钮的点击分析，按钮点击后需要做的事情是什么？ 1.标题颜色 变成 红色。 2.把对应子控制器的view添加上去。 3.内容滚动视图滚动到对应的位置。 12345678910111213#pragma mark - 按钮的点击事件- (void)titleClick:(UIButton *)btn &#123; NSInteger i = btn.tag; // 1.标题颜色 变成 红色（抽取方法） [self selectButton:btn]; // 2.把对应子控制器的view添加上去（抽取方法） [self setupViewController:i]; // 3.内容滚动视图滚动到对应的位置 self.contentScrollView.contentOffset = CGPointMake(i * ScreenW, 0);&#125; 选中标题按钮 123456789101112131415161718192021222324/** 补充:切换三步曲 1.取消上次选中 2.选中当前点击的按钮 3.记录当前选中的按钮 */#pragma mark - 选中标题按钮@property (nonatomic, weak) UIButton *selectBtn;// 记录选中的按钮- (void)selectButton:(UIButton *)btn &#123; _selectBtn.transform = CGAffineTransformIdentity;// 字体恢复原始状态 [_selectBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [btn setTitleColor:[UIColor redColor] forState:UIControlStateNormal]; // 标题居中 [self setupTitleCenter:btn]; // 选中字体缩放:形变 btn.transform = CGAffineTransformMakeScale(1.3, 1.3); _selectBtn = btn;// 记录选中的按钮&#125; 添加子控制器的View1234567891011121314#pragma mark - 添加子控制器的View- (void)setupViewController:(NSInteger)i &#123; UIViewController *vc = self.childViewControllers[i];// if (vc.viewIfLoaded) &#123;// 判断控制器是否加载 NS_AVAILABLE_IOS(9_0);// return;// &#125; if (vc.view.superview) &#123;// 避免重复加载 return; &#125; CGFloat x = i * ScreenW; vc.view.frame = CGRectMake(x, 0, ScreenW, self.contentScrollView.frame.size.height); [self.contentScrollView addSubview:vc.view];&#125; 接下来，处理内容视图的业务逻辑(监听内容滚动) 设置代理，目的:监听内容滚动视图什么时候完成。 原因: 1.防SB用户,按住屏幕死循环着左右滑,每次都加载会很卡。 2.用户也有可能滑动到一半,不想看了,就没有必要加载出来,浪费用户流量。 代理方法： 1234567891011121314#pragma mark - &lt;UIScrollViewDelegate&gt;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123; // 获取当前角标 NSInteger i = self.contentScrollView.contentOffset.x / ScreenW; // 获取标题按钮 //UIButton *titleBtn = self.titleScrollView.subviews[i]; UIButton *titleBtn = self.titleButtons[i]; // 1.把标题颜色 改成红色 [self selectButton:titleBtn]; // 2.把对应子控制器的view添加上去 [self setupViewController:i];&#125; 总结： 这里有个隐藏问题:–&gt;获取标题按钮 self.titleScrollView.subviews[i] 原因：UIScrollView默认有两个子控件，这里的subVeiws有可能把两个子控件给取出来，造成与标题不对应。 解决：提供一个数组专门存放添加的标题（纯洁数组）1@property (nonatomic, strong) NSMutableArray *titleButtons;// 记录标题数组 接下来，选中标题 和 滚动内容视图 让标题居中标题居中处理，本质：修改titleScrollView的偏移量 12345678910111213141516#pragma mark - 标题居中处理- (void)setupTitleCenter:(UIButton *)btn &#123; // 本质:修改titleScrollView偏移量 CGFloat offsetX = btn.center.x - ScreenW * 0.5; if (offsetX &lt; 0) &#123; offsetX = 0; &#125; CGFloat maxOffsetX = self.titleScrollView.contentSize.width - ScreenW; if (offsetX &gt; maxOffsetX) &#123; offsetX = maxOffsetX; &#125; NSLog(@"%f",offsetX); [self.titleScrollView setContentOffset:CGPointMake(offsetX, 0) animated:YES];&#125; 附图： 只要一滚动就需要字体颜色渐变和字体放大 分析字体缩放 1.缩放比例 2.缩放那两个按钮 在contentScrollView代理方法中做处理 123456789101112131415161718192021222324252627282930313233343536#pragma mark - 只要一滚动就需要字体渐变- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; // 获取角标 NSInteger leftI = scrollView.contentOffset.x / ScreenW; NSInteger rightI = leftI + 1; //NSLog(@"%ld %ld",leftI,rightI); // 获取左边的按钮 UIButton *leftBtn = self.titleButtons[leftI]; // 获取右边的按钮 NSInteger count = self.titleButtons.count; UIButton *rightBtn; if (rightI &lt; count) &#123;// 加判断,防止越界 rightBtn = self.titleButtons[rightI]; &#125; // 右边缩放比例（0 ~ 1 =&gt; 放大0.3） CGFloat scaleR = scrollView.contentOffset.x / ScreenW; scaleR -= leftI; // 左边缩放比例 CGFloat scaleL = 1 - scaleR; // 缩放按钮 leftBtn.transform = CGAffineTransformMakeScale(scaleL * 0.3 + 1, scaleL * 0.3 + 1); rightBtn.transform = CGAffineTransformMakeScale(scaleR * 0.3 + 1, scaleR * 0.3 + 1); // 颜色渐变 UIColor *leftColor = [UIColor colorWithRed:scaleL green:0 blue:0 alpha:1];// R 1-0 UIColor *rightColor = [UIColor colorWithRed:scaleR green:0 blue:0 alpha:1];// R 0-1 [leftBtn setTitleColor:leftColor forState:UIControlStateNormal]; [rightBtn setTitleColor:rightColor forState:UIControlStateNormal]; &#125; 总结： 标题文字缩放，解决：1.字体放大(做不到下面要做的颜色渐变效果) 2.改形变（采用） 颜色：3种颜色通道组成 R:红 G:绿 B:蓝，如：白色(1 1 1)、黑色(0 0 0)、红色(1 0 0)。 基本使用我们封装一个东西，要考虑（方法抽取 和 可扩展性）。 1.添加所有子控制器，放到子控制器中 2.设置所有标题，应放到viewWillAppear 新建 TestViewController : LNViewController1234567891011121314151617181920// TestViewController.m- (void)viewDidLoad &#123; [super viewDidLoad]; // 添加所有子控制器 [self setupAllChildViewController]; &#125;//--------------------------- &lt;#我是分割线#&gt; ------------------------------////// LNViewController.m@property (nonatomic, assign) BOOL isInitialize;// 记录标题是否初始化- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; if (_isInitialize == NO) &#123; // 设置所有标题 [self setupAllTitle]; _isInitialize = YES; &#125;&#125; 附上总结写的小样 Demo，如果「你喜欢 或 有帮助」，可否点个 Star 「重要的部分代码中都有相应的注解和文字打印，运行程序可以很直观的表现」]]></content>
      <categories>
        <category>封装</category>
      </categories>
      <tags>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac&Xcode「实用快捷键」续更]]></title>
    <url>%2FMacUseEfficiency%2FMac%26XcodeShortcuts.html</url>
    <content type="text"><![CDATA[毅力能滴水穿石，重复能熟能生巧。 温馨提示：要使用键盘快捷键，请按住一个或多个修饰键，同时按快捷键的最后一个键。例如：要使用快捷键 Command + C（拷贝），请按住 Command 键并按 C 键，然后同时松开这两个键。Mac 菜单和键盘通常使用某些按键的符号，其中包括以下修饰键： Command ⌘ Shift ⇧ Option ⌥ Control ⌃ Caps Lock ⇪ Fn 如果你使用的是 Windows PC 专用键盘，请用 Alt 键代替 Option 键，用 Windows 标志键代替 Command 键。有些 Mac 键盘在顶行中设有特殊按键，快捷键中也会用到它们；这些按键上有音量图标、显示屏亮度图标和其他功能图标。按下图标键可执行相应功能，将其与 Fn 键组合可用作 F1、F2、F3 或其他标准功能键。 (有福利在最后哦~) 常用快捷键12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152快捷键 | 描述Command + Q | 退出应用程序。Command + W | 关闭最前面的窗口。要关闭该应用程序的所有窗口，请按 Command-Option-W。Command + i | 显示文件夹简介（选中文件夹）Command + O | 打开所选项，或打开一个对话框以选择要打开的文件。Command + P | 打印当前文稿。Command + A | 全选各项。Command + S | 保存当前文稿。Command + F | 查找：打开“查找”窗口，或在文稿中查找项目。Command + G | 再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Command + Shift + G。Command + H | 隐藏最前面的应用程序的窗口。要查看最前面的应用程序但隐藏所有其他应用程序，请按 Command + Option + H。Command + L | 当前程序是浏览器时，可以直接定位到地址栏Command + Z | 撤销前一个命令。随后你可以按 Command + Shift + Z 来重做，从而反向执行撤销命令。在某些应用程序中，你可以撤销和重做多个命令。Command + X | 剪切：删除所选项并将其拷贝到剪贴板。Command + C | 将所选项拷贝到剪贴板。这同样适用于 Finder 中的文件。Command + V | 将剪贴板的内容粘贴到当前文稿或应用程序中。这同样适用于 Finder 中的文件。Command + N | 新建：打开一个新文稿或窗口。Command + M | 将最前面的窗口最小化至 Dock。要最小化最前面的应用程序的所有窗口，请按 Command + Option + M。Option + Command + Esc | 强制退出：选择要强制退出的应用程序。或者，按住 Command + Shift + Option + Esc 3 秒钟来仅强制最前面的应用程序退出。Command + 波浪号(~) | 切换窗口：切换到最前端应用中下一个最近使用的窗口。Command + Tab | 切换应用程序：在打开的应用程序中切换到下一个最近使用的应用程序。Shift + Command + 3 | 屏幕快照：截桌面屏。Shift + Command + 4 | 屏幕快照：自由截屏Command + 空格键 | Spotlight：显示或隐藏 Spotlight 搜索栏。要从 Finder 窗口执行 Spotlight 搜索，请按 Command + Option + 空格键。如果你使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示 Spotlight。空格键 | 快速查看：使用快速查看预览所选项。Command + 逗号 (,) | 偏好设置：打开最前面的应用程序的偏好设置。Command + Delete | 把选中的资源移到废纸篓Shift + Command + Delete | 清倒废纸篓(有确认)Shift + Option + Command + Delete | 直接清倒废纸篓选中文件 + enter | 修改文件名Command + [ | 左缩进Command + ] | 右缩进Ctrl + ↑ | 进入屏幕选择界面 Ctrl + ↓ | 进入选定的屏幕Ctrl + ←／→ | 切换屏幕Command + option + control + Eject | 关机Command + option + Eject | 睡眠Command + control + Eject | 重启Command + shift + control + Q | 注销 启动组合键在启动期间按住某些键可以使用一些 Mac 功能。 请在 Mac 开机并听到启动声后立即按住这些键。请一直按住，直至所述行为出现。以下组合适用于基于 Intel 的 Mac 电脑。 123456789101112131415161718在启动期间按住 | 描述Shift ⇧ | 以安全模式启动。Option ⌥ | 启动进入启动管理器。C | 从可引导的 CD、DVD 或 USB 闪存驱动器（如 OS X 安装介质）启动。D | 启动进入 Apple Hardware Test 或 Apple Diagnostics，具体取决于您正在使用的 Mac。Option-D | 通过互联网启动进入 Apple Hardware Test 或 Apple Diagnostics。N | 从兼容的 NetBoot 服务器启动。Option-N | 使用默认的启动映像从 NetBoot 服务器启动。T | 以目标磁盘模式启动。X | 从 OS X 启动宗卷启动，否则 Mac 将从非 OS X 启动宗卷启动。Command + V | 以详细模式启动。Command + S | 以单用户模式启动。Command (⌘) + R | 从 OS X 恢复功能启动。Command + Option + R | 通过互联网从 OS X 恢复功能启动。Command + Option + P + R | 重置 NVRAM。当再次听到启动声后，请松开这些键。推出键 (⏏)、F12、鼠标键或触控板按钮 | 推出可移动介质，如光盘。 Finder 快捷键1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768快捷键 | 描述Command + D | 复制所选文件。Command + E | 推出所选磁盘或宗卷。Command + F | 在 Finder 窗口中开始 Spotlight 搜索。Command + I | 显示所选文件的“显示简介”窗口。Shift + Command + C | 打开“电脑”窗口。Shift + Command + D | 打开“桌面”文件夹。Shift + Command + F | 打开“我的所有文件”窗口。Shift + Command + G | 打开“前往文件夹”窗口。Shift + Command + H | 打开当前 macOS 用户帐户的个人文件夹。Shift + Command + I | 打开 iCloud Drive。Shift + Command + K | 打开“网络”窗口。Option + Command + L | 打开“下载”文件夹。Shift + Command + O | 打开“文稿”文件夹。Shift + Command + R | 打开“AirDrop”窗口。Shift + Command + T | 将所选的 Finder 项目添加到 Dock（OS X Mountain Lion 或较早版本）Control + Shift + Command + T | 将所选的 Finder 项目添加到 Dock（OS X Mavericks 或更高版本）Shift + Command + U | 打开“实用工具”文件夹。Option + Command + D | 显示或隐藏 Dock。即使您未打开 Finder，此快捷键通常也有效。Control + Command + T | 将所选项添加到边栏（OS X Mavericks 或更高版本）。Option + Command + P | 隐藏或显示 Finder 窗口中的路径栏。Option + Command + S | 隐藏或显示 Finder 窗口中的边栏。Command–斜线 (/) | 隐藏或显示 Finder 窗口中的状态栏。Command + J | 调出“显示”选项。Command + K | 打开“连接服务器”窗口。Command + L | 为所选项制作替身。Command + N | 打开一个新的 Finder 窗口。Shift + Command + N | 新建文件夹。Option + Command + N | 新建智能文件夹。Command + R | 显示所选替身的原始文件。Command + T | 在当前 Finder 窗口中打开单个标签时显示或隐藏标签栏。Shift + Command + T | 显示或隐藏 Finder 标签。Option + Command + T | 在当前 Finder 窗口中打开单个标签时显示或隐藏工具栏。Option + Command + V | 移动：将剪贴板中的文件从其原始位置移动到当前位置。Option + Command + Y | 显示所选文件的快速查看幻灯片显示。Command + Y | 使用“快速查看”预览所选文件。Command + 1 | 以图标方式显示 Finder 窗口中的项目。Command + 2 | 以列表方式显示 Finder 窗口中的项目。Command + 3 | 以分栏方式显示 Finder 窗口中的项目。 Command + 4 | 以 Cover Flow 方式显示 Finder 窗口中的项目。Command + 左中括号 ([) | 前往上一文件夹。Command + 右中括号 (]) | 前往下一文件夹。Command + 上箭头 | 打开包含当前文件夹的文件夹。Command + Control + 上箭头 | 在新窗口中打开包含当前文件夹的文件夹。Command + 下箭头 | 打开所选项。Command + Mission Control | 显示桌面。即使您未打开 Finder，此快捷键也有效。Command + 调高亮度 | 开启或关闭目标显示器模式。Command + 调低亮度 | 当 Mac 连接到多个显示器时打开或关闭显示器镜像功能。右箭头 | 打开所选文件夹。此快捷键仅在列表视图中有效。左箭头 | 关闭所选文件夹。此快捷键仅在列表视图中有效。Option + 连按 | 在单独窗口中打开文件夹，并关闭当前窗口。Command + 连按 | 在单独标签或窗口中打开文件夹。Command + Delete | 将所选项移到废纸篓。Shift + Command + Delete| 清倒废纸篓。Option + Shift + Command + Delete| 清倒废纸篓（不显示确认对话框）。Command + Y | 使用“快速查看”预览文件。Option + 调高亮度 | 打开“显示器”偏好设置。此快捷键可与任一亮度键搭配使用。Option + Mission Control | 打开“Mission Control”偏好设置。Option + 调高音量 | 打开“声音”偏好设置。此快捷键可与任一音量键搭配使用。拖移时按 Command 键| 将拖移的项目移到其他宗卷或位置。拖移项目时指针会随之变化。拖移时按 Option 键 | 拷贝拖移的项目。拖移项目时指针会随之变化。拖移时按下 Option + Command | 为拖移的项目制作替身。拖移项目时指针会随之变化。Option + 点按伸缩三角形| 打开所选文件夹内的所有文件夹。此快捷键仅在列表视图中有效。Command + 点按窗口标题 | 查看包含当前文件夹的文件夹。 文档快捷键12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970快捷键 | 描述Command + B | 以粗体显示所选文本，或者打开或关闭粗体显示功能。 Command + I | 以斜体显示所选文本，或者打开或关闭斜体显示功能。Command + U | 对所选文本加下划线，或者打开或关闭加下划线功能。Command + T | 显示或隐藏“字体”窗口.Command + D | 从“打开”对话框或“存储”对话框中选择“桌面”文件夹。Control + Command + D | 显示或隐藏所选字词的定义。Shift + Command + 冒号 (:) | 显示“拼写和语法”窗口。Command + 分号 (;) | 查找文稿中拼写错误的字词。Option + Delete | 删除插入点左边的字词。Control + H | 删除插入点左边的字符。也可以使用 Delete 键。Control + D | 删除插入点右边的字符。也可以使用 Fn-Delete。Fn + Delete | 在没有向前删除 键的键盘上向前删除。也可以使用 Control-D。Control + K | 删除插入点与行或段落末尾处之间的文本。Command + Delete | 在包含“删除”或“不存储”按钮的对话框中选择“删除”或“不存储”。Fn + 上箭头 | 向上翻页：向上滚动一页。 Fn + 下箭头 | 向下翻页：向下滚动一页。Fn + 左箭头 | 开头：滚动到文稿开头。Fn + 右箭头 | 结尾：滚动到文稿末尾。Command + 上箭头 | 将插入点移至文稿开头。Command + 下箭头 | 将插入点移至文稿末尾。Command + 左箭头 | 将插入点移至当前行的行首。Command + 右箭头 | 将插入点移至当前行的行尾。Option + 左箭头 | 将插入点移至上一字词的词首。Option + 右箭头 | 将插入点移至下一字词的词尾。Shift + Command + 上箭头 | 选中插入点与文稿开头之间的文本。Shift + Command + 下箭头 | 选中插入点与文稿末尾之间的文本。Shift + Command + 左箭头 | 选中插入点与当前行行首之间的文本。Shift + Command + 右箭头 | 选中插入点与当前行行尾之间的文本。Shift + 上箭头 | 将文本选择范围扩展到上一行相同水平位置的最近字符处。Shift + 下箭头 | 将文本选择范围扩展到下一行相同水平位置的最近字符处。Shift + 左箭头 | 将文本选择范围向左扩展一个字符。Shift + 右箭头 | 将文本选择范围向右扩展一个字符。Option + Shift + 上箭头 | 将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。Option + Shift + 下箭头 | 将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。Option + Shift + 左箭头 | 将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。Option + Shift + 右箭头 | 将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。Control + A | 移至行或段落的开头。Control + E | 移至行或段落的末尾。Control + F | 向前移动一个字符。Control + B | 向后移动一个字符。Control + L | 将光标或所选内容置于可见区域中央。Control + P | 上移一行。Control + N | 下移一行。Control + O | 在插入点后插入一行。Control-T | 将插入点后面的字符与插入点前面的字符交换。Command + 左花括号 (&#123;) | 左对齐。Command + 右花括号 (&#125;) | 右对齐。Shift + Command + 竖线 | 居中对齐。Option + Command + F | 前往搜索栏。 Option + Command + T | 显示或隐藏应用中的工具栏。Option + Command + C | 拷贝样式：将所选项的格式设置拷贝到剪贴板。Option + Command + V | 粘贴样式：将拷贝的样式应用到所选项。Option + Shift + Command + V | 粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。Option + Command + I | 显示或隐藏检查器窗口。Shift + Command + P | 页面设置：显示用于选择文稿设置的窗口。Shift + Command + S | 显示“存储为”对话框或复制当前文稿。Shift + Command + 减号 (-) | 缩小所选项。Shift + Command + 加号 (+)| 放大所选项。Command–等号 (=) 可执行相同的功能。Shift + Command + 问号 (?)| 打开“帮助”菜单。 截图操作123456截图快捷键 | 含义command + shift + 3 | 全屏截图，保存截图到桌面文件command + shift + 4 | 鼠标选定区域截图，保存截图到桌面文件command + shift + control + 3 | 全屏截图，保存到剪贴板command + shift + control + 4 | 鼠标选定区域截图，保存到剪贴板command + shift( + control) + 4 | 然后按下空格键，鼠标变成小相机，选择某一窗口后点击鼠标左键对单个窗口截图。不必担心其它窗口的遮挡。 睡眠、注销和关机快捷键12345678910快捷键 | 描述电源按钮 | 轻点可打开 Mac 或将 Mac 从睡眠状态唤醒。当 Mac 处于唤醒状态时，按住此按钮 1.5 秒钟会显示一个对话框，询问您是要重新启动、睡眠还是关机。如果您不想等待 1.5 秒钟，请按下 Control + 电源按钮或 Control + 介质推出键 。按住此按钮 5 秒钟会强制 Mac 关机。Control + Command–电源按钮 | 强制 Mac 重新启动。Control + Shift + （电源按钮或介质推出键 ） | 将显示器置于睡眠状态。Control + Command + 介质推出键 | 退出所有应用程序，然后重新启动 Mac。如果任何打开的文稿有未存储的更改，系统将询问您是否要存储这些更改。Control + Option + Command + （电源按钮或介质推出键 ）| 退出所有应用程序，然后关闭 Mac。如果任何打开的文稿有未存储的更改，系统将询问您是否要存储这些更改。Shift + Command + Q | 注销您的 macOS 用户帐户。系统将提示您确认。Option + Shift + Command + Q | 立即注销您的 macOS 用户帐户，且系统不提示您确认。 在浏览器中123456789101112131415Control + Tab | 转向下一个标签页 Command + L | 光标直接跳至地址栏 Control + Tab | 转向下一个标签页 Control + Shift + Tab | 转向上一个标签页 Command + 加号或等号 | 放大页面 Command + 减号 | 缩小页面Command + R | 刷新页面Command + + | 大屏幕的时候很实用，放大页面，基本也是全局型的。 0是恢复默认大小Command + W | 关闭当前标签。不要和退出按错了。Command + Q | 退出当前软件，其他软件也都可以用。Command + D | 收藏当前页面空格 | 屏幕下滚一页Safari的恢复刚关闭标签就是熟悉的 Command + Z。`Chrome` 是和打开差不多的，Command + Shift + T。Chrome这个功能更强大，就是可以按顺序恢复，但是Safari只能恢复最近的一个。 Xcode 快捷键Cmd + Shirt + N | 新建工程Cmd + N | 新建Cmd + R | 运行Cmd + . | 停止运行Cmd + B | 编译Cmd + Shirt + B | 编译，静态内存分析，可以检查程序结构上是否存在内存泄露Cmd + Q | 退出应用程序 Cmd + 0 | 左侧导航窗口开启和关闭Cmd + (1 - 7) | 左侧导航窗口的选择（项目，符号，搜索，问题，调试，断点，日志） Cmd + option + 0 | 右侧工具窗口开启和关闭Cmd + option + (1 - 6) | 右侧工具窗口的选择 Cmd + option + 回车 | 打开控制器对应的文件（Storyboard）Cmd + 回车 | 关闭控制器对应的文件,只显示主窗口 Cmd ＋ ↑／↓ ／←／→ | 光标移动到文字的最上／下／左／右Cmd + ctrl + ←/→ | 按浏览的先后顺序切换文件Cmd + ctrl + ↑／↓ | .h 和 .m 切换 Cmd + 鼠标左键(出现小手) | 进入查看一些类/方法option + 鼠标左键(出现问号) | 查看官方文档 Cmd + / | 选中后，加注释//Cmd + / | 选中后，取消注释 Cmd + shift + 箭头 | 快速选中 / 快速点击鼠标三下Cmd + delete | 删除光标之前的内容 Cmd + [ | 缩退Cmd + ] | 缩进Cmd + option + [ | 向上移动Cmd + option + ] | 向下缩进 Cmd + F | 搜索Cmd + shift + f | 全局搜索Cmd + ctrl + e | 全局修改Cmd + L | 点位搜索当前行 control + 6 | 弹出当前文件方法列表esc | 方法自动补全Control + i | 格式化代码(规范) Ctrl + 脱线 | 添加属性或方法option + 拖动 | 复制选中的控件Cmd + option + = | 更新选中控件的约束 模拟器快捷键Cmd + Shift + H | 按一次，取消晃动 / 按一次，回到首页Cmd + ←/→ | 旋转Cmd + k | 弹出键盘  Mac 键盘快捷键整理了那么多快捷键，一时半会根本记不住，怎么办？除了有意识的经常使用、练习外，还有一款神奇软件 CheatSheet 在任何应用程序下面长按Command ⌘ 键，即可以查看这款软件的快捷键操作。 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发神注释大全（欢迎补充）]]></title>
    <url>%2FMacUseEfficiency%2FStrangeComments.html</url>
    <content type="text"><![CDATA[写在前面的话：一时兴起就收集了以下神注释，希望能为广大ITer带来快乐，缓解你们工作中的压力，下面开车，第一个你可做头像，下文会给出制作链接。 第一个你可做头像123456789101112131415161718192021222324252627282930313233343536/** * 瓦瓦 十 * 十齱龠己 亅瓦車己 * 乙龍龠毋日丶 丶乙己毋毋丶 * 十龠馬鬼車瓦 己十瓦毋毋 * 鬼馬龠馬龠十 己己毋車毋瓦 * 毋龠龠龍龠鬼乙丶丶乙車乙毋鬼車己 * 乙龠龍龍鬼龍瓦 十瓦毋乙瓦龠瓦亅 * 馬齱龍馬鬼十丶日己己己毋車乙丶 * 己齱馬鬼車十十毋日乙己己乙乙 * 車馬齱齱日乙毋瓦己乙瓦日亅 * 亅車齺龖瓦乙車龖龍乙乙十 * 日龠龠十亅車龍毋十十 * 日毋己亅 己己十亅亅 * 丶己十十乙 丶丶丶丶丶 * 亅己十龍龖瓦 丶 丶 乙十 * 亅己十龠龖毋 丶丶 丶己鬼鬼瓦亅 * 十日十十日亅丶亅丶 丶十日毋鬼馬馬車乙 * 十日乙十亅亅亅丶 十乙己毋鬼鬼鬼龍齺馬乙 * 丶瓦己乙十十亅丶亅乙乙乙己毋鬼鬼鬼龍齱齺齺鬼十 * 乙乙十十十亅乙瓦瓦己日瓦毋鬼鬼龠齱齱龍龍齱齱毋丶 * 亅十十十十乙瓦車毋瓦瓦日車馬龠龍龍龍龍龍龠龠龠馬亅* 十十十十己毋車瓦瓦瓦瓦鬼馬龠龍龠龠龍龠龠龠馬龠車* 亅十十日毋瓦日日瓦鬼鬼鬼龠龠馬馬龠龍龍龠馬馬車* 亅亅亅乙瓦瓦毋車車車馬龍龠鬼鬼馬龠龍龍龠馬馬鬼* 丶丶乙亅亅乙車鬼鬼鬼毋車龍龍龠鬼馬馬龠龍齱齱龍馬鬼* 亅己十十己十日鬼鬼車瓦毋龠龍龠馬馬龠龠龠齱齺齺齱龠鬼* 亅乙乙乙十車馬車毋馬齱齱龍龠龠龠馬龠龍齱龍龠龠鬼瓦* 丶毋龠鬼車瓦車馬龠龍龠龠龍齱齱龠馬馬鬼毋日* 十乙己日十 丶己鬼龍齱齺齱龍馬馬馬車毋己* 丶十己乙亅丶 亅瓦馬龠龍龠龠馬毋瓦乙* 丶十十乙亅十 亅己瓦車馬龠鬼車瓦乙* 丶十乙十十丶 丶丶亅十瓦鬼車瓦己* 丶亅亅丶 亅日瓦日* 丶*/ 两只doge和一头滑稽。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * .,:,,, .::,,,::. * .::::,,;;, .,;;:,,....:i: * :i,.::::,;i:. ....,,:::::::::,.... .;i:,. ......;i. * :;..:::;::::i;,,:::;:,,,,,,,,,,..,.,,:::iri:. .,:irsr:,.;i. * ;;..,::::;;;;ri,,,. ..,,:;s1s1ssrr;,.;r, * :;. ,::;ii;:, . ................... .;iirri;;;,,;i, * ,i. .;ri:. ... ............................ .,,:;:,,,;i: * :s,.;r:... ....................................... .::;::s; * ,1r::. .............,,,.,,:,,........................,;iir; * ,s;........... ..::.,;:,,. ...............,;1s * :i,..,. .,:,,::,. .......... .......;1, * ir,....:rrssr;:, ,,.,::. .r5S9989398G95hr;. ....,.:s, * ;r,..,s9855513XHAG3i .,,,,,,,. ,S931,.,,.;s;s&amp;BHHA8s.,..,..:r: * :r;..rGGh, :SAG;;G@BS:.,,,,,,,,,.r83: hHH1sXMBHHHM3..,,,,.ir. * ,si,.1GS, sBMAAX&amp;MBMB5,,,,,,:,,.:&amp;8 3@HXHBMBHBBH#X,.,,,,,,rr * ;1:,,SH: .A@&amp;&amp;B#&amp;8H#BS,,,,,,,,,.,5XS, 3@MHABM&amp;59M#As..,,,,:,is, * .rr,,,;9&amp;1 hBHHBB&amp;8AMGr,,,,,,,,,,,:h&amp;&amp;9s; r9&amp;BMHBHMB9: . .,,,,;ri. * :1:....:5&amp;XSi;r8BMBHHA9r:,......,,,,:ii19GG88899XHHH&amp;GSr. ...,:rs. * ;s. .:sS8G8GG889hi. ....,,:;:,.:irssrriii:,. ...,,i1, * ;1, ..,....,,isssi;, .,,. ....,.i1, * ;h: i9HHBMBBHAX9: . ...,,,rs, * ,1i.. :A#MBBBBMHB##s ....,,,;si. * .r1,.. ,..;3BMBBBHBB#Bh. .. ....,,,,,i1; * :h;.. .,..;,1XBMMMMBXs,.,, .. :: ,. ....,,,,,,ss. * ih: .. .;;;, ;;:s58A3i,.. ,. ,.:,,. ...,,,,,:,s1, * .s1,.... .,;sh, ,iSAXs;. ,. ,,.i85 ...,,,,,,:i1; * .rh: ... rXG9XBBM#M#MHAX3hss13&amp;&amp;HHXr .....,,,,,,,ih; * .s5: ..... i598X&amp;&amp;A&amp;AAAAAA&amp;XG851r: ........,,,,:,,sh; * . ihr, ... . .. ........,,,,,;11:. * ,s1i. ... ..,,,..,,,.,,.,,.,.. ........,,.,,.;s5i. * .:s1r,...................... ..............;shs, * . .:shr:. .... ..............,ishs. * .,issr;,... ...........................,is1s;. * .,is1si;:,....................,:;ir1sr;, * ..:isssssrrii;::::::;;iirsssssr;:.. * .,::iiirsssssssssrri;;:. */ /*** ii. ;9ABH, * SA391, .r9GG35&amp;G * &amp;#ii13Gh; i3X31i;:,rB1 * iMs,:,i5895, .5G91:,:;:s1:8A * 33::::,,;5G5, ,58Si,,:::,sHX;iH1 * Sr.,:;rs13BBX35hh11511h5Shhh5S3GAXS:.,,::,,1AG3i,GG * .G51S511sr;;iiiishS8G89Shsrrsh59S;.,,,,,..5A85Si,h8 * :SB9s:,............................,,,.,,,SASh53h,1G. * .r18S;..,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....,,.1H315199,rX, * ;S89s,..,,,,,,,,,,,,,,,,,,,,,,,....,,.......,,,;r1ShS8,;Xi * i55s:.........,,,,,,,,,,,,,,,,.,,,......,.....,,....r9&amp;5.:X1 * 59;.....,. .,,,,,,,,,,,... .............,..:1;.:&amp;s * s8,..;53S5S3s. .,,,,,,,.,.. i15S5h1:.........,,,..,,:99 * 93.:39s:rSGB@A; ..,,,,..... .SG3hhh9G&amp;BGi..,,,,,,,,,,,,.,83 * G5.G8 9#@@@@@X. .,,,,,,..... iA9,.S&amp;B###@@Mr...,,,,,,,,..,.;Xh * Gs.X8 S@@@@@@@B:..,,,,,,,,,,. rA1 ,A@@@@@@@@@H:........,,,,,,.iX: * ;9. ,8A#@@@@@@#5,.,,,,,,,,,... 9A. 8@@@@@@@@@@M; ....,,,,,,,,S8 * X3 iS8XAHH8s.,,,,,,,,,,...,..58hH@@@@@@@@@Hs ...,,,,,,,:Gs * r8, ,,,...,,,,,,,,,,..... ,h8XABMMHX3r. .,,,,,,,.rX: * :9, . .:,..,:;;;::,.,,,,,.. .,,. ..,,,,,,.59 * .Si ,:.i8HBMMMMMB&amp;5,.... . .,,,,,.sMr * SS :: h@@@@@@@@@@#; . ... . ..,,,,iM5 * 91 . ;:.,1&amp;@@@@@@MXs. . .,,:,:&amp;S * hS .... .:;,,,i3MMS1;..,..... . . ... ..,:,.99 * ,8; ..... .,:,..,8Ms:;,,,... .,::.83 * s&amp;: .... .sS553B@@HX3s;,. .,;13h. .:::&amp;1 * SXr . ...;s3G99XA&amp;X88Shss11155hi. ,;:h&amp;, * iH8: . .. ,;iiii;,::,,,,,. .;irHA * ,8X5; . ....... ,;iihS8Gi* 1831, .,;irrrrrs&amp;@* ;5A8r. .:;iiiiirrss1H* :X@H3s....... .,:;iii;iiiiirsrh* r#h:;,...,,.. .,,:;;;;;:::,... .:;;;;;;iiiirrss1* ,M8 ..,....,.....,,::::::,,... . .,;;;iiiiiirss11h* 8B;.,,,,,,,.,..... . .. .:;;;;iirrsss111h* i@5,:::,,,,,,,,.... . . .:::;;;;;irrrss111111* 9Bi,:,,,,...... ..r91;;;;;iirrsss1ss1111*//** * .,, .,:;;iiiiiiiii;;:,,. .,, * rGB##HS,.;iirrrrriiiiiiiiiirrrrri;,s&amp;##MAS, * r5s;:r3AH5iiiii;;;;;;;;;;;;;;;;iiirXHGSsiih1, * .;i;;s91;;;;;;::::::::::::;;;;iS5;;;ii: * :rsriii;;r::::::::::::::::::::::;;,;;iiirsi, * .,iri;;::::;;;;;;::,,,,,,,,,,,,,..,,;;;;;;;;iiri,,. * ,9BM&amp;, .,:;;:,,,,,,,,,,,hXA8: ..,,,. * ,;&amp;@@#r:;;;;;::::,,. ,r,,,,,,,,,,iA@@@s,,:::;;;::,,. .;. * :ih1iii;;;;;::::;;;;;;;:,,,,,,,,,,;i55r;;;;;;;;;iiirrrr,.. * .ir;;iiiiiiiiii;;;;::::::,,,,,,,:::::,,:;;;iiiiiiiiiiiiri * iriiiiiiiiiiiiiiii;;;::::::::::::::::;;;iiiiiiiiiiiiiiiir; * ,riii;;;;;;;;;;;;;:::::::::::::::::::::::;;;;;;;;;;;;;;iiir. * iri;;;::::,,,,,,,,,,:::::::::::::::::::::::::,::,,::::;;iir: * .rii;;::::,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,::::;;iri * ,rii;;;::,,,,,,,,,,,,,:::::::::::,:::::,,,,,,,,,,,,,:::;;;iir. * ,rii;;i::,,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,,::i;;iir. * ,rii;;r::,,,,,,,,,,,,,:,:::::,:,:::::::,,,,,,,,,,,,,::;r;;iir. * .rii;;rr,:,,,,,,,,,,,,,,:::::::::::::::,,,,,,,,,,,,,:,si;;iri * ;rii;:1i,,,,,,,,,,,,,,,,,,:::::::::,,,,,,,,,,,,,,,:,ss:;iir: * .rii;;;5r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,sh:;;iri * ;rii;:;51,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.:hh:;;iir, * irii;::hSr,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,sSs:;;iir: * irii;;:iSSs:.,,,,,,,,,,,,,,,,,,,,,,,,,,,..:135;:;;iir: * ;rii;;:,r535r:...,,,,,,,,,,,,,,,,,,..,;sS35i,;;iirr: * :rrii;;:,;1S3Shs;:,............,:is533Ss:,;;;iiri, * .;rrii;;;:,;rhS393S55hh11hh5S3393Shr:,:;;;iirr: * .;rriii;;;::,:;is1h555555h1si;:,::;;;iirri:. * .:irrrii;;;;;:::,,,,,,,,:::;;;;iiirrr;, * .:irrrriiiiii;;;;;;;;iiiiiirrrr;,. * .,:;iirrrrrrrrrrrrrrrrri;:. * ..,:::;;;;:::,,. */ 机械键盘，送给你，拿走直接用~ ~12345678910111213141516/*** ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐* │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐* └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘* ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐* │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │* ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤* │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │* ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │* │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│&quot; &apos;│ Enter │ │ 4 │ 5 │ 6 │ │* ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤* │ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │* ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││* │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│* └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘*/ 佛祖保佑 永无BUG1234567891011121314151617181920212223/*** _ooOoo_* o8888888o* 88&quot; . &quot;88* (| -_- |)* O\ = /O* ____/`---&apos;\____* . &apos; \\| |// `.* / \\||| : |||// \* / _||||| -:- |||||- \* | | \\\ - /// | |* | \_| &apos;&apos;\---/&apos;&apos; | |* \ .-\__ `-` ___/-. /* ___`. .&apos; /--.--\ `. . __* .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;.* | | : `- \`.;`\ _ /`;.`/ - ` : | |* \ \ `-. \_ __\ /__ _/ .-` / /* ======`-.____`-.___\_____/___.-`____.-&apos;======* `=---=&apos;** .............................................* 佛祖保佑 永无BUG*/ / BUG ~ BUg ~ Bug ~ bug ~ 佛曰: 写字楼里写字间，写字间里程序员； 程序人员写程序，又拿程序换酒钱。 酒醒只在网上坐，酒醉还来网下眠； 酒醉酒醒日复日，网上网下年复年。 但愿老死电脑间，不愿鞠躬老板前； 奔驰宝马贵者趣，公交自行程序员。 别人笑我忒疯癫，我笑自己命太贱； 不见满街漂亮妹，哪个归得程序员？ 12345678910111213141516171819202122/*** _ooOoo_* o8888888o* 88&quot; . &quot;88* (| -_- |)* O\ = /O* ___/`---&apos;\____* . &apos; \\| |// `.* / \\||| : |||// \* / _||||| -:- |||||- \* | | \\\ - /// | |* | \_| &apos;&apos;\---/&apos;&apos; | |* \ .-\__ `-` ___/-. /* ___`. .&apos; /--.--\ `. . __* .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;.* | | : `- \`.;`\ _ /`;.`/ - ` : | |* \ \ `-. \_ __\ /__ _/ .-` / /* ======`-.____`-.___\_____/___.-`____.-&apos;======* `=---=&apos;* .............................................* 佛曰：bug泛滥，我已瘫痪！*/ welfare 福利 福利 ~ ~1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*** .::::.* .::::::::.* ::::::::::: FUCK YOU* ..:::::::::::&apos;* &apos;::::::::::::&apos;* .::::::::::* &apos;::::::::::::::..* ..::::::::::::.* ``::::::::::::::::* ::::``:::::::::&apos; .:::.* ::::&apos; &apos;:::::&apos; .::::::::.* .::::&apos; :::: .:::::::&apos;::::.* .:::&apos; ::::: .:::::::::&apos; &apos;:::::.* .::&apos; :::::.:::::::::&apos; &apos;:::::.* .::&apos; ::::::::::::::&apos; ``::::.* ...::: ::::::::::::&apos; ``::.* ```` &apos;:. &apos;:::::::::&apos; ::::..* &apos;.:::::&apos; &apos;:&apos;````..*//*** * _.._ ,------------.* ,&apos; `. ( We want you! )* / __) __` \ `-,----------&apos;* ( (`-`(-&apos;) ) _.-&apos;* /) \ = / (* /&apos; |--&apos; . \* ( ,---| `-.)__`* )( `-.,--&apos; _`-.* &apos;/,&apos; ( Uu&quot;,* (_ , `/,-&apos; )* `.__, : `-&apos;/ /`--&apos;* | `--&apos; |* ` `-._ /* \ (* /\ . \. freebuf* / |` \ ,-\* / \| .) / \* ( ,&apos;|\ ,&apos; :* | \,`.`--&quot;/ &#125;* `,&apos; \ |,&apos; /* / &quot;-._ `-/ |* &quot;-. &quot;-.,&apos;| ;* / _/[&quot;---&apos;&quot;&quot;]* : / |&quot;- &apos;* &apos; | /* ` |*/ 神兽保佑 代码无bug1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*** ┏┓ ┏┓* ┏┛┻━━━┛┻┓* ┃ ┃* ┃ ━ ┃* ┃ ＞ ＜ ┃* ┃ ┃* ┃... ⌒ ... ┃* ┃ ┃* ┗━┓ ┏━┛* ┃ ┃ * ┃ ┃* ┃ ┃* ┃ ┃ 神兽保佑* ┃ ┃ 代码无bug * ┃ ┃* ┃ ┗━━━┓* ┃ ┣┓* ┃ ┏┛* ┗┓┓┏━┳┓┏┛* ┃┫┫ ┃┫┫* ┗┻┛ ┗┻┛*//*** ┏┓ ┏┓+ +* ┏┛┻━━━┛┻┓ + +* ┃ ┃ * ┃ ━ ┃ ++ + + +* ████━████ ┃+* ┃ ┃ +* ┃ ┻ ┃* ┃ ┃ + +* ┗━┓ ┏━┛* ┃ ┃ * ┃ ┃ + + + +* ┃ ┃* ┃ ┃ + 神兽保佑* ┃ ┃ 代码无bug * ┃ ┃ + * ┃ ┗━━━┓ + +* ┃ ┣┓* ┃ ┏┛* ┗┓┓┏━┳┓┏┛ + + + +* ┃┫┫ ┃┫┫* ┗┻┛ ┗┻┛+ + + +*//*** ━━━━━━神兽出没━━━━━━* ┏┓ ┏┓* ┏┛┻━━━┛┻┓* ┃ ┃* ┃ ━ ┃* ┃ ┳┛ ┗┳ ┃* ┃ ┃* ┃ ┻ ┃* ┃ ┃* ┗━┓ ┏━┛* ┃ ┃ 神兽保佑* ┃ ┃ 代码无bug * ┃ ┗━━━┓* ┃ ┣┓* ┃ ┏┛* ┗┓┓┏━┳┓┏┛* ┃┫┫ ┃┫┫* ┗┻┛ ┗┻┛* ━━━━━━感觉萌萌哒━━━━━━*/ ━━━━━━ 感觉萌萌哒 ━━━━━━123456789101112131415/** _* _._ _..._ .-&apos;, _.._(`))* &apos;-. ` &apos; /-._.-&apos; &apos;,/* ) \ &apos;.* / _ _ | \* | a a / |* \ .-. ;* &apos;-(&apos;&apos; ).-&apos; ,&apos; ;* &apos;-; | .&apos;* \ \ /* | 7 .__ _.-\ \* | | | ``/ /` /* /,_| | /,_/ /* /,_/ &apos;`-&apos;*/ 又看源码，看你妹妹呀！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/***************************************************************** ** .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. ** | ______ | ** | .-&quot; &quot;-. | ** | / \ | ** | _ | | _ | ** | ( \ |, .-. .-. ,| / ) | ** | &gt; &quot;=._ | )(__/ \__)( | _.=&quot; &lt; | ** | (_/&quot;=._&quot;=._ |/ /\ \| _.=&quot;_.=&quot;\_) | ** | &quot;=._&quot;(_ ^^ _)&quot;_.=&quot; | ** | &quot;=\__|IIIIII|__/=&quot; | ** | _.=&quot;| \IIIIII/ |&quot;=._ | ** | _ _.=&quot;_.=&quot;\ /&quot;=._&quot;=._ _ | ** | ( \_.=&quot;_.=&quot; `--------` &quot;=._&quot;=._/ ) | ** | &gt; _.=&quot; &quot;=._ &lt; | ** | (_/ \_) | ** | | ** &apos;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=&apos; ** ** LASCIATE OGNI SPERANZA, VOI CH&apos;ENTRATE ****************************************************************//*** ,s555SB@@&amp; * :9H####@@@@@Xi * 1@@@@@@@@@@@@@@8 * ,8@@@@@@@@@B@@@@@@8 * :B@@@@X3hi8Bs;B@@@@@Ah, * ,8i r@@@B: 1S ,M@@@@@@#8; * 1AB35.i: X@@8 . SGhr ,A@@@@@@@@S * 1@h31MX8 18Hhh3i .i3r ,A@@@@@@@@@5 * ;@&amp;i,58r5 rGSS: :B@@@@@@@@@@A * 1#i . 9i hX. .: .5@@@@@@@@@@@1 * sG1, ,G53s. 9#Xi;hS5 3B@@@@@@@B1 * .h8h.,A@@@MXSs, #@H1: 3ssSSX@1 * s ,@@@@@@@@@@@@Xhi, r#@@X1s9M8 .GA981 * ,. rS8H#@@@@@@@@@@#HG51;. .h31i;9@r .8@@@@BS;i; * .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS * s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;, * :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B, * .hM@@@#@@#MX 51 r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8 * :3B@@@@@@@@@@@&amp;9@h :Gs .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: * s&amp;HA#@@@@@@@@@@@@@@M89A;.8S. ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r * ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;. ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i * 5#@@#&amp;@@@@@@@@@@@@@@@@@@9 .39: ;@@@@@@@@@@@@@@@@@@@@@@@@@@@; * 9@@@X:MM@@@@@@@@@@@@@@@#; ;31. H@@@@@@@@@@@@@@@@@@@@@@@@@@: * SH#@B9.rM@@@@@@@@@@@@@B :. 3@@@@@@@@@@@@@@@@@@@@@@@@@@5 * ,:. 9@@@@@@@@@@@#HB5 .M@@@@@@@@@@@@@@@@@@@@@@@@@B * ,ssirhSM@&amp;1;i19911i,. s@@@@@@@@@@@@@@@@@@@@@@@@@@S * ,,,rHAri1h1rh&amp;@#353Sh: 8@@@@@@@@@@@@@@@@@@@@@@@@@#: * .A3hH@#5S553&amp;@@#h i:i9S #@@@@@@@@@@@@@@@@@@@@@@@@@A. *** 又看源码，看你妹妹呀！*//***_______________#########_______________________ *______________############_____________________ *______________#############____________________ *_____________##__###########___________________ *____________###__######_#####__________________ *____________###_#######___####_________________ *___________###__##########_####________________ *__________####__###########_####_______________ *________#####___###########__#####_____________ *_______######___###_########___#####___________ *_______#####___###___########___######_________ *______######___###__###########___######_______ *_____######___####_##############__######______ *____#######__#####################_#######_____ *____#######__##############################____ *___#######__######_#################_#######___ *___#######__######_######_#########___######___ *___#######____##__######___######_____######___ *___#######________######____#####_____#####____ *____######________#####_____#####_____####_____ *_____#####________####______#####_____###______ *______#####______;###________###______#________ *________##_______####________####______________ */ 攻城湿 he 鼓励湿 ~12345678910111213141516171819202122232425262728293031323334353637/** * ,%%%%%%%%, * ,%%/\%%%%/\%% * ,%%%\c &quot;&quot; J/%%% * %. %%%%/ o o \%%% * `%%. %%%% _ |%%% * `%% `%%%%(__Y__)%%&apos; * // ;%%%%`\-/%%%&apos;* (( / `%%%%%%%&apos; * \\ .&apos; | * \\ / \ | | * \\/ ) | | * \ /_ | |__ * (___________))))))) 攻城湿 * * _ _ * __ _(_)_ _(_) __ _ _ __ * \ \ / / \ \ / / |/ _` |&apos;_ \ * \ V /| |\ V /| | (_| | | | | * \_/ |_| \_/ |_|\__,_|_| |_| */ /*** * .--, .--,* ( ( \.---./ ) )* &apos;.__/o o\__.&apos;* &#123;= ^ =&#125;* &gt; - &lt;* / \* // \\* //| . |\\* &quot;&apos;\ /&apos;&quot;_.-~^`&apos;-.* \ _ /--&apos; `* ___)( )(___ 鼓励湿* (((__) (__))) 高山仰止,景行行止.虽不能至,心向往之。*/ 下面这是神魔 ~ ~123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * １１１ １ * １１１ １１１１１１１１１１１１ １１１ * １１ １１１１１１１１１１１１ １１１１１ * １１ １１１ １１ １１１１１１１ * １１１１ １ １１１１１１１１１１１ １１１ １１１１ * １１１１１１ １１１１１１１１１１１ １１１１ １１１１１ * １１１１１１ １１ １１１１ １１１１１１ * １１ １１１１１１１１ １１ １１１１１１１１１１１１１１１１１１ * １１ １１１１１１１１１１１ １１１１１１１１１１１１１１１１１１１ * １１１１１１１１１ １１ １１ １１ １１ * １１１１１１１１１１１１１１１１１１ １１ * １１１１ １１１１１１１１１１１１ １１１１１１１１１１１１１１ * １１１１ １１ １１ １１１１１１１１１１１１１１ * １１ １１ １１ １１ １１１ １１ １１ １１１ * １１ １１ １１ １１ １１ １１１ １１ １１１ * １１ １１１ １１ １１ １１ １１１ １１ １１１ * １１１１ １１１ １１１１１１１１１ １１ １１１ １１ １１１１１１１ * １１１１１１ １１１１１１１１１１ １１１１１１１１１１１１１１１１１ * １１ １１１ １１１ １１１１１１１１１１１１１１１１１ *//*** * _____ _____ _____ _____ * /\ \ /\ \ /\ \ /\ \ * /::\____\ /::\ \ /::\ \ /::\ \ * /:::/ / \:::\ \ /::::\ \ /::::\ \ * /:::/ / \:::\ \ /::::::\ \ /::::::\ \ * /:::/ / \:::\ \ /:::/\:::\ \ /:::/\:::\ \ * /:::/____/ \:::\ \ /:::/__\:::\ \ /:::/__\:::\ \ * /::::\ \ /::::\ \ /::::\ \:::\ \ /::::\ \:::\ \ * /::::::\ \ _____ ____ /::::::\ \ /::::::\ \:::\ \ /::::::\ \:::\ \ * /:::/\:::\ \ /\ \ /\ \ /:::/\:::\ \ /:::/\:::\ \:::\____\ /:::/\:::\ \:::\ \ * /:::/ \:::\ /::\____\/::\ \/:::/ \:::\____\/:::/ \:::\ \:::| |/:::/__\:::\ \:::\____\* \::/ \:::\ /:::/ /\:::\ /:::/ \::/ /\::/ |::::\ /:::|____|\:::\ \:::\ \::/ /* \/____/ \:::\/:::/ / \:::\/:::/ / \/____/ \/____|:::::\/:::/ / \:::\ \:::\ \/____/ * \::::::/ / \::::::/ / |:::::::::/ / \:::\ \:::\ \ * \::::/ / \::::/____/ |::|\::::/ / \:::\ \:::\____\ * /:::/ / \:::\ \ |::| \::/____/ \:::\ \::/ / * /:::/ / \:::\ \ |::| ~| \:::\ \/____/ * /:::/ / \:::\ \ |::| | \:::\ \ * /:::/ / \:::\____\ \::| | \:::\____\ * \::/ / \::/ / \:| | \::/ / * \/____/ \/____/ \|___| \/____/ *//** * https://campus.alibaba.com/* `:::::::::::,* `::;:::::::;:::::::, `* `::;;:::::::@@@@;:::::::`* ,:::::::::::::@ #@&apos;:::::`* :::::::::::::::&apos;@@ @;::::* ::::::::::::&apos;@@@@&apos;``` .+:::`* ::::::::::;@@@#. ,:::,* .::::::::+@#@` ::::* :::::::+@@&apos; ::::* `:::::&apos;@@: `:::.* ,::::@@: ` ::::* ;::::::@ .:::;* :;:::::;@` ` :::;* :::::::::@` @ ;::::* :::::::::#` @` ,::::* :::::::::@` +@ @ .::::`* .::::::&apos;@@` `@@&apos; @ ::::,* :::::::++@@@@@@@@@@. ::::;* ;:::::::+, `..` :::::* ,::::::::&apos;, :::::* :::::::::+, :::::`* :::::::::+@. ,::::.` `,* ::::::;;@+ .::;:: `;* :::::::@@ `:::;: `::``* ::::::#@ ;:::: .::`* :::::;@ :::::` .;::`* :::::@ `:;::: `::::;* :::::# :::::. `,;:::::* :::::: ` ::::::,.,::::::::::.* ,::::::` .:: ::::::::::::::::;`* ;::::::::,````.,:::::, ::::::::::::::.* :::::::::::::::::: ` `::::::::::`* `::::::::::::, .:::.* `..`*/ 頂 ~ 頂 ~ 頂123456789101112131415/*** 頂頂頂頂頂頂頂頂頂 頂頂頂頂頂頂頂頂頂* 頂頂頂頂頂頂頂 頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂* 頂頂 頂頂頂頂頂頂頂頂頂頂頂* 頂頂 頂頂 頂頂* 頂頂 頂頂 頂頂頂 頂頂* 頂頂 頂頂 頂頂頂 頂頂* 頂頂 頂頂 頂頂頂 頂頂* 頂頂 頂頂 頂頂頂 頂頂* 頂頂 頂頂頂 * 頂頂 頂頂 頂頂 頂頂* 頂頂頂頂 頂頂頂頂頂 頂頂頂頂頂* 頂頂頂頂 頂頂頂頂 頂頂頂頂*/ 以上为魔性图 以下为神注释，是你接手的婶注释，还是你留下的神注释。1234/*** 这个公司没有年终奖的,兄弟别指望了,也别来了,我准备辞职了* 另外这个项目有很多*Bug* 你坚持不了多久的,拜拜!*/ 123456789101112131415161718192021222324252627282930313233/*** 1只羊 == one sheep* 2只羊 == two sheeps* 3只羊 == three sheeps* 4只羊 == four sheeps* 5只羊 == five sheeps* 6只羊 == six sheeps* 7只羊 == seven sheeps* 8只羊 == eight sheeps* 9只羊 == nine sheeps* 10只羊 == ten sheeps* 11只羊 == eleven sheeps* 12只羊 == twelve sheeps* 13只羊 == thirteen sheeps* 14只羊 == fourteen sheeps* 15只羊 == fifteen sheeps* 16只羊 == sixteen sheeps* 17只羊 == seventeen sheeps* 18只羊 == eighteen sheeps* 19只羊 == nineteen sheeps* 20只羊 == twenty sheeps* 21只羊 == twenty one sheeps* 22只羊 == twenty two sheeps* 23只羊 == twenty three sheeps* 24只羊 == twenty four sheeps* 25只羊 == twenty five sheeps* 26只羊 == twenty six sheeps* 27只羊 == twenty seven sheeps* 28只羊 == twenty eight sheeps* 29只羊 == twenty nine sheeps* 30只羊 == thirty sheeps* 现在瞌睡了吧，好了，不要再改下面的代码了，睡觉咯~~*/ 12345678910111213/*** You may think you know what the following code does.* But you dont. Trust me.* Fiddle with it, and youll spend many a sleepless* night cursing the moment you thought youd be clever* enough to &quot;optimize&quot; the code below.* Now close this file and go play with something else.*//*** 你可能会认为你读得懂以下的代码。但是你不会懂的，相信我吧。* 要是你尝试玩弄这段代码的话，你将会在无尽的通宵中不断地咒骂自己为什么会认为自己聪明到可以优化这段代码。* 现在请关闭这个文件去玩点别的吧。*/ 12345678/*** somedev1 - 6/7/02 Adding temporary tracking of Login screen* somedev2 - 5/22/07 Temporary my ass*//*** 一些修改1 - 2002/6/7 增加临时的跟踪登录界面* 一些修改2 - 2007/5/22 我临时的犯傻*/ 1234567/*** 程序员1（于2010年6月7日）：在这个坑临时加入一些调料* 程序员2（于2011年5月22日）：临你个屁啊* 程序员3（于2012年7月23日）：楼上都是狗屎，鉴定完毕* 程序员4（于2013年8月2日）：fuck 楼上，三年了，这坑还在！！！* 程序员5（于2014年8月21日）：哈哈哈，这坑居然坑了这么多人，幸好我也不用填了，系统终止运行了，you&apos;re died*/ 1234567891011121314/*** For the brave souls who get this far: You are the chosen ones,* the valiant knights of programming who toil away, without rest,* fixing our most awful code. To you, true saviors, kings of men,* I say this: never gonna give you up, never gonna let you down,* never gonna run around and desert you. Never gonna make you cry,* never gonna say goodbye. Never gonna tell a lie and hurt you.*//*** 致终于来到这里的勇敢的人： * 你是被上帝选中的人，是英勇的、不敌辛苦的、不眠不休的来修改我们这最棘手的代码的编程骑士。* 你，我们的救世主，人中之龙，我要对你说：永远不要放弃，永远不要对自己失望，永远不要逃走，辜负了自己，* 永远不要哭啼，永远不要说再见，永远不要说谎来伤害自己。*/ 123456789101112131415161718/*** Dear maintainer:* * Once you are done trying to &apos;optimize&apos; this routine,* and have realized what a terrible mistake that was,* please increment the following counter as a warning* to the next guy:* * total_hours_wasted_here = 42*//*** 亲爱的维护者：* * 如果你尝试了对这段程序进行&apos;优化&apos;* 下面这个计数器的个数用来对后来人进行警告* * 浪费在这里的总时间 = 42h*/ 12345678/** * When I wrote this, only God and I understood what I was doing* Now, God only knows*//** * 写这段代码的时候，只有上帝和我知道它是干嘛的* 现在，只有上帝知道*/ 12// sometimes I believe compiler ignores all my comments// 有时候我相信编译器忽略了我所有的注释 12// drunk, fix later// 有点晕了，以后再修改 12// Magic. Do not touch.// 麻鸡。勿动。 1#define TRUE FALSE// Happy debugging suckers 12double penetration; // ouch// 自行了解，不方便解释 123456// To understand recursion, see the bottom of this file At the bottom of the file:// To understand recursion, see the top of this file// 想要明白递归须看文件末尾到了文末// 想要明白递归须看文件顶部 1234// This code sucks, you know it and I know it. // Move on and call me an idiot later.// 你我都知道这代码很烂// 先不要骂我2B了，请先继续往下看 12// I am not sure why this works but it fixes the problem. // 虽然我不知道为什么这样管用，但它却是修复了问题 12// This function has been here since 1987. DON&apos;T FXXKING TOUCH IT// 这函数1987年就这在了，别他娘动它 12// if i ever see this again i&apos;m going to start bringing guns to work// 如果要是再让我看见这样的代码，也许我会带着一把枪来上班 1234// no comments for you// it was hard to write// so it should be hard to read// 难写的代码，肯定很难读。因此，我没有注释留给你。 123// I am not responsible of this code.// They made me write it, against my will.// 下面的代码，我不负责。因为是他们逼我写的，违背了我的意愿。 12// I have to find a better job// 看来我需要找份更好的工作了 123/*** 这个类是Object的子类*/ 转载原著：http://www.jianshu.com/p/bd1f551a1915 如果有更好地可以留言，如果看到这能带给你快乐的话，那就点个稀饭吧，愿所有的程序都永无Bug。]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 封装思维—TabBarNavBar]]></title>
    <url>%2FEncapsulationThinking%2FTabBarNavBar.html</url>
    <content type="text"><![CDATA[本篇文章主要从【简易-TabBar + NavBar 封装】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： 封装自定义TabBar(表格栏) 封装自定义NavBar(导航栏) 1.封装自定义TabBar(表格栏)1234解决:本文采用自定义 TabBar 继承于UIView，移除系统tabBar上的子控件 UITabBarButton 用自定义 UIButton 来代替，切换控制器 self.selectedIndex = index; PS. 效果在最下面. . . 1. 自定义LNTabBarController121.自定义继承于UITabBarController2.创建子控制器,添加所有的子控制器addChildVC，封装方法 添加所有的子控制器addChildVC 1234567891011121314151617/** 添加所有的子控制器 */- (void)addChildVC&#123; // 1.购彩大厅 [self setUpChildVC:[[LNHallTableVC alloc] init] image:[UIImage imageNamed:@"TabBar_LotteryHall_new"] selectedImage:[UIImage imageNamed:@"TabBar_LotteryHall_selected_new"] title:@"购彩大厅"]; // 2.竞技场 [self setUpChildVC:[[LNArenaVC alloc] init] image:[UIImage imageNamed:@"TabBar_Arena_new"] selectedImage:[UIImage imageNamed:@"TabBar_Arena_selected_new"] title:nil]; // 3.发现 [self setUpChildVC:[[LNDiscoverTableVC alloc] init] image:[UIImage imageNamed:@"TabBar_Discovery_new"] selectedImage:[UIImage imageNamed:@"TabBar_Discovery_selected_new"] title:@"发现"]; // 4.开奖信息 [self setUpChildVC:[[LNHistoryTableVC alloc] init] image:[UIImage imageNamed:@"TabBar_History_new"] selectedImage:[UIImage imageNamed:@"TabBar_History_selected_new"] title:@"开奖信息"]; // 5.我的彩票 [self setUpChildVC:[[LNMyLotteryVC alloc] init] image:[UIImage imageNamed:@"TabBar_MyLottery_new"] selectedImage:[UIImage imageNamed:@"TabBar_MyLottery_selected_new"] title:@"我的彩票"];&#125; 封装添加子控制器方法 1234567891011121314151617/** 封装添加子控制器方法 */- (void)setUpChildVC:(UIViewController *)vc image:(UIImage *)image selectedImage:(UIImage *)selectedImage title:(NSString *)title &#123; // 1.设置tabBar的图片和标题 vc.tabBarItem.image = image; vc.tabBarItem.selectedImage = selectedImage; vc.navigationItem.title = title; [self.items addObject:vc.tabBarItem]; // 2.创建导航栏 UINavigationController *nav = [[LNNavigationController alloc] initWithRootViewController:vc]; // 在这里可以判断当前类是使用系统NavBar,还是自定义NavBar if ([vc isKindOfClass:[LNArenaVC class]]) &#123; nav = [[LNArenaNavController alloc] initWithRootViewController: vc]; &#125; [self addChildViewController:nav];&#125; 2. 自定义tabBar1234561.当系统tabBar不满足需求时, 解决:UIView 子控件UIButton 切换控制器selectedIndex2.自定义LNTabBar继承于UIView3.切换控制器 self.selectedIndex = index;4.自定义LNTabBarButton继承于UIButton，作用:去掉高亮效果(重写setHighlighted:方法) 注意：这里我们要对系统的tabBar做处理。方法一：移除系统的tabBar，方法二：移除tabBar上的子控件(采用)，采用原因：(方便我们下步统一设置返回按钮或是滑动移除非根控制器，vc.hidesBottomBarWhenPushed = YES;此属性是隐藏的系统的tabBar) 1.移除系统tabBar上的子控件 123456789101112131415161718192021222324/** 在view即将显示的时候, 把系统的UITabBarButton移除 */- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; for (UIView *view in self.tabBar.subviews) &#123; /** UITabBarButton:系统的私有tabBar属性 这里采用逆向思维,判断是自己的(LNTabBar)就不移除.不是自己就移除 */ if (![view isKindOfClass:[LNTabBar class]]) &#123; [view removeFromSuperview]; &#125; &#125;&#125;/** 自定义tabBar */- (void)setUpTabBar&#123; LNTabBar *tabBar = [[LNTabBar alloc] init]; // 注意:这里赋值frame要用bounds tabBar.frame = self.tabBar.bounds; tabBar.items = self.items; tabBar.delegate = self; [self.tabBar addSubview:tabBar];&#125; 2.创建自定义LNTabBar继承于UIView1234封装控件基本步骤：1、在`initWithFrame:`方法中添加子控件，提供便利构造方法2、在`layoutSubviews`方法中设置子控件的`frame` (一定要调用`[super layoutSubviews];`)3、增加模型属性，在模型属性`set方法`中子控件赋值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#import "LNTabBar.h"#import "LNTabBarButton.h"@interface LNTabBar ()/** 记录当前选中的按钮 */@property (nonatomic, weak) UIButton *selectBtn;@end@implementation LNTabBar// set方法赋值- (void)setItems:(NSArray *)items &#123; _items = items; for (UITabBarItem *tabBarItem in items) &#123; // 添加子控件 /** 注意:这里使用系统button会有高亮效果,没有去掉高亮的属性,需要自定义btn */ LNTabBarButton *btn = [[LNTabBarButton alloc] init]; btn.tag = self.subviews.count; // 设置背景图片和点击事件 [btn setBackgroundImage:tabBarItem.image forState:UIControlStateNormal]; [btn setBackgroundImage:tabBarItem.selectedImage forState:UIControlStateSelected]; [btn addTarget:self action:@selector(btnClick:) forControlEvents:UIControlEventTouchDown]; // 添加按钮 [self addSubview:btn]; // 默认让第一个按钮成为选中状态 if (self.subviews.count == 1) &#123; [self btnClick:btn]; &#125; &#125;&#125;// 设置子控件的frame- (void)layoutSubviews&#123; [super layoutSubviews]; CGFloat btnX = 0; CGFloat btnY = 0; CGFloat btnW = self.frame.size.width / self.items.count; CGFloat btnH = self.frame.size.height; int index = 0; // 取出所有的按钮 for (UIButton *btn in self.subviews) &#123; btnX = btnW * index; btn.frame = CGRectMake(btnX, btnY, btnW, banh); index++; &#125;&#125;@end 3.切换控制器给Btn添加tag值self.subviews.count,通过代理将tag传值到控制器,控制器实现代理方法且self.selectedIndex = index; 12345678910111213141516171819// LNTabBar.h#import &lt;UIKit/UIKit.h&gt;// 1.定义协议@class LNTabBar;@protocol LNTabBarDelegate &lt;NSObject&gt;// 2.定义协议方法- (void)tabBar:(LNTabBar *)tabBar index:(NSInteger)index;@end@interface LNTabBar : UIView/** 存放TabBarItem模型 */@property (nonatomic, strong) NSArray *items;// 3.定义遵守协议的代理@property (nonatomic, weak) id&lt; LNTabBarDelegate &gt;delegate;@end 在btnClick方法中,三步设置Btn的切换1234567891011121314// 当点击按钮的时候调用(这里需要定义selectBtn属性来记录当前选中的按钮)- (void)btnClick:(UIButton *)btn&#123; // 1.取消上次选中 self.selectBtn.selected = NO; // 2.选中当前点击的按钮 btn.selected = YES; // 3.记录当前选中的按钮 self.selectBtn = btn; // 4.调用代理方法通知代理 if ([self.delegate respondsToSelector:@selector(tabBar:index:)]) &#123; [self.delegate tabBar:self index:btn.tag]; &#125;&#125; 1234567#import "LNTabBarVC.h"// 5.实现协议方法- (void)tabBar:(LNTabBar *)tabBar index:(NSInteger)index&#123; // 切换子控制器 self.selectedIndex = index;&#125; 4.自定义LNTabBarButton继承于UIButton 1234567@implementation LNTabBarButton/** UIButton去掉高亮效果,重写 setHighlighted: 方法 */- (void)setHighlighted:(BOOL)highlighted&#123;&#125; 2. 封装自定义NavBar(导航栏)1. 自定义LNNavigationController1231.自定义继承于UINavigationController2.做到谁的事情谁管理(自定义设置导航栏的内容)3.initialize 性能优化 首先了解两个知识点 initialize 和 appearanceinitialize什么时候调用：当第一次初始化这个类的时候调用且只调用一次，如果当这个类有子类会调用多次.作用：初始化这个类 appearance：获取整个项目当中的某个属性UINavigationBar *navBar = [UINavigationBar appearance];1、用这个方法,获取整个项目当中的UINavigationBar.系统的也给获取了,也给设置了背景,我们不须要改系统的东西.所以在这里,不能直接获取整个系统当中的UINavigationBar,所以我们也不直接使用这个.2、解决:12// 获取指定类下的所有UINavigationBarUINavigationBar *navBar = [UINavigationBar appearanceWhenContainedInInstancesOfClasses:@[[LNNavigationController class]]]; 12345678910111213141516// 控制器添加5个tabBar会调用封装方法5次,即会调用viewDidLoad5次,需要性能优化,initialize 此方法只会调用一次. + (void)initialize &#123; if (self == [LNNavigationController class]) &#123; // 1.获取指定一个类或多个类下UINavigationBar UINavigationBar *navBar = [UINavigationBar appearanceWhenContainedInInstancesOfClasses:@[[LNNavigationController class]]]; /** 2.设置navBar背景图片 设置为UIBarMetricsDefault的,控制器的View的Y值从64开始.其它类型的控制器的View的Y值从0开始 */ [navBar setBackgroundImage:[UIImage imageNamed:@"NavBar64"] forBarMetrics:UIBarMetricsDefault]; // 设置navBar标题 NSDictionary *dict = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:18.f],NSForegroundColorAttributeName:[UIColor whiteColor]&#125;; [navBar setTitleTextAttributes:dict]; &#125;&#125; 2. 统一设置返回按钮+滑动移除控制器+全屏滑动移除控制器 1.修改系统的push方法,判断当非根控制器时,设置左侧返回按钮 &amp; 隐藏底部表格栏.2.当是根控制器的时候还原系统代理,是非根控制器的时候清空系统代理3.当是根控制器手势禁止,非控制器手势可以用 1.统一设置返回按钮:修改系统的push方法,判断当非根控制器时,设置左侧返回按钮 &amp; 隐藏底部表格栏. 12345678910111213141516- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; // 当非根控制器时,设置左侧返回按钮 if (self.viewControllers.count &gt; 0) &#123; // 设置左侧返回按钮 viewController.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithImage:[UIImage imageWithOriginalImageName:@"NavBack"] style:0 target:self action:@selector(back:)]; // 统一设置非根控制器隐藏底部表格栏(隐藏一定要写在push之前) viewController.hidesBottomBarWhenPushed = YES; &#125; [super pushViewController:viewController animated:animated];&#125;- (void)back:(UIBarButtonItem *)item &#123; [self popViewControllerAnimated:YES];&#125; 注意:如果在导航控制器统一设置返回按钮,就没有滑动移除控制器的功能解决:统一设置滑动移除控制器 2.统一设置滑动移除控制器:当是根控制器的时候还原系统代理,是非根控制器的时候清空系统代理 1234567891011/** 系统手势代理 */@property (nonatomic, strong) id popGesture;- (void)viewDidLoad &#123; [super viewDidLoad]; //self.interactivePopGestureRecognizer.delegate = nil;// 这里有bug,不使用 self.popGesture = self.interactivePopGestureRecognizer.delegate; // 把自己设置成自己的代理,遵守&lt;UINavigationControllerDelegate&gt; self.delegate = self;&#125; 代理方法12345678910111213#pragma mark NavControllerDelegate// 当控制器显示完毕的时候调用- (void)navigationController:(UINavigationController *)navigationController didShowViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; if (self.viewControllers[0] == viewController) &#123; // 根控制器还原代理 self.interactivePopGestureRecognizer.delegate = self.popGesture; &#125; else &#123; // 非根控制器清空代理 self.interactivePopGestureRecognizer.delegate = nil; &#125;&#125; 3.统一设置全屏滑动移除控制器:当是根控制器手势禁止,非控制器手势可以用 方法一: 1.先修改系统的手势,系统没有给我提供全屏滑动的属性,需要自己添加手势2.自己添加Pan拖动手势3.缺少Target(系统的私有属性),利用KVC取target的类型. 其中也用到OC runtime机制,获取当前类的成员属性 12345678910111213141516171819202122232425// 全屏滑动移除控制器方法一- (void)fullScreenSlideMethodsA &#123; // 1.先修改系统的手势,系统没有给我提供全屏滑动的手势,需要自己添加 UIScreenEdgePanGestureRecognizer *gest = self.interactivePopGestureRecognizer; // OC runtime 机制,注意点只能动态获取当前类的成员属性,不能获取子类或者父类的属性// unsigned int outCount = 0;// Ivar *ivars = class_copyIvarList([UIGestureRecognizer class], &amp;outCount);// for (int i = 0; i &lt; outCount; i++) &#123;// // 获取成员属性的名字(C语言转换成OC成员属性)// NSString *name = @(ivar_getName(ivars[i]));// NSLog(@"%@",name);// _targets// &#125; NSArray *targets = [gest valueForKeyPath:@"_targets"]; id target = [targets[0] valueForKeyPath:@"_target"]; // 2.自己添加手势 UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)]; [self.view addGestureRecognizer:pan]; // 3.禁止系统的手势 self.interactivePopGestureRecognizer.enabled = YES;&#125; 方法二: target和系统手势代理一样的id target = self.interactivePopGestureRecognizer.delegate; 123456789101112131415// 全屏滑动移除控制器方法二- (void)fullScreenSlideMethodsB &#123; // 1.系统手势代理 id target = self.interactivePopGestureRecognizer.delegate; // 2.自己添加手势 UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)]; [self.view addGestureRecognizer:pan]; // Target:self 和 delegate = self 是一样的. pan.delegate = self; // 3.禁止系统的手势 self.interactivePopGestureRecognizer.enabled = YES;&#125; 共同bug解决:遵守,在代理方法中判断如果是根控制器就禁止手势12345678#pragma mark UIGestureRecognizerDelegate// 当开始滑动就会调用.如果返回YES可以滑动,返回NO禁止手势- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123; // 当是根控制器手势禁止,非控制器手势可以用 BOOL open = self.viewControllers.count &gt; 1; return open;&#125; 总结1.问题：系统会默认将选中图片渲染成蓝色显示解决：方法一,封装:给UIImage添加image分类12345678910// 方法/** 返回一张没有经过渲染的图片 */+ (UIImage *)imageWithOriginalImageName:(NSString *)imageName&#123; UIImage *image = [UIImage imageNamed:imageName]; return [image imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];&#125;// 调用UIImage *image = [UIImage imageWithOriginalImageName:@"NavBack"]; 方法二：图形化设置 效果]]></content>
      <categories>
        <category>封装</category>
      </categories>
      <tags>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 封装思维—Button]]></title>
    <url>%2FEncapsulationThinking%2FButton.html</url>
    <content type="text"><![CDATA[本篇文章主要从【简易-Button 按钮封装】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量🔍白开水ln。 目录： 调整Btn内部imageView和label的位置 1.调整Btn内部imageView和label的位置12需求: 以写导航栏 titleView ,封装思维,别人有可能改变你的标题;改变了标题内容还需要重新适应sizeToFit.解决: 自定义Button;重写set方法(一定要调用父类),sizeToFit也需要封装里面 创建继承于UIButton的 LNTitleViewBtn方法：1234567891011121314151617181920212223242526@implementation LNTitleViewBtn/** 这个方法会调两次 UIButton设置title的时候会调用一次,设置image的时候会调用一次(image必须有且不为nil) */- (void)layoutSubviews &#123; [super layoutSubviews]; //NSLog(@"%s, line = %d",__FUNCTION__,__LINE__); // 调整子控件的位置 if (self.imageView.x &lt; self.titleLabel.x) &#123; self.titleLabel.x = self.imageView.x; self.imageView.x = CGRectGetMaxX(self.titleLabel.frame); &#125;&#125;- (void)setTitle:(NSString *)title forState:(UIControlState)state &#123; [super setTitle:title forState:state]; [self sizeToFit];&#125;- (void)setImage:(UIImage *)image forState:(UIControlState)state &#123; [super setImage:image forState:state]; [self sizeToFit];&#125;@end 调用：1234567891011121314// 1.设置titleViewUIButton *btn = [[LNTitleViewBtn alloc] init];self.btn = btn;[btn setImage:[UIImage imageNamed:@&quot;titleView&quot;] forState:UIControlStateNormal];[btn setTitle:@&quot;全部猜中&quot; forState:UIControlStateNormal];[btn sizeToFit];self.navigationItem.titleView = btn;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [self.btn setTitle:@&quot;标题标题标题标题&quot; forState:UIControlStateNormal]; [self.btn setImage:nil forState:UIControlStateNormal]; //[self.btn sizeToFit];&#125;]]></content>
      <categories>
        <category>封装</category>
      </categories>
      <tags>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一杯白开水]]></title>
    <url>%2FPerceptionWork%2Fwater.html</url>
    <content type="text"><![CDATA[念念不忘 晚上吃了一大块蛋糕，甜甜的奶油在吃多了之后让人觉得腻的想吐，舍友开始用黑咖啡解腻，一直不喜欢咖啡呢我也去凑了个热闹，喝了一大口。大半夜还没睡着，不知道是自己最近睡太多还是真的是咖啡的功效，随手翻了翻手机相册，看到了白天随手拍的那杯白开水。 说不上特别喜欢糖，但是比起无味的东西我更愿意接受有点味道的，所以以前在白水和饮料之间我更喜欢那些乱七八糟呢饮料，到了后来，切切的说应该是从大二时起我开始逐渐抵触各类饮料，奶茶之类的东西也一学期最多喝上一两次，可能是受“那些东西不健康，吃多了不好！”“那里面有防腐剂，色素！”等等之类的话的影响，也可能是因为年龄的增长，总之到现在那些东西我对它们已经没有了兴趣。反而，我更喜欢白开水。每天早晨起床，第一件事绝对是倒一大杯白开水，待洗漱完毕之后再把它一饮而尽，我很喜欢它带给我的那种心旷神怡的感觉，美好的早晨从一杯白开水开始。 有句话说“生活就像一杯白开水”，我之前一直都觉得白开水只是一种平淡无奇的液体，因而在很久之前看到这句话的时候也不大理解为何要这样比喻，我一直都感觉生活是一个具有酸、甜、麻、苦、辣的五味瓶，而不仅仅只是平淡无奇。前几天晚上睡觉之前在一个电台听到一篇文章，文章的题目叫做《幸福是一杯白开水》文中作者对生活幸福的感触以及精简有力的文字表达的细腻情感引起了我的情感共鸣，我开始理解生活确实是像一杯白开水，而我们都是可以控制白开水味道的人，在里面加入“糖”我们拥有的便是甜蜜，加入“黑咖啡”拥有的便是让人回味的苦，加入“茶叶”拥有的便是苦涩之后的回味无穷，生活如何全靠自己所加的料。 生活原本就像一杯白开水，而我们自己才是掌控生活质量的主人，我们需不要因为昨天而让明天黯然失色的信心，需要拥有我就是我，我生活的主人的执念，去经营生活，去把握生活，把本来类似白开水的生活过成我们喜欢的样子]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 模式详解—「Block面试、工作」]]></title>
    <url>%2FiOSUI%2FBlock.html</url>
    <content type="text"><![CDATA[引导Block 在开发中是比较实用的，一般能用Block的就使用Block，学会使用Block，你再也不想用繁琐的代理。Block没有你想象中的那么难，不要害怕，要勇敢尝试。 Write in the first 下面是我对 Block 的整理，从零开始，由浅入深，并且带了几个 Block 实际开发的应用场景。对于从事 iOS 开发人员来说，不会使用 Block，那 ~ ~ 本篇文章主要从【Block 实用相关详解】学习总结。在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量；@ 白开水ln 目录： Block概念 Block声明、定义、类型、调用 开发使用场景：保存代码 开发使用场景：Block传值 &amp; 代理传值1.传值简明介绍2.示例需求：代理传值3.示例需求：Block传值 Block在MRC &amp; ARC下的内存管理1.面试题1/22.Block内存管理(MRC)3.Block内存管理(ARC) Block循环引用1.附图注解： Block变量传递 开发使用场景：Block当参数使用 开发使用场景：Block当返回值使用 block的分类（栈、堆、全局区） Block底层实现 Block详解效果图 期待后续 &amp; About me Block概念Block 释义：匿名的函数、代码块（把你想要执行的代码封装在这个代码块里，等到需要的时候再去调用），是苹果在 iOS4 开始引入的对 C 语言的扩展，用来实现匿名函数的特性，Block 是一种特殊的数据类型，可以正常定义变量、作为参数、作为返回值；还可以保存一段代码，在需要的时候调用（注意：必须调用才能执行保存内部的代码），目前Block 已经广泛应用于iOS开发中，常用于传值、各类回调等； Block声明、定义、类型、调用声明12341.Block声明格式:返回值(^Block变量名)(参数)示例:void(^block)(); 最纯洁的block,无返回值无参 定义12345678910111213141516171819202122232425262728//------------ block定义:三种方式 = ^(参数)&#123;&#125;; ------------////// 第一种: 最纯洁的block,无返回值无参void(^block1)() = ^()&#123;&#125;;// 第二种: 如果没有参数,参数可以隐藏,如果有参数,定义的时候,必须要写参数,而且必须要有参数变量名void(^block2)(NSString *) = ^(NSString *name)&#123;&#125;;// 第三种 block返回可以省略,不管有没有返回值,都可以省略int(^block3)() = ^int&#123; return 3;&#125;;//--------------------------- block快捷方式 ------------------------------////// block快捷方式 inline&lt;#returnType#&gt;(^&lt;#blockName#&gt;)(&lt;#parameterTypes#&gt;) = ^(&lt;#parameters#&gt;) &#123; &lt;#statements#&gt;&#125;;补充：变量、属性、方法NSString *(^myBlock2)(NSString *) = nil;// 带参数与返回值@property (nonatomic, strong) NSString *(^myBlock2)(NSString *);// 带参数与返回值- (void)test2:(NSString *(^)(NSString *))testBlock//带参数与返回值 类型 注解：Block 变量的赋值格式可以是: Block变量 = ^返回值类型(参数列表){函数体};不过通常情况下都将返回值类型省略，因为编译器可以从存储代码块的变量中确定返回值的类型. 12345678910111213// block类型:int(^)(NSString *),形参变量名称可以省略,只留有变量类型即可int(^block4)(NSString *) = ^(NSString *name)&#123; NSLog(@"block4 %s, line = %d",__FUNCTION__,__LINE__); return 2;&#125;;block4(@"11");// 无返回值,参数为两个字符串对象,变量名叫做LNBlock的Blockvoid(^LNBlock)(NSString *x, int y) = ^(NSString *name,int age)&#123; NSLog(@"LNBlock %@-%d%s, line = %d",name,age, __FUNCTION__,__LINE__);&#125;;LNBlock(@"liunan",18); 使用 typedef 定义 Block 类型在实际使用Block的过程中，我们可能需要重复地声明多个相同返回值相同参数列表的Block变量，如果总是重复地编写一长串代码来声明变量会非常繁琐，所以我们可以使用typedef来定义Block类型。 123456789// 方式一：blockType:类型别名typedef void (^BlockType)();@property (nonatomic, strong) BlockType block1;/** 提供构造方法 */- (instancetype)initWithFrame:(CGRect)frame andImageArray:(NSArray *)imageArray index:(LNBlock)indexBlock;// 方式二：block怎么声明,就如何定义成属性（推荐使用）@property (nonatomic, strong) void(^block)(); 调用12345678// Block调用（传参数值）= ^(NSString *name,int age)&#123;LNBlock(@"liunan",18);// 这里严谨点,要加上判断if (item.LNblock) &#123; item.LNblock(); // Block调用&#125; 赋值12345678@property (nonatomic, strong) void(^myBlock)(NSString *value);// Block接收值(参数值),保存代码_myBlock = ^(NSString *value)&#123; NSLog(@"%@",value);&#125;;_myBlock(@"123456"); 开发使用场景：保存代码下面举个小示例（把点击每个 Cell 把要做的事情(代码)保存到模型中）：先看效果 核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#pragma mark ------------------#pragma mark - tableViewDataSource Delegate- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; static NSString *cellID = @"cellID"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID]; if (cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellID]; &#125; LNCellItem *item = self.items[indexPath.row]; cell.textLabel.text = item.title; return cell;&#125;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; LNCellItem *item = self.items[indexPath.row]; /** 点击每个Cell把要做的事情(代码)保存到模型中 */ // 这里严谨点,要加上判断 if (item.LNBlock) &#123; item.LNBlock(); // Block调用 &#125; //--------------------------- 笨的方式二 ------------------------------// // 代码可读性很差 // if (indexPath.row == 0) &#123;// NSLog(@"白开水ln--简书");// &#125; else if (indexPath.row == 1) &#123;// NSLog(@"白开水ln--GitHub");// &#125; else if (indexPath.row == 2) &#123;// NSLog(@"白开水ln--Blog");// &#125; &#125; 1234567891011121314151617181920212223242526//----------- 2.在一个类中定义,在另外一个类中调用 小实力---------------////- (void)createItems &#123; //--------------------------- 创建模型 ------------------------------// /** item1.LNblock = ^&#123; // Block保存代码 &#125;; */ LNCellItem *item1 = [LNCellItem itemWithTitle:@"简书"]; LNCellItem *item2 = [LNCellItem itemWithTitle:@"GitHub"]; LNCellItem *item3 = [LNCellItem itemWithTitle:@"Blog"]; item1.LNBlock = ^&#123; NSLog(@"白开水ln--简书"); &#125;; item2.LNBlock = ^&#123; NSLog(@"白开水ln--GitHub"); &#125;; item3.LNBlock = ^&#123; NSLog(@"白开水ln--Blog"); &#125;; _items = @[item1,item2,item3];&#125; LNCellItem 模型类 12345678910111213141516// LNCellItem.h#import &lt;Foundation/Foundation.h&gt;@interface LNCellItem : NSObject// 设计模型:控件需要展示什么内容,就定义什么属性@property (nonatomic, strong) NSString *title;// 提供构造方法+ (instancetype)itemWithTitle:(NSString *)title;// 保存每个cell做的事情@property (nonatomic, strong) void(^LNBlock)();// 提示:你要写什么，缺什么就补什么；开始不要想太多，就写个纯净的block@end 总结：提示: 你要写什么，缺什么就补什么；开始不要想太多，就直接干（这里指的是如定义Block要不要带参数，你可别没有思路就直接干了啊）。 开发使用场景：Block传值 &amp; 代理传值 传值简明介绍 传值: 1.只要能拿到对方就能传值 顺传：给需要传值的对象,直接定义属性就能传值 逆传：2–&gt;传1，用代理、block，就是干–&gt; 开发中就是利用block去代替代理。 示例需求：点击1ViewController 跳转 2ViewController，点解2ViewController 传值给1ViewController 示例需求：代理传值总结： 传值界面需要4点: 1.定义代理名(先声明) 2.定义协议 3.定义遵守协议的代理 4.判断是否执行协议方法（是传值给ViewController） 接收值界面需要1点: 5.遵守协议，实现协议方法 1234567891011121314151617181920212223242526272829//--------------------------- 代理传值 ------------------------------////#import &lt;UIKit/UIKit.h&gt; // 1.定义代理名(先声明)@class LNModalViewController;@protocol LNModalViewControllerDelegate &lt;NSObject&gt;// 2.定义协议(想要代理做什么事情)- (void)modalViewController:(LNModalViewController *)modalVc sendValue:(NSString *)value;@end@interface LNModalViewController : UIViewController// 3.定义遵守协议的代理@property (nonatomic, strong) id &lt;LNModalViewControllerDelegate&gt;delegate;// LNModalViewController.m- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 4.判断是否执行协议方法（是传值给ViewController） if ([_delegate respondsToSelector:@selector(modalViewController:sendValue:)]) &#123; [_delegate modalViewController:self sendValue:@"白开水ln--我是delegate逆传"]; &#125; [self dismissViewControllerAnimated:YES completion:nil];&#125; 示例需求：Block传值 Block在MRC &amp; ARC下的内存管理 面试题1/2面试题1：block是不是一个对象? 答案：是滴谁说的，咱看权威的。 释义为：block是一个OC对象，这意味着它能被添加到集合，比如NSArray、NSDictionary 面试题2：如何判断当前文件是 MRC，还是ARC? 1.dealloc 能否调用super，只有MRC才能调用super 2.能否使用retain，release. 如果能用就是MRC Block内存管理(MRC)MRC了解开发常识： 1.MRC没有strong,weak,局部变量对象就是相当于基本数据类型（基本数据类型放在栈里，代码块结束就销毁）。 2.MRC给成员属性赋值,一定要使用set方法,不能直接访问下划线成员属性赋值. 注解2: 123456789//--------------------------- Block内存管理(MRC) ------------------------------////void(^block)() = ^&#123; NSLog(@"调用block");&#125;;NSLog(@"%@",block); 2017-03-30 20:15:56.054 Block详解[23533:817404] &lt;__NSGlobalBlock__: 0x102080320&gt; 123456789101112//--------------------------- Block内存管理(MRC) ------------------------------//// //static int a = 3;// 静态变量 __block int a = 3;// 还是局部变量 void(^block)() = ^&#123; NSLog(@"调用block%d",a); &#125;; NSLog(@"%@",block); 2016-03-30 20:22:12.458 Block详解[23762:824109] &lt;__NSMallocBlock__: 0x60800005eff0&gt; 123456789//--------------------------- Block内存管理(MRC) ------------------------------////@property (nonatomic, retain) void(^block)();用retain打印输出：2016-03-30 20:31:06.321 Block详解[23953:833320] &lt;__NSMallocBlock__: 0x608000056530&gt;@property (nonatomic, copy) void(^block)();用copy打印输出：2016-03-30 20:34:06.872 Block详解[24033:837243] &lt;__NSGlobalBlock__: 0x10db8b320&gt; 总结以上三段代码 1.只要block没有引用外部局部变量,block放在全局区。 2.只要Block引用外部局部变量,block放在栈里面。 3.block只能使用copy,不能使用retain. 原因: 使用retain,block还是在栈里面（代码块结束就销毁），而使用copy，block就在堆里面。 Block内存管理(ARC) ARC：管理原则：只要一个对象没有被强指针修饰就会被销毁，默认局部变量对象都是强指针，存放到堆里面。 ARC：管理block 1.只要block引用外部局部变量，block放在堆里面。 2.block使用strong，最好不要使用copy（没有必须进行copy内部其它操作）。 3.思考：为什么block在堆里，也不能用weak来修饰？解答：ARC下,默认局部变量对象都是强指针，block指针强引用block对象，代码块结束就会释放，所以需要对block对象再进行一次强引用。为什么要对局部变量进行一次强引用，就是为了防止代码块销毁。 注解2： Block循环引用循环引用：我引用你，你也引用，就会造成循环引用，双方都不会被销毁，导致内存泄露问题。 Block 循环引用123456789101112131415//--------------------------- Block循环引用 ------------------------------////@property (nonatomic, strong) void(^block)(); // 这种情况下回造成循环引用 // block造成循环问题:Block会对里面所有 强指针变量(如:self) 都强引用一次 _block = ^&#123; NSLog(@"%@",self); &#125;; // 解决防止Block造成循环引用问题,改成弱引用 __weak typeof(self) weakSelf = self; _block = ^&#123; NSLog(@"%@",weakSelf); &#125;; 12345678910111213141516171819202122232425//--------------------------- Block循环引用进阶(三方框架中学习) ------------------------------////// 需求:Block里面要访问控制器对象做些事情，这时如果Block内部有延迟操作，可能就已经销毁，就会拿不到控制器对象。// 解决:需要再强引用来防止对象的销毁__weak typeof(self) weakSelf = self;_block = ^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 这里的block 和外面的block不是同一个. NSLog(@"%@",strongSelf); &#125;);&#125;;_block();// 调用/** 内部代码块,使用weakSelf 打印输出 2016-03-31 00:15:08.861 Block详解[25029:875491] ModalViewController销毁 2016-03-31 00:15:09.835 Block详解[25029:875491] (null) 内部代码块,使用strongSelf 打印输出 2016-03-31 00:18:47.966 Block详解[25117:877961] &lt;ModalViewController: 0x7f89f0c07030&gt; 2016-03-31 00:18:47.966 Block详解[25117:877961] ModalViewController销毁 */ 附图注解： Block变量传递1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; int a = 3; void(^block1)() = ^&#123; NSLog(@"block1--%d",a); // a为3 &#125;; a = 5;// 改变a的值 block1(); // 调用&#125; 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; __block int b = 3; void(^block2)() = ^&#123; NSLog(@"block2--%d",b); // a为5 &#125;; b = 5;// 改变a的值 block2(); // 调用&#125; 总结： 如果是局部变量，Block是值传递（外面修改不影响里面） 。 如果是static静态变量,int全局变量,__block修饰的变量,block都是指针传递（外面的修改影响block里面的值）。 开发使用场景：Block当参数使用 1.怎么区分参数是block,就看有没有^,只要有^.把block当做参数 2.把block当做参数,并不是马上就调用Block,什么时候调用,由方法内部决定 3.什么时候需要把block当做参数去使用：做的事情由外界(非本类)决定,但是什么时候做由内部决定。就如:UIView动画 示例需求：封装一个计算器，提供一个计算方法，怎么计算由外界决定，什么时候计算由内部决定. 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; // 创建计算器管理者 LNCacultorManager *mgr = [[LNCacultorManager alloc] init]; [mgr cacultor:^(NSInteger result)&#123; result += 5; result += 6; result *= 2; return result; &#125;]; NSLog(@"%ld",mgr.result); &#125; 1234567891011// LNCacultorManager.h/** 保存计算的值 */@property (nonatomic, assign) NSInteger result;/** 计算 */- (void)cacultor:(NSInteger(^)(NSInteger result))cacultorBlock;- (void)cacultor:(NSInteger (^)(NSInteger))cacultorBlock &#123; if (cacultorBlock) &#123; _result = cacultorBlock(_result); &#125;&#125; 开发使用场景：Block当返回值 这里体现了一种思想：链式编程思想：把所有的语句用.号连接起来, 好处:可读性非常好。 把Block当返回值使用，经典框架 messay 示例需求：封装一个计算器，提供一个加号方法。 123456- (void(^)())test &#123; return ^&#123; NSLog(@"调用了block"); &#125;;&#125;self.test(); 总结：self.test(); 发两步：1、self.test是调用get方法，返回一个block，2、self.test()调用block。 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; CalculatorManager *mgr = [[CalculatorManager alloc] init]; /** 方式三：+ 5（欣赏） mgr.add(5).add(5).add(5).add(5).add(5).add(5) 方式二：+ 5（可读性差） [[[[[mgr add:5] add:5] add:5] add:6] add:7]; 方式一：+ 5（可读性差） [mgr add:5]; [mgr add:5]; [mgr add:5]; */ mgr.add(5).add(5).add(5).add(5).add(5); NSLog(@"%d",mgr.result);&#125; 总结：mgr.add调用get方法返回一个block，mgr.add(5)调用的block是参数为5，mgr.add(5).add(5)需要返回mgr对象才可以一直.add调用下去。 block的分类（栈、堆、全局区） block 块的存储位置（block入口的地址）可能存放在3个地方：代码区（全局区）、堆区、栈区（ARC情况下回自动拷贝到堆区、因此ARC下只有两个地方：代码区和堆区）。 NSStackBlock：栈 特点：生命周期由系统控制，函数返回即销毁用到局部变量、成员属性\变量，且没有强指针引用的block都是栈block。 NSMallocBlock：堆 特点：没有强指针引用即销毁，生命周期由程序员手动管理栈block如果有强指针引用或copy修饰的成员属性引用就会被拷贝到堆中，变成堆block。 NSGlobalBlock：全局区特点：生命期长（应用程序在它就在）没有用到外界变量，或者只用到全局变量、静态(static)变量的block就是全局block。 Block底层实现 这里参考了 iOS音视频 block是一个指针结构体，在终端下使用LLVM编译器的clang命令可将含有Block的Objective-C代码转换成C++的源代码，以探查其具体实现方式：1clang -rewrite-objc 源码文件名 创建一个OS X 工程，写一个最简单的block 1234567891011#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; void (^myblock)() = ^() &#123; NSLog(@"hello block"); &#125;; myblock(); &#125; return 0;&#125; 利用终端编译生成C++代码：clang -rewrite-objc main.m 几个重要的结构体和函数简介： __block_impl：这是一个结构体，也是C面向对象的体现，可以理解为block的基类; __main_block_impl_0: 可以理解为block变量; __main_block_func_0: 可以理解为匿名函数； __main_block_desc_0: block的描述,Block_size; 注意点：block容易造成循环引用，在block里面如果使用了self，然后形成强引用时，需要打断循环引用；在MRC下用_block，在ARC下使用__weak; Block效果图 附上总结写的小样 Demo，重要的部分代码中都有相应的注解和文字打印，运行程序可以很直观的表现，可否点个 Star 期待 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS·官方译文 & 源码注解]]></title>
    <url>%2FAppleTranslation%2FAppleGitHub.html</url>
    <content type="text"><![CDATA[对你有新思想 或是 习惯 ！ 今日更新、今日更新、今日更新 Reading the best source||system files, Excellent design ideas are timeless, Give us a lot of reference and enlightenment to coding in the future, I enjoy sharing @码员白开水ln 。 阅读源码 || 系统文件，不仅能使我们了解作者的功能实现方式，方便我们运用其功能，快速的fix使用中遇到的bug，更重要的是在阅读优秀源码时体会作者的设计思想和架构设计，具体的技术很快就会过时，优秀的设计思想却会历久弥新，给我们今后编码以很大的借鉴和启迪。向优秀的开源者致敬 ！ 向优秀的分享者致敬 ！Two of my idea @码员白开水ln 。 【@码员真爱 : 真的不点进去阅读一下 ❓】【译文 &amp; 源码】 【工具类】 Content progress非官方 &amp; 非大牛 &amp; 非符合 ——&gt; 只是一帮有思想的伐码猿 ——&gt; 不准确 &amp; 新思想 &amp; 槽槽点 ——&gt; (参考)欢迎你的槽点 || 补充 ！【招募】 不管谁的博客上面写的文章(也包括自己)，阅读的你要敢于去验证，停止无意义的 ⏹copy paste。 工具插件安装+问题解决+活用 iOS 源代码管理「SVN &amp; Git」续更。 iOS 管理库工具CocoaPods「安装+问题解决+活用」续更。 Markdown—写作便捷高效。 Mac&amp;Xcode「实用快捷键」续更。 蛋疼一刻：开发神注释大全 iOS 伐码猿真爱—「偷懒 || 效率 工具类」 iOS 伐码猿自检—「Masonry约束」 感悟职场 学习整理 时间&amp;知识 管理。 老司机带你学习千份技术简历的秘籍【更方便的阅读视角】。 开源技术嘉年华「夜聊」社区，邀你加入 Hexo·博客搭建 学习整理 Hexo(Pages)—博客搭建同步GitHub&amp;Coding GitHubPages + Hexo—详解博客搭建。 Hexo文章简单加密访问 码员熟知 runtime-runloop iOS模式详解—「runtime面试、工作」看我就 了 ^_^. iOS 模式详解—「Runloop面试、工作」看我就 🐒 了 ^_^. iOS模块详解（部分示例，更多文章请订阅博客Rss获取） iOS 模式详解—「KVC编码 &amp; KVO监听」 iOS 多线程模块分解—「GCD中枢调度器」 iOS 网络请求—「NSURLSession会话」 iOS 数据安全—「加密解密」 //————————— 【Apple官方译文 学习整理】 ——————————// // 【从 NSURLConnection 到 NSURLSession】✔️【官方文档】 https://www.objc.io/issues/5-ios7/from-nsurlconnection-to-nsurlsession/【博客译文】https://githubidea.github.io/AppleTranslation/ConnectionToSession.html 【NSURLSession译文】✔️【官方文档】https://developer.apple.com/reference/foundation/urlsession#//apple_ref/occ/clm/NSURLSession/sharedSession【博客译文】https://githubidea.github.io/AppleTranslation/NSURLSessionApple.html 【UIWebView译文】✔️【官方文档】https://developer.apple.com/reference/uikit/uiwebview【博客译文】https://githubidea.github.io/AppleTranslation/UIWebViewApple.html 【UIBezierPath译文】✔️【官方文档】https://developer.apple.com/reference/uikit/uibezierpath?language=objc【博客译文】https://githubidea.github.io/AppleTranslation/UIBezierPathApple.html 【UIView API 官方文档译文】✔️【官方文档】https://developer.apple.com/reference/uikit/uiview?language=objc【博客译文】https://githubidea.github.io/AppleTranslation/UIViewApple.html 【iOS RunLoop 编程手册 （译）】✔️【官方文档】https://developer.apple.com/reference/foundation/runloop【博客译文】http://www.jianshu.com/p/4c38d16a29f1 【Podfile语法参考（译）】✔️【官方文档】https://guides.cocoapods.org/syntax/podfile.html【博客译文】http://www.jianshu.com/p/8af475c4f717 【iOS自动布局框架-Masonry详解】✔️【官方文档】【博客译文】http://www.jianshu.com/p/ea74b230c70d 【OC_runtime运行时官方文档翻译】✔️【官方文档】https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048【博客译文】http://blog.csdn.net/liangliang103377/article/details/39007683 【苹果文档翻译 iOS10 NSAppTransportSecurity】✔️【官方文档】https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW34【博客译文】http://www.jianshu.com/p/1ec3fa1ec00f 【iOS 9设计规范 中文版 完整版】✔️【官方文档】【博客译文】http://www.jianshu.com/p/fbdd713eb2ce 【iOS 10设计规范笔记与整理】✔️【官方文档】【博客译文】http://www.pmcaff.com/article/index/514586365192320?from=label&amp;pmc_param[label_name]=发现 【Stack Overflow 2017 开发者调查报告】✔️【官方文档】https://insights.stackoverflow.com/survey/2017#technology-most-loved-dreaded-and-wanted-languages【博客译文】https://www.oschina.net/news/83164/stack-overflow-developer-survey-results-2017 【Swift 4 JSON 解析指南】✔️【官方文档】【博客译文】http://bignerdcoding.com/archives/37.html //————————— 【三方框架 学习整理】 ——————————// // 【AFNetworking（v3.0+）框架结构】✔️【三方框架】https://github.com/AFNetworking/AFNetworking【博客注解】https://githubidea.github.io/SourceAnnotations/AFNLibraryStructure.html 【AFNetworking（v3.0+）内部逻辑处理过程】✔️【三方框架】https://github.com/AFNetworking/AFNetworking【博客注解】https://githubidea.github.io/SourceAnnotations/AFNLibraryProcessingLogic.html 【SDWebImage框架&amp;源码学习总结】✔️【三方框架】https://github.com/rs/SDWebImage【博客注解】https://githubidea.github.io/SourceAnnotations/SDLibrary.html【博客注解】https://githubidea.github.io/SourceAnnotations/SDSourceCode1.html 【MJExtension框架学习总结】✔️【三方框架】https://github.com/CoderMJLee/MJExtension【博客注解】https://githubidea.github.io/SourceAnnotations/MJExtensionLibrary.html 【VVeboTableView源码解析】✔️【三方框架】https://github.com/johnil/VVeboTableViewDemo【博客注解】http://www.jianshu.com/p/78027a3a2c41 【MJRefresh解析与详细使用指导】✔️【三方框架】https://github.com/CoderMJLee/MJRefresh【博客注解】http://www.jianshu.com/p/4ea427bab0af【博客注解】http://www.jianshu.com/p/437095c88717 【iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Connect篇)】✔️【三方框架】【博客注解】http://www.jianshu.com/p/0a11b2d0f4ae 【Masonry 源码解析】✔️【三方框架】https://github.com/SnapKit/Masonry【博客注解】http://www.jianshu.com/p/3fce11e370b1 【基于AFNetworking3.1的二次封装和拓展】✔️【三方框架】【博客注解】http://www.jianshu.com/p/d0751b9a8d65【博客注解】http://www.jianshu.com/p/cca7656ac41e //————————— 【Objective C-SourceAnnotation】 ——————————// // 【AFNetworking-3.1.0】✔️ 网络请求; 库原地址: 向优秀的开源者致敬 ! https://github.com/AFNetworking/AFNetworking【源码注解】待注解持续 +【工具类】待工具类持续 + 【SDWebImage-3.7.5】✔️ 图片下载; 库原地址: 向优秀的开源者致敬 ! https://github.com/rs/SDWebImage【源码注解】待注解持续 +【工具类】待工具类持续 + 【MBProgressHUD-】✔️ 进度提示; 库原地址: 向优秀的开源者致敬 ! https://github.com/rs/SDWebImage【源码注解】待注解持续 +【工具类】待工具类持续 + 【MJRefresh-3.1.12】✔️ 刷新; 库原地址: 向优秀的开源者致敬 ! https://github.com/CoderMJLee/MJRefresh【源码注解】待注解持续 +【工具类】待工具类持续 + 【MJExtension-3.0.13】✔️ 字典转模型; 库原地址: 向优秀的开源者致敬 ! https://github.com/CoderMJLee/MJExtension【源码注解】待注解持续 +【工具类】待工具类持续 + 【SVProgressHUD-2.1.2】✔️ 进度提示; 库原地址: 向优秀的开源者致敬 ! https://github.com/SVProgressHUD/SVProgressHUD【源码注解】待注解持续 +【工具类】待工具类持续 + //————————— 【Swift-SourceAnnotation】 ——————————//// 【SwiftyJSON-3.1.4】✔️ Swift界JSON解析之王; 库原地址: 向优秀的开源者致敬 ! https://github.com/SwiftyJSON/SwiftyJSON【源码注解】待 +【工具类】待 + 【DZNEmptyDataSet-1.8.1】✔️ 避免空白UITableView; 库原地址: 向优秀的开源者致敬 ! https://github.com/dzenbot/DZNEmptyDataSet【源码注解】待 +【工具类】待 + //————————— 【学习资源 学习整理】 ——————————// // “摘录于”: https://github.com/zhouhuanqiang/LearningIOS 地址 简介 objc中国 为中国 Objective-C 社区带来最佳实践和先进技术 NSHipster中文版 NSHipster 关注被忽略的 Objective-C、Swift 和 Cocoa 特性。每周更新。 iOS Dev Weekly 如果你是老手精通英文，那么这个周刊是非常值得推荐订阅的，该周刊提供行业新闻、最新开发动态、开发工具、代码分享、UI设计、设计师招聘等丰富的资源。 Shinobicontrols The latest technical blog posts iOS Developer Tips Code, tips and tricks for iOS developers Raywenderlich 国外iOS视频教程网站 trip-to-iOS 6000多个star的iOS学习资料整理 SwiftGuide 这份指南汇集了Swift语言主流学习资源，接近1W的star TimLiu-iOS 4000多个star，iOS、mac开源项目及库 skill-map IT技术领域（云计算，大数据，运维，安全，开发语言，智能硬件等）及互联网产品、运营等领域学习技能图谱 全球移动技术大会2016 全球移动技术大会2016PPT下载合集 atswift-2016-resources 2016中国Swift开发者大会源文件，包括keynote, pdf 和源工程文件 全球移动技术大会2017 全球移动技术大会2017PPT下载合集 //————————— 【开源项目源码 学习整理】 ——————————//// 地址 简介 iOS-Source-Code-Analyze 收集了优秀的iOS开源框架源代码解析文章，强烈推荐 Yep 社交IM软件YEP，star5000+ TeamTalk 蘑菇街开源IM，star4500+ MessageDisplayKit 类似微信的IMapp，可发送图片，音频，视频，文字，位置信息等，star3800+ 仿网易新闻 star3000+ 高仿城觅 star1800+ YoCelsius 天气预报的应用，动画和交互非常丰富，star2300+ Coding-iOS Coding iOS 客户端源代码, star2600+ v2ex v2ex.com客户端，star1700+ 高仿微信 star2000+ 高仿美团 star1500+ 高仿喵播APP 视频直播项目，star2000+ 高仿Bilibili客户端 star2000+ 高仿最美应用 swift, star800+ 一个 《一个》 iOS 客户端, star600+ CocoaChina+ 开源的第三方CocoaChina移动端, star600+ 高仿百度糯米 star500+ Four 一个上线的任务记录app，star300+ PHPHub客户端 star1100+ 高仿美团1 star500+ 高仿美团2 star400+ 高仿城觅 star1800+ SegmentFault客户端 star1200+ 网易新闻 star3000+ //————————— 【优秀Blog 学习整理】 ——————————// // “同步于”: https://github.com/tangqiaoboy/iOSBlogCN 博客地址 RSS地址 Plain boiled water 无耻的写上 http://www.jianshu.com/u/fd745d76c816 OneV’s Den http://onevcat.com/atom.xml 一只魔法师的工坊 http://blog.ibireme.com/feed/ 破船之家 http://beyondvincent.com/atom.xml NSHipster http://nshipster.cn/feed.xml Limboy 无网不剩 http://feeds.feedburner.com/lzyy 唐巧的技术博客 http://blog.devtang.com/atom.xml Ted’s Homepage http://wufawei.com/feed sunnyxx的技术博客 http://blog.sunnyxx.com/atom.xml Kevin Blog http://zhowkev.in/rss 阿毛的蛋疼地 http://www.xiangwangfeng.com/atom.xml 亚庆的 Blog http://billwang1990.github.io/atom.xml Nonomori http://nonomori.farbox.com/feed Wonderffee’s Blog http://wonderffee.github.io/atom.xml I’m TualatriX http://imtx.me/feed/latest/ Cocoabit http://blog.cocoabit.com/rss/ 不会开机的男孩 http://studentdeng.github.io/atom.xml Nico http://blog.inico.me/atom.xml 阿峰的技术窝窝 http://hufeng825.github.io/atom.xml answer_huang http://answerhuang.duapp.com/index.php/feed/ webfrogs http://blog.nswebfrog.com/feed/ 代码手工艺人 http://joeyio.com/atom.xml Lancy’s Blog http://gracelancy.com/atom.xml I’m Allen http://www.imallen.com/atom.xml Travis’ Blog http://imi.im/feed 王中周的技术博客 http://wangzz.github.io/atom.xml 克伟的博客 http://feed.cnblogs.com/blog/u/23857/rss 摇滚诗人 http://feed.cnblogs.com/blog/u/35410/rss Luke’s Homepage http://geeklu.com/feed/ 萧宸宇 http://iiiyu.com/atom.xml Yuan博客 http://www.heyuan110.com/?feed=rss2 KooFrank’s Blog http://koofrank.com/rss hello it works http://helloitworks.com/feed 码农人生 http://msching.github.io/atom.xml 玉令天下的Blog http://yulingtianxia.com/atom.xml 不掏蜂窝的熊 http://www.hotobear.com/?feed=rss2 猫·仁波切 https://andelf.github.io/atom.xml 煲仔饭 http://ivoryxiong.org/feed.xml 里脊串的开发随笔 http://adad184.com/atom.xml Why’s blog - 汪海的实验室 http://blog.callmewhy.com/atom.xml 土土哥的技术Blog http://tutuge.me/atom.xml 庞海礁的个人空间 http://www.olinone.com/?feed=rss2 Casa Taloyum http://casatwy.com/feeds/all.atom.xml Kenshin Cui’s Blog http://www.cnblogs.com/kenshincui/rss 技术哥的博客 http://suenblog.duapp.com/rss/ 老谭笔记 http://www.tanhao.me/atom.xml coderyi http://www.coderyi.com/feed 雷纯锋的技术博客 http://blog.leichunfeng.com/atom.xml 向晨宇的技术博客 http://iosxxx.com/atom.xml 学习一门三方框架库的时侯，需要追根溯源，才好提纲切领，即能掌握全局，又能深入细节。从源码出发，结合事件业务逻辑处理的机制，再深入到各个功能点或再次封装，就会胸有成竹而不乱阵脚了。 Reading 如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。 对该模块我会 不定时、持续、更新一些 学习心得与文章、实用才是硬道理 ^_^. 。 点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。 未完 待续 每周 更新 About me【Plain boiled water ln - Code Member】]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>源码</tag>
      </tags>
  </entry>
</search>