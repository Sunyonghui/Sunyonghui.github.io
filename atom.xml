<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录寄己走过的路</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunyonghui.github.io/"/>
  <updated>2017-09-04T06:13:16.000Z</updated>
  <id>https://sunyonghui.github.io/</id>
  
  <author>
    <name>寄己的路</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AFNetworking3.1—内部逻辑处理过程</title>
    <link href="https://sunyonghui.github.io/SourceAnnotations/AFNLibraryProcessingLogic.html"/>
    <id>https://sunyonghui.github.io/SourceAnnotations/AFNLibraryProcessingLogic.html</id>
    <published>2017-07-09T16:00:00.000Z</published>
    <updated>2017-09-04T06:13:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h4><hr>
<p><strong>AFNetWorking</strong> 基本是iOS开发中使用网络通信框架的标配，这个框架本身比较庞大，也很复杂，但是使用起来非常非常简单。</p>
<p>本篇文章主要从【AFN 内部逻辑处理过程】以Get请求为例，学习总结，<br>在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-52f44551d97d1941.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" AFNetworking"></p>
<blockquote>
<p>目录：</p>
<ol>
<li>AFN GET内部逻辑处理</li>
<li>AFN POST内部逻辑处理</li>
<li>总结</li>
<li>后续【AFN 框架 | 源码 学习总结】</li>
</ol>
</blockquote>
<h4 id="Business-logic【AFN-GET-内部逻辑处理】"><a href="#Business-logic【AFN-GET-内部逻辑处理】" class="headerlink" title="Business logic【AFN GET 内部逻辑处理】"></a>Business logic【AFN GET 内部逻辑处理】</h4><hr>
<p>这是 AFNetworking 发起一个 Get 请求的流程图，大概可以分为这几个步骤，下面会逐个解读这个流程。<br><img src="http://upload-images.jianshu.io/upload_images/2230763-50cd9ac10597d305.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFN--&gt;GET业务逻辑处理.png"></p>
<h4 id="1-AFHTTPSessionManager-发起GET请求"><a href="#1-AFHTTPSessionManager-发起GET请求" class="headerlink" title="1. AFHTTPSessionManager 发起GET请求"></a>1. AFHTTPSessionManager 发起GET请求</h4><p><img src="http://upload-images.jianshu.io/upload_images/2230763-ce63bee95c1191a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="manager--&gt;GET请求"></p>
<p>这个方法是 AFN 的 Get请求 的起点，其他 Get 请求的方法也都是直接或者间接调用这个方法来发起 Get 请求。这个方法的代码量很少也很直观，就是调用其他方法生成 <code>NSURLSessionDataTask</code>对象的实例，然后调用 <code>NSURLSessionDataTask</code> 的 <code>resume</code> 方法发起请求。</p>
<h4 id="2-创建-NSURLSessionDataTask"><a href="#2-创建-NSURLSessionDataTask" class="headerlink" title="2. 创建 NSURLSessionDataTask"></a>2. 创建 NSURLSessionDataTask</h4><p><img src="http://upload-images.jianshu.io/upload_images/2230763-5283f20a36d3446e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建--&gt;NSURLSessionDataTask"></p>
<p>这个方法是创建 <code>NSURLSessionDataTask</code> 对象实例并返回这个实例。首先创建一个 <code>NSMutableURLRequest</code> 对象的实例，然后配置。之后是使用 <code>NSMutableURLRequest</code> 对象的实例创建<code>NSURLSessionDataTask</code> 对象实例，然后配置，可以选择性地传入各类<code>Block</code>回调，用于监听网络请求的进度比如上传进度，下载进度，请求成功，请求失败。</p>
<h4 id="3-配置-NSMutableURLRequest对象"><a href="#3-配置-NSMutableURLRequest对象" class="headerlink" title="3. 配置 NSMutableURLRequest对象"></a>3. 配置 NSMutableURLRequest对象</h4><p><img src="http://upload-images.jianshu.io/upload_images/2230763-e08acd0c3f8ddc99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置--&gt;NSMutableURLRequest对象"></p>
<p>在这个方法中先使用了 url 创建了一个 <code>NSMutableURLRequest</code> 对象的实例,并且设置了 <code>HTTPMethod</code> 为 <code>Get</code> 方法（如果是Post方法，那么这里就是设置Post方法）然后使用KVC的方法设置了 <code>NSMutableURLRequest</code> 的一些属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置 NSMutableURLRequest 的属性</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFHTTPRequestSerializerObservedKeyPaths() &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSArray</span> *_AFHTTPRequestSerializerObservedKeyPaths = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        <span class="comment">//allowsCellularAccess 允许使用数据流量</span></div><div class="line">        <span class="comment">//cachePolicy 缓存策略</span></div><div class="line">        <span class="comment">//HTTPShouldHandleCookies 处理Cookie</span></div><div class="line">        <span class="comment">//HTTPShouldUsePipelining 批量请求</span></div><div class="line">        <span class="comment">//networkServiceType 网络状态</span></div><div class="line">        <span class="comment">//timeoutInterval 超时</span></div><div class="line">        _AFHTTPRequestSerializerObservedKeyPaths = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowsCellularAccess)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(cachePolicy)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldHandleCookies)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldUsePipelining)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(networkServiceType)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(timeoutInterval))];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> _AFHTTPRequestSerializerObservedKeyPaths;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-60291964bad44b91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置--&gt;NSMutableURLRequest对象"><br>先设置 HTTP header，之后格式化请求参数，设置参数的编码类型。这个是这个方法的基本操作流程。对于Get操作来说，参数是直接拼接在请求地址后面。</p>
<h4 id="4-配置-NSURLSessionDataTask对象"><a href="#4-配置-NSURLSessionDataTask对象" class="headerlink" title="4. 配置 NSURLSessionDataTask对象"></a>4. 配置 NSURLSessionDataTask对象</h4><p><img src="http://upload-images.jianshu.io/upload_images/2230763-b23c86c80e838520.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置--&gt;NSURLSessionDataTask对象"></p>
<p>之后配置 <code>NSMutableURLRequest</code> 对象就需要配置 <code>NSURLSessionDataTask</code> 对象了。主要分为2个步骤，第一个步骤是创建 <code>NSURLSessionDataTask</code> 对象实例，第二个步骤是给<code>NSURLSessionDataTask</code> 对象实例设置 <code>Delegate</code>。用于实时了解网络请求的过程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-457c5cdc1218d891.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="给NSURLSessionDataTask对象实例设置Delegate.png"></p>
<p>AFN 的代理统一使用 <code>AFURLSessionManagerTaskDelegate</code> 对象来管理，使用 <code>AFURLSessionManagerTaskDelegate</code> 对象来接管<code>NSURLSessionTask</code> 网络请求过程中的回调，然后再传入 <code>AFN</code> 内部进行管理。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFURLSessionManagerTaskDelegate</span> : <span class="title">NSObject</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>, </span></div><div class="line"><span class="built_in">NSURLSessionDataDelegate</span>, <span class="built_in">NSURLSessionDownloadDelegate</span>&gt;</div></pre></td></tr></table></figure>
<p>如代码所示 <code>AFURLSessionManagerTaskDelegate</code> 接管了<code>NSURLSessionTaskDelegate</code>，<code>NSURLSessionDataDelegate</code>，<code>NSURLSessionDownloadDelegate</code> 的各种回调，然后做内部处理。这也是第三方网络请求框架的重点，让网络请求更加易用，好用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过 task 的标识符管理代理</span></div><div class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</div><div class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSParameterAssert</span>(task);</div><div class="line">    <span class="built_in">NSParameterAssert</span>(delegate);</div><div class="line"></div><div class="line">    [<span class="keyword">self</span>.lock lock];</div><div class="line">    <span class="comment">// 将task和代理类绑定，task的taskIdentifier作为字典的key,delegate作为字典的value</span></div><div class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</div><div class="line">    <span class="comment">// 给该task添加两个KVO事件（Resume 和 Suspend）</span></div><div class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</div><div class="line">    [<span class="keyword">self</span>.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>NSURLSessionTask</code>的<code>taskIdentifier</code>标识符对<code>delegate</code>进行管理，只要是用于识别该<code>NSURLSessionTask</code>的代理。</p>
<hr>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-bf27849f4cfa33ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSURLSessionTask 设置进度回调"><br>设置各类回调 Block,给 NSURLSessionTask 使用 KVO 进行各种过程进度监听。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark -</span></div><div class="line"><span class="comment">// 给task添加暂停和恢复的通知</span></div><div class="line">- (<span class="keyword">void</span>)addNotificationObserverForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>监听 <code>NSURLSessionTask</code> 被挂起 和 恢复的通知。</p>
<hr>
<h4 id="5-网络请求开始"><a href="#5-网络请求开始" class="headerlink" title="5. 网络请求开始"></a>5. 网络请求开始</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 发送GET请求</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> GET: 请求路径(不包含参数),url</div><div class="line"> parameters: 字典(发送给服务器的数据~参数)</div><div class="line"> progress: 进度回调</div><div class="line"> success: 成功回调（task:请求任务、responseObject:响应体信息JSON-&gt;OC对象）</div><div class="line"> failure: 失败回调（error:错误信息）</div><div class="line"> task.response: 响应头</div><div class="line"> */</div><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                   parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                     progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> * _Nonnull))downloadProgress</div><div class="line">                      success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull, <span class="keyword">id</span> _Nullable))success</div><div class="line">                      failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable, <span class="built_in">NSError</span> * _Nonnull))failure</div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"GET"</span></div><div class="line">                                                        URLString:URLString</div><div class="line">                                                       parameters:parameters</div><div class="line">                                                   uploadProgress:<span class="literal">nil</span></div><div class="line">                                                 downloadProgress:downloadProgress</div><div class="line">                                                          success:success</div><div class="line">                                                          failure:failure];</div><div class="line"></div><div class="line">    [dataTask resume];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 <code>NSURLSessionTask</code> 创建和配置完毕之后，它并不会主动执行，而是需要我们主动调用 <code>resume</code> 方法，<code>NSURLSessionTask</code> 才会开始执行。</p>
<h4 id="6-网络请求回调"><a href="#6-网络请求回调" class="headerlink" title="6. 网络请求回调"></a>6. 网络请求回调</h4><p><img src="http://upload-images.jianshu.io/upload_images/2230763-6db56d320d5b1814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSURLSessionDelegate 方法"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-71c4e889d1e81a66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSURLSessionTaskDelegate 方法"></p>
<p>AFN 里面有关 <code>NSURLSessionDelegate</code> 的回调方法非常的多，这里我们只说和 <code>NSURLSessionTask</code> 相关的部分方法和 <code>KVO</code> 处理来进行说明，其他的大家可以参考源码细看。</p>
<hr>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-7eeef076feb91c74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KVO监听请求过程.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-d1e3bd92a9398065.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="收到响应数据.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-a9a82b1054d5fe85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求完成.png"></p>
<p>对于我们的 Get请求 来说，我们最关注的莫过于关注请求过程进度，收到响应数据和请求完成这2个回调。</p>
<p>KVO监听的属性值发生变化：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// KVO监听的属性值发生变化</span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    <span class="keyword">if</span> ([object isKindOfClass:[<span class="built_in">NSURLSessionTask</span> <span class="keyword">class</span>]] || [object isKindOfClass:[<span class="built_in">NSURLSessionDownloadTask</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))]) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"countOfBytesReceived"</span>);</div><div class="line">            <span class="comment">// 这个是在Get请求下，网络响应过程中已经收到的数据量</span></div><div class="line">            <span class="comment">// 已经收到</span></div><div class="line">            <span class="keyword">self</span>.downloadProgress.completedUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))]) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"countOfBytesExpectedToReceive"</span>);</div><div class="line">            <span class="comment">// 这个是在Get请求下，网络响应过程中期待收到的数据量</span></div><div class="line">            <span class="comment">// 期待收到</span></div><div class="line">            <span class="keyword">self</span>.downloadProgress.totalUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))]) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"countOfBytesSent"</span>);</div><div class="line">            <span class="comment">// 已经发送</span></div><div class="line">            <span class="keyword">self</span>.uploadProgress.completedUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))]) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"countOfBytesExpectedToSend"</span>);</div><div class="line">            <span class="comment">// 期待发送</span></div><div class="line">            <span class="keyword">self</span>.uploadProgress.totalUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.downloadProgress]) &#123;</div><div class="line">        <span class="comment">// 下载进度变化</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgressBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.downloadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.uploadProgress]) &#123;</div><div class="line">        <span class="comment">// 上传进度变化</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.uploadProgressBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.uploadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>收到请求响应：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 收到请求响应</span></div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line">          didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</div><div class="line">          completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"收到请求响应"</span>);</div><div class="line">    <span class="comment">// 允许处理服务器的响应，才会继续接收服务器返回的数据</span></div><div class="line">    <span class="built_in">NSURLSessionResponseDisposition</span> disposition = <span class="built_in">NSURLSessionResponseAllow</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 是否有收到请求响应的回调Block</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveResponse) &#123;</div><div class="line">        <span class="comment">// 若有调用该Block</span></div><div class="line">        disposition = <span class="keyword">self</span>.dataTaskDidReceiveResponse(session, dataTask, response);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 是否有请求响应完成的回调Block</span></div><div class="line">    <span class="keyword">if</span> (completionHandler) &#123;</div><div class="line">        <span class="comment">// 若有调用该Block</span></div><div class="line">        completionHandler(disposition);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>请求完成：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 请求完成</span></div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</div><div class="line">              didCompleteWithError:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"请求完成"</span>);</div><div class="line">    <span class="comment">// 取出该NSURLSessionTask的代理对象</span></div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</div><div class="line">    </div><div class="line">    <span class="comment">// delegate may be nil when completing a task in the background</span></div><div class="line">    <span class="keyword">if</span> (delegate) &#123;</div><div class="line">        <span class="comment">// 若是该代理对象存在，那么将对应数据转给该代理对象处理</span></div><div class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</div><div class="line">        <span class="comment">// NSURLSessionTask任务完成之后，移除该NSURLSessionTask的代理对象</span></div><div class="line">        [<span class="keyword">self</span> removeDelegateForTask:task];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 是否有请求完成的回调Block</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidComplete) &#123;</div><div class="line">        <span class="comment">// 若有调用改Block</span></div><div class="line">        <span class="keyword">self</span>.taskDidComplete(session, task, error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为在配置 NSURLSessionDataTask 对象的时候我们有给 NSURLSessionTask 做了一系列配置，那么当 NSURLSessionDataTask 任务完成之后，我们需要将该 NSURLSessionDataTask 的一系列配置全部清理掉。</p>
<p>这个是我们的配置过程：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过task的标识符管理代理</span></div><div class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</div><div class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSParameterAssert</span>(task);</div><div class="line">    <span class="built_in">NSParameterAssert</span>(delegate);</div><div class="line"></div><div class="line">    [<span class="keyword">self</span>.lock lock];</div><div class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</div><div class="line">    [delegate setupProgressForTask:task];</div><div class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</div><div class="line">    [<span class="keyword">self</span>.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么对应的清理过程是这样的，就是设置过程中做了什么，在清理过程中就需要去掉什么。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 给task移除delegate</span></div><div class="line">- (<span class="keyword">void</span>)removeDelegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</div><div class="line">    <span class="built_in">NSParameterAssert</span>(task);</div><div class="line"></div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</div><div class="line">    [<span class="keyword">self</span>.lock lock];</div><div class="line">    [delegate cleanUpProgressForTask:task];</div><div class="line">    [<span class="keyword">self</span> removeNotificationObserverForTask:task];</div><div class="line">    [<span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</div><div class="line">    [<span class="keyword">self</span>.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-81bdec38d280ee1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cleanUpProgressForTask.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-ec45f15cbc7cf786.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="removeNotificationObserverForTask.png"></p>
<h4 id="Business-logic【AFN-POST内部逻辑处理】"><a href="#Business-logic【AFN-POST内部逻辑处理】" class="headerlink" title="Business logic【AFN POST内部逻辑处理】"></a>Business logic【AFN POST内部逻辑处理】</h4><hr>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-ecb59ae9e6d82be3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求序列化方法"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - AFURLRequestSerialization</span></div><div class="line"><span class="comment">// 设置Header和请求参数</span></div><div class="line">- (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                               withParameters:(<span class="keyword">id</span>)parameters</div><div class="line">                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSParameterAssert</span>(request);</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</div><div class="line">    [<span class="keyword">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> field, <span class="keyword">id</span> value, <span class="built_in">BOOL</span> * __unused stop) &#123;</div><div class="line">        <span class="comment">// 判断header的field是否存在,如果不存在则设置，存在则跳过</span></div><div class="line">        <span class="keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;</div><div class="line">            <span class="comment">// 设置 header</span></div><div class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *query = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> (parameters) &#123;</div><div class="line">        <span class="comment">// 用传进来的自定义block格式化请求参数</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.queryStringSerialization) &#123;</div><div class="line">            <span class="built_in">NSError</span> *serializationError;</div><div class="line">            query = <span class="keyword">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);</div><div class="line">            <span class="keyword">if</span> (serializationError) &#123;</div><div class="line">                <span class="keyword">if</span> (error) &#123;</div><div class="line">                    *error = serializationError;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">switch</span> (<span class="keyword">self</span>.queryStringSerializationStyle) &#123;</div><div class="line">                <span class="keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:</div><div class="line">                    <span class="comment">// 默认的格式化方式</span></div><div class="line">                    query = AFQueryStringFromParameters(parameters);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 判断是否是GET/HEAD/DELETE方法， 对于GET/HEAD/DELETE方法，把参数加到URL后面</span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</div><div class="line">        <span class="comment">// 判断是否有参数</span></div><div class="line">        <span class="keyword">if</span> (query &amp;&amp; query.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 拼接请求参数</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"query--&gt;%@"</span>,query);</div><div class="line">            mutableRequest.URL = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="string">@"&amp;%@"</span> : <span class="string">@"?%@"</span>, query]];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></div><div class="line">        <span class="keyword">if</span> (!query) &#123;</div><div class="line">            query = <span class="string">@""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 参数带在body上，大多是POST PUT</span></div><div class="line">        <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@"Content-Type"</span>]) &#123;</div><div class="line">            <span class="comment">// 设置Content-Type HTTP头，告诉服务端body的参数编码类型</span></div><div class="line">            [mutableRequest setValue:<span class="string">@"application/x-www-form-urlencoded"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</div><div class="line">        &#125;</div><div class="line">        [mutableRequest setHTTPBody:[query  dataUsingEncoding:<span class="keyword">self</span>.stringEncoding]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是 Post 请求，那么请求参数是没有拼接在 URL 上面，而是放在 <code>body</code> 上，这是 Post 和 Get 请求的最大区别了，其他过程和Get 请求并没有太多区别。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>AFN发起Get请求主要分为以下步骤：</p>
<ul>
<li><p>1.创建<code>NSURLSessionDataTask</code></p>
</li>
<li><p>2.配置<code>NSURLSessionDataTask</code></p>
</li>
<li><p>3.设置<code>NSURLSessionDataTask的Delegate</code></p>
</li>
<li><p>4.调用<code>NSURLSessionDataTask</code>的<code>resume</code>方法开始请求</p>
</li>
<li><p>5.在<code>Delegate</code>的方法里面处理网络请求的各个过程</p>
</li>
<li><p>6.清理<code>NSURLSessionDataTask</code>的配置</p>
</li>
</ul>
<p>其实也就是使用 <code>NSURLSessionDataTask</code> 的步骤，AFN在这几个步骤加了一些封装，让我们的使用更简单。</p>
<p><a href="http://www.jianshu.com/p/c36159094e24" target="_blank" rel="external">转载原著</a></p>
<h4 id="期待"><a href="#期待" class="headerlink" title="期待"></a>期待</h4><hr>
<ul>
<li>如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。</li>
</ul>
<ul>
<li>点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;引导&quot;&gt;&lt;a href=&quot;#引导&quot; class=&quot;headerlink&quot; title=&quot;引导&quot;&gt;&lt;/a&gt;引导&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;AFNetWorking&lt;/strong&gt; 基本是iOS开发中使用网络通信框架的标配，这个框架本身比较庞大，也很复
    
    </summary>
    
      <category term="源码" scheme="https://sunyonghui.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="https://sunyonghui.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>时间和知识管理经验</title>
    <link href="https://sunyonghui.github.io/PerceptionWork/TimeManagement.html"/>
    <id>https://sunyonghui.github.io/PerceptionWork/TimeManagement.html</id>
    <published>2017-06-12T16:00:00.000Z</published>
    <updated>2017-08-18T09:16:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>转自 weekly 维护作者:<a href="https://github.com/zenany/zenany.github.io/blob/master/_posts/about_time_and_knowledge_management.md" target="_blank" rel="external">About Time and Knowledge Management</a></p>
<p>关于时间管理和知识管理这两个话题，我见过最好的一个总结是：</p>
<blockquote>
<p>此生理想、近期计划、今日功课</p>
</blockquote>
<p>这是马英九的父亲马鹤凌为马英九制定的人生规划解决之道，是从我的师傅 nwind 的一场培训 <a href="https://speakerdeck.com/baidufe/gong-cheng-shi-de-ge-ren-fa-zhan-gui-hua" target="_blank" rel="external">工程师的个人发展规划</a> 中学到的。总结的很完美，但实践起来坑很多。分享一些我的实践经验，以及 <a href="https://github.com/zenany/weekly" target="_blank" rel="external">Weekly</a> 是怎么整理的。</p>
<h4 id="此生理想"><a href="#此生理想" class="headerlink" title="此生理想"></a>此生理想</h4><p>很多关于时间管理和知识管理的书最后都会指向这点：<strong>你的理想是什么，你想成为什么样的人，你想要的生活是什么样的</strong>。因为只有搞清楚这点，时间和知识管理才是最高效的。拥有理想看起来很美好，然而现实是：<strong>大多数人当下并没有真正想清楚自己的理想是什么</strong>，有可能是在年龄很大时才找到属于自己理想。有时候，我们貌似有了一个理想或梦想，但行动往往会出卖我们，暴露出真相并非如此。</p>
<p>所以，我的实践变成了：<strong>不刻意去追寻理想，活在当下</strong>。做好这几件事：</p>
<ul>
<li><p>专注于：解决问题+知识积累，这两件事可以保证知识和技能始总是提升的。不管最终理想是什么，知识和技能最后都会发挥作用。在解决问题的过程中，也会展现个人价值。</p>
</li>
<li><p>不要给自己设限，认定自己不能做什么，勇于尝试各种可能，逐步排除掉什么不是自己想要的。</p>
</li>
</ul>
<h4 id="近期计划"><a href="#近期计划" class="headerlink" title="近期计划"></a>近期计划</h4><p>请注意：是“近期”而非“远期”，是“计划”而非“规划”。这一点，在理想的驱使下，很容易错误地被实践成长远规划。按我的经验：1 年内的计划比较容易可控，超过 1 年的变数太多，只能当做远景来确定方向。</p>
<p>我的实践是：<strong>踏歌而行，踩着节拍往前走</strong>。保持节奏可以让我们的工作和学习有序前行，避免迷失方向。我通常这样做：</p>
<ul>
<li><p>按 <code>年 -&gt; 月 -&gt; 周</code> 这样的自然节奏进行，在上一个时间周期结束时确定下一个周期的事，比如：春节期间想好下一年的，每月初想好下月的事情，每周写周报或周末空闲时时想好下周要做的事，周末闲暇时间 &amp; 每天在路上想好每件事大致怎么做。所以在工作时，我往往只需执行。</p>
</li>
<li><p>不迷恋于各种日程及时间管理工具，用心记，当一周事情特别多时，用纸+笔</p>
</li>
</ul>
<h4 id="今日功课"><a href="#今日功课" class="headerlink" title="今日功课"></a>今日功课</h4><p>关于这点，我想分享一个我总结出的词汇“可持续性编程”。为什么编程还需要可持续性，因为：一个人的工作生涯会在20 年以上，这是一场长跑。而且，从职业生涯的角度去看问题，会发现一些有意思的东西：</p>
<ul>
<li><p>很多当下的问题根本只是浪花一朵，比如：晋升、绩效、涨薪…</p>
</li>
<li><p>很多看似不可能的东西变得可能，比如：掌握 N 种编程语言、研究清楚浏览器内核、学会一种乐器…</p>
</li>
</ul>
<p>从编程生涯的角度来看，今日功课其实是每日功课，要跑好这场长跑，我觉得这几点很重要：</p>
<ul>
<li><p>给自己一个<strong>安静的环境</strong>，同时省出学习时间</p>
<ul>
<li><p>关掉聊天工具、消息提醒，QQ 我已经变成每 1 周甚至 1月去开一次了，在攻坚时我会不开邮件客户端、旺旺、钉钉</p>
</li>
<li><p>少刷微博、微信、新闻，甚至不看，需要时定期去扫即可，不用担心会漏掉什么，重要的东西总会通过各种渠道传递到你这里的</p>
</li>
<li><p>减少不必要的会议，每个技术交流都是一份非常好的学习机会，可以选择不去，但去了后就全心参与，不看手机、不开电脑，专心获取或输出有效信息</p>
</li>
</ul>
</li>
<li><p><strong>健康的体魄</strong>，没有好身体，怎么写 20 年代码</p>
<ul>
<li><p>工作必须有底线，也不能让自己长期处于高压工作下。我的习惯是：周末尽量不做实体性工作（除非计划有变）；平时不能牺牲吃饭+睡觉时间去赶进度。</p>
</li>
<li><p>适度运动，找到属于自己的一种方式。我会坚持每周去爬山一次，呼吸新鲜空气+思考问题</p>
</li>
</ul>
</li>
<li><p><strong>持续学习的精神</strong>，这点 阮一峰老师 是我们的榜样。要保持持续学习，我觉得这两点非常重要：</p>
<ul>
<li><p>兼容并蓄：不要给技术贴标签，以学习的心态去看待每个技术，了解它们思考和解决问题的方式、实现原理、应用场景，不断丰富自己对编程的认知和解决问题的思路。</p>
</li>
<li><p>格物致知：计算机科学是非常庞大的一门科学，足以支撑我们研究一辈子。前端所接触的，只是技术的冰山一角，还有很多东西需要我们去探索。格物致知能让我们掌握日常使用的技术背后的原理，从而提升掌控复杂的能力。</p>
</li>
</ul>
</li>
</ul>
<h4 id="Weekly-是如何整理的"><a href="#Weekly-是如何整理的" class="headerlink" title="Weekly 是如何整理的"></a>Weekly 是如何整理的</h4><p>很多人会问我这个问题，其实，做这件事的初心很简单：记录自己平时看到的优质资料以备用，完善个人知识库。但由于常常有会把一些特别好的东西分享到群里，就有人建议我可以定期整理这类东西，发给大家。于是 Weekly 就开始了，坚持了好多年。</p>
<p>做这件事，我使用的<strong>工具</strong>是：</p>
<ul>
<li><p>RSS ：Feedly + gReader，离线、在线都能看，上网约等于看 rss</p>
</li>
<li><p>资源汇集地：hn-daily、JavaScript Weekly 等各种 weekly、技术组织官网、Medium、JavaScriptKicks</p>
</li>
<li><p>OneNote：记录感兴趣的文章和资源，比 evernote 快，稳定性、复制 html 的效率和效果、搜索等都更好用</p>
</li>
<li><p>微博：订阅一些喜欢分享资源的人或者组织，其实微博仍然是非常好的一个传播渠道</p>
</li>
</ul>
<hr>
<ul>
<li>微信：<a href="https://mp.weixin.qq.com/s/ukxcdzkA80kgCZeZYqV4nw" target="_blank" rel="external">订阅公众号</a></li>
</ul>
<p><strong>方式</strong>：</p>
<ul>
<li><p>定期看，而非实时关注，一般我会在周三晚上、周六集中扫一遍，筛选出有价值的和感兴趣的，周日汇总并完成整理</p>
</li>
<li><p>零散时间会看 rss 筛选信息，在周末或者晚上空闲时看自己感兴趣的文章</p>
</li>
</ul>
<p><strong>信源</strong>：</p>
<ul>
<li><p>雪球效应：以资源汇集点为起点，逐步收集优质资源来自的 bolg 、技术站点</p>
</li>
<li><p>整理自己感兴趣的知识，逐步形成个人知识库<br>总结</p>
</li>
</ul>
<p>时间管理和知识管理可以围绕这 12 字去探索自己的模式：<strong>此生理想、近期计划、今日功课</strong>。<br>我的习惯和建议是：</p>
<ul>
<li><p>活在当下：专注于解决问题+知识积累；不给自己设限，去尝试未来的各种可能；</p>
</li>
<li><p>踏歌而行，踩着节拍往前走：<code>以 年 -&gt; 月 -&gt; 周</code> 的维度制定计划；用心而非工具管理计划；</p>
</li>
<li><p>可持续编程：安静的环境；健康的体魄；持续学习的精神；</p>
</li>
<li><p>知识管理：从信息汇聚源除非逐步形成自己的知识库；利用零散时间+定期扫的模式收集资源，在业余时间集中阅读</p>
</li>
</ul>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自 weekly 维护作者:&lt;a href=&quot;https://github.com/zenany/zenany.github.io/blob/master/_posts/about_time_and_knowledge_management.md&quot; target=&quot;_bl
    
    </summary>
    
      <category term="职场" scheme="https://sunyonghui.github.io/categories/%E8%81%8C%E5%9C%BA/"/>
    
    
      <category term="职场" scheme="https://sunyonghui.github.io/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>学习技术简历</title>
    <link href="https://sunyonghui.github.io/PerceptionWork/TechnicalResume.html"/>
    <id>https://sunyonghui.github.io/PerceptionWork/TechnicalResume.html</id>
    <published>2017-05-24T16:00:00.000Z</published>
    <updated>2017-08-18T09:16:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>先玩个小游戏，如果你在写简历时也遇到了相同的情况，请打勾：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[ ] 1. 不知道招聘企业最看重什么，学历、技术、还是项目？</td>
</tr>
<tr>
<td style="text-align:left">[ ] 2. 习惯把工作年限写长，比如2016年毕业要写2年工作经验。</td>
</tr>
<tr>
<td style="text-align:left">[ ] 3. Java、Python、C/C++等技能，不管熟不熟，都要写“精通”。</td>
</tr>
<tr>
<td style="text-align:left">[ ] 4. 项目经历、工作经历几笔带过或啰啰嗦嗦。</td>
</tr>
<tr>
<td style="text-align:left">[ ] 5. 觉得技术简历和普通简历没什么区别，照着模板写就好了。</td>
</tr>
<tr>
<td style="text-align:left">[ ] 6. 每次面试官最后说“你有什么要问的吗”，都觉得特别尴尬。</td>
</tr>
</tbody>
</table>
<ul>
<li><p>勾0-1条，请点左上方的叉号，关掉这个页面。</p>
</li>
<li><p>勾2-3条，你之前的简历可能是在自嗨，需要一点解药。</p>
</li>
<li><p>勾4-6条，重度患者，请仔细消化下面的内容。</p>
</li>
</ul>
<p><strong>其实，上面的几种情况，大部分人写简历和求职时都会遇到。</strong></p>
<p>有的人不了解面试官的需求，想把简历写得面面俱到，写完却是毫无重点，且不自知，最终简历石沉大海；</p>
<p>有的人想在简历中呈现更好的自己，不管这个“自己”是不是真实的：把工作年限加长、把技能全写成精通。这种自嗨只能换来面试时的尴尬；</p>
<p>有的人技术强，肯努力，却怀才不遇，找不到一条更有效的渠道，让更多大公司了解到自己，就错过了很多上升机会。其实这也是可以改善的。</p>
<p><strong>这篇文章，就教你如何躲过这些简历中常见的“坑”。</strong>写一份让面试官喜欢、又真实的技术简历。</p>
<p><strong>如果你是在校生，你更该好好看看这篇文章。</strong>它将让你毕业时已经拥有一份最好的技术简历。</p>
<p>（本文内容整理自「 百楼俱乐部技术分享第一期——如何准备技术简历 」，分享人是<strong>实验楼CEO石头山</strong>。</p>
<p>「 百楼俱乐部 」顾名思义，是实验楼100楼以上的用户组成的群体，除了定期的技术分享外，还有其他福利，欢迎大家爬楼加入。）</p>
<hr>
<p>简介<br><strong>分享人：石头山</strong></p>
<p>（实验楼CEO，曾任职于VMware、Intel等知名外企，有9年研发和管理经验，筛选过数千份简历，面试过数百名技术人员，深知简历和面试的“套路”，<strong>将带你从面试官的角度，了解什么样的简历才是受人欢迎的</strong>。）</p>
<hr>
<p>01</p>
<h6 id="“-本文不适合老司机…-”"><a href="#“-本文不适合老司机…-”" class="headerlink" title="“ 本文不适合老司机… ”"></a><del>“ 本文不适合老司机… ”</del></h6><p>今天的话题时如何准备技术简历。我个人因为在技术公司，包括一些外企有过很多经验，所以在这里和大家分享一些想法和经验。</p>
<p>对于这个话题，我们面向的读者是面向互联网行业或软件行业求职的人，而且主要是应届生和毕业三年以内的求职者。因为对于经验丰富的求职者，他们的招聘方式可能会差异非常大。比方说，他对简历的重视程度会越来越低，更多依靠的是行业内的知名度，和公司内部高级工程师的引荐。</p>
<p>因为我个人缺少大型国企、传统行业的经验，所以说这个话题难免不全面，请大家见谅。</p>
<p>02</p>
<h6 id="“-基本信息那么简单吗？”"><a href="#“-基本信息那么简单吗？”" class="headerlink" title="“ 基本信息那么简单吗？”"></a>“ 基本信息那么简单吗？”</h6><p>首先是基本信息，大家肯定都会写到。包括：</p>
<ul>
<li><p>姓名</p>
</li>
<li><p>年龄</p>
</li>
<li><p>工作年限</p>
</li>
<li><p>学历</p>
</li>
<li><p>城市</p>
</li>
<li><p>联系方式：手机 + 邮箱</p>
</li>
</ul>
<p>这里还有几项需要注意的：</p>
<p>首先在基本信息里面，我们会看到，<strong>有很多同学会故意地把自己的工作年限写得很长</strong>。比如16年毕业，自己会选择性地写成两年甚至三年的工作经验。我要讲的是，这是完全没有必要。</p>
<p>因为首先，这会让招聘者很疑惑，你前面的这些工作经验是哪里来的？当然大部分可能是把实习经验算成工作经验了，但实际上到面试阶段还是会把这部分抛除掉的。</p>
<p>所以我们希望的原则是尽可能地实事求是，不要虚报。不要把自己的毕业年限故意提前，来增加自己的工作年限。哪怕这会帮你过简历自动筛选的过程，到人工筛选或面试时，仍有很大的可能会被筛掉。</p>
<p>另外，<strong>对于一些转行的朋友，如果你原来不是做计算机这一行的</strong>，并且和计算机行业相差非常多，比方说汽车维修，那就简单的一句话概过就可以了。只是为了让你的招聘方知道，你毕业以后前几年并不是在从事计算机行业，然后把自己在计算机行行业内的工作经验、工作年限写清楚就可以了。</p>
<p>联系方式的话，手机号自然不必多说，邮箱尽可能地用一些常用的邮箱。如果你有自己的个人网站，也可以选择用自己个人网站的邮箱。但是呢，邮箱的名称尽可能要简短好认，比如1和L混合在一起的那种邮箱地址，看起来是非常痛苦的。</p>
<p>03</p>
<h6 id="“-工作、实习经历，相当重要-”"><a href="#“-工作、实习经历，相当重要-”" class="headerlink" title="“ 工作、实习经历，相当重要 ”"></a>“ 工作、实习经历，相当重要 ”</h6><p>简历的第二部分，就是工作和实习经历。</p>
<ul>
<li><p>公司名称</p>
</li>
<li><p>职位</p>
</li>
<li><p>时间</p>
</li>
<li><p>详细工作</p>
</li>
</ul>
<p>这部分相当重要。无论是应届毕业生，还是工作过几年的、有经验的，其实<strong>招聘方最看重的就是这一部分的内容</strong>。</p>
<p>在这一部分中，至少你要证明你在先前的实习或者工作中，有非常多收获，有对你个人的成长非常有帮助的经历。<strong>这样的经历是最有价值的</strong>。</p>
<p>另外工作经验要尽可能地<strong>避免断档</strong>。如果有断档的话，在你面试的时候肯定会问到，你需要有一个比较合理的解释。比方说你中间是出国读书了，或者哪种情况，然后有一两年的断档，这个是没什么问题的。</p>
<p>第二点需要注意的就是，一个公司只需要写一栏。在这一栏下，你可以列出一、二、三、四的这种条目，详细介绍在这个公司中，你所从事的事情以及学到的技术。<strong>但是要避免一个公司写很多栏</strong>，哪怕你在这公司里的职务有些变化，你可以只写一个最重要职务，或者一个最高级的职务。</p>
<p><strong>对于工作的描述</strong>，需要详细地介绍自己曾经开发的产品，以及开发这个产品中间用到的一些技术，负责的任务，并且要标明是否带过团队、带团队的规模是多少个人、这个项目的是否自己独立完成、或者两个人协作完成中你所处的角色，这个是非常细节的地方，但是一定要写得清楚一些。不需要太啰嗦，但是每一点一定要点到位。</p>
<p>最后一点就是刚才也提到的，把每一项以一个简短的条目一二三四标出来。这样能让对方非常清晰地看到，你所收获到的一些关键点，能够抓住他们的眼球。</p>
<p>在描述项目中的时候，<strong>尽可能多的使用一些关键字，一些技术的关键字</strong>。比方说，这个项目中我用到了Mongo DB、Laravel，或是前后端常用的一些框架，然后把它写到这个项目描述中。</p>
<p>而对于应届生来说的话，如果没有工作经验，<strong>实习经验就非常非常宝贵了</strong>。因为目前绝大部分的公司，其实都相对功利，希望自己招聘来的应届生能够直接上手，尽可能地快速融入自己的团队，形成战斗力。真正说希望拿过来培养一到两年的公司，应该是规模非常大的企业，属于比较少见的一种情况。</p>
<p>04</p>
<h6 id="“-什么样的项目经历让人信服？-”"><a href="#“-什么样的项目经历让人信服？-”" class="headerlink" title="“ 什么样的项目经历让人信服？ ”"></a>“ 什么样的项目经历让人信服？ ”</h6><p>第三部分通常是项目经历，分为：</p>
<ul>
<li><p>项目名称</p>
</li>
<li><p>项目描述</p>
</li>
<li><p>承担的职责</p>
</li>
<li><p>用到的技术</p>
</li>
<li><p>实现的效果</p>
</li>
</ul>
<p>项目经历，一般会把自己先前的工作或者实习，以及在学校实验室跟老师做的项目，做一些提取。选取其中最好的项目，最能够代表自己真实水平的。像一些课程的大作业，其实是完全没有必要贴上去的。当然，如果这个大作业的代码量非常大，并且有一定的知名度的话也可以。</p>
<p><strong>一些情况下，项目经验和工作经验是可以合并到一起的</strong>。比如你工作经历非常丰富，每一份工作的项目也非常明确，那完全可以将这两项内容合在一起。然后对于应届生，如果工作经历和实习经历都没有，项目经历一定要写得非常精选。</p>
<p><strong>在项目的描述中，我们最看重的就有三点</strong>。</p>
<ul>
<li><p>这个项目跟应聘的职位之间的关联性。</p>
</li>
<li><p>这个项目在整个技术圈内的知名度。</p>
</li>
<li><p>最后就是这个项目是否有一些数据，可以证明你做到了，并且让你有所收获。</p>
</li>
</ul>
<p>回到刚才的项目经验，其实我们是需要证据的，而<strong>最好的证据就是你GitHub的代码链接</strong>，或者是你这个项目的一个线上版本——有可能是一个网站，有可能是你展示的一个demo。只要有这样的效果，对于审核简历的人来说，他一眼就能看出来这个项目的技术水平，是能增加很多分的加分项。</p>
<p><strong>选择熟悉的项目，一定要选择熟悉的项目</strong>。应该自己写的项目如果进入了面试，很有可能面试官的问题都来自于你写的项目内容中，所以不要写那些自己模棱两可，或者说仅仅是一个旁观者身份的那种项目。只是看过的，或者没办法深入进去的，被问到也很尴尬。</p>
<p><strong>项目经历还需要数据支撑</strong>。举个例子，比如你为实验楼开发了一个实验操作的模块，这个模块可以支持1000人同时做实验，并且已经稳定在线上运行了几年，这个实验操作模块能达到几百万次实验的检测。这其实是非常好的，有价值的项目经验。</p>
<p>其实不只是应届生，<strong>我们鼓励所有的人在简历里面，尽可能的在项目经验部分列出自己曾经参与过的开源项目</strong>。比方说你参与过一些非常知名的、像VIEW一类的开源项目，提交过代码、提交过PR，这其实是非常好的增分项。</p>
<p>如果，应届生没有这方面的项目的话，<strong>也可以写一些实验楼的大项目</strong>。但是呢，如果是单纯的实验楼的教学项目，其实<strong>我们更希望你能够做一些扩展</strong>，就是在实验楼项目基础之上，额外做了一些扩展功能。这也可以帮你在向面试官介绍项目的时候，更好地展示自己的能力。</p>
<p>最后一点需要注意的是，<strong>你的项目描述一定要以非常标准的技术语言来写</strong>。甚至说一些技术的关键字，该大写的地方一定要大写，该小写地方一定要小写。这其实非常体现一个人专业化的水平。</p>
<p>05</p>
<h6 id="“-精通Java、Python、C、PHP-呵呵-”"><a href="#“-精通Java、Python、C、PHP-呵呵-”" class="headerlink" title="“ 精通Java、Python、C、PHP = 呵呵 ”"></a>“ 精通Java、Python、C、PHP = 呵呵 ”</h6><p>第四部分通常是技能列表。</p>
<p>注意事项：</p>
<ol>
<li><p>实事求是</p>
</li>
<li><p>根据目标职位适当调整</p>
</li>
<li><p>数字证明：30000行代码、3个项目-Python</p>
</li>
<li><p>项目证据：爬取知乎10万用户-Python</p>
</li>
</ol>
<p>我们在介绍完自己的项目经历之后，<strong>通常会写一个技能的列表</strong>。而这个技能列表，通常会根据你所应聘的职位做一些修正。你如果应聘Python后端工程师，那你尽可能地把自己Python相关的技能放在最前面。这些关键点，就能够抓住潜在面试官的眼球。</p>
<p>首先需要注意的仍然是实事求是，<strong>尽可能地不要写精通这两个字</strong>，可以写熟悉或了解。</p>
<p>技能列表也可以增加一些<strong>数字辅助</strong>的证据。比方说在Python后写上：我曾经有3万行代码的经验；曾经做过三个项目，三个项目在前面的项目经验里也可以做一些验证。此外还有其他的一些证据，比方说我曾经用Python爬取知乎10万个用户，这其实都是非常好的、能体现你技能水平的一些工作。</p>
<p>06</p>
<h6 id="“-教育经历中需要规避的-”"><a href="#“-教育经历中需要规避的-”" class="headerlink" title="“ 教育经历中需要规避的 ”"></a>“ 教育经历中需要规避的 ”</h6><p>教育经历这部分，好像就没有什么太多可说的。基本上专科、本科、硕士这些自己写清楚，学校、专业、时间也写清楚就可以了。</p>
<p><strong>务必实事求是，没有必要在这方面弄虚造假</strong>。尽管很多的公司可能会看学校，看学历，但在我的理解，他们只是在选择一种更快的筛选方式。而这一点，在实验楼我们并不会特别看重。我们对学历，或者说学校，其实并不是特别在乎。我们更看重的是你先前的一些工作经验或者自己的项目经验，和其他的一些证明自己实力和能力的东西。</p>
<p><strong>在教育经历这里，大家尽量不要特别强调自学成才</strong>。因为哪怕你没有上大学，没有上大专，高中毕业，但是自己对计算机非常感兴趣，又非常努力，是可以拿项目来证明的。但是不要在这里强调自学成才，因为自学成才的概率是非常非常低的，完全靠自己拼搏，出来一个能力非常强的个人，是非常难的，很多公司对这种小概率是非常惧怕的，基本上就会选择筛过。</p>
<p><strong>最后一点就是，尽可能不要写培训班的经验</strong>。因为目前大部分的线下培训，都是比较粗糙的，能够获得的技能的提升也是非常有限的。</p>
<p>07</p>
<h6 id="“-不要轻视额外信息-”"><a href="#“-不要轻视额外信息-”" class="headerlink" title="“ 不要轻视额外信息 ”"></a>“ 不要轻视额外信息 ”</h6><p>第六点基本上简历的最后一部分，会介绍很多其他的额外信息，比方说个人的网站或者是GitHub的链接。这里就有很多需要注意的地方。</p>
<p>首先你自己的个人网站或技术博客，如果内容不够丰富的话，只有一两篇日志这种的，其实是完全没有必要放出来的。</p>
<p>第二点需要强调的就是，<strong>GitHub是非常非常重要的</strong>。至少我们实验楼在招聘的时候，会首先看GitHub上面的一些记录，比方说原创的代码项目，甚至说代码的一些规范，包括提交的一些记录。如果你的GitHub仓库里是空的，并且，大部分都是fork别人的代码，那就不要放了，可以避免很多时间上的浪费。</p>
<p>如果你有其他原创的项目代码的下载链接，其实也是可以放在这里的。但是，<strong>如果需要招聘方花很多时间去查看的话，通常都不会有人看</strong>。</p>
<p><strong>在列出任何一个额外信息的时候</strong>，把它的亮点附在后面。比方说你自己的技术博客，你可以写上有150篇的技术博文，当月的访问量达到了100万。这样子是通过数字来吸引别人对你技术博客的关注。</p>
<p><strong>在技术简历里，非技术相关的信息，比方说参加过的志愿活动、社团活动啊、一律不要放，除非是技术社团</strong>。但是技术社团除非很知名，一般情况下也价值不大。</p>
<p>最后就是，不要写自己的个人描述。技术简历比较单纯一些，我们只看重你的技术水平，你的项目经验。其他的你个人的一些爱好，比如喜欢什么运动，这真的不是特别重要。</p>
<p>最后一点就是，<strong>如果职位没有要求你写期望的薪资，就不要写，可以到现场去谈</strong>。有可能你写了就会错过一些面试的机会。</p>
<p>08</p>
<h6 id="“-私人干货——技术社交！”"><a href="#“-私人干货——技术社交！”" class="headerlink" title="“ 私人干货——技术社交！”"></a>“ 私人干货——技术社交！”</h6><p>最后介绍一些简历之外的东西，我个人称之为就是<strong>「 技术社交 」。其实是为你打造一个不需要简历，就获得一些应聘机会的方式</strong>。需要通过下面这些渠道，增加你自己在技术社区里的知名度。</p>
<p>当知名度有了的话，很多公司会主动地去联系你。我知道的就<strong>有很多大公司的HR，会泡在GitHub上，然后去爬当地star排名非常靠前的用户，再主动地发邮件联系他们，邀请他们来公司进行面试</strong>。</p>
<p>而这部分的内容，就需要时间和个人精力的投入。比方说大学里，你可以选择从大二开始维护自己的GitHub仓库，在上面可以多创建一下项目，然后把自己原创的一些代码，包括参与的开源项目中提交的PR都可以发布上去。</p>
<p>你还可以用GitHub去搭建一个自己的技术博客，把大二大三大四几年以来的技术的积累和收获都放在上面，<strong>到你真正毕业去找工作的时候，其实你基本上不需要一个简历了。GitHub上面几百次的提交就是对你最好的一个证明</strong>。</p>
<p>还有就是像Stack Overflow这一类的技术社区。我个人建议是，在你有一些非常深入的技术了解之后，可以尝试着去回答一些小白的提问，这样子对个人的名声和技术也是有一个提高。</p>
<p>其他的内容无外乎就是你翻译过的一些技术文档，国外的非常著名的技术文档。其实在GitHub上，就可以加入很多的翻译组。还有你为一些在线教育网站贡献的内容，比方说想实验楼，你在实验楼投稿了一些课程，或是在一些在线教育的视频网站上，发布了一些自己录制的视频，这其实都是非常好的证明。</p>
<p>09</p>
<h6 id="“-常见问题！”"><a href="#“-常见问题！”" class="headerlink" title="“ 常见问题！”"></a>“ 常见问题！”</h6><p>第三部分的内容，就是我能想到的一些常见的问题。</p>
<p>首先需要注意的是，<strong>简历一定要短</strong>。把你最重要的内容精简到一页纸里面；把你最重要的关键字，精简到最突出的位置上。</p>
<p>千万不要增加大段的内容，大段的文字是简历的一个大忌。也不要夹杂太多个人感受、个人经历的文字，<strong>真的没人看</strong>。Hr或者工程师在收到很多简历的时候，他们的时间是非常有限的。如果你不能在很短的时间内抓住他们的眼球，那其实是浪费了一个很好的机会。</p>
<p>第二点是关于信息的顺序。首先应届生的话要突出学校，就把自己的教育信息和个人信息合在一起就可以了。非应届的话，最重要的是你的工作经验——你先前的工作、工作的时间长短、工作的核心内容是否与你应聘的职位相关、以及工作中的一些数据证据。个人信息下面就可以直接放一些工作经历。</p>
<p><strong>在投递简历的时候要根据应聘的职位进行一些调整</strong>。比如调整一些想要顺序、技术技能的顺序、以及先前工作经验中重点关键词的描述，尽可能往应聘需求上靠。</p>
<p>简历的格式尽可能的用pdf，这样通用性会更好一些。然后是不要放照片，除非是长得非常漂亮，或者职位有要求的，基本上，我见过的职位是没有要求放照片的。</p>
<p>最后就是如果投递外企的话，尽可能一页英文简历，一页中文简历，因为面试你的很可能是外国工程师。</p>
<p>另外，如果选择一个公司，可以适当地对这个公司的产品，包括用到的技术进行一些调研，也可以准备一份简短的对该公司产品的技术分析，放在简历里面。当然基本上用不到，更多的可能在面试环节里会用到。</p>
<p>这就是我今天给大家分享的一些内容，因为比较精简，可能很多地方并不是特别全面，大家想问的问题，或者想讨论的话题都可以提出来。</p>
<p>10</p>
<h6 id="“-用户提问”"><a href="#“-用户提问”" class="headerlink" title="“ 用户提问”"></a>“ 用户提问”</h6><table>
<thead>
<tr>
<th style="text-align:left">01</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>提问</strong>：学完基础后，怎么找一个好项目来做？</td>
</tr>
<tr>
<td style="text-align:left"><strong>回答</strong>：学完基础之后，可以先来实验楼做一些小的项目。如果你想有拿得出去、可以证明的项目，最好是去GitHub上找一些开源的项目，看一下人家提的ISSUE，然后找一些自己可以修的，再尝试着去提一些PR，哪怕被拒掉了。我觉得经过这几次交流之后，基本会有被接受的。这是一个非常好的锻炼自己的机会。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">02</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>提问</strong>：一般公司最看重应届生的哪方面？实习经验还是其他东西？</td>
</tr>
<tr>
<td style="text-align:left"><strong>回答</strong>：就拿我们公司来说，对应届生更多地看重的是实习的项目经验，以及学习能力，包括他真正解决问题的能力。并不是特别重要的是你现在技术方面的东西。因为过来以后，都是需要在团队里面进行很长时间的磨合，磨合的过程中也会有高级工程师会带一些，做一些经验的分享。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">03</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>提问</strong>：您强调 GitHub 中原创性的重要性，但个人又想兼容较大的提交量，这样的话需要怎么平衡？比如在实验楼做完实验，自动会把实验代码git下，其实更多的是一种个人的记录和托管，但这不是与原创性有所矛盾啦？</td>
</tr>
<tr>
<td style="text-align:left"><strong>回答</strong>：GitHub的提交和原创性其实并不矛盾啊。比方说你有什么思路，就在GitHub上创建这个项目，尝试着从最小的版本开始，慢慢地做一些迭代，持续上半年的时间，你的项目从代码量到知名度都会起来的啊。当然这就是一个坚持的过程。另外，如果要一个知名度比较高的，其实可以找一个大型项目里面的ISSUE，相当于你帮别人解决一些已知的问题。或者用他的框架去提出一些问题，然后提出自己的修复方案，提交一个PR，在讨论或者说在代码提交中，都会收到很多国内外工程师的反馈，这也是非常重要的。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">04</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>提问</strong>：感觉面试完了，面试官说：我的问题问完了，你有什么要问的吗？这是最尴尬的时候。</td>
</tr>
<tr>
<td style="text-align:left"><strong>回答</strong>：其实这个时候面试官也很尴尬……他可能自己也没有什么话要说了，只不过想找一个方式来结束本次面试。其实这个时候你就可以礼貌性质地问一些公司产品或者研发技术的一些问题。如果正好面试官属于这个产品线，或者对这个技术非常感兴趣的话，可以再深入地跟他探讨一下，但是呢，不要冒昧的提出一些自己并不是特别懂的建议。</td>
</tr>
</tbody>
</table>
<hr>
<hr>
<p><a href="http://www.jianshu.com/p/0b676530e506" target="_blank" rel="external">原文链接</a> <a href="http://www.jianshu.com/p/0b676530e506" target="_blank" rel="external">http://www.jianshu.com/p/0b676530e506</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先玩个小游戏，如果你在写简历时也遇到了相同的情况，请打勾：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-alig
    
    </summary>
    
      <category term="职场" scheme="https://sunyonghui.github.io/categories/%E8%81%8C%E5%9C%BA/"/>
    
    
      <category term="职场" scheme="https://sunyonghui.github.io/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>iOS 模式详解—「NSNotification通知」</title>
    <link href="https://sunyonghui.github.io/iOSUI/NSNotification.html"/>
    <id>https://sunyonghui.github.io/iOSUI/NSNotification.html</id>
    <published>2017-03-09T16:00:00.000Z</published>
    <updated>2017-08-09T10:38:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Write-in-the-first【写在最前】"><a href="#Write-in-the-first【写在最前】" class="headerlink" title="Write in the first【写在最前】"></a>Write in the first【写在最前】</h4><hr>
<p><strong>Notification(通知)</strong> 是 <strong>iOS</strong> 系统下重要的消息传递机制之一，通知封装了诸如窗口获得焦点、网络连接关闭等事件信息，通知的内容可按照我们实际的需求来定制。在实际开发中或多或少都会接触到，<strong>NSNotificationCenter</strong> 与 其它对象之间通信方式类似，但也存在不同，我们需要根据具体应用场景选择（或优先选择）恰当的通信方式。</p>
<p>本篇文章主要从【<strong>NSNotification和NSNotificationCenter 使用和注意点</strong>】学习总结。<br>在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。</p>
<blockquote>
<p>目录：</p>
<ol>
<li>NSNotification<br>1.NSNotification 概念<br>2.NSNotification.h 系统文件</li>
<li>NSNotificationCenter<br>1.NSNotificationCenter 概念<br>2.NSNotificationCenter 系统文件</li>
<li>NSNotificationCenter 的使用流程<br>1.注册观察者（添加监听）<br>2.发送通知<br>3.移除观察者（移除监听）</li>
<li>NSNotificationQueue<br>1.NSNotificationQueue 概念<br>2.NSNotificationQueue.h 系统文件<br>3.NSNotificatinonCenter 实现原理</li>
<li>NSNotificatinonCenter 实战使用<br>1.基本使用<br>2.通知在多线程中使用<br>3.通知在多线程中注意点</li>
<li>NSNotification Demo效果图</li>
<li>期待 &amp; 后续 &amp; About me</li>
</ol>
</blockquote>
<h4 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h4><hr>
<p>本着好好学习，了解权威的目的，我们还是主动看官网的说明。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-584a8f311cd81359.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" NSNotification iOS 2.0+"></p>
<h5 id="NSNotification-概念"><a href="#NSNotification-概念" class="headerlink" title="NSNotification 概念"></a>NSNotification 概念</h5><p>上图简单点释义就是<br><code>NSNotification</code>是方便<code>NSNotificationCenter</code> 广播到其他对象时的封装对象，简单讲即通知中心对通知调度表中的对象广播时发送<code>NSNotification</code>对象。<br><code>NSNotification</code>对象(称为通知)包含名称、<code>object</code> 和一个可选字典三个属性，名称是用来标识通知的标记（一般为常量字符串），<code>object</code>是任意想要携带的对象（通常为发送者自己 或为nil），字典用来存储发送通知时附带的信息（可为nil）。<code>NSNotification</code> 对象是不可变的对象。</p>
<h5 id="NSNotification-h-系统文件"><a href="#NSNotification-h-系统文件" class="headerlink" title="NSNotification.h 系统文件"></a>NSNotification.h 系统文件</h5><p>看完官网，接下来当然是看系统文件了。你说是吧！</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/****************	Notifications	****************/</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNotification</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSNotificationName</span> name;<span class="comment">// 通知的标识名称(一般为常量字符串)</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="keyword">id</span> object;<span class="comment">// 任意想要携带的对象(通常为发送者自己,可为nil)，</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *userInfo;<span class="comment">// 关于通知的附加信息(可为nil)</span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSNotificationName</span>)name object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)userInfo <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0) <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div></pre></td></tr></table></figure>
<p>接下来看下三个初始化方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)notificationWithName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</div><div class="line"><span class="comment">// 有附加信息</span></div><div class="line">+ (<span class="keyword">instancetype</span>)notificationWithName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init <span class="comment">/*NS_UNAVAILABLE*/</span>;	<span class="comment">/* do not invoke; not a valid initializer for this class */</span></div></pre></td></tr></table></figure>
<h4 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h4><hr>
<p>我们还是主动看官网的说明。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-1f50cf6f454b2a88.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" NSNotificationCenter iOS 8.0+"></p>
<h5 id="NSNotificationCenter-概念"><a href="#NSNotificationCenter-概念" class="headerlink" title="NSNotificationCenter 概念"></a>NSNotificationCenter 概念</h5><p>上图简单点释义就是<br><code>NSNotificationCenter</code>对象(通知中心) 是 Foundation 框架的一个子系统，提供了在程序中广播消息的机制。通过<code>［NSNotificationCenter defaultCenter］</code>获取引用总的通知中心，可以在不同类之间通信的时候使用。</p>
<p>在通知中心注册观察者，发送者使用通知中心广播时，以<code>NSNotification</code>的<code>name</code>和<code>object</code>来确定需要发送给哪个观察者。为保证观察者能接收到通知，所以应先向通知中心注册观察者，接着再发送通知这样才能在通知中心调度表中查找到相应观察者进行通知。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-55956fe654a781c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" NSNotificationCenter"></p>
<h5 id="NSNotificationCenter-系统文件"><a href="#NSNotificationCenter-系统文件" class="headerlink" title="NSNotificationCenter 系统文件"></a>NSNotificationCenter 系统文件</h5><p>看完官网，接下来当然是看系统文件了。你说是吧！</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/****************	Notification Center	****************/</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNotificationCenter</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">@package</span></div><div class="line">    <span class="keyword">void</span> *_impl;</div><div class="line">    <span class="keyword">void</span> *_callback;</div><div class="line">    <span class="keyword">void</span> *_pad[<span class="number">11</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#if FOUNDATION_SWIFT_SDK_EPOCH_AT_LEAST(8)</span></div><div class="line"><span class="comment">// 获取通知中心</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSNotificationCenter</span> *defaultCenter;</div></pre></td></tr></table></figure>
<p><strong>总结</strong>：获取<code>NSNotificationCenter</code>的方法只有一种，即<code>[NSNotificationCenter defaultCenter]</code>，并且<code>NSNotificationCenter</code>是一个单例模式，一旦创建，这个通知中心的对象会一直存在于一个应用的生命周期。</p>
<h5 id="通知中心的使用流程"><a href="#通知中心的使用流程" class="headerlink" title="通知中心的使用流程"></a>通知中心的使用流程</h5><p>获取通知中心对象后，我们就可以使用它来处理通知相关的操作了，包括注册观察者、发送通知 和 移除观察者。</p>
<h5 id="1、注册观察者（添加监听）"><a href="#1、注册观察者（添加监听）" class="headerlink" title="1、注册观察者（添加监听）"></a>1、注册观察者（添加监听）</h5><p>你可以使用以下两种方式注册观察者</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//--------------------------- 注册观察者方式一 ------------------------------//</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> Observer: 观察者</div><div class="line"> selector: 只要一监听到通知,就会调用观察者这个方法</div><div class="line"> Name: 通知名称也是通知的唯一标示，编译器就是通过这个找到通知的。</div><div class="line"> object: 谁发出的通知,表示会对哪个发送者对象发出的事件作出响应，nil 时表示接受所有发送者的事件。</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer selector:(SEL)aSelector </div><div class="line">                     name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName </div><div class="line">                     object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</div><div class="line"></div><div class="line"><span class="comment">//--------------------------- 注册观察者方式二 ------------------------------//</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> Name: 通知名称</div><div class="line"> object: 谁发出的通知</div><div class="line"> queue: 决定block在哪个线程执行,nil:在发布通知的线程中执行</div><div class="line"> [NSOperationQueue mainQueue]: 一般都是使用主队列</div><div class="line"> usingBlock: 只要监听到通知,就会执行这个block</div><div class="line"> 注意: 一定要记得移除</div><div class="line"> */</div><div class="line">- (<span class="keyword">id</span> &lt;<span class="built_in">NSObject</span>&gt;)addObserverForName:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)name </div><div class="line">            object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)obj queue:(<span class="keyword">nullable</span> <span class="built_in">NSOperationQueue</span> *)queue </div><div class="line">            usingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSNotification</span> *note))block <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0);</div><div class="line"><span class="comment">// The return value is retained by the system, and should be held onto by the caller in</span></div><div class="line"><span class="comment">// order to remove the observer with removeObserver: later, to stop observation.</span></div></pre></td></tr></table></figure>
<p><strong>总结</strong>：</p>
<ul>
<li><p>第一种方式是比较常用的添加<code>Oberver</code>的方式，接到通知时执行<code>Selector</code>方法，<strong>观察者接收到通知后执行任务的代码在发送通知的线程中执行</strong>（下面示例代码验证）。</p>
</li>
<li><p>第二种方式是提供了一个以<code>block</code>方式实现的添加观察者的方法。大家第一次看到这个方法时是否会有这样的疑问：观察者呢？参数中并没有指定具体的观察者，那谁是观察者呢？需要移除吗？</p>
</li>
<li><p>实际上，与前一个方法不同的是，前者使用一个现存的对象作为观察者，而这个方法会创建一个<strong>匿名的对象作为观察者</strong>(即方法返回的<code>id&lt;NSObject&gt;</code>对象)，这个匿名对象会在指定的队列<code>(queue)</code>上去执行我们的<code>block</code>。</p>
</li>
</ul>
<p><strong>第二种注册方式注意点</strong>：</p>
<ul>
<li><p>1、参数<code>queue</code> 决定<code>block</code>在哪个线程执行，即<strong>我们指定了操作队列</strong>。如果<code>queue</code>为<code>nil</code>，则消息是默认在<code>post</code>线程中同步处理，即 <strong>观察者接收到通知后执行任务的代码在发送通知的线程中执行</strong>（下面示例代码验证）。</p>
</li>
<li><p>2、<code>block</code>块会被通知中心拷贝一份(<code>执行copy操作</code>)，以在堆中维护一个<code>block</code>对象，直到观察者被从通知中心中移除。所以，<strong>应该特别注意在<code>block</code>中使用外部对象，避免出现对象的循环引用</strong>。</p>
</li>
<li><p>3、如果一个给定的通知触发了多个观察者的<code>block</code>操作，则这些操作会在各自的<code>Operation Queue</code>中被并发执行。所以我们 <strong>不能去假设操作的执行会按照添加观察者的顺序来执行</strong>。</p>
</li>
<li><p>4、该方法会返回一个表示观察者的对象，<strong>记得在不用时移除这个对象</strong>。</p>
</li>
</ul>
<p>第2点示例，由于使用的是block，所以需要注意的就是避免引起循环引用的问题：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Observer</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> i;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt; observer;</div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Observer</span></span></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Init Observer"</span>);</div><div class="line">        </div><div class="line">        <span class="comment">// 添加观察者</span></div><div class="line">        _observer =  [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:TEST_NOTIFICATION object:<span class="literal">nil</span> queue:[<span class="built_in">NSOperationQueue</span> mainQueue] usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"handle notification"</span>);</div><div class="line">            <span class="comment">// 使用self</span></div><div class="line">            <span class="keyword">self</span>.i = <span class="number">10</span>;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="meta">#pragma mark - ViewController</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">  </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> createObserver];</div><div class="line">    <span class="comment">// 发送消息</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:TEST_NOTIFICATION object:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)createObserver &#123;</div><div class="line">    Observer *observer = [[Observer alloc] init];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//--------------------------- &lt;#我是分割线#&gt; ------------------------------//</span></div><div class="line"><span class="comment">// 打印输出</span></div><div class="line">Init Observer</div><div class="line">handle notification</div></pre></td></tr></table></figure>
<p>我们可以看到<code>createObserver</code>中创建的<code>observer</code>并没有被释放。所以，使用<code>addObserverForName:object:queue:usingBlock:</code>一定要注意这个问题。</p>
<h5 id="2、发送通知"><a href="#2、发送通知" class="headerlink" title="2、发送通知"></a>2、发送通知</h5><p>发送通知可使用以下方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)postNotification:(<span class="built_in">NSNotification</span> *)notification;</div><div class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</div><div class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</div></pre></td></tr></table></figure></p>
<p><strong>总结</strong>：</p>
<ul>
<li><p>三种方式都是发送<code>NSNotification</code>对象给通知中心注册的所有观察者。</p>
</li>
<li><p>发送通知通过<code>name</code>和<code>object</code>来确定来标识观察者，<code>name</code>和<code>object</code>两个参数的规则相同即当通知设置<code>name</code>为<code>kChangeNotifition</code>时，那么只会发送给符合<code>name</code>为<code>kChangeNotifition</code>的观察者，同理<code>object</code>指发送给某个特定对象通知，如果只设置了<code>name</code>，那么只有对应名称的通知会触发。如果同时设置<code>name</code>和<code>object</code>参数时就必须同时符合这两个条件的观察者才能接收到通知。</p>
</li>
</ul>
<h5 id="3、移除观察者（移除监听）"><a href="#3、移除观察者（移除监听）" class="headerlink" title="3、移除观察者（移除监听）"></a>3、移除观察者（移除监听）</h5><p>在对象被释放前需要移除掉观察者，避免已经被释放的对象还接收到通知导致崩溃。<br>移除观察者有两种方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer;</div><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</div></pre></td></tr></table></figure>
<p><strong>总结</strong>：</p>
<ul>
<li><p>传入相应的需要移除的<code>observer</code> 或者使用第二种方式三个参数来移除指定某个观察者。</p>
</li>
<li><p>如果使用基于<code>-[NSNotificationCenter addObserverForName:object:queue:usingBlock:]</code>方法在获取方法返回的观察者进行释放。基于这个方法我们还可以让观察者接到通知后只执行一次：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__block __<span class="keyword">weak</span> <span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt; observer = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"note"</span> object:<span class="literal">nil</span> queue:<span class="literal">nil</span> usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
<li><p>通知的发送与处理是同步的，在某个地方<code>post</code>一个消息时，会等到所有观察者对象执行完处理操作后，才回到<code>post</code>的地方，继续执行后面的代码。</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(reciveNote1) name:<span class="string">@"note"</span> object:<span class="literal">nil</span>];</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(reciveNote2) name:<span class="string">@"note"</span> object:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"note"</span> object:<span class="literal">nil</span>];</div><div class="line"> </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"continue"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)reciveNote1 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"接收到通知--reciveNote1"</span>);  </div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)reciveNote2 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"接收到通知--reciveNote2"</span>);  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//--------------------------- &lt;#我是分割线#&gt; ------------------------------//</span></div><div class="line"><span class="comment">//</span></div><div class="line">打印输出</div><div class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">15</span>:<span class="number">33</span>:<span class="number">48.423</span> <span class="number">03</span>-通知补充[<span class="number">8711</span>:<span class="number">298506</span>] 接收到通知--reciveNote1</div><div class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">15</span>:<span class="number">33</span>:<span class="number">48.423</span> <span class="number">03</span>-通知补充[<span class="number">8711</span>:<span class="number">298506</span>] 接收到通知--reciveNote2</div><div class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">15</span>:<span class="number">33</span>:<span class="number">48.423</span> <span class="number">03</span>-通知补充[<span class="number">8711</span>:<span class="number">298506</span>] <span class="keyword">continue</span></div></pre></td></tr></table></figure>
<h4 id="NSNotificationQueue"><a href="#NSNotificationQueue" class="headerlink" title="NSNotificationQueue"></a>NSNotificationQueue</h4><hr>
<p>我们还是主动看官网的说明。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-340d3312562513e5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" NSNotificationQueue iOS 2.0+"></p>
<h5 id="NSNotificationQueue-概念"><a href="#NSNotificationQueue-概念" class="headerlink" title="NSNotificationQueue 概念"></a>NSNotificationQueue 概念</h5><p>上图简单点释义就是<br><strong>NSNotificationQueue</strong> 通知队列，更像是通知中心的缓冲区，用来管理多个通知的调用。通知队列通常以先进先出（FIFO）顺序管理通知。当一个通知上升到队列的前面时，队列就将它发送给通知中心(<code>NSNotificationCenter</code>)，通知中心随后将它派发给所有注册为观察者的对象。。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-039eb1cb519b98df.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" NSNotificationQueue"></p>
<h5 id="NSNotificationQueue-h-系统文件"><a href="#NSNotificationQueue-h-系统文件" class="headerlink" title="NSNotificationQueue.h 系统文件"></a>NSNotificationQueue.h 系统文件</h5><p>看完官网，接下来当然是看系统文件了。你说是吧！</p>
<ul>
<li>创建通知队列方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建通知队列方法</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithNotificationCenter:(<span class="built_in">NSNotificationCenter</span> *)notificationCenter <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div></pre></td></tr></table></figure>
<ul>
<li>往队列加入通知方法(异步)</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 往队列加入通知方法</span></div><div class="line">- (<span class="keyword">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle;</div><div class="line">- (<span class="keyword">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle coalesceMask:(<span class="built_in">NSNotificationCoalescing</span>)coalesceMask forModes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</div></pre></td></tr></table></figure>
<ul>
<li>移除队列中的通知方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除队列中的通知方法</span></div><div class="line">- (<span class="keyword">void</span>)dequeueNotificationsMatching:(<span class="built_in">NSNotification</span> *)notification coalesceMask:(<span class="built_in">NSUInteger</span>)coalesceMask;</div></pre></td></tr></table></figure>
<ul>
<li>发送方式</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSPostingStyle包括三种类型</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSPostingStyle</span>) &#123;</div><div class="line">    <span class="built_in">NSPostWhenIdle</span> = <span class="number">1</span>,</div><div class="line">    <span class="built_in">NSPostASAP</span> = <span class="number">2</span>,</div><div class="line">    <span class="built_in">NSPostNow</span> = <span class="number">3</span></div><div class="line">&#125;;</div><div class="line">注解：</div><div class="line"><span class="built_in">NSPostWhenIdle</span>：空闲发送通知 当运行循环处于等待或空闲状态时，发送通知，对于不重要的通知可以使用。</div><div class="line"><span class="built_in">NSPostASAP</span>：尽快发送通知 当前运行循环迭代完成时，通知将会被发送，有点类似没有延迟的定时器。</div><div class="line"><span class="built_in">NSPostNow</span> ：同步发送通知 如果不使用合并通知 和postNotification:一样是同步通知。</div></pre></td></tr></table></figure>
<ul>
<li>合并通知<ul>
<li>通过合并我们可以用来保证相同的通知只被发送一次。</li>
<li><code>forModes:(nullable NSArray&lt;NSRunLoopMode&gt; *)modes</code>可以使用不同的<code>NSRunLoopMode</code>配合来发送通知，可以看出实际上<code>NSNotificationQueue</code>与<code>RunLoop</code>的机制以及运行循环有关系，通过<code>NSNotificationQueue</code>队列来发送的通知和关联的<code>RunLoop</code>运行机制来进行的。</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSNotificationCoalescing也包括三种类型</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSNotificationCoalescing</span>) &#123;</div><div class="line">    <span class="built_in">NSNotificationNoCoalescing</span> = <span class="number">0</span>,</div><div class="line">    <span class="built_in">NSNotificationCoalescingOnName</span> = <span class="number">1</span>,</div><div class="line">    <span class="built_in">NSNotificationCoalescingOnSender</span> = <span class="number">2</span></div><div class="line">&#125;;</div><div class="line">注解：</div><div class="line"><span class="built_in">NSNotificationNoCoalescing</span>：不合并通知。</div><div class="line"><span class="built_in">NSNotificationCoalescingOnName</span>：合并相同名称的通知。</div><div class="line"><span class="built_in">NSNotificationCoalescingOnSender</span>：合并相同通知和同一对象的通知。</div></pre></td></tr></table></figure>
<h4 id="NSNotificatinonCenter-实现原理"><a href="#NSNotificatinonCenter-实现原理" class="headerlink" title="NSNotificatinonCenter 实现原理"></a>NSNotificatinonCenter 实现原理</h4><hr>
<ul>
<li><p><code>NSNotificatinonCenter</code>是使用观察者模式来实现的用于跨层传递消息，用来降低耦合度。</p>
</li>
<li><p><code>NSNotificatinonCenter</code>用来管理通知，将观察者注册到<code>NSNotificatinonCenter</code>的通知调度表中，然后发送通知时利用标识符<code>name</code>和<code>object</code>识别出调度表中的观察者，然后调用相应的观察者的方法，即传递消息（在<code>Objective-C</code>中对象调用方法，就是传递消息，消息有name或者<code>selector</code>，可以接受参数，而且可能有返回值），如果是基于<code>block</code>创建的通知就调用<code>NSNotification</code>的<code>block</code>。</p>
</li>
</ul>
<h4 id="NSNotificatinonCenter-实战使用"><a href="#NSNotificatinonCenter-实战使用" class="headerlink" title="NSNotificatinonCenter 实战使用"></a>NSNotificatinonCenter 实战使用</h4><hr>
<h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>第一种注册观察者的方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">// 1.注册观察者（添加监听）</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(reciveNote1) name:<span class="string">@"note"</span> object:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 2.发送通知</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"note"</span> object:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 一个对象即将销毁就会调用</span></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    <span class="comment">// 3.移除通知</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 观察者接收到通知后执行任务的代码</span></div><div class="line">- (<span class="keyword">void</span>)reciveNote1 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"接收到通知--reciveNote1"</span>);   </div><div class="line">&#125;</div><div class="line"></div><div class="line">打印输出：</div><div class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">57</span>:<span class="number">45.320</span> <span class="number">03</span>-通知补充[<span class="number">10343</span>:<span class="number">376649</span>] 接收到通知--reciveNote1</div></pre></td></tr></table></figure>
<p>第二种注册观察者的方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> observe;</div><div class="line"><span class="comment">// 1.注册观察者（添加监听）</span></div><div class="line">_observe = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"note"</span> object:<span class="literal">nil</span> queue:<span class="literal">nil</span> usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</div><div class="line">      </div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"我是block方式注册观察者"</span>);</div><div class="line">&#125;];</div><div class="line">    </div><div class="line"><span class="comment">// 2.发送通知</span></div><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"note"</span> object:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p><strong>总结</strong>：这个方法的优点在于添加观察者的操作与回调处理操作的代码更加紧凑，不需要拼命滚动鼠标就能直接找到处理代码，简单直观。个人比较喜欢。</p>
<h5 id="通知在多线程中使用"><a href="#通知在多线程中使用" class="headerlink" title="通知在多线程中使用"></a>通知在多线程中使用</h5><p>注册观察者两种方式，在多线程中的使用和注意点，以下 会分别说明。</p>
<p>第一种注册观察者方式，以下代码我们将验证这个结论：<br><strong>接收通知代码 由 发出通知线程决定，即观察者接收到通知后执行任务的代码在发送通知的线程中执行</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.注册观察者（添加监听）</span></div><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(reciveNote1) name:<span class="string">@"note"</span> object:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="comment">// 2.发送通知（主线程）</span></div><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"note"</span> object:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="comment">// 发送通知（异步线程）</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"note"</span> object:<span class="literal">nil</span>];</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//--------------------------- &lt;#我是分割线#&gt; ------------------------------//</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 接收到通知执行代码</span></div><div class="line">- (<span class="keyword">void</span>)reciveNote1 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"接收到通知--reciveNote1"</span>); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">发送通知（异步线程）打印输出：</div><div class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">36.122</span> <span class="number">03</span>-通知补充[<span class="number">10818</span>:<span class="number">402396</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x600000267cc0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</div><div class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">36.122</span> <span class="number">03</span>-通知补充[<span class="number">10818</span>:<span class="number">402396</span>] 接收到通知--reciveNote1</div><div class="line"></div><div class="line">发送通知（主线程）打印输出：</div><div class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">42.705</span> <span class="number">03</span>-通知补充[<span class="number">10868</span>:<span class="number">404679</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x60800007a6c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">42.705</span> <span class="number">03</span>-通知补充[<span class="number">10868</span>:<span class="number">404679</span>] 接收到通知--reciveNote1</div></pre></td></tr></table></figure>
<p>第二种注册观察者方式，以下代码我们将验证这个结论：<br><strong>接收通知代码 由 发出通知线程决定，即观察者接收到通知后执行任务的代码在发送通知的线程中执行（指定操作队列除外）</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 指定操作队列 [NSOperationQueue mainQueue] </span></div><div class="line"><span class="comment">// _observe = [[NSNotificationCenter defaultCenter] addObserverForName:@"note" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123;</span></div><div class="line"><span class="comment">// 1.注册观察者（添加监听）</span></div><div class="line">_observe = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"note"</span> object:<span class="literal">nil</span> queue:<span class="literal">nil</span> usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 只要监听到通知 就会调用</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我是block方式注册观察者"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 2.发送通知（主线程）</span></div><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"note"</span> object:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="comment">// 发送通知（异步线程）</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"note"</span> object:<span class="literal">nil</span>];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">发送通知（主线程）打印输出：</div><div class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">08.587</span> <span class="number">03</span>-通知补充[<span class="number">11305</span>:<span class="number">421194</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x608000072940</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">08.587</span> <span class="number">03</span>-通知补充[<span class="number">11305</span>:<span class="number">421194</span>] 我是block方式注册观察者</div><div class="line"></div><div class="line">发送通知（异步线程）打印输出：</div><div class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">24</span>:<span class="number">56.248</span> <span class="number">03</span>-通知补充[<span class="number">11503</span>:<span class="number">431482</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x60000007ec40</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</div><div class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">24</span>:<span class="number">56.248</span> <span class="number">03</span>-通知补充[<span class="number">11503</span>:<span class="number">431482</span>] 我是block方式注册观察者</div><div class="line"></div><div class="line">注册观察者,指定操作队列（不管发送通知在那个线程都按指定操作队列执行）</div><div class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">27</span>:<span class="number">04.567</span> <span class="number">03</span>-通知补充[<span class="number">11555</span>:<span class="number">433722</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x600000073e40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">27</span>:<span class="number">04.567</span> <span class="number">03</span>-通知补充[<span class="number">11555</span>:<span class="number">433722</span>] 我是block方式注册观察者</div></pre></td></tr></table></figure>
<h5 id="通知在多线程中注意点"><a href="#通知在多线程中注意点" class="headerlink" title="通知在多线程中注意点"></a>通知在多线程中注意点</h5><p>开发中使用场景，第一种方式，一般在接收通知执行代码中，做一下处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)reciveNote1</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 更新UI</span></div><div class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">       <span class="comment">// 更新UI</span></div><div class="line"></div><div class="line">       <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种方式，一般在接收通知执行代码中，做一下处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一般不要写nil ,更新UI指定主队列</span></div><div class="line">_observe = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"note"</span> object:<span class="literal">nil</span> queue:[<span class="built_in">NSOperationQueue</span> mainQueue] usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 更新UI</span></div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><hr>
<p>在我们的应用程序中，两个对象之间如何通信。根据具体应用场景优先选择哪一种通信方式。<br>对象之间的通信方式主要有以下几种：</p>
<ul>
<li>直接方法调用</li>
<li><code>Target-Action事件</code></li>
<li><code>Delegate</code>代理</li>
<li><code>block</code>回调</li>
<li><code>KVO</code>监听</li>
<li><code>NSNotification</code>通知</li>
</ul>
<p>优先选择哪一种通信方式：</p>
<blockquote>
<p>通信对象是一对一的还是一对多的<br>对象之间的耦合度.</p>
</blockquote>
<p>建议：</p>
<ul>
<li>1.在需要的地方使用通知，<strong>要求</strong>: 必须得保证通知的名称在监听和发出时是一致的。</li>
<li>2.注册的观察者在不使用时一定要记得移除，即添加和移除要配对出现。</li>
<li>3.尽可能迟地去注册一个观察者，并尽可能早将其移除，这样可以改善程序的性能。因为，每<code>post</code>一个通知，都会是遍历通知中心的分发表，确保通知发给每一个观察者。</li>
<li>4.记住通知的发送和处理是在同一个线程中。</li>
<li>5.使用<code>-addObserverForName:object:queue:usingBlock:</code>务必处理好内存问题，避免出现循环引用。</li>
<li>6.<code>NSNotificationCenter</code>是线程安全的，但并不意味着在多线程环境中不需要关注线程安全问题。不恰当的使用仍然会引发线程问题。</li>
</ul>
<h4 id="期待"><a href="#期待" class="headerlink" title="期待"></a>期待</h4><hr>
<ul>
<li>如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。</li>
</ul>
<ul>
<li>点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Write-in-the-first【写在最前】&quot;&gt;&lt;a href=&quot;#Write-in-the-first【写在最前】&quot; class=&quot;headerlink&quot; title=&quot;Write in the first【写在最前】&quot;&gt;&lt;/a&gt;Write in the f
    
    </summary>
    
      <category term="iOS" scheme="https://sunyonghui.github.io/categories/iOS/"/>
    
    
      <category term="模式" scheme="https://sunyonghui.github.io/tags/%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS 模式详解—「KVC编码 &amp; KVO监听」</title>
    <link href="https://sunyonghui.github.io/iOSUI/KVCKVO.html"/>
    <id>https://sunyonghui.github.io/iOSUI/KVCKVO.html</id>
    <published>2017-03-03T16:00:00.000Z</published>
    <updated>2017-08-09T10:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Write-in-the-first【写在最前】"><a href="#Write-in-the-first【写在最前】" class="headerlink" title="Write in the first【写在最前】"></a>Write in the first【写在最前】</h4><hr>
<p>开发过程中，最常见的就是程序的流程取决于你所使用的各种变量和属性的值，根据变量和属性的值确定后面运行的代码。<br>学好「获取类中属性的变化」这一模块是开发重要部分之一，<br>目地：为了解决在开发过程中，由需求改变引发的各种蛋疼、繁琐的问题。</p>
<p>本篇文章主要从【KVC &amp; KVO 使用场景相关】学习总结。<br>在「时间 &amp; 知识 」有限内，总结的文章难免有「未全、不足 」的地方，还望各位好友指出，以提高文章质量。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-0f88c35baf927f43.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KVC &amp; KVO"></p>
<blockquote>
<p>目录：</p>
<ol>
<li>引导 </li>
<li>KVC 概论</li>
<li>KVC 常用方法</li>
<li>KVC 对多种数据类型的支持</li>
<li>KVC 实现原理</li>
<li>KVC 基本使用<br>1.KVC 简单赋值 &amp; 取值<br>2.KVC 访问私有成员变量<br>3.KVC 字典转模型</li>
<li>KVO 概论</li>
<li>KVO 使用步骤</li>
<li>KVO 实现原理</li>
<li>KVO 手动发送通知机制</li>
</ol>
</blockquote>
<h4 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h4><hr>
<p>我们有多种方式获取对象的改变。例如，使用委托、通知获取值的改变。如果需要观察多个属性的变化，使用委托或通知会产生大量代码，一个更好用来观察属性变化的方法是使用 <strong>键值监听（Key Value Observing，简称KVO）</strong>，<strong>Apple</strong> 在自己的软件中大量使用 KVO。使用 KVO 跟踪单个属性或集合（如数组）的变化非常高效，键值观察建立在 <strong>键值编码（Key Value Coding，简称KVC）</strong> 基础上，也就是任何你想使用 KVO 监听的属性必须符合键值编码。KVO 只需要在观察者方法中添加代码，不需要修改被观察文件内代码，这一点和委托、通知不同。</p>
<p>KVC 和 KVO 提供了一个强大高效的方式来编写代码，学习 KVO 前必须先掌握 KVC，所以 我们按实用开发技巧一点点剖析它。</p>
<h4 id="KVC-概论"><a href="#KVC-概论" class="headerlink" title="KVC 概论"></a>KVC 概论</h4><hr>
<p><strong>KVC</strong>（全称 <code>key-value-coding</code>）即键值编码。KVC 的操作方法由<code>NSKeyValueCoding</code> 非正式协议提供，而<code>NSObject(NSKeyValueCoding)</code>就实现了这个协议，也就是说ObjC中几乎所有的对象都支持 KVC 操作，它是一种不通过存取方法（<code>Setter、Getter</code>），而通过属性名称字符串（<code>key</code>）间接访问类属性(实例变量)的机制。</p>
<h4 id="KVC-常用方法"><a href="#KVC-常用方法" class="headerlink" title="KVC 常用方法"></a>KVC 常用方法</h4><hr>
<p>KVC 常用的方法如下：</p>
<ul>
<li>赋值</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</div><div class="line"></div><div class="line"><span class="comment">// 注解:</span></div><div class="line">setValue:(属性值) forKey:(属性名),（用于简单属性）。</div><div class="line">setValue:(属性值) forKeyPath:(属性名),（用于复合属性，进行内部的点语法，层层访问内部的属性; 例如student.name，Student学生模型类中的name属性。</div></pre></td></tr></table></figure>
<ul>
<li>获取值</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</div><div class="line"></div><div class="line"><span class="comment">// 注解:</span></div><div class="line">valueForKey:属性名</div><div class="line">valueForKeyPath:属性名(用于复合属性）</div></pre></td></tr></table></figure>
<h4 id="KVC-对多种数据类型的支持"><a href="#KVC-对多种数据类型的支持" class="headerlink" title="KVC 对多种数据类型的支持"></a>KVC 对多种数据类型的支持</h4><hr>
<p>首先要说的是对于基本数据类型的属性，KVC 的这几个方法会自动装箱和拆箱。其次，KVC 也支持数组和字典等集合数据。这里了解不多，不做过多总结，有兴趣可参考：<a href="http://blog.csdn.net/wzzvictory/article/details/9674431#t5" target="_blank" rel="external">KVC/KVO原理详解及编程指南</a></p>
<p>简单示例：KVC 自动类型转换<br>如：模型类定义的属性是 <code>float money</code><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">float</span> money;</div><div class="line"></div><div class="line"><span class="comment">// KVC 赋值</span></div><div class="line">[person setValue:<span class="string">@"18"</span> forKeyPath:<span class="string">@"money"</span>];</div><div class="line">[person setValue:[<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">18</span>] forKeyPath:<span class="string">@"money"</span>];</div><div class="line">打印输出会自动转换成 <span class="keyword">float</span> 类型 <span class="number">18.00</span>;</div></pre></td></tr></table></figure></p>
<h4 id="KVC-实现原理"><a href="#KVC-实现原理" class="headerlink" title="KVC 实现原理"></a>KVC 实现原理</h4><hr>
<p>1、<code>[item setValue:@&quot;白开水ln简书&quot; forKey:@&quot;name&quot;];</code></p>
<ul>
<li>1.首先去模型中查找有没有 <code>setName</code>，若有，直接调用赋值 <code>[self setName:@&quot;白开水ln简书&quot;]</code>。</li>
<li>2.若无，去模型中查找有没有 <code>name</code> 属性，若有，直接访问属性赋值  <code>name = value</code>。</li>
<li>3.若无，再去模型中查找有没有 <code>_name</code> 成员变量，若有，直接访问属性赋值 <code>_name = value</code>。</li>
<li>4.找不到，就会直接报找不到的错误（<code>valueForUndefinedKey:</code>）。</li>
</ul>
<hr>
<p>2、<code>[item setValuesForKeysWithDictionary:dict];</code></p>
<ul>
<li><p>1.遍历字典中所有 <code>key</code>。</p>
</li>
<li><p>2.去模型中查找有没有对应的属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull value, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">    <span class="comment">// 2.去模型中查找有没有对应属性 KVC</span></div><div class="line">    [item setValue:value forKey:key];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="KVC-基本使用"><a href="#KVC-基本使用" class="headerlink" title="KVC 基本使用"></a>KVC 基本使用</h4><hr>
<h5 id="KVC-简单赋值-amp-取值"><a href="#KVC-简单赋值-amp-取值" class="headerlink" title="KVC 简单赋值 &amp; 取值"></a>KVC 简单赋值 &amp; 取值</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">LNPerson *person = [[LNPerson alloc] init];    </div><div class="line">person.dog = [[LNDog alloc] init];</div><div class="line"></div><div class="line">﻿[person.dog setValue:<span class="string">@"阿黄"</span> forKey:<span class="string">@"name"</span>];</div><div class="line">[person setValue:<span class="string">@"旺财"</span> forKeyPath:<span class="string">@"dog.name"</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, person.dog.name);</div></pre></td></tr></table></figure>
<p>区别：<code>forKey:</code> 和 <code>forKeyPath:</code><br>1、<code>forKeyPath</code> 包含了所有 <code>forKey</code> 的功能<br>2、<code>forKeyPath</code> 进行内部的点语法,层层访问内部的属性<br>3、注意：<code>key</code> 值一定要在属性中找到，开发中最好使用<code>forKeyPath</code>。</p>
<p><strong>KVC 取值</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[person valueForKeyPath:<span class="string">@"name"</span>]</div><div class="line"></div><div class="line"><span class="comment">// 取出数组中所有模型的某个属性值</span></div><div class="line"><span class="built_in">NSArray</span> *allPersons = @[person1, person2, person3];</div><div class="line"><span class="built_in">NSArray</span> *allPersonName = [allPersons valueForKeyPath:<span class="string">@"name"</span>];</div></pre></td></tr></table></figure></p>
<h5 id="KVC-访问私有成员变量"><a href="#KVC-访问私有成员变量" class="headerlink" title="KVC 访问私有成员变量"></a>KVC 访问私有成员变量</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LNPerson</span></span></div><div class="line">&#123;</div><div class="line">      <span class="keyword">int</span> _age; </div><div class="line">&#125;</div><div class="line"></div><div class="line">LNPerson *person = [[LNPerson alloc] init];</div><div class="line">[person setValue:<span class="string">@"88"</span> forKeyPath:<span class="string">@"age"</span>];</div></pre></td></tr></table></figure>
<p>注意：上面的 <code>keyPath</code> 写age 或 _age都可以，KVC 会自动去查找。</p>
<h5 id="KVC-字典转模型"><a href="#KVC-字典转模型" class="headerlink" title="KVC 字典转模型"></a>KVC 字典转模型</h5><p>简单示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;</div><div class="line">                     <span class="string">@"name"</span> :<span class="string">@"lurry"</span>,</div><div class="line">                     <span class="string">@"money"</span> : @<span class="number">189.88</span>,</div><div class="line">                     <span class="comment">//@"development" : @"iOS"--&gt;问题1模型的属性和字典不能一一对应</span></div><div class="line">                     <span class="comment">/*</span></div><div class="line">                      @"dog" : @&#123;</div><div class="line">                               @"name" : @"wangcai",</div><div class="line">                               @"price" : @8</div><div class="line">                               &#125;,</div><div class="line">                      */ <span class="comment">//--&gt;问题2模型中嵌套模型</span></div><div class="line">                       &#125;;</div><div class="line">LNPerson *person = [[LNPerson alloc] init];</div><div class="line">[person setValuesForKeysWithDictionary:dict];<span class="comment">// 等同于下面的代码</span></div><div class="line"></div><div class="line"><span class="comment">// setValuesForKeysWithDictionary: 原理:</span></div><div class="line"><span class="comment">// 1.遍历字典中所有key,去模型中查找有没有对应的属性</span></div><div class="line">[dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull value, <span class="built_in">BOOL</span> * _Nonnull stop) &#123; </div><div class="line">    <span class="comment">// 2.去模型中查找有没有对应属性 KVC</span></div><div class="line">    [item setValue:value forKey:key];      </div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, person);</div></pre></td></tr></table></figure></p>
<ul>
<li><p>开发中不建议使用 <code>setValuesForKeysWithDictionary:</code>（把字典中所有值给模型的属性赋值）</p>
</li>
<li><p>问题1：如果服务器多返回几个数据 <code>Key</code>，在模型中系统找不到就会报错。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reason: '[&lt;LNPerson 0x100304730&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key nam.</div></pre></td></tr></table></figure>
</li>
</ul>
<p>解决：重写系统方法 <code>setValue:forUndefinedKey:</code>，就不会有报错信息了。<br>补充：<strong>什么时候重写系统方法?</strong><br><strong>1、想给系统方法添加额外功能   2、不想要系统方法实现</strong></p>
<ul>
<li><p>问题2：如果模型中带有模型型，<code>setValuesForKeysWithDictionary</code> 不能用。<br>解决：思路，拿到每一个模型属性，去字典中取出对应的值，给模型赋值（提醒：从字典中取值,不一定要全部取出来）。<br>建议使用：<strong>MJExtension</strong> 字典转模型 和 <strong>Runtime</strong>（根据模型中属性，去字典中取出对应的 <code>value</code> 给模型属性赋值）</p>
</li>
<li><p>模型转成字典</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dict = [person dictionaryWithValuesForKeys:@[<span class="string">@"name"</span>, <span class="string">@"money"</span>]];</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="KVO-概论"><a href="#KVO-概论" class="headerlink" title="KVO 概论"></a>KVO 概论</h4><hr>
<p><strong>KVO</strong>（<code>Key-Value-Obersver</code>）即键值监听，利用一个<code>key</code>来找到某个属性并监听其属性值得改变，当该属性发生变化时，会自动的通知观察者，这比通知中心需要<code>post</code>通知来说，简单了许多。其实这也是一种典型的观察者模式。</p>
<h4 id="KVO-使用步骤"><a href="#KVO-使用步骤" class="headerlink" title="KVO 使用步骤"></a>KVO 使用步骤</h4><hr>
<ol>
<li>给目标对象的属性添加观察者</li>
<li>在回调方法中监听属性的变化</li>
<li>移除观察者</li>
</ol>
<p>具体代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.person = [[LNPerson alloc] init];</div><div class="line">    person.name = <span class="string">@"zs"</span>;</div><div class="line">    </div><div class="line">   <span class="comment">/*</span></div><div class="line">     - Observer 观察者</div><div class="line">     - KeyPath 要监听的属性</div><div class="line">     - options 选项(可选属性值，示例：旧值和新值)</div><div class="line">    */</div><div class="line">    <span class="comment">// 1.添加观察者</span></div><div class="line">    [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options: <span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</div><div class="line">    person.name = <span class="string">@"ls"</span>;<span class="comment">// 这里重新赋值</span></div><div class="line">    person.name = <span class="string">@"ww"</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)dealloc&#123;</div><div class="line">    <span class="comment">// 2.移除观察者</span></div><div class="line">    [<span class="keyword">self</span>.person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** </span></div><div class="line"> *  当监听的属性值发生改变</div><div class="line"> *  @param keyPath 要监听的属性</div><div class="line"> *  @param object  要监听的属性所属的对象</div><div class="line"> *  @param change  改变的内容</div><div class="line"> *  @param context 上下文</div><div class="line"> */</div><div class="line"><span class="meta">#pragma mark - KVO</span></div><div class="line"><span class="comment">// 3.监听属性的变化</span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(LNPerson *)person change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@------%@------%@"</span>, keyPath, change);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="KVO-实现原理"><a href="#KVO-实现原理" class="headerlink" title="KVO 实现原理"></a>KVO 实现原理</h4><hr>
<p>当一个类的属性被观察的时候，系统会通过runtime动态的创建一个该类的派生类，并且会在这个类中重写基类被观察的属性的setter方法，而且系统将这个类的isa指针指向了派生类，从而实现了给监听的属性赋值时调用的是派生类的setter方法。重写的setter方法会在调用原setter方法前后，通知观察对象值得改变。此外，派生类还重写了 dealloc 方法来释放资源。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2230763-631a74fec5f7f1a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KVO 实现原理"></p>
<p>可以看到重写的 setter 方法，给属性赋值的前后分别调用了两个方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure></p>
<p>而<code>- (void)didChangeValueForKey:(NSString *)key;</code>会调用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span>*, <span class="keyword">id</span>&gt; *)change context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure></p>
<h4 id="KVO-手动发送通知机制"><a href="#KVO-手动发送通知机制" class="headerlink" title="KVO 手动发送通知机制"></a>KVO 手动发送通知机制</h4><hr>
<p>默认情况下，KVO 观察到属性变化系统会自动发送通知，但在某些情况下，你可能需要控制何时发送通知。例如：在某些情况下不需要发送通知，或将多个改变合并为一个通知发送。其实我们也可以手动，显式的调用上面两个方法，以使其具有通知机制。<br>举个示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.person = [[LNPerson alloc] init];</div><div class="line">    person.name = <span class="string">@"zs"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 1.添加观察者</span></div><div class="line">    [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options: <span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"name"</span>];</div><div class="line">    person.name = <span class="string">@"this is a test"</span>; <span class="comment">// 直接修改成员变量的值，手动的调用上下两个方法，使其就有通知机制</span></div><div class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"name"</span>];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)dealloc&#123;</div><div class="line">    <span class="comment">// 2.移除观察者</span></div><div class="line">    [<span class="keyword">self</span>.person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - KVO</span></div><div class="line"><span class="comment">// 3.监听属性的变化</span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(LNPerson *)person change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context&#123;</div><div class="line">   </div><div class="line">   <span class="keyword">if</span>(object == <span class="keyword">self</span> &amp;&amp; [keyPath isEqualToString:<span class="string">@"name"</span>]) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@------%@------%@"</span>, keyPath, change);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject: person change:change context:context];</div><div class="line">    &#125;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="期待"><a href="#期待" class="headerlink" title="期待"></a>期待</h4><hr>
<ul>
<li><p>如果在阅读过程中遇到 error || new ideas，希望你能 messages 我，我会及时改正谢谢。</p>
</li>
<li><p>点击右上角的 喜欢 和 订阅Rss 按钮，可以收藏本仓库，并在 Demo 更新时收到邮件通知。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Write-in-the-first【写在最前】&quot;&gt;&lt;a href=&quot;#Write-in-the-first【写在最前】&quot; class=&quot;headerlink&quot; title=&quot;Write in the first【写在最前】&quot;&gt;&lt;/a&gt;Write in the f
    
    </summary>
    
      <category term="iOS" scheme="https://sunyonghui.github.io/categories/iOS/"/>
    
    
      <category term="模式" scheme="https://sunyonghui.github.io/tags/%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
